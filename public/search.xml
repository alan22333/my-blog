<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>100 go mistakes 总结01</title>
    <url>/2025/06/05/100gomistakes%E6%80%BB%E7%BB%9301/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Summary</strong></p>
<ul>
<li>
<p><strong>Avoiding shadowed variables can help prevent mistakes like referencing the wrong variable or confusing readers.</strong></p>
<ul>
<li>避免使用遮蔽变量可以帮助防止诸如引用错误变量或混淆读者之类的错误。</li>
</ul>
</li>
<li>
<p><strong>Avoiding nested levels and keeping the happy path aligned on the left makes building a mental code model easier.</strong></p>
<ul>
<li>避免嵌套层级并将“ happy path”（正常流程）代码靠左对齐，可以使构建代码的思维模型更容易。</li>
</ul>
</li>
<li>
<p><strong>When initializing variables, remember that init functions have limited error handling and make state handling and testing more complex. In most cases, initializations should be handled as specific functions.</strong></p>
<ul>
<li>在初始化变量时，请记住 <code>init</code> 函数的错误处理能力有限，并且会使状态处理和测试变得更复杂。在大多数情况下，初始化应作为特定函数来处理。</li>
</ul>
</li>
<li>
<p><strong>Forcing the use of getters and setters isn’t idiomatic in Go. Being pragmatic and finding the right balance between efficiency and blindly following certain idioms should be the way to go.</strong></p>
<ul>
<li>在 Go 语言中，强制使用 getter 和 setter 并不符合 Go 语言习惯。务实并在效率和盲目遵循某些惯例之间找到正确的平衡，才是正确的方法。</li>
</ul>
</li>
<li>
<p><strong>Abstractions should be discovered, not created. To prevent unnecessary complexity, create an interface when you need it and not when you foresee needing it, or if you can at least prove the abstraction to be a valid one.</strong></p>
<ul>
<li>抽象应该被发现，而不是被创造。为了防止不必要的复杂性，请在需要时才创建接口，而不是在你预见到需要时，或者至少你可以证明该抽象是有效的。</li>
</ul>
</li>
<li>
<p><strong>Keeping interfaces on the client side avoids unnecessary abstractions.</strong></p>
<ul>
<li>将接口保留在客户端侧可以避免不必要的抽象。</li>
</ul>
</li>
<li>
<p><strong>To prevent being restricted in terms of flexibility, a function shouldn’t return interfaces but concrete implementations in most cases. Conversely, a function should accept interfaces whenever possible.</strong></p>
<ul>
<li>为了防止在灵活性方面受到限制，函数在大多数情况下不应返回接口，而应返回具体实现。相反，函数应尽可能接受接口。</li>
</ul>
</li>
<li>
<p><strong>Only use <code>any</code> if you need to accept or return any possible type, such as <code>json.Marshal</code>. Otherwise, <code>any</code> doesn’t provide meaningful information and can lead to compile-time issues by allowing a caller to call methods with any data type.</strong></p>
<ul>
<li>仅在需要接受或返回任何可能的类型（例如 <code>json.Marshal</code>）时才使用 <code>any</code>。否则，<code>any</code> 不提供有意义的信息，并且可能通过允许调用者使用任何数据类型调用方法而导致编译时问题。</li>
</ul>
</li>
<li>
<p><strong>Relying on generics and type parameters can prevent writing boilerplate code to factor out elements or behaviors. However, do not use type parameters prematurely, but only when you see a concrete need for them. Otherwise, they introduce unnecessary abstractions and complexity.</strong></p>
<ul>
<li>依赖泛型和类型参数可以防止编写样板代码来分解元素或行为。但是，不要过早地使用类型参数，而只在您看到具体需要时才使用它们。否则，它们会引入不必要的抽象和复杂性。</li>
</ul>
</li>
<li>
<p><strong>Using type embedding can also help avoid boilerplate code; however, ensure that doing so doesn’t lead to visibility issues where some fields should have remained hidden.</strong></p>
<ul>
<li>使用类型嵌入也可以帮助避免样板代码；但是，请确保这样做不会导致可见性问题，即某些字段应该保持隐藏。</li>
</ul>
</li>
<li>
<p><strong>To handle options conveniently and in an API-friendly manner, use the functional options pattern.</strong></p>
<ul>
<li>为了方便且以 API 友好的方式处理选项，请使用函数式选项模式。</li>
</ul>
</li>
<li>
<p><strong>Following a layout such as project-layout can be a good way to start structuring Go projects, especially if you are looking for existing conventions to standardize a new project.</strong></p>
<ul>
<li>遵循诸如 project-layout 之类的布局是开始组织 Go 项目的好方法，特别是如果您正在寻找现有约定来标准化新项目。</li>
</ul>
</li>
<li>
<p><strong>Naming is a critical piece of application design. Creating packages such as <code>common</code>, <code>util</code>, and <code>shared</code> doesn’t bring much value for the reader. Refactor such packages into meaningful and specific package names.</strong></p>
<ul>
<li>命名是应用程序设计的关键部分。创建诸如 <code>common</code>、<code>util</code> 和 <code>shared</code> 之类的包对读者来说价值不大。将这些包重构为有意义和具体的包名。</li>
</ul>
</li>
<li>
<p><strong>To avoid naming collisions between variables and packages, leading to confusion or perhaps even bugs, use unique names for each one. If this isn’t feasible, use an import alias to change the qualifier to differentiate the package name from the variable name, or think of a better name.</strong></p>
<ul>
<li>为了避免变量和包之间的命名冲突，导致混淆甚至错误，请为每个使用唯一的名称。如果这不可行，请使用导入别名来更改限定符，以区分包名和变量名，或者考虑一个更好的名称。</li>
</ul>
</li>
<li>
<p><strong>To help clients and maintainers understand your code’s purpose, document exported elements.</strong></p>
<ul>
<li>为了帮助客户端和维护者理解代码的目的，请为导出的元素编写文档。</li>
</ul>
</li>
<li>
<p><strong>To improve code quality and consistency, use linters and formatters.</strong></p>
<ul>
<li>为了提高代码质量和一致性，请使用代码检查工具（linters）和格式化工具（formatters）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Sparse Merkle Tree (BSMT)</title>
    <url>/2025/11/21/BSMT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Binary Sparse Merkle Tree (BSMT) 不仅仅是一种数据结构，它是解决区块链 “状态爆炸” 和 “高效验证” 矛盾的关键技术方案。它结合了 Merkle Tree 的验证能力和 Trie（前缀树）的寻址能力。</p>
<blockquote>
<p>本文结构：通俗讲解-&gt;运行机制-&gt;代码实现</p>
</blockquote>
<span id="more"></span>
<h2 id="A-什么事是BSMT？">A 什么事是BSMT？</h2>
<p>为了让你一听就懂，我们可以把 <strong>Binary Sparse Merkle Tree (BSMT)</strong> 想象成一个 <strong>“带有魔法的无限大仓库”</strong> 。</p>
<p>我们可以把它的三个名字拆开来理解：</p>
<h3 id="1-Binary（二叉）：这是“地图”">1. Binary（二叉）：这是“地图”</h3>
<p>想象你要去仓库取东西，路标只有两种：<strong>“向左”</strong>（代表0）和 <strong>“向右”</strong>（代表1）。<br>
所有的门牌号（Key）都是由0和1组成的。比如你要找门牌号 <code>011</code> 的柜子，你就走：左 -&gt; 右 -&gt; 右。</p>
<ul>
<li><strong>通俗点说：</strong> 只要知道门牌号（二进制），你就能顺着唯一的路径找到那个位置。</li>
</ul>
<h3 id="2-Sparse（稀疏）：这是“魔法”">2. Sparse（稀疏）：这是“魔法”</h3>
<p>这是 BSMT 最核心的技术。<br>
这个仓库理论上<strong>大到无穷大</strong>（比如有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup></mrow><annotation encoding="application/x-tex">2^{256}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span></span></span></span> 个柜子，比宇宙里的原子还多）。<br>
如果我们要真的造这么多柜子，地球都放不下。</p>
<p><strong>魔法在于：</strong></p>
<ul>
<li>在这个无限大的仓库里，<strong>99.9999% 的柜子都是空的</strong> 。</li>
<li>对于空的柜子，我们 <strong>不造它，也不存储它</strong> 。</li>
<li>我们预先算好一个“空柜子的指纹”（Hash），凡是没东西的地方，直接用这个“空指纹”代替。</li>
<li><strong>通俗点说：</strong> 这是一个 <strong>“懒人仓库”</strong> 。只有当你真的往某个柜子放东西时，我们才会在那一瞬间把去往那个柜子的路和柜子造出来。其他的空间都是虚拟的，不占地方。</li>
</ul>
<h3 id="3-Merkle-Tree（默克尔树）：这是“防伪锁”">3. Merkle Tree（默克尔树）：这是“防伪锁”</h3>
<p>仓库大门上有一把总锁（Root Hash）。</p>
<ul>
<li>如果你偷偷改了哪怕最深处一个柜子里的东西，这把总锁的“指纹”就会立刻改变。</li>
<li><strong>通俗点说：</strong> 它可以极快地证明“某样东西确实在这个仓库里”，而且没人动过手脚。</li>
</ul>
<hr>
<h3 id="总而言之">总而言之</h3>
<p>它就是一个<strong>看起来有无限容量，但实际上只占用你存了多少东西的空间，且能随时极速验证数据真伪的超级数据库</strong>。</p>
<p><strong>它解决了什么问题？</strong></p>
<ul>
<li><strong>空间小：</strong> 哪怕树深达256层，如果你只存了3个数据，它占用的空间就只和这3个数据相关，而不是整个宇宙。</li>
<li><strong>速度快：</strong> 验证数据是否存在非常快（顺着0和1走就行）。</li>
<li><strong>甚至能证明“不存在”：</strong> 你顺着路走到某个位置，发现那是“空指纹”，就能立刻证明“这个数据确实不存在”（Non-inclusion proof），这在区块链里非常有用。</li>
</ul>
<h2 id="B-运行机制">B 运行机制</h2>
<p>好，我们继续用“魔法仓库”的比喻，把 <strong>BSMT (Binary Sparse Merkle Tree)</strong> 的具体运作流程拆解开来看。</p>
<p>首先你要记住一个核心规则：<strong>在这个树里，位置（Key）就是导航图。</strong><br>
比如你的 Key 是 <code>101</code>，那就代表：第一层向右走，第二层向左走，第三层向右走。</p>
<hr>
<h3 id="1-存储：它是怎么做到“省空间”的？">1. 存储：它是怎么做到“省空间”的？</h3>
<p>普通的树是把所有节点都存进数据库，但 BSMT 是个“极简主义者”。</p>
<ul>
<li>
<p><strong>预计算空节点（Zero Hashes）：</strong><br>
系统启动前，就已经算好了一套“空值表”。</p>
<ul>
<li>第256层（最底层）如果为空，Hash是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>第255层如果左右孩子都为空（即孩子都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），那这一层的Hash就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>H</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_1 = Hash(H_0, H_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li>…以此类推，算到根节点。<br>
<strong>这些“空指纹”是永远不变的，不需要存进数据库，写在代码常量里就行。</strong></li>
</ul>
</li>
<li>
<p><strong>只存有效路径：</strong><br>
当你要存一个数据时，BSMT <strong>只会把从“根”到“叶子”这条路径上的非空节点</strong> 存到数据库（通常是 KV 数据库，如 LevelDB）里。</p>
<ul>
<li><strong>如果一个节点的右边是空的？</strong> 数据库里不存右边，只记录“右边是默认空指纹”。</li>
<li><strong>效果：</strong> 哪怕树有 256 层高，存一个数据只需要存 256 个节点（甚至经过优化压缩后更少），而不是存 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup></mrow><annotation encoding="application/x-tex">2^{256}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span></span></span></span> 个节点。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-更新（插入-修改）：如何放入数据？">2. 更新（插入/修改）：如何放入数据？</h3>
<p>假设你要把 <strong>“苹果”</strong> 放入柜子 <code>10...0</code>（假设这是 Key）。</p>
<ol>
<li><strong>下沉（找位置）：</strong><br>
从根节点（Root）出发，根据 Key（1 -&gt; 右，0 -&gt; 左…）一路往下走。</li>
<li><strong>放置：</strong><br>
走到最底层的叶子节点，把“苹果”放进去。</li>
<li><strong>上浮（重算指纹）：</strong><br>
这是最关键的一步。你放了苹果，叶子的指纹变了。
<ul>
<li>你需要算出新的叶子 Hash。</li>
<li>回到父节点，父节点的 Hash = <code>Hash(左孩子Hash, 右孩子Hash)</code>。</li>
<li><strong>注意：</strong> 如果左孩子是你刚改的，右孩子是空的，那就取 <code>Hash(新左Hash, 预计算的空右Hash)</code>。</li>
<li>一路向上计算，直到生成一个新的 <strong>Root Hash</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-证明存在（Merkle-Proof）：怎么证明“苹果”在里面？">3. 证明存在（Merkle Proof）：怎么证明“苹果”在里面？</h3>
<p>你要向别人证明：柜子 <code>10...0</code> 里确实有“苹果”。你不需要把整个仓库给别人看，只需要提供<strong>一条“证据链”</strong>。</p>
<ul>
<li>
<p><strong>证据链（Proof）包含什么？</strong><br>
你需要提供从“苹果”所在位置，一直到树根的路径上，<strong>所有“另一侧”的兄弟节点的 Hash</strong>。</p>
<ul>
<li>比如：你要算你爸爸的 Hash，你需要你自己的 Hash + 你兄弟的 Hash。</li>
</ul>
</li>
<li>
<p><strong>验证过程：</strong><br>
验证者手里只有一个 <strong>Root Hash</strong>（可信的总指纹）。</p>
<ol>
<li>验证者拿着你给的“苹果”。</li>
<li>根据 Key（路径），配合你提供的“兄弟节点 Hash”，一层层往上算。</li>
<li>如果最后算出来的 Hash <strong>等于</strong> 他手里的 Root Hash，那就证明：<strong>苹果确实在这个位置，且没有被篡改。</strong></li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-证明不存在（Non-Inclusion-Proof）：怎么证明“没苹果”？">4. 证明不存在（Non-Inclusion Proof）：怎么证明“没苹果”？</h3>
<p>这是 BSMT 最厉害的地方。普通的 Merkle Tree 很难证明“没有”，通常需要把相邻的数据都拿出来由你来推断中间是空的，但 BSMT 很直接。</p>
<p>假设有人问：柜子 <code>11...1</code> 里有东西吗？</p>
<ul>
<li>
<p><strong>情况 A：路断了（遇到空子树）</strong><br>
你顺着 <code>1</code>（向右）走，发现这里本该有个节点，但这棵子树全是空的（是一个预计算的空 Hash）。<br>
<strong>证明：</strong> 你直接把这个“空 Hash”对应的兄弟路径给验证者。验证者一算，发现根 Hash 对得上，且路径指向的是个“空地”，那就证明<strong>该位置绝对没有数据</strong>。</p>
</li>
<li>
<p><strong>情况 B：被占了（叶子节点不匹配）</strong><br>
你顺着路走到终点，发现里面确实有个东西，但它的 Key 是 <code>11...0</code>，而不是你要找的 <code>11...1</code>。<br>
<strong>证明：</strong> 展示这个错误的叶子节点。验证者一看：路径是对的，但这只有 <code>11...0</code> 的数据，说明 <code>11...1</code> 没地方站了（位置冲突），所以 <strong>目标数据不存在</strong>。</p>
</li>
</ul>
<hr>
<h3 id="总结一下流程">总结一下流程</h3>
<table>
<thead>
<tr>
<th style="text-align:left">动作</th>
<th style="text-align:left">核心机制</th>
<th style="text-align:left">通俗解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>存储</strong></td>
<td style="text-align:left"><strong>剪枝 (Pruning)</strong></td>
<td style="text-align:left">只有真的放了东西的柜子才会造出来，空的全部用“空气指纹”代替，不占硬盘。</td>
</tr>
<tr>
<td style="text-align:left"><strong>更新</strong></td>
<td style="text-align:left"><strong>回溯重哈希</strong></td>
<td style="text-align:left">动了最下面的东西，要一层层往上汇报，直到大门上的总锁（Root）换成新的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>证明存在</strong></td>
<td style="text-align:left"><strong>兄弟路径</strong></td>
<td style="text-align:left">“这是我和我每一级邻居的合影，你看最后能不能拼出那把总锁。”</td>
</tr>
<tr>
<td style="text-align:left"><strong>证明不存在</strong></td>
<td style="text-align:left"><strong>证明为空</strong></td>
<td style="text-align:left">“你顺着路走，你看，那地方是一片荒地（默认空值），所以东西肯定不在那。”</td>
</tr>
</tbody>
</table>
<p>这就是为什么 BSMT 在区块链（如 CKB, Ethereum 2.0 的某些状态树）中很受欢迎：它<strong>又大</strong>（能存无限Key），<strong>又小</strong>（只占有效数据空间），还能<strong>极速证明</strong>“有”或者“没有”。</p>
<h2 id="C-代码实现（Go）">C 代码实现（Go）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定树的深度为 256 层 (对应 SHA256 的位宽)</span></span><br><span class="line"><span class="keyword">const</span> TreeDepth = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SMT 定义</span></span><br><span class="line"><span class="keyword">type</span> SparseMerkleTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	root       []<span class="type">byte</span>                <span class="comment">// 当前树根 Hash</span></span><br><span class="line">	db         <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>     <span class="comment">// 模拟数据库 (NodeKey -&gt; NodeHash)</span></span><br><span class="line">	zeroHashes [TreeDepth + <span class="number">1</span>][]<span class="type">byte</span> <span class="comment">// 预计算的空节点 Hash 表（默认的，用作计算查询）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSMT 初始化一棵空树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMT</span><span class="params">()</span></span> *SparseMerkleTree &#123;</span><br><span class="line">	smt := &amp;SparseMerkleTree&#123;</span><br><span class="line">		db: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 预计算空哈希 (魔法部分)</span></span><br><span class="line">	<span class="comment">// 最底层(第256层)的空 Hash 是全 0</span></span><br><span class="line">	smt.zeroHashes[TreeDepth] = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从下往上计算每一层的空 Hash</span></span><br><span class="line">	<span class="comment">// Hash(Parent) = Hash(LeftChild + RightChild)</span></span><br><span class="line">	<span class="keyword">for</span> i := TreeDepth - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		childHash := smt.zeroHashes[i+<span class="number">1</span>]</span><br><span class="line">		smt.zeroHashes[i] = hashNode(childHash, childHash)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始状态下，树根就是第 0 层的空 Hash</span></span><br><span class="line">	smt.root = smt.zeroHashes[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> smt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 插入或更新数据</span></span><br><span class="line"><span class="comment">// key: 32字节的大整数 (路径图), value: 要存的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SparseMerkleTree)</span></span> Set(key []<span class="type">byte</span>, value []<span class="type">byte</span>) &#123;</span><br><span class="line">	valueHash := hashData(value)</span><br><span class="line">	<span class="comment">// 更新根节点，递归更新路径</span></span><br><span class="line">	t.root = t.update(t.root, key, <span class="number">0</span>, valueHash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update 递归函数：下沉寻找位置，上浮重新计算 Hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SparseMerkleTree)</span></span> update(nodeHash []<span class="type">byte</span>, key []<span class="type">byte</span>, depth <span class="type">int</span>, valueHash []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 到底了 (叶子节点)，直接返回数据的 Hash</span></span><br><span class="line">	<span class="keyword">if</span> depth == TreeDepth &#123;</span><br><span class="line">		<span class="keyword">return</span> valueHash</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 确定走左边还是右边 (查看 Key 在当前深度的位是 0 还是 1)</span></span><br><span class="line">	<span class="comment">// path: 0 -&gt; Left, 1 -&gt; Right</span></span><br><span class="line">	bit := getBit(key, depth)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前节点的左右孩子</span></span><br><span class="line">	<span class="comment">// 如果当前节点是空的(ZeroHash)，那它的孩子肯定也是空的</span></span><br><span class="line">	leftChild, rightChild := t.getChildren(nodeHash, depth)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> newLeft, newRight []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 向左走，右边保持不变</span></span><br><span class="line">		newLeft = t.update(leftChild, key, depth+<span class="number">1</span>, valueHash)</span><br><span class="line">		newRight = rightChild</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 向右走，左边保持不变</span></span><br><span class="line">		newLeft = leftChild</span><br><span class="line">		newRight = t.update(rightChild, key, depth+<span class="number">1</span>, valueHash)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 上浮：计算当前节点的新 Hash</span></span><br><span class="line">	newHash := hashNode(newLeft, newRight)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 存储：把非空节点存入 DB (为了演示简单，这里我们存了所有经过的路径节点)</span></span><br><span class="line">	<span class="comment">// 实际 BSMT 优化中，如果 Hash 等于 ZeroHash，是不需要存 DB 的</span></span><br><span class="line">	t.db[hex.EncodeToString(newHash)] = <span class="built_in">append</span>(newLeft, newRight...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateProof 生成默克尔证明 (Merkle Proof)</span></span><br><span class="line"><span class="comment">// 返回：兄弟节点 Hash 列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SparseMerkleTree)</span></span> GenerateProof(key []<span class="type">byte</span>) [][]<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> proof [][]<span class="type">byte</span></span><br><span class="line">	currentNode := t.root</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; TreeDepth; i++ &#123;</span><br><span class="line">		bit := getBit(key, i)</span><br><span class="line">		left, right := t.getChildren(currentNode, i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 我走左边，把右边的兄弟放入证据包</span></span><br><span class="line">			proof = <span class="built_in">append</span>(proof, right)</span><br><span class="line">			currentNode = left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 我走右边，把左边的兄弟放入证据包</span></span><br><span class="line">			proof = <span class="built_in">append</span>(proof, left)</span><br><span class="line">			currentNode = right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> proof</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VerifyProof 验证默克尔证明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyProof</span><span class="params">(root []<span class="type">byte</span>, key []<span class="type">byte</span>, value []<span class="type">byte</span>, proof [][]<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	currentHash := hashData(value)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从底向上回推</span></span><br><span class="line">	<span class="comment">// 注意 proof 的顺序是 从上到下 还是 从下到上，这里生成时是从上到下，验证我们要反过来或者对应索引</span></span><br><span class="line">	<span class="comment">// 实际上循环最好还是从 Root 往下模拟，或者从 Leaf 往上计算。</span></span><br><span class="line">	<span class="comment">// 这里我们采用：从 Leaf (TreeDepth) 往上 (0) 计算</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(proof) != TreeDepth &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := TreeDepth - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		sibling := proof[i] <span class="comment">// 获取对应层的兄弟</span></span><br><span class="line">		bit := getBit(key, i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Key 是 0 (左)，兄弟在右： Hash(Me, Sibling)</span></span><br><span class="line">			currentHash = hashNode(currentHash, sibling)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Key 是 1 (右)，兄弟在左： Hash(Sibling, Me)</span></span><br><span class="line">			currentHash = hashNode(sibling, currentHash)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 比较计算出的 Root 和 这里的 Root</span></span><br><span class="line">	<span class="keyword">return</span> bytes.Equal(currentHash, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 辅助函数 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getChildren 获取左右孩子，如果是空节点，返回预计算的 ZeroHash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SparseMerkleTree)</span></span> getChildren(nodeHash []<span class="type">byte</span>, depth <span class="type">int</span>) ([]<span class="type">byte</span>, []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果当前节点就是该层的“空哈希”，那孩子直接取下一层的空哈希</span></span><br><span class="line">	<span class="keyword">if</span> bytes.Equal(nodeHash, t.zeroHashes[depth]) &#123;</span><br><span class="line">		<span class="keyword">return</span> t.zeroHashes[depth+<span class="number">1</span>], t.zeroHashes[depth+<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则查 DB</span></span><br><span class="line">	data, ok := t.db[hex.EncodeToString(nodeHash)]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// 理论上不应发生，除非数据丢失，但在 Sparse 逻辑里，找不到我们就当它是空的</span></span><br><span class="line">		<span class="keyword">return</span> t.zeroHashes[depth+<span class="number">1</span>], t.zeroHashes[depth+<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前32字节是左，后32字节是右</span></span><br><span class="line">	<span class="keyword">return</span> data[:<span class="number">32</span>], data[<span class="number">32</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getBit 获取 Key 在第 depth 位的二进制值 (0 或 1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBit</span><span class="params">(key []<span class="type">byte</span>, depth <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	byteIndex := depth / <span class="number">8</span></span><br><span class="line">	bitIndex := <span class="number">7</span> - (depth % <span class="number">8</span>)</span><br><span class="line">	<span class="keyword">if</span> (key[byteIndex]&gt;&gt;bitIndex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashNode 计算中间节点 Hash = SHA256(Left + Right)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashNode</span><span class="params">(left, right []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	hash.Write(left)</span><br><span class="line">	hash.Write(right)</span><br><span class="line">	<span class="keyword">return</span> hash.Sum(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashData 计算叶子数据 Hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashData</span><span class="params">(data []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	hash.Write(data)</span><br><span class="line">	<span class="keyword">return</span> hash.Sum(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 主程序 ---</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建树</span></span><br><span class="line">	smt := NewSMT()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;初始 Root: %x\n&quot;</span>, smt.root)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 准备数据</span></span><br><span class="line">	<span class="comment">// Key 需要是 32 字节 (256 bit)，这里简单构造一个</span></span><br><span class="line">	key1 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line">	key1[<span class="number">31</span>] = <span class="number">0x01</span> <span class="comment">// ...0001</span></span><br><span class="line"></span><br><span class="line">	val1 := []<span class="type">byte</span>(<span class="string">&quot;Hello BSMT&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 存储数据</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;正在存储 &#x27;Hello BSMT&#x27; 到 key 1...&quot;</span>)</span><br><span class="line">	smt.Set(key1, val1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;新 Root:   %x\n&quot;</span>, smt.root)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 生成证明</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;正在生成证明...&quot;</span>)</span><br><span class="line">	proof := smt.GenerateProof(key1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 验证证明 (模拟轻客户端验证)</span></span><br><span class="line">	isValid := VerifyProof(smt.root, key1, val1, proof)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;验证结果: %v\n&quot;</span>, isValid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 测试篡改验证</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;测试篡改数据...&quot;</span>)</span><br><span class="line">	fakeVal := []<span class="type">byte</span>(<span class="string">&quot;Hacker&quot;</span>)</span><br><span class="line">	isValidFake := VerifyProof(smt.root, key1, fakeVal, proof)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;篡改验证结果: %v\n&quot;</span>, isValidFake)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>科研</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>2025年终总结</title>
    <url>/2025/12/28/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://pic1.imgdb.cn/item/69312a851f1698c4ff092d74.jpg" alt="2025"></p>
<p>年初的时候开始在这个博客里记录一些知识，主要还是自己看看，马上2025都要结束了，这一年发生的事情太多了，有很多开心的也有很多难过的。</p>
<p>在这一年我解锁前进之路上的新阶段，那就是读研，我认为这是一个很重要的学习阶段，也是进入社会前的最后缓冲。</p>
<p>在这里，我总结一下这一年里的经历和想法。</p>
<hr>
<h3 id="读研">读研</h3>
<p>冬天的初试比较顺利，春天的复试有点紧张但好在很简单，基本就是走流程，顺便还带家人来京玩了几天挺不错的。虽然不是很好的学校，但是能顺利考上还是比较开心的。双选碰到了闹心的坏老师捣乱，但是好在最后匹配到了一个非常棒的年轻导师，各方面都很好，做的也是我喜欢的研究领域，还带我出去参加学术交流（lvyou）。<br>
这半年的科研工作相对平淡，基本就是完成导师给的工作，有了AI帮助感觉很容易应付的，只是隐隐觉得有点不妥，自己还是没有应有能力。下学期得自己读论文找创新点、做实验、写论文、投稿了，还是挺有压力的。因为念的是专硕，没有太高的学术追求，所以再三思考下拒绝了去清华科研学习的机会。现在回过头来确实没有好好地去读一些论文，只是机械地完成任务，感觉半年下来还是缺少一些所谓“学术素养”的东西，大抵是心底的功利心让我觉得学这些对找工作没啥用。</p>
<h3 id="学习">学习</h3>
<p>大概是gap太久了，感觉学习的劲头不是很对，在家放假时候也没有好好学来了也没有很好的做规划，只是零零散散地学一些东西。<br>
其中最重要的莫过于开始接触Golang这门语言，说实话上手的时候一下子就被吸引住了，忍不住感叹太优雅了，所以下定决心做一个gopher萌新。<br>
成为Go学弟之后很快就学完了，然后又学了学web开发的一些内容，跟着敲了几个简单的玩具项目，暑假的时候用Go复刻了一下以前做过的Java项目，又学了一个脚手架的开源项目，后面开始给老师做科研又耽误没再继续学习了，虽然做实验也是使用Go来写，但大部分都叫AI帮我搞了，没太多的实践。<br>
开学之后也是随便乱学学，有时候写写算法，有时候学学eino之类的技术，有其他事情忙起来就又忘了，八股文也是看个几题就不看了，一个完整项目也没做，哎，怎么说呢，一地鸡毛。总的来说就是没有一个很好的学习轨迹，东看看西看看，一个东西没学透又跑去捣鼓其他的，或者直接鸽了，回顾起来挺烦躁的。<br>
差点忘了自己还有一个技能树是web3了，这一块更是鸽的没边了哈哈，暑假比赛里拿了个第一和500小刀乐之后就开始一直摸鱼了捏，考虑到就业优先级其实也没什么毛病，没有web2经验，我想也很难入行web3了。</p>
<blockquote>
<p>过段时间写一个关于规划的总结，真得好好调整一下自己学习状态</p>
</blockquote>
<h3 id="生活">生活</h3>
<p>生活上真是喜忧参半，本来想着开开心心来读研提升自己，然后风风光光找个好工作，结果在一起好多年的女朋友因为各种原因分手了，一个人跑到北方来读书一个朋友也没交到了，整天一个人玩儿，总是闷闷不乐，也许这也是学习上失利的原因吧…</p>
<p>希望2026年我的生活能开心点。</p>
<h3 id="FLAG">FLAG</h3>
<p>2026立一个总的flag就是“认真地做好每一件重要的事”，科研好好做不偷懒、认真看论文，技术好好学、冲击一下大厂实习，生活上心态更好一点更坦然的面对所有事情。。。加油</p>
<p><img data-src="https://pic1.imgdb.cn/item/683aeca558cb8da5c81eb777.jpg" alt="smlie"></p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>芜杂心绪</tag>
      </tags>
  </entry>
  <entry>
    <title>ENS域名系统</title>
    <url>/2025/05/04/ENS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ENS-域名简介"><strong>ENS 域名简介</strong></h3>
<p>ENS（Ethereum Name Service，以太坊域名服务）是以太坊上的去中心化域名解析系统，类似于传统互联网的DNS（域名系统），但它专门为区块链地址服务。ENS允许用户将复杂的以太坊钱包地址（如 <code>0x1234...abcd</code>）映射到易于记忆的<strong>域名</strong>（如 <code>alice.eth</code>）。</p>
<p>ENS不仅支持地址映射，还可以存储IPFS内容哈希、文本记录、加密钱包等信息，从而让区块链更具可读性和可用性。</p>
<hr>
<h3 id="ENS-的核心功能"><strong>ENS 的核心功能</strong></h3>
<p>ENS 提供的主要功能包括：</p>
<ol>
<li>
<p><strong>钱包地址解析</strong>：将 <code>alice.eth</code> 解析为 <code>0x1234...abcd</code>。</p>
</li>
<li>
<p><strong>反向解析</strong>：从钱包地址解析出 ENS 域名。</p>
</li>
<li>
<p><strong>文本记录存储</strong>：可以存储社交媒体链接、IPFS哈希、电子邮件等信息。</p>
</li>
<li>
<p><strong>子域名管理</strong>：可以创建如 <code>mail.alice.eth</code> 这样的子域名。</p>
</li>
</ol>
<hr>
<h3 id="ENS-工作流程"><strong>ENS 工作流程</strong></h3>
<p>ENS 依赖智能合约运行在以太坊网络上，主要组件包括：</p>
<ol start="5">
<li>
<p><strong>Registry（注册表合约）</strong>：存储域名的所有者、解析器、到期时间等信息。</p>
</li>
<li>
<p><strong>Resolver（解析器合约）</strong>：处理域名的解析逻辑，将ENS名称转换为地址或其他记录。</p>
</li>
<li>
<p><strong>Registrar（注册管理器）</strong>：处理ENS域名的购买、转移和续费。</p>
</li>
</ol>
<hr>
<h3 id="如何在DApp中集成ENS域名解析"><strong>如何在DApp中集成ENS域名解析</strong></h3>
<p>为了在你的Web3Mail DApp中支持ENS域名，可以使用 <code>ethers.js</code> 库进行交互，ENS解析流程如下：</p>
<h4 id="1-检查用户是否拥有ENS域名"><strong>1. 检查用户是否拥有ENS域名</strong></h4>
<p>在用户登录时，我们可以使用 <code>ethers.js</code> 查询用户的ENS名称，如果没有，则显示其钱包地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接以太坊钱包</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="title class_">BrowserProvider</span>(<span class="variable language_">window</span>.<span class="property">ethereum</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getENSName</span>(<span class="params">address</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ensName = <span class="keyword">await</span> provider.<span class="title function_">lookupAddress</span>(address);</span><br><span class="line">    <span class="keyword">if</span> (ensName) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ENS 名称: <span class="subst">$&#123;ensName&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> ensName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`未找到 ENS 名称，地址: <span class="subst">$&#123;address&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;ENS 查询失败:&quot;</span>, error);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前用户地址</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUserENS</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> signer = <span class="keyword">await</span> provider.<span class="title function_">getSigner</span>();</span><br><span class="line">  <span class="keyword">const</span> address = <span class="keyword">await</span> signer.<span class="title function_">getAddress</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getENSName</span>(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchUserENS</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-发送邮件时解析-ENS-域名"><strong>2. 发送邮件时解析 ENS 域名</strong></h4>
<p>当用户输入接收者 ENS 域名（如 <code>bob.eth</code>）时，需解析为以太坊地址，并存储到智能合约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">resolveENS</span>(<span class="params">ensName</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> address = <span class="keyword">await</span> provider.<span class="title function_">resolveName</span>(ensName);</span><br><span class="line">    <span class="keyword">if</span> (address) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ENS 解析结果: <span class="subst">$&#123;ensName&#125;</span> -&gt; <span class="subst">$&#123;address&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> address;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;ENS 名称解析失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;解析 ENS 时出错:&quot;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例: 发送邮件前解析 ENS 名称</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sendMail</span>(<span class="params">toENS, ipfsHash</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> recipientAddress = <span class="keyword">await</span> <span class="title function_">resolveENS</span>(toENS);</span><br><span class="line">    <span class="comment">// 这里调用智能合约，将 recipientAddress 和 ipfsHash 存储</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;发送邮件失败:&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-反向解析（地址到-ENS-名称）"><strong>3. 反向解析（地址到 ENS 名称）</strong></h4>
<p>在收件箱列表中，你可以使用反向解析将以太坊地址转换为ENS名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">reverseLookup</span>(<span class="params">address</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ensName = <span class="keyword">await</span> provider.<span class="title function_">lookupAddress</span>(address);</span><br><span class="line">  <span class="keyword">return</span> ensName ? ensName : address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何在-Solidity-智能合约中集成-ENS"><strong>如何在 Solidity 智能合约中集成 ENS</strong></h3>
<p>ENS 提供了官方的智能合约接口，可以在合约中直接查询 ENS 名称：</p>
<h4 id="ENS-合约地址（Ethereum-Mainnet）"><strong>ENS 合约地址（Ethereum Mainnet）</strong></h4>
<p>ENS 的注册表合约在以太坊主网上的地址为：<br>
<code>0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e</code></p>
<h4 id="在-Solidity-中解析-ENS"><strong>在 Solidity 中解析 ENS</strong></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IENSResolver &#123;</span><br><span class="line">    function addr(bytes32 node) external view returns (address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ENSHelper &#123;</span><br><span class="line">    IENSResolver ensResolver = IENSResolver(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);</span><br><span class="line"></span><br><span class="line">    function resolveENS(bytes32 node) public view returns (address) &#123;</span><br><span class="line">        return ensResolver.addr(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在合约中使用ENS解析时，ENS名称需要转换为 <code>keccak256</code> 哈希，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ensNameHash = ethers.<span class="title function_">keccak256</span>(ethers.<span class="title function_">toUtf8Bytes</span>(<span class="string">&quot;alice.eth&quot;</span>));</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="部署-ENS-域名"><strong>部署 ENS 域名</strong></h3>
<p>如果你想为你的 DApp 部署 ENS 域名，你可以使用 ENS 官方网站或脚本进行注册：</p>
<ol start="8">
<li>
<p>打开 <a href="https://ens.domains/">ens.domains</a> 官方网站。</p>
</li>
<li>
<p>连接你的以太坊钱包（MetaMask等）。</p>
</li>
<li>
<p>搜索你的域名（如 <code>web3mail.eth</code>）。</p>
</li>
<li>
<p>按照提示完成注册并支付所需的GAS费用。</p>
</li>
</ol>
<p>注册完成后，你可以将ENS域名指向你的DApp前端或合约地址。</p>
<hr>
<h3 id="ENS-费用"><strong>ENS 费用</strong></h3>
<p>ENS 域名注册通常涉及：</p>
<ul>
<li>
<p><strong>年费</strong>：根据ENS域名的长度决定，3位字符的域名最贵，5位以上相对便宜。</p>
</li>
<li>
<p><strong>Gas 费</strong>：进行注册或更新时需要支付以太坊的交易费用。</p>
</li>
<li>
<p><strong>子域名</strong>：注册的ENS域名可以免费创建子域名，如 <code>inbox.alice.eth</code>。</p>
</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>web3</tag>
      </tags>
  </entry>
  <entry>
    <title>Foundry上手指南</title>
    <url>/2025/05/05/Foundry%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Foundry-是什么">Foundry 是什么</h2>
<p>Foundry 是一个开源的以太坊智能合约开发工具包，由 Paradigm 等团队开发，旨在提供<strong>快速、便携、模块化</strong>的开发体验。Foundry 完全用 Rust 编写，避免了繁重的 Node.js 依赖，支持多种 Solidity 版本。它主要包含四个组件：</p>
<ul>
<li>
<p><strong>Forge</strong>：测试框架（类似于 Truffle/Hardhat），可直接用 Solidity 编写测试合约。</p>
</li>
<li>
<p><strong>Cast</strong>：多功能命令行工具，可执行以太坊 RPC 调用、查询链上数据和发送交易。</p>
</li>
<li>
<p><strong>Anvil</strong>：本地 EVM 节点（类似于 Ganache 或 Hardhat Network），支持快速启动和主网状态分叉（fork）测试。</p>
</li>
<li>
<p><strong>Chisel</strong>：Solidity 解释器（REPL），方便交互式调试和尝试合约代码。</p>
</li>
</ul>
<p>总体而言，Foundry 适合专注于智能合约本身的开发场景，尤其是需要高效测试、模糊测试以及本地链调试的项目。</p>
<h2 id="核心特性">核心特性</h2>
<ul>
<li>
<p><strong>原生支持 Solidity 编译与测试</strong>：Foundry 的工具链直接调用本地 <code>solc</code> 编译合约，并允许在 Solidity 中编写测试，无需 JavaScript/TypeScript 环境。</p>
</li>
<li>
<p><strong>极快的编译和测试速度</strong>：基于 Rust 的二进制程序，编译和运行测试速度远超传统的 Hardhat/Truffle 等 JS 工具。对于大型项目或频繁迭代而言，这带来了明显效率提升。</p>
</li>
<li>
<p><strong>内置模糊测试（Fuzz Testing）</strong>：支持属性（property-based）测试，只要测试函数带有参数（如 <code>function testFuzz_XXX(uint256 x)</code>），Forge 会自动生成随机输入进行测试。如果找到失败的输入，还会给出最小化的反例，帮助发现边界问题。</p>
</li>
<li>
<p><strong>丰富的 Cheatcodes</strong>：提供多种“作弊码”用于修改测试时的区块链状态。例如，可以使用 <code>vm.prank(address)</code> 伪造交易发送者、<code>vm.warp(uint)</code> 修改区块时间戳、<code>vm.roll(uint)</code> 改变区块高度、<code>vm.deal(address, amount)</code> 设定地址余额、<code>vm.expectRevert(...)</code> 预期下一次调用回退等。这些功能可以大幅简化测试场景，如设置账户余额、时间推进等操作无需真实链交互。</p>
</li>
<li>
<p><strong>与 EVM 的高度一致性</strong>：Anvil 作为本地节点，与官方客户端行为高度相符，支持如 Hardhat 那样的主网分叉。测试时可直接以当前或指定区块高度的主网状态作为基础，更真实地模拟生产环境。</p>
</li>
</ul>
<h2 id="与-Hardhat-的区别和迁移考量">与 Hardhat 的区别和迁移考量</h2>
<p>Foundry 和 Hardhat 都是主流的以太坊开发框架，但在设计理念和生态上有明显差别：</p>
<ul>
<li>
<p><strong>语言和依赖</strong>：Hardhat 以 JavaScript/TypeScript 为主，依赖大量 Node.js 包；而 Foundry 是用 Rust 编写的 CLI 工具，不依赖 JS 环境。这意味着 Foundry 安装包更轻量、跨平台性好，但如果项目需要使用 JS 工具链（如前端脚本或第三方 JS 库），可能需要额外集成。</p>
</li>
<li>
<p><strong>测试框架</strong>：Hardhat 测试基于 Mocha/Chai 和 ethers.js，需要编写 JS 脚本来部署合约、发送交易和断言结果；Foundry 测试在 Solidity 内部进行，使用 <code>DSTest</code> 或 <code>forge-std</code> 标准库中的断言函数，测试代码更贴近合约本身。这对于纯 Solidity 团队来说，上手更快、避免了语言上下文切换。</p>
</li>
<li>
<p><strong>性能</strong>：Foundry 的编译和测试速度显著高于 Hardhat。如果项目测试规模大、迭代频繁，Foundry 可以节省大量时间。</p>
</li>
<li>
<p><strong>生态和插件</strong>：Hardhat 拥有成熟的插件生态，可与各种工具（如 Gas 报告、安全检查、前端框架等）无缝集成；Foundry 生态相对新兴，但也支持部分集成（例如官方提供了 Hardhat 插件，可在同一个项目中同时使用两者）。选择时应考虑团队技术栈：如果以 JS/TS 开发前端和自动化脚本为主，Hardhat 更方便；如果团队主要关心合约逻辑和高效测试，Foundry 更具吸引力。</p>
</li>
<li>
<p><strong>迁移注意</strong>：从 Hardhat 迁移到 Foundry 时，需要将测试代码从 JS 重写为 Solidity 脚本，并将配置文件从 <code>hardhat.config.js</code> 转换为 <code>foundry.toml</code>。依赖管理也有所不同，Foundry 使用 <code>forge install</code> 将依赖以 Git 子模块形式安装到 <code>lib/</code> 目录。</p>
</li>
</ul>
<h2 id="安装和初始化项目">安装和初始化项目</h2>
<ul>
<li>
<p><strong>安装 Foundryup</strong>：Foundry 官方提供了安装脚本。执行以下命令即可安装 Foundryup 管理工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://foundry.paradigm.xyz | bash</span><br></pre></td></tr></table></figure>
<p>按提示完成安装后，即可在终端使用 <code>foundryup</code> 命令。运行 <code>foundryup</code> 将自动下载并安装最新稳定版本的 Forge、Cast、Anvil、Chisel 等组件。若要安装最新夜间版，可使用 <code>foundryup --install nightly</code>。<strong>注意</strong>：在 Windows 上应通过 Git Bash 或 WSL 环境执行此脚本。</p>
</li>
<li>
<p><strong>初始化新项目</strong>：安装完成后，可以使用 <code>forge init</code> 创建新项目。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">forge init hello_foundry</span><br></pre></td></tr></table></figure>
<p>上述命令会在当前目录下创建 <code>hello_foundry</code> 文件夹，并根据模板生成项目结构。默认情况下，它还会初始化一个 Git 仓库并安装所需子模块。若不需要 Git 仓库，可加上 <code>--no-git</code> 参数。</p>
</li>
</ul>
<h2 id="项目结构说明">项目结构说明</h2>
<p>默认模板创建的 Foundry 项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── foundry.toml       // Foundry 配置文件</span><br><span class="line">├── src                // 智能合约源代码目录</span><br><span class="line">├── test               // 测试合约目录</span><br><span class="line">├── lib                // 依赖库目录（git 子模块）</span><br><span class="line">└── script             // Solidity 脚本目录</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>foundry.toml</strong>：项目配置文件，可在其中指定编译器版本、文件路径、编译参数等。</p>
</li>
<li>
<p><strong>src/</strong>：存放待部署的 Solidity 合约源文件，所有最终部署的合约都应放在此目录下。</p>
</li>
<li>
<p><strong>test/</strong>：存放测试合约，文件名通常以 <code>.t.sol</code> 结尾。Forge 会编译此目录中的合约，并运行所有函数名以 <code>test</code> 开头的函数。例如，<code>MyContract.t.sol</code> 中的 <code>function testFoo()</code> 会被识别为一个测试用例。</p>
</li>
<li>
<p><strong>lib/</strong>：存放项目依赖的库代码，以 Git 子模块方式管理。例如通过 <code>forge install</code> 安装 OpenZeppelin 库时，会将其放在 <code>lib/openzeppelin-contracts</code> 子目录中。</p>
</li>
<li>
<p><strong>script/</strong>：通常放置使用 Solidity 编写的脚本文件（后缀 <code>.s.sol</code>），用于与链交互（如部署合约或执行操作）。这些脚本可以通过 <code>forge script</code> 命令运行，将生成事务并发送到指定网络。</p>
</li>
</ul>
<p>以上目录结构可以通过 <code>foundry.toml</code> 或命令行参数进行自定义。同时，Foundry 支持使用 <code>--hh</code> 参数来兼容 Hardhat 项目结构（自动设置 <code>--lib-paths node_modules --contracts contracts</code>）。</p>
<h2 id="编写和运行测试">编写和运行测试</h2>
<p>Foundry 允许直接用 Solidity 编写测试合约。通常在测试文件中导入 Forge 标准库，然后让测试合约继承 <code>Test</code>（或 <code>DSTest</code>）基类。下面是一个简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">contract MyContractTest is Test &#123;</span><br><span class="line">    MyContract c;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        c = new MyContract();</span><br><span class="line">    &#125;</span><br><span class="line">    function testFunctionality() public &#123;</span><br><span class="line">        // 在这里进行断言</span><br><span class="line">        assertTrue(c.value() == 42);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在 <code>test/</code> 目录下，例如命名为 <code>MyContract.t.sol</code>。<code>setUp()</code> 函数会在每个测试运行前调用，用于初始化状态（类似于 JS 测试中的 <code>beforeEach</code>）。以 <code>test</code> 开头的函数（如 <code>testFunctionality</code>）会被 Forge 自动识别为测试。测试内部可使用 <code>assertEq</code>、<code>assertTrue</code>、<code>assertRevert</code> 等函数进行断言，无需手动捕捉异常。</p>
<p>运行测试非常简单：在项目根目录运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">forge test</span><br></pre></td></tr></table></figure>
<p>Forge 会自动编译 <code>src/</code> 和 <code>test/</code> 目录下的合约，并执行所有测试用例。测试输出会列出每个测试的执行结果及 Gas 消耗情况。如果测试失败，会展示失败信息和回溯调用栈。</p>
<p>与 Hardhat 不同，Foundry 测试过程不依赖 Mocha/Chai，也不需要启动额外节点，完全在本地进行，运行速度更快。而且测试代码与合约语言一致，Solidity 开发者无需切换语言即可编写和调试测试。</p>
<h2 id="使用-Cheatcodes">使用 Cheatcodes</h2>
<p>Foundry 的测试框架内置了大量“作弊码”，用于在测试中修改链上状态或检查行为。这些作弊码通过一个预设地址（<code>0x7109...DD12D</code>）暴露，通常通过 <code>vm</code> 变量调用。例如：</p>
<ul>
<li>
<p><code>vm.prank(address)</code>：将下一笔交易的发送者伪造为指定地址。</p>
</li>
<li>
<p><code>vm.startPrank(address)</code> / <code>vm.stopPrank()</code>：连续伪造后续多笔交易的发送者。</p>
</li>
<li>
<p><code>vm.warp(uint256 timestamp)</code>：设置区块的时间戳。</p>
</li>
<li>
<p><code>vm.roll(uint256 blockNumber)</code>：设置区块高度。</p>
</li>
<li>
<p><code>vm.deal(address who, uint256 amount)</code>：为指定地址设置以太币余额。</p>
</li>
<li>
<p><code>vm.load(address who, bytes32 slot)</code> / <code>vm.store(address who, bytes32 slot, bytes32 val)</code>：直接读写任意地址的存储槽。</p>
</li>
<li>
<p><code>vm.expectRevert() / vm.expectRevert(bytes4) / vm.expectRevert(string)</code>：预期下一次合约调用会回退（可指定错误选择子或错误信息）。</p>
</li>
<li>
<p><code>vm.expectEmit(bool,bool,bool,bool)</code>：预期下一笔交易会发出某个事件，并可部分匹配事件的索引参数。</p>
</li>
</ul>
<p>例如，下面的测试片段使用 <code>expectRevert</code> 和 <code>prank</code> 来断言非合约所有者调用失败：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_RevertWhen_CallerIsNotOwner() public &#123;</span><br><span class="line">    vm.expectRevert(Unauthorized.selector);</span><br><span class="line">    vm.prank(address(0));</span><br><span class="line">    upOnly.increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这些 Cheatcodes，测试可以方便地模拟各种链上操作（例如快速推进时间、设置账户余额、模拟外部合约调用等），从而覆盖更多场景。</p>
<h2 id="使用-Fuzz-Testing-和属性测试">使用 Fuzz Testing 和属性测试</h2>
<p>Foundry 支持“属性测试”（Property-Based Testing），即模糊测试。如果测试函数带有至少一个参数，Forge 会将其视为模糊测试，并自动生成随机输入执行多次测试。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testFuzz_Withdraw(uint256 amount) public &#123;</span><br><span class="line">    payable(address(safe)).transfer(amount);</span><br><span class="line">    uint256 pre = address(this).balance;</span><br><span class="line">    safe.withdraw();</span><br><span class="line">    uint256 post = address(this).balance;</span><br><span class="line">    assertEq(pre + amount, post);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，<code>testFuzz_Withdraw</code> 会被 Forge 多次调用，每次传入不同的随机 <code>amount</code> 值。Forge 会寻找导致测试失败的输入，并给出经过“缩小”处理（minimal counterexample）的反例。这种方法有助于自动发现边界情况和潜在错误，使得测试覆盖更全面。测试函数名可以以 <code>testFuzz_</code> 开头（或者任何 <code>test</code> 前缀带参数的函数都会自动 fuzz），也可配合分支条件等，以明确表示这是一个模糊测试场景。</p>
<h2 id="合约部署和与前端交互方式简介">合约部署和与前端交互方式简介</h2>
<p>Foundry 提供了 <code>forge</code> 和 <code>cast</code> 两个命令行工具来进行部署和与链交互：</p>
<ul>
<li>
<p><strong>部署合约</strong>：使用 <code>forge create</code> 命令。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">forge create MyContract --private-key &lt;YOUR_PRIVATE_KEY&gt; --rpc-url &lt;RPC_URL&gt;</span><br></pre></td></tr></table></figure>
<p>这会编译 <code>MyContract</code> 合约并使用指定的私钥在指定网络（通过 <code>--rpc-url</code>）上部署该合约。可以通过 <code>--constructor-args</code> 传入构造函数参数，通过 <code>--verify</code> 启用 Etherscan 等服务的源码验证。</p>
</li>
<li>
<p><strong>读取链上数据（只读调用）</strong>：使用 <code>cast call</code>，无需私钥。例如，可以调用一个 ERC20 合约的 <code>balanceOf</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cast call 0x6B175474E89094C44Da98b954EedeAC495271d0F &quot;balanceOf(address)(uint256)&quot; --rpc-url &lt;RPC_URL&gt;</span><br></pre></td></tr></table></figure>
<p>该命令通过 ABI 编码并调用合约函数，然后输出返回结果。</p>
</li>
<li>
<p><strong>发送交易</strong>：使用 <code>cast send</code> 并提供私钥。比如向 ERC20 合约发送一笔 <code>transfer</code> 交易：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cast send --private-key &lt;YOUR_PRIVATE_KEY&gt; 0xTOKEN_ADDRESS &quot;transfer(address,uint256)&quot; 0xRECIPIENT 100</span><br></pre></td></tr></table></figure>
<p><code>cast send</code> 会使用指定私钥签名并发送交易，可通过 <code>--rpc-url</code> 指定节点。这些工具使得在脚本或命令行下即可完成链上交互，无需像 Hardhat 那样启动整个框架环境。</p>
</li>
</ul>
<h2 id="最佳实践">最佳实践</h2>
<ul>
<li>
<p><strong>测试组织</strong>：测试合约文件一般与源合约同名（<code>MyContract.sol</code> 对应 <code>MyContract.t.sol</code>）。可以为同一个合约创建多个测试合约或分组：一种方式是按功能拆分小的测试合约；另一种方式是每个待测合约对应一个测试合约，内含多个测试函数。无论采用哪种，都建议保持一致的结构便于维护。</p>
</li>
<li>
<p><strong>命名规范</strong>：统一的函数命名有助于管理测试。常见约定如 <code>testXXX</code>（一般测试）、<code>testFuzz_XXX</code>（模糊测试）、<code>test_RevertIfYYY</code>（预期发生回退）等。例如，可使用 <code>testFork_...</code> 前缀表示需要主网分叉的测试。遵循这些模式可以在运行 <code>forge test</code> 时方便地筛选测试用例。</p>
</li>
<li>
<p><strong>代码格式和静态检查</strong>：建议使用 <code>forge fmt</code> 格式化代码，保持代码风格统一。Foundry 还提供静态分析工具（如 <code>forge check</code>）检查可能的错误。此外，尽量编写清晰可读的合约和测试代码，例如使用有意义的变量名、避免冗余逻辑、将相关代码放在一起等。</p>
</li>
<li>
<p><strong>持续集成（CI）</strong>：在 CI 流水线中集成 Foundry 通常只需安装 Rust 环境并运行 <code>forge test</code>。官方文档提供了 GitHub Actions、Travis CI、GitLab CI 等示例配置。例如，在 GitHub Actions 中可在 push 时触发，安装 Foundry 后执行 <code>forge test</code> 验证所有测试通过即可。通过自动化 CI，可确保每次代码提交都经过 Foundry 测试套件的检查。</p>
</li>
</ul>
<p><strong>参考资料：</strong> Foundry 官方文档和示例等。</p>
]]></content>
      <categories>
        <category>Cyfrin Updraft</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>Foundry</tag>
      </tags>
  </entry>
  <entry>
    <title>GeeWeb学习笔记</title>
    <url>/2025/12/06/GeeWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>未完待续。。。</p>
</blockquote>
<h2 id="day3-前缀树路由">day3 前缀树路由</h2>
<h3 id="Trie树">Trie树</h3>
<p>在前一节我们使用map结构存储路由表（key是具体请求的路由，value是对应的HandlerFunc），使用map存储键值对，索引非常高效。但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。</p>
<p>那如果我们想支持类似于/hello/:name这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。</p>
<p>我们想要实现的是：<br>
- 请求 <code>/hello/alan</code> or <code>/hello/vhsj</code>       --路由到–&gt; <code>/hello/:name</code>索引到的处理函数下 （获取路径参数）<br>
- 请求 <code>/asset/anything/like/CSSfiles/path</code> --路由到–&gt; <code>/asset/*filename</code>索引到的处理函数下 （静态资源请求）</p>
<p><img data-src="https://geektutu.com/post/gee-day3/trie_eg.jpg" alt="前缀树"></p>
<p>所以我们引入前缀树来实现动态路由，添加路由表的时候我们会使用带有通配符（:/*）的路由注册到树中并所引导对应的处理函数，然后到查询的时候我们会解析request的具体路径，从根节点开始递归的查询，一层层往下匹配（通配符会有特殊的处理，例如“:”需要解析路径参数保存，而“*”则需要结束匹配保存路径的后半部分）直到叶子结点（在中间停止也是失败的，例如请求路径“/user/alan” 不可以 匹配路由“/user/:name/hahaha”）</p>
<p>规则不用多说，直接看怎么实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	pattern  <span class="type">string</span>  <span class="comment">// 目标路由，例如 /hello/:name</span></span><br><span class="line">	part     <span class="type">string</span>  <span class="comment">// 路由一部分，或者说树的一层内容，例如 /:name</span></span><br><span class="line">	children []*node <span class="comment">// 子节点</span></span><br><span class="line">	isWild   <span class="type">bool</span>    <span class="comment">// 是否模糊匹配，part 含有 : 或 * 时为true，此时需要按照对应规则进行处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个匹配成功的节点，用于插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChild(part <span class="type">string</span>) *node &#123;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> c.part == part || c.isWild &#123;</span><br><span class="line">			<span class="keyword">return</span> c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有匹配成功的节点，用于查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChildren(part <span class="type">string</span>) []*node &#123;</span><br><span class="line">	nodes := []*node&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> c.part == part || c.isWild &#123;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建路由：前缀树插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> insert(pattern <span class="type">string</span>, parts []<span class="type">string</span>, height <span class="type">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入结束，每一个part都加入树中，递归结束</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">		n.pattern = pattern</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前层要处理part</span></span><br><span class="line">	part := parts[height]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到第一个匹配的子节点</span></span><br><span class="line">	child := n.matchChild(part)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果这个位置是空，则创建一个子节点，把这个part放在这个位置</span></span><br><span class="line">	<span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line">		child = &amp;node&#123;</span><br><span class="line">			part:   part,</span><br><span class="line">			isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向下递归匹配</span></span><br><span class="line">	child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由检索：前缀树插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> search(parts []<span class="type">string</span>, height <span class="type">int</span>) *node &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 递归终止条件：到底了或者遇到通配符*（表示后面都可以匹配）</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">		<span class="comment">// 说明不是当前节点不是完整路由，而是中间某一块</span></span><br><span class="line">		<span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前要搜索的块</span></span><br><span class="line">	part := parts[height]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 匹配的所有子节点</span></span><br><span class="line">	children := n.matchChildren(part)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分别去递归搜索</span></span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">		result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现动态路由">实现动态路由</h3>
<p>现在使用新的数据结构来存储路由表实现我们的目标：通配符路由注册 + 动态请求路径匹配</p>
<ol>
<li>定义路由：roots中key为Method，value是树根，意为一种req method一棵树；handlers中key为注册的路由（含有通配符的），value为对应的处理函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	roots    <span class="keyword">map</span>[<span class="type">string</span>]*node</span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">		roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*node),</span><br><span class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解析路径：把实际的请求路径切割成一个个part</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only one * is allowed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">	parts := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line">		<span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line">			<span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>添加和查询路由：对应TrieTree的插入和搜索</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">	parts := parsePattern(pattern)</span><br><span class="line"></span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">	_, ok := r.roots[method]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r.roots[method].insert(pattern, parts, <span class="number">0</span>)</span><br><span class="line">	r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：对应的路由、路径参数列表，例如 /user/:id/hello、&#123;&quot;id&quot;:&quot;114514&quot;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoute(method <span class="type">string</span>, path <span class="type">string</span>) (*node, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) &#123;</span><br><span class="line">	searchParts := parsePattern(path)</span><br><span class="line">	params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	root, ok := r.roots[method]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := root.search(searchParts, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		parts := parsePattern(n.pattern)</span><br><span class="line">		<span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = searchParts[index]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n, params</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="day4分组控制">day4分组控制</h2>
<h3 id="什么是分组控制">什么是分组控制</h3>
<p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。简单理解就是，很多的路由有共同的需求可以集中处理设置（中间件），例如：</p>
<ul>
<li>以/post开头的路由匿名可访问。</li>
<li>以/admin开头的路由需要鉴权。</li>
<li>以/api开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li>
</ul>
<p>所以路由分组主要是可以方便功能扩展、提升代码注册逻辑性、减少大量重复代码编写。</p>
<h3 id="实现逻辑">实现逻辑</h3>
<p>首先一个分组需要什么呢？一个公共的前缀prefix、一组公共处理逻辑（中间件）middlewares、领导/管理者/上层抽象，即我们的引擎engine，所以RouterGroup可以定义为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	prefix      <span class="type">string</span></span><br><span class="line">	middlewares []HandlerFunc </span><br><span class="line">	engine      *Engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在引擎结构中也嵌入（embeding）Group，那么enigin就可以直接使用Group的所有方法，相当于engine是group的子类。<br>
作为子类，是一定比父类功能更多的，作为路由分组，他需要处理路由相关的功能（注册、查询等等），而引擎则需要更多功能（服务器启动关闭等等）。那么为什么不把分组作为属性放到引擎中呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引擎就是一个根路由</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    *RouterGroup</span><br><span class="line">    router *router</span><br><span class="line">    groups []*RouterGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line">	engine := &amp;Engine&#123;router: NewRouter()&#125;</span><br><span class="line">	engine.groups = []*RouterGroup&#123;&#125;</span><br><span class="line">	engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class="line">	<span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-嵌入（Embedding）的作用">1.嵌入（Embedding）的作用</h4>
<p><code>Engine</code>通过嵌入<code>*RouterGroup</code>，可以直接使用<code>RouterGroup</code>的所有方法（<code>GET</code>、<code>POST</code>、<code>Group</code>等）。但这<strong>不是继承</strong>，而是<strong>方法提升（method promotion）</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    *RouterGroup  <span class="comment">// 嵌入</span></span><br><span class="line">    router *router</span><br><span class="line">    groups []*RouterGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为嵌入了 *RouterGroup，所以可以这样调用：</span></span><br><span class="line">engine.GET(<span class="string">&quot;/&quot;</span>, handler)  <span class="comment">// 实际是 engine.RouterGroup.GET()</span></span><br><span class="line">engine.Group(<span class="string">&quot;/v1&quot;</span>)       <span class="comment">// 实际是 engine.RouterGroup.Group()</span></span><br></pre></td></tr></table></figure>
<h4 id="2-为什么用嵌入而不是普通属性？">2.为什么用嵌入而不是普通属性？</h4>
<ol>
<li><strong>API一致性和便利性</strong><br>
如果用普通属性：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    group RouterGroup  <span class="comment">// 普通属性</span></span><br><span class="line">    router *router</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用时必须：</span></span><br><span class="line">engine.group.GET(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">engine.group.Group(<span class="string">&quot;/v1&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>用嵌入后，<code>Engine</code>和<code>RouterGroup</code>有相同的API接口，使用者不需要关心是操作根路由组还是子路由组。</p>
<ol start="2">
<li><strong>根路由组的特殊性</strong><br>
<code>Engine</code>本质上<strong>就是一个根路由组</strong>，它具有：</li>
</ol>
<ul>
<li>能注册路由（<code>GET</code>、<code>POST</code>）</li>
<li>能创建子路由组（<code>Group</code>）</li>
<li>另外还能启动服务器（<code>Run</code>、<code>ServeHTTP</code>）</li>
</ul>
<p>用嵌入表示这种&quot;is-a&quot;关系（Engine <strong>是一个</strong> RouterGroup）。</p>
<p>然后把所有根路由有关的方法定义到Group上面即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group is defined to create a new RouterGroup</span></span><br><span class="line"><span class="comment">// remember all groups share the same Engine instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> Group(prefix <span class="type">string</span>) *RouterGroup &#123;</span><br><span class="line">	engine := rg.engine <span class="comment">// share engine</span></span><br><span class="line">	newRg := &amp;RouterGroup&#123;</span><br><span class="line">		prefix: rg.prefix + prefix,</span><br><span class="line">		engine: engine,</span><br><span class="line">	&#125;</span><br><span class="line">	engine.groups = <span class="built_in">append</span>(engine.groups, newRg)</span><br><span class="line">	<span class="keyword">return</span> newRg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由相关的方法全部定义到 rg 上</span></span><br><span class="line"><span class="comment">// 由于engine中嵌入了 rg ，所以engine也可以直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> addRoute(method <span class="type">string</span>, comp <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">	pattern := rg.prefix + comp</span><br><span class="line">	log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">	rg.engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些基本的方法的添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">	rg.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">	rg.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eigine作为根可以使用上面的函数，另外也有其他：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span></span> Run(addr <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// e 必须得实现接口方法</span></span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(addr, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	<span class="comment">// 一次请求，创建一个context</span></span><br><span class="line">	context := newContext(w, r)</span><br><span class="line">	e.router.handle(context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用示例">使用示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gee.New()</span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.Html(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// expect /hello?name=alan</span></span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// expect /hello/geektutu</span></span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Param(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/assets/*filepath&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gee.H&#123;<span class="string">&quot;filepath&quot;</span>: c.Param(<span class="string">&quot;filepath&quot;</span>)&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day5中间件">day5中间件</h2>
<h3 id="什么是中间件">什么是中间件</h3>
<p>中间件(middlewares)，简单说，就是非业务的技术类组件。<br>
Web 框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样，例如：日志、鉴权、错误处理等等</p>
<p>再简单点的，在当前的框架中，中间件本质上也是一个个HandlerFunc，他们通过求情的context获取需要的信息，然后完成相应的功能，并且像链条一样往后执行（Next），直到最后一步到达我们的业务处理HandlerFunc，执行完之后再沿着这个链条返回回去（其中可能中间件还有代码要执行）。</p>
<h3 id="中间件设计">中间件设计</h3>
<p>就以最简单的统计请求处理时长为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span></span> HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line">		<span class="comment">// 往后执行中间件or实际业务（压盏）</span></span><br><span class="line">		c.Next()</span><br><span class="line">		log.Printf(<span class="string">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.R.RequestURI, time.Since(t))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中间件是加在 RouterGroup（路由分组）上的。如果把中间件加在最顶层的 Group(engine)，就是全局中间件，所有请求都会经过它。</p>
<blockquote>
<p>那为什么不直接把中间件加在每一条路由上呢？其实如果只针对某一条路由用中间件，还不如直接在 Handler 里写逻辑，反而更直观。中间件的意义就在于“通用”，如果只服务于一条路由，灵活性和复用性都很差，也就不适合叫中间件了。</p>
</blockquote>
<p>在我们的框架设计里，请求进来后会先匹配路由，然后把请求的所有信息都放到 Context 里。中间件也是一样：请求进来后，先找到所有应该作用在这条路由上的中间件，按顺序放进 Context，然后依次执行。为什么要这样？因为中间件不仅可以在业务 Handler 之前做事，还可以在 Handler 执行完之后继续处理（比如日志、收尾工作等），所以需要统一管理。</p>
<p>为此，我们给 Context 增加了两个参数，并定义了 Next 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// origin objects</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// request info</span></span><br><span class="line">	Path   <span class="type">string</span></span><br><span class="line">	Method <span class="type">string</span></span><br><span class="line">	Params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	<span class="comment">// response info</span></span><br><span class="line">	StatusCode <span class="type">int</span></span><br><span class="line">	<span class="comment">// middleware</span></span><br><span class="line">	handlers []HandlerFunc</span><br><span class="line">	index    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> *Context &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">		Path:   req.URL.Path,</span><br><span class="line">		Method: req.Method,</span><br><span class="line">		Req:    req,</span><br><span class="line">		Writer: w,</span><br><span class="line">		index:  <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Next() &#123;</span><br><span class="line">	c.index++</span><br><span class="line">	s := <span class="built_in">len</span>(c.handlers)</span><br><span class="line">	<span class="keyword">for</span> ; c.index &lt; s; c.index++ &#123;</span><br><span class="line">		c.handlers[c.index](c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="框架实现">框架实现</h3>
<p>直接看全文+注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	*RouterGroup</span><br><span class="line">	router *router</span><br><span class="line">	groups []*RouterGroup <span class="comment">// store all groups</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	prefix      <span class="type">string</span></span><br><span class="line">	middlewares []HandlerFunc <span class="comment">// support middleware</span></span><br><span class="line">	engine      *Engine       <span class="comment">// all groups share a Engine instance</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line">	engine := &amp;Engine&#123;router: NewRouter()&#125;</span><br><span class="line">	<span class="comment">// engine.groups = []*RouterGroup&#123;&#125;</span></span><br><span class="line">	engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;</span><br><span class="line">	engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class="line">	<span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group is defined to create a new RouterGroup</span></span><br><span class="line"><span class="comment">// remember all groups share the same Engine instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> Group(prefix <span class="type">string</span>) *RouterGroup &#123;</span><br><span class="line">	engine := rg.engine <span class="comment">// share engine</span></span><br><span class="line">	newRg := &amp;RouterGroup&#123;</span><br><span class="line">		prefix: rg.prefix + prefix,</span><br><span class="line">		engine: engine,</span><br><span class="line">	&#125;</span><br><span class="line">	engine.groups = <span class="built_in">append</span>(engine.groups, newRg)</span><br><span class="line">	<span class="keyword">return</span> newRg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由相关的方法全部定义到 rg 上</span></span><br><span class="line"><span class="comment">// 由于engine中嵌入了 rg ，所以engine也可以直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> addRoute(method <span class="type">string</span>, comp <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">	pattern := rg.prefix + comp</span><br><span class="line">	log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">	rg.engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些基本的方法的添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">	rg.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *RouterGroup)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">	rg.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span></span> Run(addr <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// e 必须得实现接口方法</span></span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(addr, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span></span><br><span class="line"><span class="comment">// 	// 一次请求，创建一个context</span></span><br><span class="line"><span class="comment">// 	context := newContext(w, r)</span></span><br><span class="line"><span class="comment">// 	e.router.handle(context)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	<span class="keyword">var</span> middlewares []HandlerFunc</span><br><span class="line">	<span class="comment">// 检查所有的分组，如果当前请求属于这个分组，则把这个分组的中间件添加到context里去</span></span><br><span class="line">	<span class="keyword">for</span> _, group := <span class="keyword">range</span> engine.groups &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;</span><br><span class="line">			middlewares = <span class="built_in">append</span>(middlewares, group.middlewares...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c := newContext(w, req)</span><br><span class="line">	c.handlers = middlewares</span><br><span class="line">	<span class="comment">// 开始处理handlers，同时在handle()添加业务处理的HandlerFunc</span></span><br><span class="line">	engine.router.handle(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use is defined to add middleware to the group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Use(middlewares ...HandlerFunc) &#123;</span><br><span class="line">	group.middlewares = <span class="built_in">append</span>(group.middlewares, middlewares...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相应的handle方法也要更新，主要是添加上业务handlerFunc + 启动这个链条的执行（第一个调用Next）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">	n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">		c.Params = params</span><br><span class="line">		<span class="comment">// 添加业务处理的Handler到链条的尾部，最后执行</span></span><br><span class="line">		c.handlers = <span class="built_in">append</span>(c.handlers, r.handlers[key])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.handlers = <span class="built_in">append</span>(c.handlers, <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">			c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始按顺序处理handlers，这是第一次调用，处理链条中的第一个</span></span><br><span class="line">	<span class="comment">// 中间的每一个“中间件”都要会调用Next往后执行（也可以不调用，但是我没见过）</span></span><br><span class="line">	<span class="comment">// 注意：业务HandlerFunc不会Next，他们会正常执行，然后返回到上一层的Next的“after”位置做收尾工作（如果有的话）</span></span><br><span class="line">	<span class="comment">// 例如，Logger开始计时后，执行所有的请求处理，结束后回到Logger统计时间，打印日志</span></span><br><span class="line">	c.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Commit术语</title>
    <url>/2025/05/03/Gitcommit%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 <code>git commit -m</code> 提交代码时，通常会在提交信息中使用一些常见的前缀来描述提交的类型和目的。这些前缀有助于团队更好地理解提交的内容，尤其是在查看提交历史或生成变更日志时。以下是一些常用的前缀及其含义：</p>
<hr>
<h3 id="1-fix">1. <strong><code>fix</code></strong></h3>
<p>表示修复了一个 bug 或问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;fix: 修复登录页面无法加载的问题&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-feat">2. <strong><code>feat</code></strong></h3>
<p>表示新增了一个功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;feat: 添加用户注册功能&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-docs">3. <strong><code>docs</code></strong></h3>
<p>表示文档相关的更改（如 README、注释等）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;docs: 更新项目 README 文件&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-style">4. <strong><code>style</code></strong></h3>
<p>表示代码风格的更改（如格式化、缩进等），不涉及功能或逻辑的修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;style: 格式化代码缩进&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="5-refactor">5. <strong><code>refactor</code></strong></h3>
<p>表示代码重构，既不修复 bug 也不添加新功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;refactor: 重构用户模块的代码结构&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="6-test">6. <strong><code>test</code></strong></h3>
<p>表示测试相关的更改（如添加或修改测试用例）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;test: 添加用户登录功能的单元测试&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="7-chore">7. <strong><code>chore</code></strong></h3>
<p>表示日常维护或工具相关的更改（如依赖更新、构建配置等）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;chore: 更新项目依赖包&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="8-perf">8. <strong><code>perf</code></strong></h3>
<p>表示性能优化相关的更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;perf: 优化数据库查询性能&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="9-ci">9. <strong><code>ci</code></strong></h3>
<p>表示持续集成（CI）相关的更改（如 GitHub Actions、Travis CI 等）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;ci: 添加 GitHub Actions 自动化测试&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="10-revert">10. <strong><code>revert</code></strong></h3>
<p>表示回滚之前的提交。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;revert: 回滚错误的用户注册功能提交&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="11-build">11. <strong><code>build</code></strong></h3>
<p>表示构建系统或外部依赖的更改（如 Webpack、Gulp 等）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;build: 更新 Webpack 配置&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="12-wip">12. <strong><code>wip</code></strong></h3>
<p>表示正在进行中的工作（Work In Progress），通常用于临时提交。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;wip: 用户模块开发中&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="13-hotfix">13. <strong><code>hotfix</code></strong></h3>
<p>表示紧急修复生产环境中的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;hotfix: 紧急修复支付接口崩溃问题&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="14-init">14. <strong><code>init</code></strong></h3>
<p>表示项目初始化或首次提交。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;init: 初始化项目&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="15-merge">15. <strong><code>merge</code></strong></h3>
<p>表示合并分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;merge: 合并 feature/login 分支到 main&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="提交信息格式建议">提交信息格式建议</h3>
<p>通常推荐使用以下格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;: &lt;描述&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;feat: 添加用户登录功能&quot;</span><br></pre></td></tr></table></figure>
<p>如果需要更详细的描述，可以使用多行提交信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;fix: 修复登录页面无法加载的问题</span><br><span class="line"></span><br><span class="line">- 修复了登录页面因 API 接口错误导致的加载失败问题</span><br><span class="line">- 优化了错误提示信息&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="总结">总结</h3>
<ul>
<li>
<p>使用清晰的前缀（如 <code>fix</code>、<code>feat</code>、<code>docs</code> 等）来描述提交的类型。</p>
</li>
<li>
<p>提交信息应简洁明了，便于团队协作和代码审查。</p>
</li>
<li>
<p>如果需要更详细的描述，可以使用多行提交信息。</p>
</li>
</ul>
<p>这些规范可以帮助团队更好地管理提交历史，并生成更有意义的变更日志。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之Gorm入门</title>
    <url>/2025/07/17/Go%E8%AF%AD%E8%A8%80%E4%B9%8BGorm%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="使用-GORM-操作-MySQL-数据库：从入门到实践">使用 GORM 操作 MySQL 数据库：从入门到实践</h2>
<p>在 Go 语言中进行数据库操作，除了 <code>database/sql</code> 标准库和像 <code>sqlx</code> 这样的扩展库外，还有许多优秀的 ORM (Object-Relational Mapping) 框架。其中，<strong>GORM</strong> 以其简洁的 API、强大的功能和活跃的社区支持，成为了 Go 开发者进行数据库操作的首选之一。</p>
<p>本文将从一个 <code>sqlx</code> 的示例出发，逐步讲解如何使用 GORM 实现数据库的增删改查以及事务操作，并分享一些 GORM 的高级用法和开发技巧。</p>
<h3 id="为什么选择-GORM？">为什么选择 GORM？</h3>
<p>在深入 GORM 之前，我们先来探讨一下为什么选择 ORM，以及 GORM 相较于 <code>sqlx</code> 有何优势：</p>
<ul>
<li><strong>减少 SQL 编写</strong>: ORM 的核心优势在于将数据库操作抽象为 Go 结构体和方法调用，大大减少了手动编写 SQL 语句的工作量，降低了出错的概率。</li>
<li><strong>提高开发效率</strong>: 结构化的 API 和内置的各种便利函数，能够让开发者更专注于业务逻辑，而非底层的数据库细节。</li>
<li><strong>类型安全</strong>: GORM 通过 Go 结构体来映射数据库表，利用 Go 的类型系统，在编译期就能发现一些潜在的类型错误。</li>
<li><strong>跨数据库兼容性</strong>: GORM 支持多种数据库（MySQL, PostgreSQL, SQLite, SQL Server 等），在切换数据库时，大部分代码无需修改。</li>
</ul>
<p>相较于 <code>sqlx</code>，GORM 的优势主要体现在：</p>
<ul>
<li><strong>更彻底的抽象</strong>: <code>sqlx</code> 依然需要手动编写 SQL 语句，而 GORM 更多地通过方法链来构建查询。</li>
<li><strong>更丰富的功能</strong>: GORM 内置了预加载、关联查询、自动迁移等高级功能，这些在 <code>sqlx</code> 中需要手动实现或依赖其他库。</li>
<li><strong>更友好的链式 API</strong>: GORM 的方法链式调用让代码更具可读性和流畅性。</li>
</ul>
<h3 id="GORM-基础入门：连接、模型与CRUD">GORM 基础入门：连接、模型与CRUD</h3>
<h4 id="1-安装-GORM">1. 安装 GORM</h4>
<p>首先，你需要安装 GORM 及其 MySQL 驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/mysql</span><br></pre></td></tr></table></figure>
<h4 id="2-连接数据库">2. 连接数据库</h4>
<p>在 GORM 中，连接数据库非常简单。我们通常在 <code>init</code> 函数中完成数据库的初始化，并将其存储在一个全局变量中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DB *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dsn := <span class="string">&quot;username:password@(localhost:3306)/study?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	DB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to connect database: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动迁移</span></span><br><span class="line">	<span class="comment">// GORM 会根据结构体定义自动创建或更新表结构</span></span><br><span class="line">	err = DB.AutoMigrate(&amp;Person&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to auto migrate: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;Database connection and migration successful!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 结构体定义和CRUD操作</span></span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>dsn</code>: DSN (Data Source Name) 是连接数据库的字符串，格式与 <code>sqlx</code> 类似。</li>
<li><code>mysql.Open(dsn)</code>: 使用 GORM 提供的 MySQL 驱动打开数据库连接。</li>
<li><code>gorm.Open(...)</code>: 初始化 GORM 数据库连接，并可以传入 <code>&amp;gorm.Config&#123;&#125;</code> 进行一些配置，例如日志模式、命名策略等。</li>
<li><code>DB.AutoMigrate(&amp;Person&#123;&#125;)</code>: 这是 GORM 的一个非常方便的功能。它会根据 <code>Person</code> 结构体定义，自动创建 <code>user</code> 表（如果不存在），或者根据结构体的字段变化更新表结构。这在开发阶段非常有用。</li>
</ul>
<h4 id="3-定义数据结构-模型">3. 定义数据结构 (模型)</h4>
<p>GORM 使用 Go 结构体来定义数据库表。默认情况下，GORM 会将结构体名称的复数形式作为表名（例如，<code>Person</code> 结构体对应 <code>people</code> 表），但我们可以通过 <code>TableName()</code> 方法或者在 <code>gorm:&quot;table:user&quot;</code> 标签中指定表名。字段名默认转换为蛇形命名（例如 <code>UserId</code> 对应 <code>user_id</code>）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 结构体定义</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// GORM 约定 `ID` 或 `Id` 字段为主键，会自动识别为自增主键。</span></span><br><span class="line">	<span class="comment">// 这里我们使用 `UserId` 来映射 `id` 列，并且指定其为主键。</span></span><br><span class="line">	<span class="comment">// GORM 约定: 如果是 `ID` 字段，默认就是主键且自增。</span></span><br><span class="line">	<span class="comment">// 如果不是 `ID` 字段，需要显式加上 `gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">	UserId   <span class="type">string</span> <span class="string">`gorm:&quot;column:id;primaryKey&quot;`</span> <span class="comment">// 对应数据库的 id 列，并且是主键</span></span><br><span class="line">	Username <span class="type">string</span> <span class="string">`gorm:&quot;column:name&quot;`</span>          <span class="comment">// 对应数据库的 name 列</span></span><br><span class="line">	Age      <span class="type">int</span>    <span class="string">`gorm:&quot;column:age&quot;`</span>           <span class="comment">// 对应数据库的 age 列</span></span><br><span class="line">	Address  <span class="type">string</span> <span class="string">`gorm:&quot;column:address&quot;`</span>       <span class="comment">// 对应数据库的 address 列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableName 方法用于指定 GORM 对应的数据库表名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Person)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;user&quot;</span> <span class="comment">// 将 Person 结构体映射到 user 表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>gorm:&quot;column:id;primaryKey&quot;</code>: 通过 <code>gorm</code> 标签来指定字段与数据库列的映射关系以及其他属性。
<ul>
<li><code>column:id</code>: 指定结构体字段 <code>UserId</code> 映射到数据库表的 <code>id</code> 列。</li>
<li><code>primaryKey</code>: 将 <code>UserId</code> 标记为主键。</li>
</ul>
</li>
<li><code>TableName()</code> 方法: 这是一个 GORM 的约定，通过实现这个方法，我们可以自定义结构体对应的表名，这里我们将其设置为 <code>user</code>，与你的 <code>sqlx</code> 示例保持一致。</li>
</ul>
<h4 id="4-CRUD-操作-增删改查">4. CRUD 操作 (增删改查)</h4>
<h5 id="查询-Retrieve">查询 (Retrieve)</h5>
<p><strong>查询单条记录</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// query 查询单条记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="comment">// First 根据主键查找第一条记录</span></span><br><span class="line">	<span class="comment">// DB.First(&amp;p, &quot;12132&quot;)</span></span><br><span class="line">	<span class="comment">// Where 子句用于构建查询条件</span></span><br><span class="line">	result := DB.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;12132&quot;</span>).First(&amp;p)</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> result.Error == gorm.ErrRecordNotFound &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;query fail: record not found for id %s\n&quot;</span>, <span class="string">&quot;12132&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;query fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;query succ: %v\n&quot;</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>DB.Where(&quot;id = ?&quot;, &quot;12132&quot;)</code>: 使用 <code>Where</code> 方法构建查询条件。GORM 会自动将 <code>Person</code> 结构体中的 <code>UserId</code> 字段映射到 <code>id</code> 列。</li>
<li><code>First(&amp;p)</code>: 查找满足条件的第一条记录，并将其扫描到 <code>p</code> 结构体中。如果没有找到记录，会返回 <code>gorm.ErrRecordNotFound</code> 错误。</li>
</ul>
<p><strong>查询多条记录 (列表)</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list 查询多条记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ps []Person</span><br><span class="line">	<span class="comment">// Find 查询所有记录</span></span><br><span class="line">	result := DB.Find(&amp;ps)</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;list fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> ps &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;list succ: %v\n&quot;</span>, p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>DB.Find(&amp;ps)</code>: 查找所有 <code>Person</code> 记录，并将其扫描到 <code>ps</code> 切片中。</li>
</ul>
<h5 id="新增-Create">新增 (Create)</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert 插入单条记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">()</span></span> &#123;</span><br><span class="line">	newPerson := Person&#123;UserId: <span class="string">&quot;1145&quot;</span>, Username: <span class="string">&quot;alan&quot;</span>, Age: <span class="number">24</span>, Address: <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">	result := DB.Create(&amp;newPerson)</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;insert fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果主键是自增的，GORM 会自动填充到结构体中</span></span><br><span class="line">	log.Printf(<span class="string">&quot;insert succ, ID: %s, RowsAffected: %d\n&quot;</span>, newPerson.UserId, result.RowsAffected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>DB.Create(&amp;newPerson)</code>: 将 <code>newPerson</code> 结构体插入到数据库中。GORM 会自动根据结构体字段生成 <code>INSERT</code> 语句。</li>
<li><code>result.RowsAffected</code>: 返回受影响的行数。</li>
</ul>
<h5 id="更新-Update">更新 (Update)</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// update 更新记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 更新单个字段</span></span><br><span class="line">	<span class="comment">// result := DB.Model(&amp;Person&#123;&#125;).Where(&quot;id = ?&quot;, &quot;1145&quot;).Update(&quot;name&quot;, &quot;alan223&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新多个字段</span></span><br><span class="line">	result := DB.Model(&amp;Person&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1145&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;alan223&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 或者直接传入结构体，GORM 会更新非零值字段</span></span><br><span class="line">	<span class="comment">// p := Person&#123;UserId: &quot;1145&quot;, Username: &quot;alan223&quot;, Age: 25&#125;</span></span><br><span class="line">	<span class="comment">// result := DB.Model(&amp;p).Where(&quot;id = ?&quot;, &quot;1145&quot;).Updates(p) // 注意这里Updates(p)会更新所有非零值字段</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;update fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result.RowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;update warning: no records updated for id %s\n&quot;</span>, <span class="string">&quot;1145&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;update succ&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>DB.Model(&amp;Person&#123;&#125;)</code>: 指定要操作的模型。</li>
<li><code>Where(&quot;id = ?&quot;, &quot;1145&quot;)</code>: 指定更新条件。</li>
<li><code>Update(&quot;name&quot;, &quot;alan223&quot;)</code>: 更新单个字段。</li>
<li><code>Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;alan223&quot;, &quot;age&quot;: 25&#125;)</code>: 更新多个字段。传入 <code>map</code> 可以精确控制更新的字段。</li>
<li><code>Updates(p)</code>: 传入结构体进行更新，GORM 默认会更新所有<strong>非零值</strong>字段。如果你想更新所有字段，包括零值，可以使用 <code>Select(&quot;*&quot;).Updates(p)</code>。</li>
</ul>
<h5 id="删除-Delete">删除 (Delete)</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delete 删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 硬删除 (物理删除)</span></span><br><span class="line">	result := DB.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1145&quot;</span>).Delete(&amp;Person&#123;&#125;)</span><br><span class="line">	<span class="comment">// 或者</span></span><br><span class="line">	<span class="comment">// result := DB.Delete(&amp;Person&#123;&#125;, &quot;1145&quot;) // 根据主键删除</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;delete fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result.RowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;delete warning: no records deleted for id %s\n&quot;</span>, <span class="string">&quot;1145&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;delete succ&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>DB.Where(&quot;id = ?&quot;, &quot;1145&quot;).Delete(&amp;Person&#123;&#125;)</code>: 根据条件删除记录。</li>
<li><code>DB.Delete(&amp;Person&#123;&#125;, &quot;1145&quot;)</code>: 根据主键删除记录。</li>
<li><strong>软删除</strong>: GORM 支持软删除。如果你在模型中包含 <code>gorm.DeletedAt</code> 字段，GORM 在执行 <code>Delete</code> 操作时，不会真正删除记录，而是将 <code>DeletedAt</code> 字段设置为当前时间。查询时会自动过滤掉被软删除的记录。这在很多业务场景下非常有用。</li>
</ul>
<h4 id="5-事务-Transactions">5. 事务 (Transactions)</h4>
<p>GORM 提供了两种方式进行事务操作：<strong>块事务</strong>和<strong>手动事务</strong>。块事务更推荐，因为它会自动处理提交和回滚，并且在函数退出时自动回滚未提交的事务。</p>
<h5 id="块事务-推荐">块事务 (推荐)</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tx GORM 的事务操作 (块事务)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tx</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := DB.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 事务中的所有操作都使用 tx 对象</span></span><br><span class="line">		<span class="comment">// 例如：</span></span><br><span class="line">		<span class="comment">// 插入一条记录</span></span><br><span class="line">		newPerson := Person&#123;UserId: <span class="string">&quot;9999&quot;</span>, Username: <span class="string">&quot;tx_test&quot;</span>, Age: <span class="number">30</span>, Address: <span class="string">&quot;Transaction Land&quot;</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> err := tx.Create(&amp;newPerson).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;transaction insert failed: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> err <span class="comment">// 返回错误，事务将回滚</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新一条记录</span></span><br><span class="line">		<span class="keyword">if</span> err := tx.Model(&amp;Person&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;12132&quot;</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;UpdatedByTx&quot;</span>).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;transaction update failed: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> err <span class="comment">// 返回错误，事务将回滚</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果所有操作都成功，GORM 会自动提交事务</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;transaction failed: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;transaction succ&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>DB.Transaction(func(tx *gorm.DB) error &#123;...&#125;)</code>: GORM 的块事务方法。你传入一个函数，所有在这个函数内部使用 <code>tx</code> 对象进行的操作都会在同一个事务中。</li>
<li>如果函数返回 <code>nil</code>，事务会被提交。如果函数返回任何错误，事务会自动回滚。</li>
</ul>
<h5 id="手动事务-不推荐，除非有特殊需求">手动事务 (不推荐，除非有特殊需求)</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manualTx 手动事务操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">manualTx</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tx := DB.Begin() <span class="comment">// 开始事务</span></span><br><span class="line">	<span class="keyword">if</span> tx.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to begin transaction: %v&quot;</span>, tx.Error)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			tx.Rollback() <span class="comment">// 发生 panic 时回滚</span></span><br><span class="line">			<span class="built_in">panic</span>(r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 事务中的操作</span></span><br><span class="line">	newPerson := Person&#123;UserId: <span class="string">&quot;8888&quot;</span>, Username: <span class="string">&quot;manual_tx_test&quot;</span>, Age: <span class="number">28</span>, Address: <span class="string">&quot;Manual Land&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">if</span> err := tx.Create(&amp;newPerson).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		tx.Rollback() <span class="comment">// 出现错误时回滚</span></span><br><span class="line">		log.Fatalf(<span class="string">&quot;manual transaction insert failed: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := tx.Model(&amp;Person&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;12132&quot;</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;ManualUpdated&quot;</span>).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		tx.Rollback() <span class="comment">// 出现错误时回滚</span></span><br><span class="line">		log.Fatalf(<span class="string">&quot;manual transaction update failed: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := tx.Commit().Error; err != <span class="literal">nil</span> &#123; <span class="comment">// 提交事务</span></span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to commit transaction: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;manual transaction succ&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>:</p>
<ul>
<li><code>DB.Begin()</code>: 开始一个事务。</li>
<li><code>tx.Commit()</code>: 提交事务。</li>
<li><code>tx.Rollback()</code>: 回滚事务。</li>
<li><code>defer</code> 结合 <code>recover()</code>: 确保即使在事务中发生 <code>panic</code>，事务也能被正确回滚。手动事务需要开发者自己处理提交和回滚逻辑，容易出错，所以通常推荐使用块事务。</li>
</ul>
<h3 id="示例代码-GORM-版本">示例代码 (GORM 版本)</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DB *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 连接数据库</span></span><br><span class="line">	<span class="comment">// DSN (Data Source Name) 格式：username:password@(host:port)/database?charset=utf8mb4&amp;parseTime=True&amp;loc=Local</span></span><br><span class="line">	<span class="comment">// parseTime=True 是为了让 GORM 能正确解析 MySQL 中的 DATETIME 和 TIMESTAMP 类型</span></span><br><span class="line">	<span class="comment">// loc=Local 是为了让时间以本地时区解析</span></span><br><span class="line">	dsn := <span class="string">&quot;root:vader20011014@(localhost:3306)/study?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	DB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to connect database: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动迁移</span></span><br><span class="line">	<span class="comment">// GORM 会根据结构体定义自动创建或更新表结构</span></span><br><span class="line">	err = DB.AutoMigrate(&amp;Person&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to auto migrate: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;Database connection and migration successful!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据结构</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// GORM 约定 `ID` 或 `Id` 字段为主键，会自动识别为自增主键。</span></span><br><span class="line">	<span class="comment">// 这里我们使用 `UserId` 来映射 `id` 列，并且指定其为主键。</span></span><br><span class="line">	UserId   <span class="type">string</span> <span class="string">`gorm:&quot;column:id;primaryKey&quot;`</span> <span class="comment">// 对应数据库的 id 列，并且是主键</span></span><br><span class="line">	Username <span class="type">string</span> <span class="string">`gorm:&quot;column:name&quot;`</span>          <span class="comment">// 对应数据库的 name 列</span></span><br><span class="line">	Age      <span class="type">int</span>    <span class="string">`gorm:&quot;column:age&quot;`</span>           <span class="comment">// 对应数据库的 age 列</span></span><br><span class="line">	Address  <span class="type">string</span> <span class="string">`gorm:&quot;column:address&quot;`</span>       <span class="comment">// 对应数据库的 address 列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableName 方法用于指定 GORM 对应的数据库表名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Person)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;user&quot;</span> <span class="comment">// 将 Person 结构体映射到 user 表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----查询-----</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="comment">// First 根据主键查找第一条记录</span></span><br><span class="line">	<span class="comment">// DB.First(&amp;p, &quot;12132&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Where 子句用于构建查询条件</span></span><br><span class="line">	result := DB.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;12132&quot;</span>).First(&amp;p)</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> result.Error == gorm.ErrRecordNotFound &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;query fail: record not found for id %s\n&quot;</span>, <span class="string">&quot;12132&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;query fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;query succ: %v\n&quot;</span>, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ps []Person</span><br><span class="line">	<span class="comment">// Find 查询所有记录</span></span><br><span class="line">	result := DB.Find(&amp;ps)</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;list fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> ps &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;list succ: %v\n&quot;</span>, p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----新增-----</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">()</span></span> &#123;</span><br><span class="line">	newPerson := Person&#123;UserId: <span class="string">&quot;1145&quot;</span>, Username: <span class="string">&quot;alan&quot;</span>, Age: <span class="number">24</span>, Address: <span class="string">&quot;China&quot;</span>&#125;</span><br><span class="line">	result := DB.Create(&amp;newPerson)</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;insert fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果主键是自增的，GORM 会自动填充到结构体中</span></span><br><span class="line">	log.Printf(<span class="string">&quot;insert succ, ID: %s, RowsAffected: %d\n&quot;</span>, newPerson.UserId, result.RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----更新-----</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 更新多个字段</span></span><br><span class="line">	result := DB.Model(&amp;Person&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1145&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;alan223&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;update fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result.RowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;update warning: no records updated for id %s\n&quot;</span>, <span class="string">&quot;1145&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;update succ&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----删除-----</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 硬删除 (物理删除)</span></span><br><span class="line">	result := DB.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1145&quot;</span>).Delete(&amp;Person&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;delete fail: %v\n&quot;</span>, result.Error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result.RowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;delete warning: no records deleted for id %s\n&quot;</span>, <span class="string">&quot;1145&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;delete succ&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----事务-----</span></span><br><span class="line"><span class="comment">// GORM 推荐使用块事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tx</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := DB.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 事务中的所有操作都使用 tx 对象</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 插入一条记录</span></span><br><span class="line">		newPerson := Person&#123;UserId: <span class="string">&quot;9999&quot;</span>, Username: <span class="string">&quot;tx_test&quot;</span>, Age: <span class="number">30</span>, Address: <span class="string">&quot;Transaction Land&quot;</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> err := tx.Create(&amp;newPerson).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;transaction insert failed: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> err <span class="comment">// 返回错误，事务将回滚</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新一条记录</span></span><br><span class="line">		<span class="comment">// 注意：更新不存在的ID并不会报错，只会影响0行。如果业务需要严格控制，需要单独检查RowsAffected</span></span><br><span class="line">		<span class="keyword">if</span> err := tx.Model(&amp;Person&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;12132&quot;</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;UpdatedByTx&quot;</span>).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;transaction update failed: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> err <span class="comment">// 返回错误，事务将回滚</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果所有操作都成功，GORM 会自动提交事务</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;transaction failed: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;transaction succ&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	query()</span><br><span class="line">	insert() <span class="comment">// 先插入一条记录，方便后续操作</span></span><br><span class="line">	update()</span><br><span class="line">	<span class="built_in">delete</span>()</span><br><span class="line">	list()</span><br><span class="line">	tx() <span class="comment">// 执行事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="GORM-开发技巧与高级用法">GORM 开发技巧与高级用法</h3>
<p>GORM 不仅仅提供了基本的 CRUD 和事务操作，还有许多强大的功能和技巧可以帮助你更高效地进行 Go 数据库开发。</p>
<h4 id="1-结构体标签-Tags-详解">1. 结构体标签 (Tags) 详解</h4>
<p>GORM 的结构体标签是其强大功能的核心。除了上面用到的 <code>column</code> 和 <code>primaryKey</code>，还有许多其他有用的标签：</p>
<ul>
<li><code>gorm:&quot;-&quot;</code>: 忽略此字段，不映射到数据库。</li>
<li><code>gorm:&quot;autoIncrement&quot;</code>: 标记字段为自增主键（通常不需要，GORM 默认 <code>ID</code> 为自增）。</li>
<li><code>gorm:&quot;unique&quot;</code>: 字段值唯一。</li>
<li><code>gorm:&quot;default:value&quot;</code>: 设置字段的默认值。</li>
<li><code>gorm:&quot;not null&quot;</code>: 字段不允许为空。</li>
<li><code>gorm:&quot;size:255&quot;</code>: 设置字符串类型字段的长度。</li>
<li><code>gorm:&quot;type:longtext&quot;</code>: 指定字段的数据库类型。</li>
<li><code>gorm:&quot;index&quot;</code>: 为字段创建普通索引。</li>
<li><code>gorm:&quot;uniqueIndex&quot;</code>: 为字段创建唯一索引。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID          <span class="type">uint</span>   <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">    Code        <span class="type">string</span> <span class="string">`gorm:&quot;unique;size:100&quot;`</span></span><br><span class="line">    Price       <span class="type">uint</span>   <span class="string">`gorm:&quot;default:0&quot;`</span></span><br><span class="line">    Description <span class="type">string</span> <span class="string">`gorm:&quot;type:longtext&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-日志与调试">2. 日志与调试</h4>
<p>GORM 提供了非常灵活的日志功能，方便你在开发和调试过程中查看生成的 SQL 语句和执行结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gorm.io/gorm/logger&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dsn := <span class="string">&quot;root:vader20011014@(localhost:3306)/study?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    DB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;</span><br><span class="line">        Logger: logger.Default.LogMode(logger.Info), <span class="comment">// 设置日志模式为 Info</span></span><br><span class="line">        <span class="comment">// Other options</span></span><br><span class="line">        <span class="comment">// NamingStrategy: schema.NamingStrategy&#123;</span></span><br><span class="line">        <span class="comment">//     SingularTable: true, // 使用单数表名，即 Person 对应 person 表</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to connect database: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    DB.AutoMigrate(&amp;Person&#123;&#125;)</span><br><span class="line">    log.Println(<span class="string">&quot;Database connection and migration successful!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>日志模式</strong>:</p>
<ul>
<li><code>logger.Silent</code>: 不打印任何日志。</li>
<li><code>logger.Error</code>: 只打印错误日志。</li>
<li><code>logger.Warn</code>: 打印错误和警告日志。</li>
<li><code>logger.Info</code>: 打印所有日志，包括 SQL 语句。</li>
</ul>
<p>你也可以自定义 Logger 来满足更复杂的日志需求。</p>
<h4 id="3-链式方法与作用域">3. 链式方法与作用域</h4>
<p>GORM 最大的特点之一就是其优雅的链式方法调用。你可以将多个方法链接起来构建复杂的查询。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找年龄大于20，且地址在中国，并按年龄降序排列，取前10条记录</span></span><br><span class="line"><span class="keyword">var</span> adults []Person</span><br><span class="line">DB.Where(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">20</span>).Where(<span class="string">&quot;address = ?&quot;</span>, <span class="string">&quot;China&quot;</span>).Order(<span class="string">&quot;age desc&quot;</span>).Limit(<span class="number">10</span>).Find(&amp;adults)</span><br></pre></td></tr></table></figure>
<p>GORM 还支持<strong>作用域 (Scopes)</strong>，它允许你将常用的查询条件封装成可复用的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OlderThan</span><span class="params">(age <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">        <span class="keyword">return</span> db.Where(<span class="string">&quot;age &gt; ?&quot;</span>, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InAddress</span><span class="params">(address <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">        <span class="keyword">return</span> db.Where(<span class="string">&quot;address = ?&quot;</span>, address)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用作用域</span></span><br><span class="line"><span class="keyword">var</span> result []Person</span><br><span class="line">DB.Scopes(OlderThan(<span class="number">25</span>), InAddress(<span class="string">&quot;China&quot;</span>)).Find(&amp;result)</span><br></pre></td></tr></table></figure>
<p>作用域可以大大提高代码的复用性和可读性。</p>
<h4 id="4-预加载-Preload-与关联查询">4. 预加载 (Preload) 与关联查询</h4>
<p>在处理关联数据时，GORM 的预加载功能非常强大，可以避免 N+1 查询问题。假设你有 <code>User</code> 和 <code>CreditCard</code> 两个模型，一个用户可以有多张信用卡：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Number <span class="type">string</span></span><br><span class="line">    UserID <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name       <span class="type">string</span></span><br><span class="line">    CreditCards []CreditCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户及其所有信用卡</span></span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">DB.Preload(<span class="string">&quot;CreditCards&quot;</span>).First(&amp;user, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 此时 user.CreditCards 字段会被自动填充</span></span><br></pre></td></tr></table></figure>
<p><code>Preload</code> 会执行额外的查询来加载关联数据，但比手动多次查询要高效得多。</p>
<h4 id="5-原生-SQL">5. 原生 SQL</h4>
<p>尽管 GORM 旨在减少原生 SQL 的使用，但在某些复杂场景下，你可能仍然需要执行原生 SQL。GORM 提供了 <code>Raw</code> 和 <code>Exec</code> 方法来满足这些需求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Raw 用于查询</span></span><br><span class="line"><span class="keyword">var</span> p Person</span><br><span class="line">DB.Raw(<span class="string">&quot;SELECT id, name, age FROM user WHERE id = ?&quot;</span>, <span class="string">&quot;12132&quot;</span>).Scan(&amp;p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec 用于非查询操作 (INSERT, UPDATE, DELETE)</span></span><br><span class="line">DB.Exec(<span class="string">&quot;UPDATE user SET name = ? WHERE id = ?&quot;</span>, <span class="string">&quot;RawUpdate&quot;</span>, <span class="string">&quot;1145&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="6-Hooks-钩子">6. Hooks (钩子)</h4>
<p>GORM 提供了各种钩子方法，允许你在模型生命周期的不同阶段执行自定义逻辑，例如在创建前、更新后等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BeforeCreate hook</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> p.Address == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        p.Address = <span class="string">&quot;Unknown&quot;</span> <span class="comment">// 为新记录设置默认地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AfterUpdate hook</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> AfterUpdate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Person with ID %s was updated.\n&quot;</span>, p.UserId)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些钩子方法非常适合用于数据验证、日志记录、缓存更新等场景。</p>
<h4 id="7-错误处理">7. 错误处理</h4>
<p>GORM 的操作结果会返回一个 <code>*gorm.DB</code> 对象，你可以通过检查其 <code>Error</code> 字段来判断操作是否成功。</p>
<ul>
<li><code>result.Error</code>: 如果操作失败，这里会包含具体的错误信息。</li>
<li><code>gorm.ErrRecordNotFound</code>: 特定于未找到记录的错误。</li>
<li><code>result.RowsAffected</code>: 对于 DML 操作 (Create, Update, Delete)，表示受影响的行数。</li>
</ul>
<p>始终检查 <code>result.Error</code> 是一个好习惯。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>database</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之JWT鉴权</title>
    <url>/2025/07/28/Go%E8%AF%AD%E8%A8%80%E4%B9%8BJWT%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="🧠-一、JWT-是什么？">🧠 一、JWT 是什么？</h2>
<p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在网络应用环境间以一种简洁、安全的方式传递信息，常用于身份认证与授权。它是一段由三部分组成的字符串，如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Header&gt;.&lt;Payload&gt;.&lt;Signature&gt;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</span><br><span class="line">eyJ1c2VyX2lkIjoxLCJleHAiOjE3MDA4NzA1OTEsImlzcyI6ImdvLWpzIn0.</span><br><span class="line">hQ4jkHVz4x5cpQZKlyFP2rRokM8HxM1HxRXa4GZkGaQ</span><br></pre></td></tr></table></figure>
<h3 id="JWT-三个组成部分解释：">JWT 三个组成部分解释：</h3>
<table>
<thead>
<tr>
<th>部分</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td>元数据，如算法类型</td>
<td>通常为 <code>&#123;&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;</code></td>
</tr>
<tr>
<td>Payload</td>
<td>有效负载</td>
<td>包括自定义字段如 <code>user_id</code>、<code>role</code>、<code>exp</code></td>
</tr>
<tr>
<td>Signature</td>
<td>签名</td>
<td>用密钥对前两部分加密生成，防篡改</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🔐-二、JWT-鉴权原理流程图">🔐 二、JWT 鉴权原理流程图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[客户端提交登录信息]</span><br><span class="line">          ↓</span><br><span class="line">[服务端验证成功，生成JWT]</span><br><span class="line">          ↓</span><br><span class="line">[客户端拿到JWT并保存在Header中]</span><br><span class="line">          ↓</span><br><span class="line">[每次请求携带Authorization: Bearer &lt;token&gt;]</span><br><span class="line">          ↓</span><br><span class="line">[服务端中间件校验Token有效性]</span><br><span class="line">          ↓</span><br><span class="line">[Token有效：提取user_id放入上下文，继续处理]</span><br><span class="line">       无效：拒绝请求</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🚀-三、项目实现：Gin-JWT-鉴权系统">🚀 三、项目实现：Gin + JWT 鉴权系统</h2>
<p>我们将实现一个包括：</p>
<ul>
<li>登录接口（生成Token）</li>
<li>JWT中间件（验证Token）</li>
<li>受保护接口（需要Token访问）</li>
<li>统一响应结构</li>
<li>用户模型（模拟数据库）</li>
</ul>
<hr>
<h2 id="📁-目录结构">📁 目录结构</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go-jwt-auth/</span><br><span class="line">├── main.go</span><br><span class="line">├── controller/</span><br><span class="line">│   └── user.go</span><br><span class="line">├── middleware/</span><br><span class="line">│   └── jwt.go</span><br><span class="line">├── model/</span><br><span class="line">│   └── user.go</span><br><span class="line">├── response/</span><br><span class="line">│   └── response.go</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🔧-四、代码详解与讲解">🔧 四、代码详解与讲解</h2>
<hr>
<h3 id="（1）中间件部分（middleware-jwt-go）">（1）中间件部分（middleware/jwt.go）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;alan-snippet/response&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/golang-jwt/jwt/v4&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jwtSecret = []<span class="type">byte</span>(<span class="string">&quot;a_very_secret_key&quot;</span>) <span class="comment">// 推荐从配置文件或环境变量读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClaims 自定义 JWT 的 Payload 部分</span></span><br><span class="line"><span class="keyword">type</span> MyClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserID <span class="type">uint</span> <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">    jwt.RegisteredClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JWTAuth 中间件：拦截请求并验证 JWT 的合法性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWTAuth</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        authHeader := c.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> authHeader == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            response.Unauthorized(c, <span class="string">&quot;缺少Authorization头&quot;</span>)</span><br><span class="line">            c.Abort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parts := strings.SplitN(authHeader, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span> || parts[<span class="number">0</span>] != <span class="string">&quot;Bearer&quot;</span> &#123;</span><br><span class="line">            response.Unauthorized(c, <span class="string">&quot;Token格式应为Bearer &#123;token&#125;&quot;</span>)</span><br><span class="line">            c.Abort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tokenStr := parts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析Token，并将结果写入自定义claims结构体</span></span><br><span class="line">        token, err := jwt.ParseWithClaims(tokenStr, &amp;MyClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> jwtSecret, <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || !token.Valid &#123;</span><br><span class="line">            response.Unauthorized(c, <span class="string">&quot;Token无效或过期&quot;</span>)</span><br><span class="line">            c.Abort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析成功，提取UserID注入上下文供后续handler使用</span></span><br><span class="line">        claims, ok := token.Claims.(*MyClaims)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            response.Unauthorized(c, <span class="string">&quot;Token解析失败&quot;</span>)</span><br><span class="line">            c.Abort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.Set(<span class="string">&quot;userID&quot;</span>, claims.UserID)</span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateToken 登录成功后调用，用于生成JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(userID <span class="type">uint</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    claims := MyClaims&#123;</span><br><span class="line">        UserID: userID,</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(<span class="number">7</span> * <span class="number">24</span> * time.Hour)), <span class="comment">// 7天有效期</span></span><br><span class="line">            Issuer:    <span class="string">&quot;go-jwt-auth&quot;</span>, <span class="comment">// 签发人</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">    <span class="keyword">return</span> token.SignedString(jwtSecret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（2）模拟用户数据库（model-user-go）">（2）模拟用户数据库（model/user.go）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID       <span class="type">uint</span></span><br><span class="line">    Username <span class="type">string</span></span><br><span class="line">    Password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users = <span class="keyword">map</span>[<span class="type">string</span>]User&#123;</span><br><span class="line">    <span class="string">&quot;alan&quot;</span>: &#123;ID: <span class="number">1</span>, Username: <span class="string">&quot;alan&quot;</span>, Password: <span class="string">&quot;123456&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserByUsername</span><span class="params">(username <span class="type">string</span>)</span></span> (User, <span class="type">bool</span>) &#123;</span><br><span class="line">    user, ok := users[username]</span><br><span class="line">    <span class="keyword">return</span> user, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（3）统一响应格式（response-response-go）">（3）统一响应格式（response/response.go）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CodeSuccess      = <span class="number">0</span></span><br><span class="line">    CodeUnauthorized = <span class="number">401</span></span><br><span class="line">    CodeBadRequest   = <span class="number">400</span></span><br><span class="line">    CodeServerError  = <span class="number">500</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Success</span><span class="params">(c *gin.Context, data <span class="keyword">interface</span>&#123;&#125;, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: CodeSuccess,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>:  msg,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: data,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fail</span><span class="params">(c *gin.Context, code <span class="type">int</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: code,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>:  msg,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unauthorized</span><span class="params">(c *gin.Context, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    Fail(c, CodeUnauthorized, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（4）用户控制器（controller-user-go）">（4）用户控制器（controller/user.go）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;alan-snippet/middleware&quot;</span></span><br><span class="line">    <span class="string">&quot;alan-snippet/model&quot;</span></span><br><span class="line">    <span class="string">&quot;alan-snippet/response&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login 用户登录接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req <span class="keyword">struct</span> &#123;</span><br><span class="line">        Username <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">        Password <span class="type">string</span> <span class="string">`json:&quot;password&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := c.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        response.Fail(c, response.CodeBadRequest, <span class="string">&quot;请求参数错误&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user, exists := model.GetUserByUsername(req.Username)</span><br><span class="line">    <span class="keyword">if</span> !exists || user.Password != req.Password &#123;</span><br><span class="line">        response.Unauthorized(c, <span class="string">&quot;用户名或密码错误&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token, err := middleware.GenerateToken(user.ID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        response.Fail(c, response.CodeServerError, <span class="string">&quot;Token生成失败&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.Success(c, gin.H&#123;<span class="string">&quot;token&quot;</span>: token&#125;, <span class="string">&quot;登录成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetProfile 获取当前用户信息（需JWT认证）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProfile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    userID := c.GetUint(<span class="string">&quot;userID&quot;</span>)</span><br><span class="line">    response.Success(c, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;user_id&quot;</span>: userID,</span><br><span class="line">        <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;Alan&quot;</span>,</span><br><span class="line">    &#125;, <span class="string">&quot;用户信息获取成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（5）项目入口（main-go）">（5）项目入口（main.go）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;alan-snippet/controller&quot;</span></span><br><span class="line">    <span class="string">&quot;alan-snippet/middleware&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录路由，无需鉴权</span></span><br><span class="line">    r.POST(<span class="string">&quot;/login&quot;</span>, controller.Login)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 受保护路由，使用JWTAuth中间件</span></span><br><span class="line">    api := r.Group(<span class="string">&quot;/api&quot;</span>, middleware.JWTAuth())</span><br><span class="line">    &#123;</span><br><span class="line">        api.GET(<span class="string">&quot;/profile&quot;</span>, controller.GetProfile)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🔬-五、Postman-测试流程">🔬 五、Postman 测试流程</h2>
<h3 id="第一步：登录获取Token">第一步：登录获取Token</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /login</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;alan&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;登录成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR...&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第二步：携带Token请求受保护接口">第二步：携带Token请求受保护接口</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /api/profile</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...</span><br></pre></td></tr></table></figure>
<p>响应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;用户信息获取成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alan&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="✅-六、最佳实践汇总">✅ 六、最佳实践汇总</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>密钥管理</td>
<td>使用 <code>.env</code> / 配置文件管理，不要硬编码</td>
</tr>
<tr>
<td>Token 有效期</td>
<td>7天为推荐值，支持RefreshToken更安全</td>
</tr>
<tr>
<td>Token 签名算法</td>
<td>推荐 HS256 或 RSA</td>
</tr>
<tr>
<td>用户存储</td>
<td>使用数据库如 MySQL/PostgreSQL</td>
</tr>
<tr>
<td>密码存储</td>
<td>使用 <code>bcrypt</code> 加密存储密码</td>
</tr>
<tr>
<td>权限控制</td>
<td>可结合 <code>Casbin</code> 或 RBAC 模型</td>
</tr>
<tr>
<td>日志记录</td>
<td>每次认证/失败建议记录日志，便于追踪</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Git合作开发流程</title>
    <url>/2025/05/04/Git%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用Git进行团队协作开发可以高效管理代码，以下是详细步骤和最佳实践：</p>
<hr>
<h3 id="1-创建远程仓库"><strong>1. 创建远程仓库</strong></h3>
<ul>
<li>
<p><strong>选择平台</strong>：在GitHub、GitLab或Gitee上创建远程仓库。</p>
</li>
<li>
<p><strong>初始化仓库</strong>：由一人创建空仓库，或推送现有项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git remote add origin &lt;远程仓库URL&gt;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="2-克隆仓库到本地"><strong>2. 克隆仓库到本地</strong></h3>
<p>其他成员克隆仓库到本地：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;远程仓库URL&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-分支管理策略"><strong>3. 分支管理策略</strong></h3>
<ul>
<li>
<p><strong>主分支（main/master）</strong>：稳定版本，仅通过合并更新。</p>
</li>
<li>
<p><strong>开发分支（develop）</strong>（可选）：集成新功能，适合复杂项目。</p>
</li>
<li>
<p><strong>功能分支（feature/xxx）</strong>：每个新功能在独立分支开发。</p>
</li>
</ul>
<p><strong>常用命令</strong>：</p>
<ul>
<li>
<p>创建并切换分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b feature/login</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>推送分支到远程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin feature/login</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-日常开发流程"><strong>4. 日常开发流程</strong></h3>
<ul>
<li>
<p><strong>频繁提交</strong>：小步提交，描述清晰：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;feat: 添加用户登录功能&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>推送更改</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin feature/login</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-代码合并与审查"><strong>5. 代码合并与审查</strong></h3>
<ul>
<li>
<p><strong>发起Pull Request (PR)/Merge Request (MR)</strong>：</p>
<ol>
<li>
<p>在远程仓库页面选择分支发起PR。</p>
</li>
<li>
<p>团队成员审查代码，讨论修改。</p>
</li>
<li>
<p>确认无误后合并到主分支。</p>
</li>
</ol>
</li>
<li>
<p><strong>合并分支</strong>（本地操作）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main       # 更新主分支</span><br><span class="line">git merge feature/login    # 合并功能分支</span><br><span class="line">git push origin main       # 推送合并结果</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="6-处理冲突"><strong>6. 处理冲突</strong></h3>
<ul>
<li>
<p>当多人修改同一文件时，拉取最新代码并解决冲突：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin main       # 拉取最新代码，发现冲突</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动编辑冲突文件，保留需要的代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;fix: 解决合并冲突&quot;</span><br><span class="line">git push origin feature/login</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="7-同步更新"><strong>7. 同步更新</strong></h3>
<ul>
<li>
<p><strong>定期拉取主分支</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Rebase保持历史整洁</strong>（可选）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout feature/login</span><br><span class="line">git rebase main           # 将主分支更新应用到当前分支</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="8-其他最佳实践"><strong>8. 其他最佳实践</strong></h3>
<ul>
<li>
<p><strong>.gitignore文件</strong>：排除临时文件、日志、编译产物。</p>
</li>
<li>
<p><strong>Commit规范</strong>：使用语义化标签（如<code>feat:</code>, <code>fix:</code>, <code>docs:</code>）。</p>
</li>
<li>
<p><strong>分支清理</strong>：合并后删除已无用的分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d feature/login   # 删除本地分支</span><br><span class="line">git push origin --delete feature/login  # 删除远程分支</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="9-选择协作模型"><strong>9. 选择协作模型</strong></h3>
<ul>
<li>
<p><strong>GitHub Flow</strong>（简单）：</p>
<ul>
<li>
<p>主分支始终可部署。</p>
</li>
<li>
<p>功能分支开发 → PR合并 → 立即部署。</p>
</li>
</ul>
</li>
<li>
<p><strong>Git Flow</strong>（复杂）：</p>
<ul>
<li>包含<code>develop</code>、<code>release</code>、<code>hotfix</code>等分支，适合定期发布。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之RPC实践学习笔记</title>
    <url>/2025/11/16/Go%E8%AF%AD%E8%A8%80%E4%B9%8BRPC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>net/rpc</code> 是 Go 语言标准库中实现远程过程调用的利器，虽然现在 gRPC 更为流行，但 <code>net/rpc</code> 以其简洁、易用和“Go-way”的设计哲学，在很多纯 Go 项目的内部通信中仍然占有一席之地。</p>
<span id="more"></span>
<h2 id="📖-Go语言之net-rpc：构建分布式系统的基石">📖 Go语言之net/rpc：构建分布式系统的基石</h2>
<h3 id="1-什么是-RPC？">1. 什么是 RPC？</h3>
<p><strong>RPC</strong>（Remote Procedure Call，远程过程调用）是一种计算机通信协议。它允许程序<strong>像调用本地函数（或方法）一样，去调用另一台计算机上（或另一个进程）的函数</strong>，而不需要显式地处理网络通信的复杂细节。关键：调用的函数的执行空间是发送方的内存空间，而不是提供者</p>
<p>RPC 的核心思想是“透明性”——开发者应该感觉不到自己是在进行网络调用。</p>
<h3 id="2-RPC-的核心原理与规范">2. RPC 的核心原理与规范</h3>
<p>无论是 Go 的 <code>net/rpc</code> 还是 gRPC，它们都遵循一套相似的 RPC 工作流：</p>
<ol>
<li><strong>客户端（Client）</strong>：</li>
</ol>
<ul>
<li>
<p>调用一个本地的“存根”（Stub）函数。这个存根函数看起来和本地函数一样，但它是由 RPC 框架生成的。</p>
</li>
<li>
<p><strong>客户端存根（Client Stub）</strong> 接收到调用后，将方法名（例如 “UserService.GetUser”）和参数（例如 “UserID: 123”）进行 <strong>“序列化”</strong>（Serialization，也叫编组/Marshalling），即把它们转换成二进制或文本格式的数据包。</p>
</li>
</ul>
<ol start="2">
<li><strong>网络传输（Network）</strong>：</li>
</ol>
<ul>
<li>客户端存根通过底层的网络协议（如 TCP 或 HTTP）将这个数据包发送到服务端。</li>
</ul>
<ol start="3">
<li><strong>服务端（Server）</strong>：</li>
</ol>
<ul>
<li>
<p>服务端的 <strong>“骨架”（Skeleton）</strong> 负责监听网络端口，接收数据包。</p>
</li>
<li>
<p><strong>服务端骨架（Server Skeleton）</strong> 接收到数据后，进行 <strong>“反序列化”</strong>（Deserialization，也叫解组/Unmarshalling），解析出方法名和参数。</p>
</li>
<li>
<p>骨架根据方法名，调用本地注册的实际服务函数（例如 <code>server.GetUser(UserID: 123)</code>）。</p>
</li>
</ul>
<ol start="4">
<li><strong>执行与返回</strong>：</li>
</ol>
<ul>
<li>
<p>服务端本地函数执行完毕，得到一个返回值（或错误）。</p>
</li>
<li>
<p>骨架将这个返回值 <strong>“序列化”</strong>，并通过网络发送回客户端。</p>
</li>
</ul>
<ol start="5">
<li><strong>客户端接收</strong>：</li>
</ol>
<ul>
<li>
<p>客户端存根接收返回的数据包，<strong>“反序列化”</strong> 出结果。</p>
</li>
<li>
<p>最后，存根将这个结果返回给最初的调用方。</p>
</li>
</ul>
<p>在这个过程中，有几个关键的 <strong>“规范”</strong> 或“要素”：</p>
<ul>
<li>
<p><strong>序列化/编解码（Codec）</strong>：数据如何在网络上传输？是 JSON、XML、Protocol Buffers（Protobuf）还是 Go 特有的 <code>gob</code>？</p>
</li>
<li>
<p><strong>网络传输（Transport）</strong>：数据是基于什么协议传输的？TCP、HTTP 还是 UDP？</p>
</li>
<li>
<p><strong>服务发现（Service Discovery）</strong>：客户端如何知道服务端的地址和端口？（<code>net/rpc</code> 对此涉及不多，但 gRPC 很看重）</p>
</li>
<li>
<p><strong>接口定义（IDL）</strong>：如何定义客户端和服务端都认可的服务接口？</p>
</li>
</ul>
<h3 id="3-RPC-的应用场景">3. RPC 的应用场景</h3>
<p>RPC 是构建<strong>分布式系统</strong>和<strong>微服务架构</strong>的基石。</p>
<ul>
<li>
<p><strong>微服务通信</strong>：在一个微服务系统中，订单服务可能需要调用用户服务来获取用户信息，RPC 是实现这种跨服务通信最高效的方式之一。</p>
</li>
<li>
<p><strong>分布式系统</strong>：在数据库集群、分布式计算（如 MapReduce）中，主节点（Master）需要通过 RPC 来协调和控制工作节点（Worker）。</p>
</li>
<li>
<p><strong>内部工具</strong>：为公司内部系统提供一个高性能的 API 接口，供其他内部工具或服务调用。</p>
</li>
</ul>
<hr>
<h3 id="4-深度教程：Go-语言-“net-rpc”">4. 深度教程：Go 语言 “net/rpc”</h3>
<p>Go 的 <code>net/rpc</code> 包在设计上非常简洁，并深度集成了 Go 的特性。</p>
<h4 id="4-1-net-rpc-的强制规范">4.1 <code>net/rpc</code> 的强制规范</h4>
<p>为了实现自动化的序列化和方法查找，<code>net/rpc</code> 对你暴露的服务（Service）有严格的“方法签名”要求：</p>
<blockquote>
<p><strong><code>net/rpc</code> 规范</strong></p>
</blockquote>
<ol>
<li>
<p>服务必须是一个 <strong>Go 对象</strong>（通常是结构体）。</p>
</li>
<li>
<p>方法必须是 <strong>可导出的</strong>（首字母大写）。</p>
</li>
<li>
<p>方法必须 <strong>有两个参数</strong>。</p>
</li>
<li>
<p>第一个参数（<code>args</code>）是客户端传入的参数，必须是可导出类型或Go内置类型。</p>
</li>
<li>
<p>第二个参数（<code>reply</code>）是返回给客户端的结果，<strong>必须是指针类型</strong>。</p>
</li>
<li>
<p>方法必须返回一个 <code>error</code> 类型的值。</p>
</li>
</ol>
<p><strong>标准签名</strong>：<code>func (t *T) MethodName(args *ArgType, reply *ReplyType) error</code></p>
<h4 id="4-2-案例一：基于-TCP-的-RPC（最常用）">4.2 案例一：基于 TCP 的 RPC（最常用）</h4>
<p>这是最简单、最高效的 <code>net/rpc</code> 使用方式。它使用 Go 独有的 <code>gob</code> 编解码，性能很高，但缺点是<strong>仅限 Go 语言之间</strong>的通信。</p>
<h5 id="步骤1：定义服务和参数">步骤1：定义服务和参数</h5>
<p>我们来创建一个简单的“数学”服务，提供一个乘法计算。</p>
<p><code>shared/common.go</code> (这个文件客户端和服务端都需要)</p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shared</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">    A, B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务方法</span></span><br><span class="line"><span class="keyword">type</span> MathService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiply 方法</span></span><br><span class="line"><span class="comment">// (t *T) MethodName(args *ArgType, reply *ReplyType) error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *MathService)</span></span> Multiply(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">    *reply = args.A * args.B</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2：编写服务端-Server">步骤2：编写服务端 (Server)</h5>
<p><code>server/main.go</code></p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;path/to/shared&quot;</span> <span class="comment">// 替换为你的</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个 MathService 的实例</span></span><br><span class="line">	mathService := <span class="built_in">new</span>(shared.MathService)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 注册服务</span></span><br><span class="line">	<span class="comment">// rpc.Register 会使用反射来分析对象的所有可导出方法</span></span><br><span class="line">	err := rpc.Register(mathService)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;注册服务失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 设置监听端口 (TCP)</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;监听失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;RPC 服务器正在监听 :1234&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 接受连接并处理</span></span><br><span class="line">	<span class="comment">// rpc.Accept 会在循环中接受连接，并为每个连接启动一个 goroutine 来处理</span></span><br><span class="line">	rpc.Accept(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤3：编写客户端-Client">步骤3：编写客户端 (Client)</h5>
<p><code>client/main.go</code></p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;path/to/shared&quot;</span> <span class="comment">// 替换为你的</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 连接 RPC 服务器</span></span><br><span class="line">	<span class="comment">// rpc.Dial(protocol, address)</span></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;连接 RPC 服务器失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 准备参数</span></span><br><span class="line">	args := &amp;shared.Args&#123;A: <span class="number">10</span>, B: <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 调用远程方法</span></span><br><span class="line">	<span class="comment">// client.Call(&quot;ServiceName.MethodName&quot;, args, &amp;reply)</span></span><br><span class="line">	<span class="comment">// ServiceName 默认是注册的结构体类型名，即 &quot;MathService&quot;</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;MathService.Multiply&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;调用远程方法失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 获得结果</span></span><br><span class="line">	log.Printf(<span class="string">&quot;MathService.Multiply(10, 20) = %d&quot;</span>, reply)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 演示：异步调用 (Async Call)</span></span><br><span class="line">	<span class="comment">// 如果你不希望阻塞等待结果，可以使用 Go() 方法</span></span><br><span class="line">	<span class="keyword">var</span> asyncReply <span class="type">int</span></span><br><span class="line">	call := client.Go(<span class="string">&quot;MathService.Multiply&quot;</span>, &amp;shared.Args&#123;A: <span class="number">5</span>, B: <span class="number">6</span>&#125;, &amp;asyncReply, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... 在这里可以做其他事情 ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待异步调用完成</span></span><br><span class="line">	replyCall := &lt;-call.Done</span><br><span class="line">	<span class="keyword">if</span> replyCall.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;异步调用失败: %v&quot;</span>, replyCall.Error)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;异步调用 MathService.Multiply(5, 6) = %d&quot;</span>, asyncReply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-案例二：基于-HTTP-的-RPC">4.3 案例二：基于 HTTP 的 RPC</h4>
<p><code>net/rpc</code> 也可以“寄宿”在 HTTP 协议上。这非常有用，因为它允许 RPC 数据穿过防火墙，并可以复用已有的 HTTP 基础设施（如 TLS、中间件等）。</p>
<p><strong>服务端 (Server)</strong></p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;path/to/shared&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mathService := <span class="built_in">new</span>(shared.MathService)</span><br><span class="line">	rpc.Register(mathService)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 将 RPC 服务绑定到 HTTP 处理器</span></span><br><span class="line">	<span class="comment">// 这会暴露一个默认的 RPC 路径（_goRPC_）</span></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;RPC 服务器正在监听 HTTP :1234&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 启动 HTTP 服务器</span></span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端 (Client)</strong></p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;path/to/shared&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 使用 rpc.DialHTTP 连接</span></span><br><span class="line">	<span class="comment">// 客户端会自动处理 HTTP POST 和路径</span></span><br><span class="line">	client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;连接 RPC 服务器失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 调用（与 TCP 案例完全相同）</span></span><br><span class="line">	args := &amp;shared.Args&#123;A: <span class="number">10</span>, B: <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;MathService.Multiply&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;调用远程方法失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;MathService.Multiply(10, 20) = %d&quot;</span>, reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-案例三：使用-JSON-RPC（实现跨语言）">4.4 案例三：使用 JSON-RPC（实现跨语言）</h4>
<p><code>net/rpc</code> 默认的 <code>gob</code> 编码导致它只能 Go ↔ Go。但标准库提供了 <code>net/rpc/jsonrpc</code> 包，它允许我们使用 <strong>JSON</strong> 作为编解码器。</p>
<p>这意味着任何支持 JSON-RPC 的语言（如 Python, JavaScript）都可以调用你的 Go RPC 服务！</p>
<p><strong>服务端 (Server)</strong></p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span> <span class="comment">// 1. 导入 jsonrpc</span></span><br><span class="line">	<span class="string">&quot;path/to/shared&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpc.Register(<span class="built_in">new</span>(shared.MathService))</span><br><span class="line">	</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	log.Println(<span class="string">&quot;JSON-RPC 服务器正在监听 :1234&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2. 使用 jsonrpc.ServeConn 替换 rpc.ServeConn</span></span><br><span class="line">		<span class="keyword">go</span> jsonrpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端 (Client - Go)</strong></p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span> <span class="comment">// 1. 导入 jsonrpc</span></span><br><span class="line">	<span class="string">&quot;path/to/shared&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 2. 使用 jsonrpc.Dial 替换 rpc.Dial</span></span><br><span class="line">	client, err := jsonrpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用方式不变</span></span><br><span class="line">	args := &amp;shared.Args&#123;A: <span class="number">10</span>, B: <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;MathService.Multiply&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;JSON-RPC 调用结果: %d&quot;</span>, reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="5-展望未来：gRPC">5. 展望未来：gRPC</h3>
<p>虽然 <code>net/rpc</code> 非常轻巧易用，但它也存在一些局限性：</p>
<ol start="6">
<li>
<p><strong>Go 绑定</strong>：默认的 <code>gob</code> 编解码导致其生态封闭。</p>
</li>
<li>
<p><strong>性能</strong>：JSON 编解码性能较差；<code>gob</code> 虽快，但不如 Protobuf。</p>
</li>
<li>
<p><strong>功能限制</strong>：不支持<strong>流式（Streaming）</strong> 调用、没有连接复用、没有内置的服务发现、负载均衡或认证机制。</p>
</li>
</ol>
<p><strong>gRPC</strong> (Google Remote Procedure Call) 是 Google 推出的现代 RPC 框架，它解决了上述所有问题，已成为云原生时代微服务的首选。</p>
<h4 id="gRPC-的核心优势">gRPC 的核心优势</h4>
<ol start="9">
<li><strong>Protocol Buffers (Protobuf)</strong>：</li>
</ol>
<ul>
<li>
<p>gRPC 默认使用 Protobuf 作为其 <strong>IDL（接口定义语言）</strong> 和序列化工具。</p>
</li>
<li>
<p>Protobuf 是一种语言无关、平台无关、可扩展的序列化结构数据的方法（类似 JSON，但更小、更快、更强）。</p>
</li>
<li>
<p>你只需要在一个 <code>.proto</code> 文件中定义服务和消息，gRPC 的工具链 (protoc) 就能自动生成<strong>所有语言</strong>（Go, Java, Python, C++, Node.js 等）的客户端和服务端代码。</p>
</li>
</ul>
<ol start="10">
<li><strong>基于 HTTP/2</strong>：</li>
</ol>
<ul>
<li>
<p><code>net/rpc</code> 通常基于 TCP 或 HTTP/1.1。</p>
</li>
<li>
<p>gRPC 建立在 <strong>HTTP/2</strong> 之上，带来了巨大优势：</p>
<ul>
<li>
<p><strong>多路复用（Multiplexing）</strong>：允许在单个 TCP 连接上同时处理多个双向请求和响应，解决了“队头阻塞”问题，极大提升了并发性能。</p>
</li>
<li>
<p><strong>头部压缩（Header Compression）</strong>：减少了请求的开销。</p>
</li>
<li>
<p><strong>服务端推送（Server Push）</strong>。</p>
</li>
</ul>
</li>
</ul>
<ol start="11">
<li><strong>支持流式（Streaming）</strong>：</li>
</ol>
<ul>
<li>
<p>这是 gRPC 的杀手级特性。<code>net/rpc</code> 只能“一问一答”（Unary RPC）。</p>
</li>
<li>
<p>gRPC 支持四种通信模式：</p>
<ol>
<li>
<p><strong>Unary RPC</strong>（一元RPC）：同 <code>net/rpc</code>。</p>
</li>
<li>
<p><strong>Server-streaming RPC</strong>（服务端流）：客户端发一个请求，服务端可以像数据流一样持续返回多个响应（例如订阅通知）。</p>
</li>
<li>
<p><strong>Client-streaming RPC</strong>（客户端流）：客户端可以像数据流一样持续发送多个消息，服务端最后返回一个响应（例如上传大文件）。</p>
</li>
<li>
<p><strong>Bidirectional-streaming RPC</strong>（双向流）：客户端和服务端可以同时、独立地向对方发送数据流（例如实时聊天）。</p>
</li>
</ol>
</li>
</ul>
<h4 id="net-rpc-vs-gRPC"><code>net/rpc</code> vs gRPC</h4>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>net/rpc (标准库)</strong></th>
<th><strong>gRPC (Google)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>序列化</strong></td>
<td>默认 <code>gob</code> (Go-only)，可选 JSON</td>
<td><strong>Protocol Buffers</strong> (高性能, 二进制)</td>
</tr>
<tr>
<td><strong>传输协议</strong></td>
<td>TCP 或 HTTP/1.1</td>
<td><strong>HTTP/2</strong> (高性能, 多路复用)</td>
</tr>
<tr>
<td><strong>跨语言</strong></td>
<td>较差 (需使用 <code>jsonrpc</code>)</td>
<td><strong>极强</strong> (自动生成多语言代码)</td>
</tr>
<tr>
<td><strong>流处理</strong></td>
<td>不支持 (仅 一问一答)</td>
<td><strong>支持</strong> (一元、客户端流、服务端流、双向流)</td>
</tr>
<tr>
<td><strong>生态系统</strong></td>
<td>基础 (标准库)</td>
<td><strong>非常丰富</strong> (服务发现、负载均衡、认证、Trace)</td>
</tr>
<tr>
<td><strong>易用性</strong></td>
<td><strong>非常简单</strong> (纯 Go 项目的快速选择)</td>
<td>学习曲线稍高 (需定义 <code>.proto</code> 文件)</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结</h3>
<p><code>net/rpc</code> 是 Go 语言“小而美”哲学的体现。如果你正在构建一个<strong>纯 Go 语言</strong>的内部系统，不希望引入复杂的 <code>.proto</code> 文件和 gRPC 依赖，<code>net/rpc</code> 及其 <code>jsonrpc</code> 变体仍然是一个优秀、轻量且高效的选择。</p>
<p>然而，如果你在构建面向未来的、高性能、跨语言的<strong>微服务</strong>系统，那么 <code>gRPC</code> 毫无疑问是当今的标准答案。</p>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之RPC实践：push VS. pull</title>
    <url>/2025/11/16/Go%E8%AF%AD%E8%A8%80%E4%B9%8BRPC%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在本文中，我们使用两个示例学习一下go中的rpc的基本使用。这是一个非常经典的 RPC 应用场景：Master/Worker，其中Master负责分发任务，Worker负责接收并执行任务，然后返回结果。</p>
<span id="more"></span>
<h2 id="Push模式">Push模式</h2>
<p>这个例子可以理解为：</p>
<blockquote>
<p>Master有很多的任务要做，但是不可能自己去做，他要检查自己有哪些Worker，然后并发调用Worker的RPC函数得到结果，仿佛是自己完成了所有工作。</p>
</blockquote>
<ol>
<li>项目结构</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpc-master-worker/</span><br><span class="line">├── go.mod</span><br><span class="line">├── master/</span><br><span class="line">│   └── main.go</span><br><span class="line">├── shared/</span><br><span class="line">│   └── common.go</span><br><span class="line">└── worker/</span><br><span class="line">    └── main.go</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>共享数据结构（shared/common.go）</li>
</ol>
<p>为了让 Master 和 Worker 能够共享数据结构（如任务参数和回复），我们创建一个 shared 包。<br>
这是 Master 和 Worker 之间的“契约”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shared</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务参数</span></span><br><span class="line"><span class="keyword">type</span> TaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	TaskID   <span class="type">int</span></span><br><span class="line">	TaskData <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务回复</span></span><br><span class="line"><span class="keyword">type</span> TaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	WorkerID   <span class="type">int</span></span><br><span class="line">	ResultData <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个通用的服务名称，以便双方都能引用</span></span><br><span class="line"><span class="keyword">const</span> WorkerServiceName = <span class="string">&quot;WorkerService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于格式化任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TaskArgs)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Task(ID: %d, Data: &#x27;%s&#x27;)&quot;</span>, t.TaskID, t.TaskData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于格式化回复</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TaskReply)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Reply(Worker: %d, Result: &#x27;%s&#x27;)&quot;</span>, r.WorkerID, r.ResultData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>服务端(worker/main.go)</li>
</ol>
<p>Worker 是这个例子中的 RPC 服务端。它注册一个 WorkerService，实现一个 DoTask 方法，然后在指定的端口上监听来自 Master 的连接。</p>
<p>我们将使用 flag 包允许从命令行指定每个 Worker 的 ID 和端口，这样我们就可以轻松地启动多个 Worker。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;rpc-master-worker/shared&quot;</span> <span class="comment">// 导入共享包</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WorkerService 是 RPC 服务端暴露的对象</span></span><br><span class="line"><span class="keyword">type</span> WorkerService <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoTask 是 RPC 调用的方法</span></span><br><span class="line"><span class="comment">// 必须遵循 net/rpc 规范: (args *ArgType, reply *ReplyType) error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WorkerService)</span></span> DoTask(args *shared.TaskArgs, reply *shared.TaskReply) <span class="type">error</span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Worker %d: 接收到任务 %s\n&quot;</span>, w.ID, args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟执行任务（例如：将字符串转换为大写）</span></span><br><span class="line">	result := strings.ToUpper(args.TaskData)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充回复</span></span><br><span class="line">	reply.WorkerID = w.ID</span><br><span class="line">	reply.ResultData = result</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;Worker %d: 完成任务 %d, 结果: %s\n&quot;</span>, w.ID, args.TaskID, result)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 使用 flag 允许从命令行传入 ID 和 端口</span></span><br><span class="line">	workerID := flag.Int(<span class="string">&quot;id&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Worker ID&quot;</span>)</span><br><span class="line">	port := flag.String(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;:9001&quot;</span>, <span class="string">&quot;Worker 监听的端口 (例如 :9001)&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 创建 WorkerService 实例</span></span><br><span class="line">	workerService := &amp;WorkerService&#123;</span><br><span class="line">		ID: *workerID,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 注册 RPC 服务</span></span><br><span class="line">	err := rpc.RegisterName(shared.WorkerServiceName, workerService)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Worker %d: 注册服务失败: %v&quot;</span>, *workerID, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 在指定端口上启动 TCP 监听(其他的也差不多)</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, *port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Worker %d: 监听 %s 失败: %v&quot;</span>, *workerID, *port, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;Worker %d: 正在 %s 上监听 RPC 请求...\n&quot;</span>, *workerID, *port)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 接受并处理连接</span></span><br><span class="line">	<span class="comment">// rpc.Accept 会阻塞并等待新的连接，为每个连接启动一个 goroutine 处理</span></span><br><span class="line">	rpc.Accept(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>客户端（master/main.go）</li>
</ol>
<p>Master 是这个例子中的 RPC 客户端。它持有一组任务和一个 Worker 地址列表（理解为我需要使用的服务们）。<br>
它将并发地（使用 goroutine 和 WaitGroup）将任务分发给 Worker，并收集所有的结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;rpc-master-worker/shared&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Master 启动...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 定义 Worker 列表</span></span><br><span class="line">	<span class="comment">// 在生产环境中，这应该通过服务发现（如 Consul, Etcd）动态获取</span></span><br><span class="line">	workerAddresses := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;localhost:9001&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9002&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 定义任务列表</span></span><br><span class="line">	tasks := []*shared.TaskArgs&#123;</span><br><span class="line">		&#123;TaskID: <span class="number">1</span>, TaskData: <span class="string">&quot;hello world&quot;</span>&#125;,</span><br><span class="line">		&#123;TaskID: <span class="number">2</span>, TaskData: <span class="string">&quot;go rpc is simple&quot;</span>&#125;,</span><br><span class="line">		&#123;TaskID: <span class="number">3</span>, TaskData: <span class="string">&quot;learn by example&quot;</span>&#125;,</span><br><span class="line">		&#123;TaskID: <span class="number">4</span>, TaskData: <span class="string">&quot;concurrency is fun&quot;</span>&#125;,</span><br><span class="line">		&#123;TaskID: <span class="number">5</span>, TaskData: <span class="string">&quot;master worker pattern&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	numWorkers := <span class="built_in">len</span>(workerAddresses)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 选择一个 Worker (这里使用简单的轮询)</span></span><br><span class="line">		workerAddr := workerAddresses[i%numWorkers]</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 4. 为每个任务启动一个 goroutine</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(task *shared.TaskArgs, addr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// a. 连接 Worker</span></span><br><span class="line">			client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;Master: 连接 Worker %s 失败: %v&quot;</span>, addr, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// b. 准备回复</span></span><br><span class="line">			<span class="keyword">var</span> reply shared.TaskReply</span><br><span class="line"></span><br><span class="line">			log.Printf(<span class="string">&quot;Master: 分发任务 %s 到 Worker %s\n&quot;</span>, task, addr)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// c. 发起同步 RPC 调用</span></span><br><span class="line">			<span class="comment">// 我们也可以使用 client.Go() 进行异步调用，但这里在 goroutine 中，Call() 已经实现了并发</span></span><br><span class="line">			err = client.Call(shared.WorkerServiceName+<span class="string">&quot;.DoTask&quot;</span>, task, &amp;reply)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;Master: 调用 Worker %s 失败: %v&quot;</span>, addr, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// d. 打印结果</span></span><br><span class="line">			log.Printf(<span class="string">&quot;Master: 收到结果: %s\n&quot;</span>, &amp;reply)</span><br><span class="line"></span><br><span class="line">		&#125;(task, workerAddr)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 稍微错开任务分发，便于观察</span></span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 等待所有任务完成</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;Master: 所有任务已完成。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>运行<br>
打开 3 个终端窗口。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rpc-master-worker</span><br><span class="line">go run . -<span class="built_in">id</span>=1 -port=:9001</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rpc-master-worker</span><br><span class="line">go run . -<span class="built_in">id</span>=2 -port=:9002</span><br></pre></td></tr></table></figure>
<p>等待两个 Worker 都启动后，运行 Master：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rpc-master-worker</span><br><span class="line">go run .</span><br></pre></td></tr></table></figure>
<h2 id="Pull模式">Pull模式</h2>
<p>这个例子可以理解为：</p>
<blockquote>
<p>Master有很多的任务要做，但是不可能自己去做，他的Worker会不停的询问他有没有待完成的工作，如果有请求+工作，Master就会把工作分发出去，否则阻塞工作进程。另外，我们再加入一点容错机制，例如超时机制（一个worker领取了任务但是没有及时完成，则任务会被重置等待新的Worker来领取）。</p>
</blockquote>
<ol>
<li>项目结构</li>
</ol>
<p>和之前一样</p>
<ol start="2">
<li>共享数据结构（shared/common.go）</li>
</ol>
<p>依旧定义一些约定</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shared</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Master 提供的服务名</span></span><br><span class="line"><span class="keyword">const</span> MasterServiceName = <span class="string">&quot;MasterService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MasterTaskTimeout 定义任务超时时间</span></span><br><span class="line"><span class="keyword">const</span> MasterTaskTimeout = <span class="number">3</span> * time.Second</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 1. Worker 请求任务 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 请求任务的参数</span></span><br><span class="line"><span class="keyword">type</span> RequestTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	WorkerID <span class="type">string</span> <span class="comment">// Worker 用自己的ID来注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Master 返回给 Worker 的任务</span></span><br><span class="line"><span class="comment">// (注意：Task 本身也定义在这里)</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="type">int</span></span><br><span class="line">	Data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Master 返回任务的回复</span></span><br><span class="line"><span class="keyword">type</span> RequestTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Task        *Task <span class="comment">// 要执行的任务 (如果为 nil，表示暂时没有)</span></span><br><span class="line">	NoMoreTasks <span class="type">bool</span>  <span class="comment">// 如果为 true，表示所有任务都完成了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 2. Worker 提交结果 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 提交结果的参数</span></span><br><span class="line"><span class="keyword">type</span> SubmitTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	WorkerID   <span class="type">string</span></span><br><span class="line">	TaskID     <span class="type">int</span></span><br><span class="line">	ResultData <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Master 对提交的回复（简单确认）</span></span><br><span class="line"><span class="keyword">type</span> SubmitTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Acknowledged <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 辅助函数 ---</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Task(ID: %d, Data: &#x27;%s&#x27;)&quot;</span>, t.ID, t.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟任务执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span></span> Process() <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;... 正在处理任务 %d ...\n&quot;</span>, t.ID)</span><br><span class="line">	<span class="comment">// 模拟耗时工作</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="comment">// 简单的字符串处理</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Processed data from task %d&quot;</span>, t.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>客户端（Worker/main.go）</li>
</ol>
<p>Worker 现在是客户端。它在一个无限循环中工作(RPC注册/连接后)：请求 -&gt; 处理 -&gt; 提交。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;rpc/shared&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 结构（无状态，只持有配置）</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID         <span class="type">string</span></span><br><span class="line">	MasterAddr <span class="type">string</span></span><br><span class="line">	client     *rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWorker 创建 Worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(id, masterAddr <span class="type">string</span>)</span></span> *Worker &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Worker&#123;</span><br><span class="line">		ID:         id,</span><br><span class="line">		MasterAddr: masterAddr,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect 连接到 Master</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> connect() <span class="type">error</span> &#123;</span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, w.MasterAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;连接 Master (%s) 失败: %v&quot;</span>, w.MasterAddr, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Worker %s: 已连接到 Master %s\n&quot;</span>, w.ID, w.MasterAddr)</span><br><span class="line">	w.client = client</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 开始工作循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> Run() &#123;</span><br><span class="line">	<span class="keyword">if</span> err := w.connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> w.client.Close()</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;Worker %s: 开始请求任务...\n&quot;</span>, w.ID)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 1. 请求任务</span></span><br><span class="line">		reqArgs := &amp;shared.RequestTaskArgs&#123;WorkerID: w.ID&#125;</span><br><span class="line">		reply := &amp;shared.RequestTaskReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">		err := w.client.Call(shared.MasterServiceName+<span class="string">&quot;.RequestTask&quot;</span>, reqArgs, &amp;reply)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果连接断开 (io.EOF 或 rpc.ErrShutdown)，说明 Master 可能已关闭</span></span><br><span class="line">			<span class="keyword">if</span> err == io.EOF || err == rpc.ErrShutdown &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;Worker %s: 与 Master 的连接已断开。退出。\n&quot;</span>, w.ID)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Printf(<span class="string">&quot;Worker %s: 请求任务失败: %v. 正在重试...\n&quot;</span>, w.ID, err)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 发生错误时稍等</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 检查 Master 是否已无任务</span></span><br><span class="line">		<span class="keyword">if</span> reply.NoMoreTasks &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Worker %s: Master 通知所有任务已完成。退出。\n&quot;</span>, w.ID)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 检查是否真的拿到了任务</span></span><br><span class="line">		<span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 这种情况在本例中不应发生（因为 Master 队列是阻塞的），但作为健壮性检查</span></span><br><span class="line">			log.Printf(<span class="string">&quot;Worker %s: 暂时没有任务，1秒后重试...\n&quot;</span>, w.ID)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. 拿到了任务，开始处理</span></span><br><span class="line">		task := reply.Task</span><br><span class="line">		log.Printf(<span class="string">&quot;Worker %s: 领到任务 %s\n&quot;</span>, w.ID, task)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟w01处理任务3 处理超时</span></span><br><span class="line">		<span class="keyword">if</span> task.ID == <span class="number">3</span> &amp;&amp; w.ID == <span class="string">&quot;w01&quot;</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Worker %s: !!! 模拟处理任务 3 超时 !!!&quot;</span>, w.ID)</span><br><span class="line">			time.Sleep(shared.MasterTaskTimeout + <span class="number">2</span>*time.Second)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在自己的地址空间里执行任务</span></span><br><span class="line">		resultData := task.Process() <span class="comment">// 模拟执行</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5. 提交结果</span></span><br><span class="line">		submitArgs := &amp;shared.SubmitTaskArgs&#123;</span><br><span class="line">			WorkerID:   w.ID,</span><br><span class="line">			TaskID:     task.ID,</span><br><span class="line">			ResultData: resultData,</span><br><span class="line">		&#125;</span><br><span class="line">		submitReply := &amp;shared.SubmitTaskReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">		err = w.client.Call(shared.MasterServiceName+<span class="string">&quot;.SubmitTaskResult&quot;</span>, submitArgs, &amp;submitReply)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Worker %s: 提交任务 %d 结果失败: %v\n&quot;</span>, w.ID, task.ID, err)</span><br><span class="line">			<span class="comment">// (在实际应用中，这里需要重试策略)</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> submitReply.Acknowledged &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Worker %s: 成功提交任务 %d 结果\n&quot;</span>, w.ID, task.ID)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	workerID := flag.String(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;worker-01&quot;</span>, <span class="string">&quot;Worker 的唯一ID&quot;</span>)</span><br><span class="line">	masterAddr := flag.String(<span class="string">&quot;master&quot;</span>, <span class="string">&quot;localhost:9000&quot;</span>, <span class="string">&quot;Master 的地址&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	worker := NewWorker(*workerID, *masterAddr)</span><br><span class="line">	worker.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>服务端（Master/main.go）</li>
</ol>
<p>Master 现在是有状态的服务端。它需要维护任务队列，并处理并发（因为多个 Worker 会同时请求）。我们将使用 Mutex (互斥锁) 来保护任务状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;rpc/shared&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务状态</span></span><br><span class="line"><span class="keyword">type</span> TaskStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	StatusIdle       TaskStatus = <span class="number">0</span> <span class="comment">// 待分配</span></span><br><span class="line">	StatusInProgress TaskStatus = <span class="number">1</span> <span class="comment">// 已分配，处理中</span></span><br><span class="line">	StatusCompleted  TaskStatus = <span class="number">2</span> <span class="comment">// 已完成</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Master 内部维护的任务结构</span></span><br><span class="line"><span class="keyword">type</span> MasterTask <span class="keyword">struct</span> &#123;</span><br><span class="line">	Task      *shared.Task</span><br><span class="line">	Status    TaskStatus</span><br><span class="line">	WorkerID  <span class="type">string</span>    <span class="comment">// 哪个 Worker 正在处理</span></span><br><span class="line">	StartTime time.Time <span class="comment">// 开始时间（用于处理超时）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Master 服务</span></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu             sync.Mutex</span><br><span class="line">	tasks          <span class="keyword">map</span>[<span class="type">int</span>]*MasterTask <span class="comment">// 所有任务的 &quot;数据库&quot;</span></span><br><span class="line">	taskQueue      <span class="keyword">chan</span> <span class="type">int</span>            <span class="comment">// 待分配的任务ID队列</span></span><br><span class="line">	totalTasks     <span class="type">int</span></span><br><span class="line">	completedTasks <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMaster 创建并初始化 Master</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMaster</span><span class="params">()</span></span> *Master &#123;</span><br><span class="line">	m := &amp;Master&#123;</span><br><span class="line">		tasks:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*MasterTask),</span><br><span class="line">		taskQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>), <span class="comment">// 带缓冲的通道</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 初始化任务列表</span></span><br><span class="line">	m.initTasks()</span><br><span class="line">	m.totalTasks = <span class="built_in">len</span>(m.tasks)</span><br><span class="line">	log.Printf(<span class="string">&quot;Master 初始化完成，总共有 %d 个任务待处理。\n&quot;</span>, m.totalTasks)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 启动扫描器，定时检查有没有超时任务</span></span><br><span class="line">	<span class="keyword">go</span> m.runScanner()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> runScanner() &#123;</span><br><span class="line">	ticker := time.NewTicker(<span class="number">1</span> * time.Second) <span class="comment">// 每秒扫描一次</span></span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查是否所有任务都已完成</span></span><br><span class="line">		<span class="keyword">if</span> m.totalTasks == m.completedTasks &#123;</span><br><span class="line">			m.mu.Unlock()</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// 所有任务完成，扫描器退出</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Println(<span class="string">&quot;Scanner: 正在扫描超时任务...&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> tasksToRequeue []<span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> taskID, masterTask := <span class="keyword">range</span> m.tasks &#123;</span><br><span class="line">			<span class="comment">// 检查正在进行中 且 超时 的任务</span></span><br><span class="line">			<span class="keyword">if</span> masterTask.Status == StatusInProgress &amp;&amp;</span><br><span class="line">				time.Since(masterTask.StartTime) &gt; shared.MasterTaskTimeout &#123;</span><br><span class="line"></span><br><span class="line">				log.Printf(<span class="string">&quot;Master: 任务 %d 在 Worker %s 上已超时! 准备重新排队。&quot;</span>, taskID, masterTask.WorkerID)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 1. 重置任务状态</span></span><br><span class="line">				masterTask.Status = StatusIdle</span><br><span class="line">				masterTask.WorkerID = <span class="string">&quot;&quot;</span></span><br><span class="line">				tasksToRequeue = <span class="built_in">append</span>(tasksToRequeue, taskID)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 【重要】在操作 channel 前解锁</span></span><br><span class="line">		m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 将超时的任务ID重新放回队列</span></span><br><span class="line">		<span class="keyword">for</span> _, taskID := <span class="keyword">range</span> tasksToRequeue &#123;</span><br><span class="line">			m.taskQueue &lt;- taskID</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initTasks 辅助函数：填充初始任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> initTasks() &#123;</span><br><span class="line">	tasksData := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;task data 1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;task data 2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;task data 3&quot;</span>,</span><br><span class="line">		<span class="string">&quot;task data 4&quot;</span>,</span><br><span class="line">		<span class="string">&quot;task data 5&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, data := <span class="keyword">range</span> tasksData &#123;</span><br><span class="line">		taskID := i + <span class="number">1</span></span><br><span class="line">		m.tasks[taskID] = &amp;MasterTask&#123;</span><br><span class="line">			Task:   &amp;shared.Task&#123;ID: taskID, Data: data&#125;,</span><br><span class="line">			Status: StatusIdle,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 推入待办队列</span></span><br><span class="line">		m.taskQueue &lt;- taskID</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- RPC 方法 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestTask (Worker 调用此方法来请求任务)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> RequestTask(args *shared.RequestTaskArgs, reply *shared.RequestTaskReply) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 从任务队列中获取一个任务ID</span></span><br><span class="line">	<span class="comment">//    这是一个阻塞操作，如果没有任务，goroutine会在此等待</span></span><br><span class="line">	taskID, ok := &lt;-m.taskQueue</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// 如果通道被关闭，意味着所有任务都已完成</span></span><br><span class="line">		reply.NoMoreTasks = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 锁定状态，更新任务</span></span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	masterTask, exists := m.tasks[taskID]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		<span class="comment">// 理论上不应该发生</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;内部错误：任务ID %d 不存在&quot;</span>, taskID)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 分配任务</span></span><br><span class="line">	masterTask.Status = StatusInProgress</span><br><span class="line">	masterTask.WorkerID = args.WorkerID</span><br><span class="line">	masterTask.StartTime = time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 填充回复</span></span><br><span class="line">	reply.Task = masterTask.Task</span><br><span class="line">	reply.NoMoreTasks = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;Master: 分配任务 %d 给 Worker %s\n&quot;</span>, taskID, args.WorkerID)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubmitTaskResult (Worker 调用此方法来提交结果)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> SubmitTaskResult(args *shared.SubmitTaskArgs, reply *shared.SubmitTaskReply) <span class="type">error</span> &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	taskID := args.TaskID</span><br><span class="line">	masterTask, exists := m.tasks[taskID]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 验证</span></span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;任务 %d 不存在&quot;</span>, taskID)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况1: 已经超时了，但尚未被分配出去（来迟半步）</span></span><br><span class="line">	<span class="keyword">if</span> masterTask.Status == StatusIdle &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Master: 收到任务 %d 的【过时】提交 (来自 %s)，任务已超时并正在等待重新分配。忽略。&quot;</span>,</span><br><span class="line">			taskID, args.WorkerID)</span><br><span class="line">		reply.Acknowledged = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况2: 已经超时了，并且分配给了其他worker，且正在处理（来迟一步）</span></span><br><span class="line">	<span class="keyword">if</span> masterTask.Status == StatusInProgress &amp;&amp; masterTask.WorkerID != args.WorkerID &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Master: 收到 Worker %s 对任务 %d 的【过时】提交 (任务现分配给 %s)。忽略此结果。&quot;</span>,</span><br><span class="line">			args.WorkerID, taskID, masterTask.WorkerID)</span><br><span class="line">		reply.Acknowledged = <span class="literal">true</span> <span class="comment">// 仍然告诉它 &quot;收到了&quot;，但我们不做处理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况3: 已经超时了，并且分配给了其他worker，且已经完成（来迟两步）</span></span><br><span class="line">	<span class="keyword">if</span> masterTask.Status == StatusCompleted &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Master: 收到任务 %d 的【重复】提交 (来自 %s)，任务已由 %s 完成。忽略。&quot;</span>,</span><br><span class="line">			taskID, args.WorkerID, masterTask.WorkerID)</span><br><span class="line">		reply.Acknowledged = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过验证，说明是一个及时的提交</span></span><br><span class="line">	<span class="comment">// 2. 更新状态</span></span><br><span class="line">	masterTask.Status = StatusCompleted</span><br><span class="line">	masterTask.WorkerID = args.WorkerID <span class="comment">// 记录最后由谁完成</span></span><br><span class="line">	m.completedTasks++</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;Master: 收到 Worker %s 对任务 %d 的结果: &#x27;%s&#x27;\n&quot;</span>, args.WorkerID, taskID, args.ResultData)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 检查是否所有任务都已完成</span></span><br><span class="line">	<span class="keyword">if</span> m.completedTasks == m.totalTasks &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;--- 所有任务已完成！即将关闭任务队列。 ---&quot;</span>)</span><br><span class="line">		<span class="comment">// 关闭任务队列，这将导致所有阻塞在 &lt;-m.taskQueue 上的 Worker 收到 !ok</span></span><br><span class="line">		<span class="built_in">close</span>(m.taskQueue)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reply.Acknowledged = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 主程序 ---</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	master := NewMaster()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 注册 MasterService</span></span><br><span class="line">	err := rpc.RegisterName(shared.MasterServiceName, master)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;注册 Master 服务失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 监听端口</span></span><br><span class="line">	port := <span class="string">&quot;:9000&quot;</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;监听 %s 失败: %v&quot;</span>, port, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;Master 服务端正在 %s 上监听...&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 接受连接</span></span><br><span class="line">	rpc.Accept(listener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="谁来管理状态？">谁来管理状态？</h2>
<p>这是一个经典问题。答案是：“尽可能地将状态推给服务端（接收方），让客户端保持无状态。”</p>
<p>我们来分析不同的模式：</p>
<h3 id="模式一：服务端管理状态（Stateful-Server）-我们的-Pull-模式">模式一：服务端管理状态（Stateful Server）- 我们的 Pull 模式</h3>
<p>谁管理？ 接收方（Master）。</p>
<p>状态：Master 维护着所有任务的完整状态（空闲、处理中、已完成）、哪个 Worker 在处理、什么时候开始的。</p>
<p>客户端（Worker）：完全无状态。它不记得自己做过什么，它只知道“请求 -&gt; 执行 -&gt; 提交”。如果一个 Worker 崩溃重启了，它会像一个新 Worker 一样简单地重新加入工作池，开始请求任务。</p>
<p>实例：</p>
<p>我们的 Master/Worker：这是最佳实践。</p>
<p>数据库：数据库（服务端）管理所有数据状态，客户端只是发出 CRUD 请求。</p>
<p>Web Sessions (服务端存储)：用户登录后，服务器创建一个 Session ID，并将用户信息（如购物车）存储在服务器的内存或 Redis 中。</p>
<h4 id="优点：">优点：</h4>
<ul>
<li>
<p>客户端简单、健壮：客户端（Worker）可以随意启停、崩溃、扩展，对系统整体状态没有影响（除了短暂的劳动力损失）。</p>
</li>
<li>
<p>逻辑集中：所有复杂的业务逻辑（如超时、重试、任务去重）都集中在 Master 处，易于管理和维护。</p>
</li>
</ul>
<h4 id="缺点：">缺点：</h4>
<p>服务端成为瓶颈：Master 成了“单点”，所有人都来问它要任务，它的并发和容错能力（SPOF - Single Point of Failure）要求极高。</p>
<h3 id="模式二：客户端管理状态（Stateless-Server）-我们的-Push-模式（第一个例子）">模式二：客户端管理状态（Stateless Server）- 我们的 Push 模式（第一个例子）</h3>
<p>谁管理？ 请求方（Master）。</p>
<p>状态：Master（请求方）维护着任务列表，以及 Worker 的地址列表。它需要自己决定“任务1给Worker A，任务2给Worker B”。</p>
<p>服务端（Worker）：无状态。它不记得 Master，它只是被动地接收一个请求，处理，然后返回。</p>
<p>实例：</p>
<p>我们的第一个 Push 示例。</p>
<p>RESTful API (如 JWT 认证)：</p>
<p>Server (API) 是无状态的。它不记得你是否登录。</p>
<p>Client (App) 必须管理自己的状态（即保存 JWT Token），并在每一次请求时，都主动在 Header 中带上 Authorization: Bearer <token> 来证明自己的身份。</p>
<p>函数计算 (Serverless)：云函数本身是无状态的，它被调用时，需要调用方（或事件源）提供所有必需的上下文数据。</p>
<h4 id="优点：-2">优点：</h4>
<p>服务端（Worker）极易扩展：因为 Worker 是无状态的，你可以轻松地从1个扩展到1000个，放在负载均衡器后面即可。</p>
<h4 id="缺点：-2">缺点：</h4>
<p>客户端（Master）逻辑复杂：Master 不仅要管理任务，还要管理 Worker 的“健康状态”和“地址列表”（即服务发现）。如果 Worker A 挂了，Master 怎么知道？它如何重试分配给 A 的任务？这非常复杂。</p>
<h3 id="模式三：双方管理状态（Hybrid）">模式三：双方管理状态（Hybrid）</h3>
<p>谁管理？ 双方都管理一部分。</p>
<p>实例：TCP 连接。</p>
<p>Server 和 Client 都必须维护一个关于连接状态（ESTABLISHED, FIN_WAIT, CLOSE_WAIT…）的“状态机”。如果一方的状态机与另一方不同步（例如一方认为连接已关闭，另一方还认为已连接），通信就会失败。</p>
<h4 id="优点：-3">优点：</h4>
<p>适用于需要持久、双向通信的场景。</p>
<h4 id="缺点：-3">缺点：</h4>
<p>复杂度极高，状态同步是分布式系统中最难的问题之一。应尽量避免。</p>
<h3 id="结论与最佳实践">结论与最佳实践</h3>
<p>对于“任务分发”这个场景：</p>
<p>最佳实践永远是“模式一”（服务端管理状态，即我们的 Pull 模式）。</p>
<p>让 Master 成为“状态的唯一事实来源 (Single Source of Truth)”，Worker 则是“无状态的劳动力 (Stateless Workforce)”。</p>
<p>这种架构的弹性是最好的：</p>
<p>Worker 挂了？ 没关系，Master 会通过超时机制把任务交给别人。</p>
<p>要加100个 Worker？ 没关系，启动它们，它们会自动去 Master 领活。</p>
<p>Master 挂了？ ……这才是你唯一需要担心的问题。你需要为 Master 做高可用（HA）集群（例如使用 Raft/Etcd 来保证 Master 状态的一致性），但这是另一个更高级的话题了。</p>
]]></content>
  </entry>
  <entry>
    <title>Go语言之Mysql-Proxy</title>
    <url>/2025/11/29/Go%E8%AF%AD%E8%A8%80%E4%B9%8BMysql-Proxy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>前言：最近想学学Agent开发（eino），但是又不太想照着别人的去学，所以想了一个小应用自己做做看。主要的思路就是做一个Mysql的代理程序，然后加上AI功能（安全过滤、自然语言转SQL、AI数据脱敏、SQL学习助手等等一些功能），主要技术就用Go + Eino + go-mysql/server（或者加一个TUI来作为前端），而本文则作为一个基本模板，也就是一个Mysql代理服务器，由go-mysql库来提供Mysql协议解析等等，避免重复造轮子了。</p>
</blockquote>
<hr>
<h2 id="项目概述">项目概述</h2>
<p>这是一个使用 Go 语言实现的 MySQL 代理服务器，可以拦截、记录和过滤客户端与 MySQL 服务器之间的所有通信。</p>
<hr>
<h2 id="核心概念">核心概念</h2>
<h3 id="1-代理模式-Proxy-Pattern">1. 代理模式 (Proxy Pattern)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端 &lt;---&gt; 代理服务器 &lt;---&gt; 真实 MySQL 服务器</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>客户端</strong>: Navicat、MySQL CLI 等任何 MySQL 客户端</li>
<li><strong>代理服务器</strong>: 本项目实现的中间层</li>
<li><strong>真实 MySQL</strong>: 实际存储数据的 MySQL 服务器</li>
</ul>
<h3 id="2-透明代理">2. 透明代理</h3>
<p>客户端无需知道代理的存在，就像直接连接到 MySQL 服务器一样。代理完全模拟 MySQL 服务器的行为。</p>
<hr>
<h2 id="架构设计">架构设计</h2>
<h3 id="目录结构">目录结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd/proxy/main.go          # 程序入口，处理命令行参数和启动逻辑</span><br><span class="line">├── internal/proxy/</span><br><span class="line">│   ├── server.go             # TCP 服务器，监听客户端连接</span><br><span class="line">│   └── handler.go            # 连接处理器，实现 MySQL 协议</span><br><span class="line">├── pkg/config/</span><br><span class="line">│   └── config.go             # 配置管理</span><br><span class="line">└── go.mod                    # 依赖管理</span><br></pre></td></tr></table></figure>
<h3 id="模块职责">模块职责</h3>
<p><strong>main</strong>：</p>
<ul>
<li>程序入口，提供服务器启动和优雅关闭</li>
<li>解析命令行参数到配置</li>
<li>设置线程间的通信管道</li>
</ul>
<p><strong>server</strong>：</p>
<ul>
<li>监听端口上的TCP连接（客户端）</li>
<li>创建线程处理客户端连接</li>
</ul>
<p><strong>handler</strong>：</p>
<ul>
<li>实现 MySQL 协议的服务端（代理后端）</li>
<li>解析客户端发送的 MySQL 命令</li>
<li>转发查询到真实 MySQL</li>
<li>返回结果给客户端</li>
<li>实现查询过滤和记录</li>
</ul>
<p><strong>config</strong>：</p>
<ul>
<li>定义相关配置（代理地址端口、真实数据库地址端口、用户密码等等）</li>
</ul>
<h3 id="实现的接口方法">实现的接口方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>对应 MySQL 命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Handle()</code></td>
<td>-</td>
<td>主循环，持续处理命令</td>
</tr>
<tr>
<td><code>UseDB(dbName)</code></td>
<td><code>USE database;</code></td>
<td>切换数据库</td>
</tr>
<tr>
<td><code>HandleQuery(query)</code></td>
<td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 等</td>
<td>处理 SQL 查询</td>
</tr>
<tr>
<td><code>HandleFieldList(table, wildcard)</code></td>
<td><code>COM_FIELD_LIST</code></td>
<td>获取表字段列表</td>
</tr>
<tr>
<td><code>HandleStmtPrepare(query)</code></td>
<td><code>PREPARE stmt FROM ...</code></td>
<td>预处理语句准备</td>
</tr>
<tr>
<td><code>HandleStmtExecute(context, query, args)</code></td>
<td><code>EXECUTE stmt USING ...</code></td>
<td>执行预处理语句</td>
</tr>
<tr>
<td><code>HandleStmtClose(context)</code></td>
<td><code>DEALLOCATE PREPARE stmt</code></td>
<td>关闭预处理语句</td>
</tr>
<tr>
<td><code>HandleOtherCommand(cmd, data)</code></td>
<td>其他命令</td>
<td>处理不常用命令</td>
</tr>
</tbody>
</table>
<h3 id="客户端执行流程">客户端执行流程</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 客户端发起连接</span><br><span class="line">   ↓</span><br><span class="line">2. Server.Accept() 接受连接</span><br><span class="line">   ↓</span><br><span class="line">3. 创建 ConnectionHandler</span><br><span class="line">   ↓</span><br><span class="line">4. server.NewConn() 建立 MySQL 协议连接</span><br><span class="line">   ↓</span><br><span class="line">5. 进入循环：conn.HandleCommand()</span><br><span class="line">   ↓</span><br><span class="line">6. 客户端发送查询: SELECT * FROM users</span><br><span class="line">   ↓</span><br><span class="line">7. 调用 HandleQuery(&quot;SELECT * FROM users&quot;)</span><br><span class="line">   ↓</span><br><span class="line">8. filterQuery() 过滤查询</span><br><span class="line">   │   ├─ 检测危险操作 (UPDATE/DELETE/DROP)</span><br><span class="line">   │   ├─ 记录日志</span><br><span class="line">   │   └─ 可以修改或阻止查询</span><br><span class="line">   ↓</span><br><span class="line">9. 连接到后端 MySQL (如果还未连接)</span><br><span class="line">   ↓</span><br><span class="line">10. backendDB.Execute(filteredQuery)</span><br><span class="line">   ↓</span><br><span class="line">11. 后端 MySQL 执行查询并返回结果</span><br><span class="line">   ↓</span><br><span class="line">12. 将结果返回给客户端</span><br><span class="line">   ↓</span><br><span class="line">13. 继续等待下一个命令</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="go-mysql">go-mysql</h2>
<p>使用 <code>github.com/go-mysql-org/go-mysql</code> 开源库处理 MySQL 协议：</p>
<h4 id="客户端模式（连接到真实-MySQL）">客户端模式（连接到真实 MySQL）</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := client.Connect(</span><br><span class="line">    <span class="string">&quot;127.0.0.1:3306&quot;</span>,  <span class="comment">// MySQL 地址</span></span><br><span class="line">    <span class="string">&quot;test&quot;</span>,             <span class="comment">// 用户名</span></span><br><span class="line">    <span class="string">&quot;test&quot;</span>,             <span class="comment">// 密码</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,                 <span class="comment">// 数据库</span></span><br><span class="line">)</span><br><span class="line">result, err := conn.Execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="服务端模式（接受客户端连接）">服务端模式（接受客户端连接）</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 MySQL 协议服务端连接</span></span><br><span class="line">conn, err := server.NewConn(</span><br><span class="line">    clientConn,  <span class="comment">// TCP 连接</span></span><br><span class="line">    <span class="string">&quot;root&quot;</span>,      <span class="comment">// 用户名（用于握手）</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,          <span class="comment">// 密码</span></span><br><span class="line">    handler,     <span class="comment">// 实现 Handler 接口的处理器</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环处理客户端命令</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    err := conn.HandleCommand()  <span class="comment">// 自动调用相应的 Handle* 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="代码实现">代码实现</h2>
<p>也可以不看上面，下面代码里有海量AI注释，一看就懂喵</p>
<p><strong>main</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;demo/internal/proxy&quot;</span></span><br><span class="line">	<span class="string">&quot;demo/pkg/config&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/siddontang/go-log/log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 程序入口函数</span></span><br><span class="line"><span class="comment">// 负责：</span></span><br><span class="line"><span class="comment">//  1. 解析命令行参数</span></span><br><span class="line"><span class="comment">//  2. 配置日志级别</span></span><br><span class="line"><span class="comment">//  3. 创建并启动代理服务器</span></span><br><span class="line"><span class="comment">//  4. 处理优雅关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 解析命令行参数</span></span><br><span class="line">	<span class="comment">// flag 包提供了命令行参数解析功能</span></span><br><span class="line">	<span class="comment">// 格式：flag.类型(&quot;参数名&quot;, 默认值, &quot;说明&quot;)</span></span><br><span class="line">	proxyAddr := flag.String(<span class="string">&quot;proxy-addr&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;Proxy server address&quot;</span>)</span><br><span class="line">	proxyPort := flag.Int(<span class="string">&quot;proxy-port&quot;</span>, <span class="number">3307</span>, <span class="string">&quot;Proxy server port&quot;</span>)</span><br><span class="line">	backendAddr := flag.String(<span class="string">&quot;backend-addr&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;Backend MySQL server address&quot;</span>)</span><br><span class="line">	backendPort := flag.Int(<span class="string">&quot;backend-port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;Backend MySQL server port&quot;</span>)</span><br><span class="line">	backendUser := flag.String(<span class="string">&quot;backend-user&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;Backend MySQL username&quot;</span>)</span><br><span class="line">	backendPassword := flag.String(<span class="string">&quot;backend-password&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;Backend MySQL password&quot;</span>)</span><br><span class="line">	backendDatabase := flag.String(<span class="string">&quot;backend-db&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Backend MySQL database&quot;</span>)</span><br><span class="line">	logLevel := flag.String(<span class="string">&quot;log-level&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;Log level (debug, info, warn, error)&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析命令行参数</span></span><br><span class="line">	<span class="comment">// 调用后，所有 flag 变量会被赋值</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置日志级别</span></span><br><span class="line">	<span class="comment">// 根据用户指定的日志级别配置日志输出</span></span><br><span class="line">	<span class="keyword">switch</span> *logLevel &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;debug&quot;</span>:</span><br><span class="line">		log.SetLevel(log.LevelDebug) <span class="comment">// 最详细，包含调试信息</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;info&quot;</span>:</span><br><span class="line">		log.SetLevel(log.LevelInfo) <span class="comment">// 一般信息，推荐使用</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;warn&quot;</span>:</span><br><span class="line">		log.SetLevel(log.LevelWarn) <span class="comment">// 警告信息</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;error&quot;</span>:</span><br><span class="line">		log.SetLevel(log.LevelError) <span class="comment">// 只显示错误</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		log.SetLevel(log.LevelInfo) <span class="comment">// 默认使用 info 级别</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建配置对象</span></span><br><span class="line">	<span class="comment">// 将命令行参数组装成配置结构</span></span><br><span class="line">	cfg := &amp;config.Config&#123;</span><br><span class="line">		ProxyAddr:       *proxyAddr, <span class="comment">// 注意：*proxyAddr 是解引用，获取指针指向的值</span></span><br><span class="line">		ProxyPort:       *proxyPort,</span><br><span class="line">		BackendAddr:     *backendAddr,</span><br><span class="line">		BackendPort:     *backendPort,</span><br><span class="line">		BackendUser:     *backendUser,</span><br><span class="line">		BackendPassword: *backendPassword,</span><br><span class="line">		BackendDatabase: *backendDatabase,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印启动配置</span></span><br><span class="line">	<span class="comment">// 让用户知道代理使用的配置</span></span><br><span class="line">	log.Infof(<span class="string">&quot;Starting MySQL Proxy with configuration:&quot;</span>)</span><br><span class="line">	log.Infof(<span class="string">&quot;  Proxy Address: %s:%d&quot;</span>, cfg.ProxyAddr, cfg.ProxyPort)</span><br><span class="line">	log.Infof(<span class="string">&quot;  Backend MySQL: %s:%d&quot;</span>, cfg.BackendAddr, cfg.BackendPort)</span><br><span class="line">	log.Infof(<span class="string">&quot;  Backend User: %s&quot;</span>, cfg.BackendUser)</span><br><span class="line">	log.Infof(<span class="string">&quot;  Backend Database: %s&quot;</span>, cfg.BackendDatabase)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建代理服务器实例</span></span><br><span class="line">	server := proxy.NewServer(cfg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置信号处理</span></span><br><span class="line">	<span class="comment">// 用于优雅关闭服务器（响应 Ctrl+C 等信号）</span></span><br><span class="line">	sigChan := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>) <span class="comment">// 创建信号通道，缓冲大小为 1</span></span><br><span class="line">	<span class="comment">// 注册要监听的信号</span></span><br><span class="line">	<span class="comment">// SIGINT: Ctrl+C 触发</span></span><br><span class="line">	<span class="comment">// SIGTERM: kill 命令默认信号</span></span><br><span class="line">	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建错误通道</span></span><br><span class="line">	<span class="comment">// 用于从 goroutine 中接收服务器启动错误</span></span><br><span class="line">	errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在新的 goroutine 中启动服务器</span></span><br><span class="line">	<span class="comment">// 这样主 goroutine 可以继续处理信号</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := server.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errChan &lt;- err <span class="comment">// 如果启动失败，将错误发送到错误通道</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待服务器关闭信号或错误</span></span><br><span class="line">	<span class="comment">// select 会阻塞，直到某个 case 可以执行</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-sigChan:</span><br><span class="line">		<span class="comment">// 收到关闭信号（如 Ctrl+C）</span></span><br><span class="line">		log.Infof(<span class="string">&quot;Received shutdown signal, stopping server...&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err := server.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Errorf(<span class="string">&quot;Error stopping server: %v&quot;</span>, err)</span><br><span class="line">			os.Exit(<span class="number">1</span>) <span class="comment">// 以错误码 1 退出</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Infof(<span class="string">&quot;Server stopped gracefully&quot;</span>)</span><br><span class="line">		<span class="comment">// 正常退出，退出码 0</span></span><br><span class="line">	<span class="keyword">case</span> err := &lt;-errChan:</span><br><span class="line">		<span class="comment">// 服务器启动或运行时出错</span></span><br><span class="line">		log.Errorf(<span class="string">&quot;Server error: %v&quot;</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>) <span class="comment">// 以错误码 1 退出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>server</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;demo/pkg/config&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/siddontang/go-log/log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server 代表代理服务器的主结构体</span></span><br><span class="line"><span class="comment">// 负责监听客户端连接并分发给处理器</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	cfg      *config.Config <span class="comment">// 服务器配置</span></span><br><span class="line">	listener net.Listener   <span class="comment">// TCP 监听器，用于接收客户端连接</span></span><br><span class="line">	running  <span class="type">bool</span>           <span class="comment">// 服务器运行状态标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewServer 创建一个新的代理服务器实例</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	cfg - 服务器配置，包含代理和后端 MySQL 的连接信息</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	*Server - 新创建的服务器实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(cfg *config.Config)</span></span> *Server &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Server&#123;</span><br><span class="line">		cfg:     cfg,</span><br><span class="line">		running: <span class="literal">false</span>, <span class="comment">// 初始状态为未运行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start 启动代理服务器</span></span><br><span class="line"><span class="comment">// 工作流程：</span></span><br><span class="line"><span class="comment">//  1. 在指定地址和端口上创建 TCP 监听器</span></span><br><span class="line"><span class="comment">//  2. 进入循环，等待客户端连接</span></span><br><span class="line"><span class="comment">//  3. 为每个新连接创建独立的 goroutine 处理</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 启动失败时返回错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Start() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 构建监听地址，格式：IP:端口</span></span><br><span class="line">	addr := fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, s.cfg.ProxyAddr, s.cfg.ProxyPort)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 TCP 监听器</span></span><br><span class="line">	<span class="comment">// net.Listen 会绑定指定的地址和端口，准备接收连接</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to listen on %s: %w&quot;</span>, addr, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.listener = listener</span><br><span class="line">	s.running = <span class="literal">true</span> <span class="comment">// 标记服务器为运行状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录服务器启动信息</span></span><br><span class="line">	log.Infof(<span class="string">&quot;MySQL Proxy server started on %s&quot;</span>, addr)</span><br><span class="line">	log.Infof(<span class="string">&quot;Backend MySQL server: %s:%d&quot;</span>, s.cfg.BackendAddr, s.cfg.BackendPort)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主循环：持续接收客户端连接</span></span><br><span class="line">	<span class="keyword">for</span> s.running &#123;</span><br><span class="line">		<span class="comment">// Accept() 会阻塞，直到有新的客户端连接</span></span><br><span class="line">		conn, err := s.listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果服务器正在运行但接收连接失败，记录错误</span></span><br><span class="line">			<span class="keyword">if</span> s.running &#123;</span><br><span class="line">				log.Errorf(<span class="string">&quot;Failed to accept connection: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// 继续等待下一个连接</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录新连接的客户端地址</span></span><br><span class="line">		log.Infof(<span class="string">&quot;New connection from %s&quot;</span>, conn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为每个连接启动独立的 goroutine 处理</span></span><br><span class="line">		<span class="comment">// 这样可以同时处理多个客户端连接，不会阻塞主循环</span></span><br><span class="line">		<span class="keyword">go</span> s.handleConnection(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop 停止代理服务器</span></span><br><span class="line"><span class="comment">// 关闭监听器，不再接收新连接</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 关闭失败时返回错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Stop() <span class="type">error</span> &#123;</span><br><span class="line">	s.running = <span class="literal">false</span> <span class="comment">// 标记服务器为停止状态</span></span><br><span class="line">	<span class="keyword">if</span> s.listener != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s.listener.Close() <span class="comment">// 关闭监听器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handleConnection 处理单个客户端连接</span></span><br><span class="line"><span class="comment">// 这个方法在独立的 goroutine 中运行</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	clientConn - 客户端的 TCP 连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> handleConnection(clientConn net.Conn) &#123;</span><br><span class="line">	<span class="comment">// 确保连接最终会被关闭，避免资源泄漏</span></span><br><span class="line">	<span class="keyword">defer</span> clientConn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建连接处理器，负责处理 MySQL 协议和查询转发</span></span><br><span class="line">	handler := NewConnectionHandler(clientConn, s.cfg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理连接，如果出错则记录错误信息</span></span><br><span class="line">	<span class="keyword">if</span> err := handler.Handle(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Errorf(<span class="string">&quot;Error handling connection from %s: %v&quot;</span>, clientConn.RemoteAddr(), err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接处理完成，记录日志</span></span><br><span class="line">	log.Infof(<span class="string">&quot;Connection from %s closed&quot;</span>, clientConn.RemoteAddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Handler</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;demo/pkg/config&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/go-mysql-org/go-mysql/client&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-mysql-org/go-mysql/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-mysql-org/go-mysql/server&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/siddontang/go-log/log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConnectionHandler 连接处理器</span></span><br><span class="line"><span class="comment">// 负责处理单个客户端连接的所有 MySQL 协议交互</span></span><br><span class="line"><span class="comment">// 实现了 server.Handler 接口，用于处理各种 MySQL 命令</span></span><br><span class="line"><span class="keyword">type</span> ConnectionHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	clientConn net.Conn       <span class="comment">// 客户端的 TCP 连接</span></span><br><span class="line">	cfg        *config.Config <span class="comment">// 代理配置信息</span></span><br><span class="line">	backendDB  *client.Conn   <span class="comment">// 与后端 MySQL 服务器的连接（懒加载）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewConnectionHandler 创建一个新的连接处理器</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	clientConn - 客户端的 TCP 连接</span></span><br><span class="line"><span class="comment">//	cfg - 代理配置，包含后端 MySQL 的连接信息</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	*ConnectionHandler - 新创建的连接处理器实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConnectionHandler</span><span class="params">(clientConn net.Conn, cfg *config.Config)</span></span> *ConnectionHandler &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConnectionHandler&#123;</span><br><span class="line">		clientConn: clientConn,</span><br><span class="line">		cfg:        cfg,</span><br><span class="line">		<span class="comment">// backendDB 初始为 nil，在第一次执行查询时才会连接</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle 处理客户端连接的主函数</span></span><br><span class="line"><span class="comment">// 工作流程：</span></span><br><span class="line"><span class="comment">//  1. 使用 go-mysql 库创建 MySQL 协议连接</span></span><br><span class="line"><span class="comment">//  2. 进入循环，持续处理客户端发来的命令</span></span><br><span class="line"><span class="comment">//  3. 每个命令会调用相应的 Handle* 方法（如 HandleQuery、UseDB 等）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 连接处理过程中的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> Handle() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 创建 MySQL 协议连接</span></span><br><span class="line">	<span class="comment">// 参数说明：</span></span><br><span class="line">	<span class="comment">//   - h.clientConn: 客户端的 TCP 连接</span></span><br><span class="line">	<span class="comment">//   - &quot;root&quot;: 客户端看到的用户名（用于协议握手）</span></span><br><span class="line">	<span class="comment">//   - &quot;&quot;: 密码（空密码，实际认证在后端进行）</span></span><br><span class="line">	<span class="comment">//   - h: Handler 接口实现，用于处理各种 MySQL 命令</span></span><br><span class="line">	conn, err := server.NewConn(h.clientConn, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;&quot;</span>, h)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create MySQL connection: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主循环：持续处理客户端命令</span></span><br><span class="line">	<span class="comment">// HandleCommand() 会阻塞等待客户端发送命令，然后调用相应的处理方法</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := conn.HandleCommand(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// mysql.ErrBadConn 表示连接已关闭，这是正常情况</span></span><br><span class="line">			<span class="keyword">if</span> err != mysql.ErrBadConn &#123;</span><br><span class="line">				log.Errorf(<span class="string">&quot;Handle command error: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UseDB 处理客户端切换数据库的请求</span></span><br><span class="line"><span class="comment">// 对应 SQL: USE database_name;</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	dbName - 要切换到的数据库名</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 切换失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> UseDB(dbName <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Client switching to database: %s&quot;</span>, dbName)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果还没有连接到后端 MySQL，先建立连接</span></span><br><span class="line">	<span class="comment">// 这是懒加载模式，只在需要时才连接</span></span><br><span class="line">	<span class="keyword">if</span> h.backendDB == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := h.connectBackend(<span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在后端 MySQL 上执行数据库切换</span></span><br><span class="line">	<span class="keyword">if</span> err := h.backendDB.UseDB(dbName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to switch database on backend: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleQuery 处理客户端发送的 SQL 查询</span></span><br><span class="line"><span class="comment">// 这是最核心的方法，所有 SELECT、INSERT、UPDATE、DELETE 等查询都经过这里</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	query - 客户端发送的 SQL 查询字符串</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	*mysql.Result - 查询结果（包含结果集或影响的行数）</span></span><br><span class="line"><span class="comment">//	error - 查询执行失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> HandleQuery(query <span class="type">string</span>) (*mysql.Result, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 记录收到的原始查询</span></span><br><span class="line">	log.Infof(<span class="string">&quot;Query received: %s&quot;</span>, query)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 过滤和处理查询</span></span><br><span class="line">	<span class="comment">// 这是实现查询拦截、修改、阻止的关键位置</span></span><br><span class="line">	filteredQuery := h.filterQuery(query)</span><br><span class="line">	log.Infof(<span class="string">&quot;Filtered query: %s&quot;</span>, filteredQuery)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果还没有连接到后端 MySQL，先建立连接</span></span><br><span class="line">	<span class="keyword">if</span> h.backendDB == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := h.connectBackend(<span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在后端 MySQL 上执行过滤后的查询</span></span><br><span class="line">	result, err := h.backendDB.Execute(filteredQuery)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Errorf(<span class="string">&quot;Failed to execute query on backend: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录执行结果</span></span><br><span class="line">	log.Infof(<span class="string">&quot;Query executed successfully, affected rows: %d&quot;</span>, result.AffectedRows)</span><br><span class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFieldList 处理字段列表请求</span></span><br><span class="line"><span class="comment">// 对应 MySQL 协议的 COM_FIELD_LIST 命令</span></span><br><span class="line"><span class="comment">// 一些客户端（如旧版 MySQL 命令行）使用这个命令获取表结构</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	table - 表名</span></span><br><span class="line"><span class="comment">//	fieldWildcard - 字段通配符（通常不使用）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	[]*mysql.Field - 字段列表</span></span><br><span class="line"><span class="comment">//	error - 获取失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> HandleFieldList(table <span class="type">string</span>, fieldWildcard <span class="type">string</span>) ([]*mysql.Field, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Field list request for table: %s, wildcard: %s&quot;</span>, table, fieldWildcard)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果还没有连接到后端 MySQL，先建立连接</span></span><br><span class="line">	<span class="keyword">if</span> h.backendDB == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := h.connectBackend(<span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 SHOW COLUMNS 查询来获取表结构</span></span><br><span class="line">	<span class="comment">// 使用反引号包裹表名，避免表名是保留字时出错</span></span><br><span class="line">	query := fmt.Sprintf(<span class="string">&quot;SHOW COLUMNS FROM `%s`&quot;</span>, table)</span><br><span class="line">	result, err := h.backendDB.Execute(query)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析查询结果，构建字段列表</span></span><br><span class="line">	<span class="keyword">var</span> fields []*mysql.Field</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; result.RowNumber(); i++ &#123;</span><br><span class="line">		<span class="comment">// GetString(行号, 列号) 获取结果集中的数据</span></span><br><span class="line">		<span class="comment">// SHOW COLUMNS 返回格式：Field, Type, Null, Key, Default, Extra</span></span><br><span class="line">		fieldName, _ := result.GetString(i, <span class="number">0</span>) <span class="comment">// 第 0 列是字段名</span></span><br><span class="line">		fieldType, _ := result.GetString(i, <span class="number">1</span>) <span class="comment">// 第 1 列是字段类型</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建字段描述</span></span><br><span class="line">		field := &amp;mysql.Field&#123;</span><br><span class="line">			Name: []<span class="type">byte</span>(fieldName),           <span class="comment">// 字段名</span></span><br><span class="line">			Type: h.parseFieldType(fieldType), <span class="comment">// 解析字段类型</span></span><br><span class="line">		&#125;</span><br><span class="line">		fields = <span class="built_in">append</span>(fields, field)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fields, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleStmtPrepare 处理预处理语句的准备请求</span></span><br><span class="line"><span class="comment">// 预处理语句（Prepared Statement）可以提高性能并防止 SQL 注入</span></span><br><span class="line"><span class="comment">// 对应 SQL: PREPARE stmt FROM &#x27;SELECT * FROM users WHERE id = ?&#x27;;</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	query - 要预处理的 SQL 语句（可能包含 ? 占位符）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	params - 参数数量（SQL 中 ? 的个数）</span></span><br><span class="line"><span class="comment">//	columns - 结果列数量</span></span><br><span class="line"><span class="comment">//	context - 预处理语句的上下文（后续执行时使用）</span></span><br><span class="line"><span class="comment">//	error - 准备失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> HandleStmtPrepare(query <span class="type">string</span>) (<span class="type">int</span>, <span class="type">int</span>, <span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Prepare statement: %s&quot;</span>, query)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保已连接到后端 MySQL</span></span><br><span class="line">	<span class="keyword">if</span> h.backendDB == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := h.connectBackend(<span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对查询进行过滤（与普通查询一样的过滤逻辑）</span></span><br><span class="line">	filteredQuery := h.filterQuery(query)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在后端 MySQL 上准备预处理语句</span></span><br><span class="line">	stmt, err := h.backendDB.Prepare(filteredQuery)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回参数数量、列数量和语句上下文</span></span><br><span class="line">	<span class="keyword">return</span> stmt.ParamNum(), stmt.ColumnNum(), stmt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleStmtExecute 处理预处理语句的执行请求</span></span><br><span class="line"><span class="comment">// 对应 SQL: EXECUTE stmt USING @param1, @param2;</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	context - 之前 HandleStmtPrepare 返回的上下文</span></span><br><span class="line"><span class="comment">//	query - 原始查询字符串（用于日志）</span></span><br><span class="line"><span class="comment">//	args - 执行参数（替换 SQL 中的 ? 占位符）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	*mysql.Result - 执行结果</span></span><br><span class="line"><span class="comment">//	error - 执行失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> HandleStmtExecute(context <span class="keyword">interface</span>&#123;&#125;, query <span class="type">string</span>, args []<span class="keyword">interface</span>&#123;&#125;) (*mysql.Result, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Execute prepared statement with %d args&quot;</span>, <span class="built_in">len</span>(args))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类型断言：确保 context 是预处理语句对象</span></span><br><span class="line">	stmt, ok := context.(*client.Stmt)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid statement context&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在后端 MySQL 上执行预处理语句，传入参数</span></span><br><span class="line">	result, err := stmt.Execute(args...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleStmtClose 处理关闭预处理语句的请求</span></span><br><span class="line"><span class="comment">// 对应 SQL: DEALLOCATE PREPARE stmt;</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	context - 之前 HandleStmtPrepare 返回的上下文</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 关闭失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> HandleStmtClose(context <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Close prepared statement&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类型断言：确保 context 是预处理语句对象</span></span><br><span class="line">	stmt, ok := context.(*client.Stmt)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid statement context&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭预处理语句，释放资源</span></span><br><span class="line">	<span class="keyword">return</span> stmt.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleOtherCommand 处理其他不常用的 MySQL 命令</span></span><br><span class="line"><span class="comment">// 这是一个兜底方法，处理库未明确支持的命令</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	cmd - MySQL 命令类型（字节码）</span></span><br><span class="line"><span class="comment">//	data - 命令数据</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 默认返回&quot;不支持&quot;错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> HandleOtherCommand(cmd <span class="type">byte</span>, data []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Other command received: %d, data length: %d&quot;</span>, cmd, <span class="built_in">len</span>(data))</span><br><span class="line">	<span class="comment">// 返回 MySQL 错误：未知错误</span></span><br><span class="line">	<span class="keyword">return</span> mysql.NewDefaultError(mysql.ER_UNKNOWN_ERROR, <span class="string">&quot;command not supported&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connectBackend 连接到后端 MySQL 服务器</span></span><br><span class="line"><span class="comment">// 这个方法实现了懒加载连接，只在第一次需要时才建立连接</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	dbName - 要连接的数据库名（可以为空）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 连接失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> connectBackend(dbName <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 构建后端 MySQL 的地址</span></span><br><span class="line">	addr := fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, h.cfg.BackendAddr, h.cfg.BackendPort)</span><br><span class="line"></span><br><span class="line">	log.Infof(<span class="string">&quot;Connecting to backend MySQL server at %s&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 go-mysql 的 client 包连接到后端 MySQL</span></span><br><span class="line">	<span class="comment">// 参数：</span></span><br><span class="line">	<span class="comment">//   - addr: MySQL 服务器地址</span></span><br><span class="line">	<span class="comment">//   - user: 用户名</span></span><br><span class="line">	<span class="comment">//   - password: 密码</span></span><br><span class="line">	<span class="comment">//   - dbName: 默认数据库（可选）</span></span><br><span class="line">	conn, err := client.Connect(</span><br><span class="line">		addr,</span><br><span class="line">		h.cfg.BackendUser,</span><br><span class="line">		h.cfg.BackendPassword,</span><br><span class="line">		dbName,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to connect to backend MySQL: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存连接到实例变量</span></span><br><span class="line">	h.backendDB = conn</span><br><span class="line">	log.Infof(<span class="string">&quot;Connected to backend MySQL server successfully&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filterQuery 过滤和修改查询</span></span><br><span class="line"><span class="comment">// 这是实现查询拦截、审计、安全控制的核心方法</span></span><br><span class="line"><span class="comment">// 你可以在这里实现各种过滤逻辑：</span></span><br><span class="line"><span class="comment">//   - 阻止危险操作（如 DROP DATABASE）</span></span><br><span class="line"><span class="comment">//   - 记录敏感操作（如 UPDATE、DELETE）</span></span><br><span class="line"><span class="comment">//   - 修改查询（如添加 WHERE 条件）</span></span><br><span class="line"><span class="comment">//   - SQL 注入检测</span></span><br><span class="line"><span class="comment">//   - 查询性能分析</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	query - 原始 SQL 查询</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	string - 过滤/修改后的查询（或原查询）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> filterQuery(query <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 将查询转换为大写，便于匹配（不影响原查询）</span></span><br><span class="line">	trimmedQuery := strings.TrimSpace(strings.ToUpper(query))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 示例1: 检测 DROP DATABASE 命令</span></span><br><span class="line">	<span class="comment">// 在生产环境中，你可能想要阻止这类危险操作</span></span><br><span class="line">	<span class="keyword">if</span> strings.HasPrefix(trimmedQuery, <span class="string">&quot;DROP DATABASE&quot;</span>) &#123;</span><br><span class="line">		log.Warnf(<span class="string">&quot;Blocked DROP DATABASE command: %s&quot;</span>, query)</span><br><span class="line">		<span class="comment">// 你可以在这里：</span></span><br><span class="line">		<span class="comment">// 1. 返回一个错误查询，让后端返回错误</span></span><br><span class="line">		<span class="comment">// 2. 返回一个安全的替代查询</span></span><br><span class="line">		<span class="comment">// 3. 抛出错误（需要修改返回类型）</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 示例2: 记录危险操作（DELETE、UPDATE、DROP）</span></span><br><span class="line">	<span class="comment">// 这些操作可能会修改或删除数据，需要特别关注</span></span><br><span class="line">	<span class="keyword">if</span> strings.HasPrefix(trimmedQuery, <span class="string">&quot;DELETE&quot;</span>) ||</span><br><span class="line">		strings.HasPrefix(trimmedQuery, <span class="string">&quot;UPDATE&quot;</span>) ||</span><br><span class="line">		strings.HasPrefix(trimmedQuery, <span class="string">&quot;DROP&quot;</span>) &#123;</span><br><span class="line">		log.Warnf(<span class="string">&quot;Dangerous operation detected: %s&quot;</span>, query)</span><br><span class="line">		<span class="comment">// 在实际应用中，你可以：</span></span><br><span class="line">		<span class="comment">// 1. 将操作记录到审计日志</span></span><br><span class="line">		<span class="comment">// 2. 发送告警通知</span></span><br><span class="line">		<span class="comment">// 3. 根据用户权限决定是否允许执行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 示例3: 你可以添加更多过滤规则</span></span><br><span class="line">	<span class="comment">// if strings.Contains(trimmedQuery, &quot;PASSWORD&quot;) &#123;</span></span><br><span class="line">	<span class="comment">//     log.Warnf(&quot;Query contains sensitive keyword: PASSWORD&quot;)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 示例4: 查询重写</span></span><br><span class="line">	<span class="comment">// if strings.HasPrefix(trimmedQuery, &quot;SELECT * FROM USERS&quot;) &#123;</span></span><br><span class="line">	<span class="comment">//     return &quot;SELECT id, name, email FROM users&quot; // 隐藏敏感字段</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回原始查询（未修改）</span></span><br><span class="line">	<span class="comment">// 如果要修改查询，返回修改后的字符串</span></span><br><span class="line">	<span class="keyword">return</span> query</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parseFieldType 解析 MySQL 字段类型字符串到类型常量</span></span><br><span class="line"><span class="comment">// MySQL 的 SHOW COLUMNS 返回的是字符串形式的类型（如 &quot;varchar(255)&quot;）</span></span><br><span class="line"><span class="comment">// 需要转换为 MySQL 协议使用的数字类型常量</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	fieldType - 字段类型字符串（如 &quot;INT&quot;, &quot;VARCHAR(50)&quot;, &quot;TEXT&quot;）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	uint8 - MySQL 协议类型常量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> parseFieldType(fieldType <span class="type">string</span>) <span class="type">uint8</span> &#123;</span><br><span class="line">	<span class="comment">// 转换为大写，便于匹配</span></span><br><span class="line">	fieldType = strings.ToUpper(fieldType)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 switch 匹配字段类型</span></span><br><span class="line">	<span class="comment">// 注意：使用 Contains 而不是精确匹配，因为类型可能包含长度信息</span></span><br><span class="line">	<span class="comment">// 例如：VARCHAR(255)、INT(11) 等</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;INT&quot;</span>):</span><br><span class="line">		<span class="comment">// INT, TINYINT, SMALLINT, MEDIUMINT, BIGINT</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_LONG</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;VARCHAR&quot;</span>), strings.Contains(fieldType, <span class="string">&quot;CHAR&quot;</span>):</span><br><span class="line">		<span class="comment">// VARCHAR, CHAR</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_VAR_STRING</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;TEXT&quot;</span>):</span><br><span class="line">		<span class="comment">// TEXT, TINYTEXT, MEDIUMTEXT, LONGTEXT</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_BLOB</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;DECIMAL&quot;</span>):</span><br><span class="line">		<span class="comment">// DECIMAL, NUMERIC</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_DECIMAL</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;DATETIME&quot;</span>):</span><br><span class="line">		<span class="comment">// DATETIME</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_DATETIME</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;TIMESTAMP&quot;</span>):</span><br><span class="line">		<span class="comment">// TIMESTAMP</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_TIMESTAMP</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;DATE&quot;</span>):</span><br><span class="line">		<span class="comment">// DATE（注意：要在 DATETIME 之后检查，避免误匹配）</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_DATE</span><br><span class="line">	<span class="keyword">case</span> strings.Contains(fieldType, <span class="string">&quot;TIME&quot;</span>):</span><br><span class="line">		<span class="comment">// TIME（注意：要在 DATETIME 和 TIMESTAMP 之后检查）</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_TIME</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 未知类型，默认返回字符串类型</span></span><br><span class="line">		<span class="keyword">return</span> mysql.MYSQL_TYPE_VAR_STRING</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭处理器和后端连接</span></span><br><span class="line"><span class="comment">// 释放资源，避免连接泄漏</span></span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	error - 关闭失败时返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnectionHandler)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h.backendDB != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h.backendDB.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时检查：确保 ConnectionHandler 实现了 server.Handler 接口</span></span><br><span class="line"><span class="comment">// 如果没有实现接口的所有方法，编译会失败</span></span><br><span class="line"><span class="comment">// 这是 Go 语言的一个常用技巧，用于在编译期发现接口实现错误</span></span><br><span class="line"><span class="keyword">var</span> _ server.Handler = (*ConnectionHandler)(<span class="literal">nil</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>config</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment">// Config 代理服务器的配置结构体</span></span><br><span class="line"><span class="comment">// 包含代理服务器和后端 MySQL 服务器的所有配置信息</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Proxy server settings - 代理服务器配置</span></span><br><span class="line">	ProxyAddr <span class="type">string</span> <span class="comment">// 代理服务器监听的 IP 地址，0.0.0.0 表示监听所有网络接口</span></span><br><span class="line">	ProxyPort <span class="type">int</span>    <span class="comment">// 代理服务器监听的端口号，客户端连接到此端口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Backend MySQL server settings - 后端真实 MySQL 服务器配置</span></span><br><span class="line">	BackendAddr     <span class="type">string</span> <span class="comment">// 后端 MySQL 服务器的 IP 地址</span></span><br><span class="line">	BackendPort     <span class="type">int</span>    <span class="comment">// 后端 MySQL 服务器的端口号（通常是 3306）</span></span><br><span class="line">	BackendUser     <span class="type">string</span> <span class="comment">// 连接后端 MySQL 的用户名</span></span><br><span class="line">	BackendPassword <span class="type">string</span> <span class="comment">// 连接后端 MySQL 的密码</span></span><br><span class="line">	BackendDatabase <span class="type">string</span> <span class="comment">// 默认连接的数据库名称（可选，为空表示不指定默认数据库）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultConfig 返回一个默认配置</span></span><br><span class="line"><span class="comment">// 默认配置：</span></span><br><span class="line"><span class="comment">// - 代理监听所有接口的 3307 端口</span></span><br><span class="line"><span class="comment">// - 后端 MySQL 在本地 3306 端口</span></span><br><span class="line"><span class="comment">// - 使用 test/test 作为后端认证凭据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultConfig</span><span class="params">()</span></span> *Config &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">		ProxyAddr:       <span class="string">&quot;0.0.0.0&quot;</span>,   <span class="comment">// 监听所有网络接口</span></span><br><span class="line">		ProxyPort:       <span class="number">3307</span>,        <span class="comment">// 代理端口（避免与 MySQL 默认 3306 冲突）</span></span><br><span class="line">		BackendAddr:     <span class="string">&quot;127.0.0.1&quot;</span>, <span class="comment">// 本地 MySQL</span></span><br><span class="line">		BackendPort:     <span class="number">3306</span>,        <span class="comment">// MySQL 标准端口</span></span><br><span class="line">		BackendUser:     <span class="string">&quot;test&quot;</span>,      <span class="comment">// 后端用户名</span></span><br><span class="line">		BackendPassword: <span class="string">&quot;test&quot;</span>,      <span class="comment">// 后端密码</span></span><br><span class="line">		BackendDatabase: <span class="string">&quot;&quot;</span>,          <span class="comment">// 不指定默认数据库</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之Redis入门</title>
    <url>/2025/07/26/Go%E8%AF%AD%E8%A8%80%E4%B9%8BRedis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、Redis-简介与-Go-适用场景">一、Redis 简介与 Go 适用场景</h2>
<p>Redis 是一个高性能的<strong>Key-Value</strong>内存数据库，常用于：</p>
<ul>
<li>数据缓存（热点数据、数据库查询结果）</li>
<li>计数器（网站访问量、点赞数）</li>
<li>排行榜系统（使用 <code>ZSet</code>）</li>
<li>消息队列（Pub/Sub 或 Redis Stream）</li>
<li>分布式锁</li>
<li>限流器（如滑动窗口、令牌桶）</li>
</ul>
<p>在 Go 微服务架构中，Redis 通常扮演<strong>缓存层 + 通讯中间件</strong>的角色，性能至关重要。</p>
<hr>
<h2 id="二、Go-中操作-Redis-基础：使用-go-redis-v9">二、Go 中操作 Redis 基础：使用 go-redis/v9</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/redis/go-redis/v9</span><br></pre></td></tr></table></figure>
<h3 id="初始化连接客户端（全局复用）">初始化连接客户端（全局复用）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> redisx</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/redis/go-redis/v9&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ctx = context.Background()</span><br><span class="line">	Rdb *redis.Client</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitRedis</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>,  <span class="comment">// no password</span></span><br><span class="line">		DB:       <span class="number">0</span>,   <span class="comment">// default DB</span></span><br><span class="line">		PoolSize: <span class="number">10</span>,  <span class="comment">// 连接池大小</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := Rdb.Ping(ctx).Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;redis 连接失败: &quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、常见-Redis-数据结构-Go-操作实战">三、常见 Redis 数据结构 + Go 操作实战</h2>
<h3 id="1-String（缓存、计数）">1. String（缓存、计数）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rdb.Set(ctx, <span class="string">&quot;views&quot;</span>, <span class="number">100</span>, time.Hour)</span><br><span class="line">val, _ := rdb.Get(ctx, <span class="string">&quot;views&quot;</span>).Int()</span><br><span class="line">rdb.Incr(ctx, <span class="string">&quot;views&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-Hash（结构化数据）">2. Hash（结构化数据）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rdb.HSet(ctx, <span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">30</span>)</span><br><span class="line">rdb.HGetAll(ctx, <span class="string">&quot;user:1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-List（队列）">3. List（队列）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rdb.LPush(ctx, <span class="string">&quot;task:queue&quot;</span>, <span class="string">&quot;job1&quot;</span>, <span class="string">&quot;job2&quot;</span>)</span><br><span class="line">rdb.RPop(ctx, <span class="string">&quot;task:queue&quot;</span>) <span class="comment">// 消费任务</span></span><br></pre></td></tr></table></figure>
<h3 id="4-Set（去重）">4. Set（去重）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rdb.SAdd(ctx, <span class="string">&quot;ip:banlist&quot;</span>, <span class="string">&quot;192.168.1.1&quot;</span>)</span><br><span class="line">rdb.SIsMember(ctx, <span class="string">&quot;ip:banlist&quot;</span>, <span class="string">&quot;192.168.1.1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-Sorted-Set（排行榜）">5. Sorted Set（排行榜）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;rank&quot;</span>, redis.Z&#123;Score: <span class="number">100</span>, Member: <span class="string">&quot;u1&quot;</span>&#125;)</span><br><span class="line">rdb.ZRevRangeWithScores(ctx, <span class="string">&quot;rank&quot;</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、典型应用场景实战（代码完整示例）">四、典型应用场景实战（代码完整示例）</h2>
<h3 id="1-缓存数据库查询结果">1. 缓存数据库查询结果</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUser</span><span class="params">(uid <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	key := <span class="string">&quot;user:&quot;</span> + uid</span><br><span class="line">	<span class="comment">// 查 Redis</span></span><br><span class="line">	val, err := rdb.Get(ctx, key).Result()</span><br><span class="line">	<span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">		<span class="comment">// 未命中，查询数据库</span></span><br><span class="line">		val = <span class="string">&quot;UserFromDB&quot;</span> <span class="comment">// 模拟</span></span><br><span class="line">		rdb.Set(ctx, key, val, time.Minute*<span class="number">10</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-ZSet-实现游戏排行榜">2. 使用 ZSet 实现游戏排行榜</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddScore</span><span class="params">(user <span class="type">string</span>, score <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">	rdb.ZIncrBy(ctx, <span class="string">&quot;game:rank&quot;</span>, score, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TopRank</span><span class="params">(n <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">	top, _ := rdb.ZRevRangeWithScores(ctx, <span class="string">&quot;game:rank&quot;</span>, <span class="number">0</span>, n<span class="number">-1</span>).Result()</span><br><span class="line">	<span class="keyword">for</span> i, z := <span class="keyword">range</span> top &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d: %s -&gt; %.0f\n&quot;</span>, i+<span class="number">1</span>, z.Member, z.Score)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-分布式锁实现（推荐-Lua-方式）">3. 分布式锁实现（推荐 Lua 方式）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AcquireLock</span><span class="params">(key, value <span class="type">string</span>, ttl time.Duration)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	ok, _ := rdb.SetNX(ctx, key, value, ttl).Result()</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReleaseLock</span><span class="params">(key, value <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	lua := <span class="string">`if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">	         return redis.call(&quot;del&quot;, KEYS[1]) else return 0 end`</span></span><br><span class="line">	rdb.Eval(ctx, lua, []<span class="type">string</span>&#123;key&#125;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-消息发布-订阅">4. 消息发布/订阅</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布</span></span><br><span class="line">rdb.Publish(ctx, <span class="string">&quot;channel:news&quot;</span>, <span class="string">&quot;Hello Subscriber!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">sub := rdb.Subscribe(ctx, <span class="string">&quot;channel:news&quot;</span>)</span><br><span class="line">ch := sub.Channel()</span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;收到消息：&quot;</span>, msg.Payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="五、封装-Redis-为模块化中间件（强烈推荐）">五、封装 Redis 为模块化中间件（强烈推荐）</h2>
<h3 id="封装-Redis-接口层（泛型支持）">封装 Redis 接口层（泛型支持）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redisx/client.go</span></span><br><span class="line"><span class="keyword">package</span> redisx</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	rdb *redis.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(opt *redis.Options)</span></span> *Client &#123;</span><br><span class="line">	rdb := redis.NewClient(opt)</span><br><span class="line">	<span class="keyword">return</span> &amp;Client&#123;rdb: rdb&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> SetString(key <span class="type">string</span>, val <span class="type">string</span>, ttl time.Duration) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.rdb.Set(ctx, key, val, ttl).Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> GetString(key <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.rdb.Get(ctx, key).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Incr(key <span class="type">string</span>) (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.rdb.Incr(ctx, key).Result()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用方式：">使用方式：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">redisClient := redisx.NewClient(&amp;redis.Options&#123;Addr: <span class="string">&quot;localhost:6379&quot;</span>&#125;)</span><br><span class="line">redisClient.SetString(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Tom&quot;</span>, time.Hour)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、性能优化与常见问题">六、性能优化与常见问题</h2>
<table>
<thead>
<tr>
<th>问题</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis 雪崩</td>
<td>设置不同 TTL、加入本地缓存降级</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>使用互斥锁或缓存空值</td>
</tr>
<tr>
<td>缓存穿透</td>
<td>对非法请求返回默认值并缓存</td>
</tr>
<tr>
<td>热 Key 过载</td>
<td>考虑引入本地缓存、Sharding</td>
</tr>
</tbody>
</table>
<h3 id="实用建议：">实用建议：</h3>
<ul>
<li>使用连接池（默认开启）</li>
<li>多操作使用 Pipeline 批处理</li>
<li>配置监控：<code>INFO memory</code>、<code>slowlog get</code></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>database</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之Wire依赖注入</title>
    <url>/2025/08/22/Go%E8%AF%AD%E8%A8%80%E4%B9%8BWire%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、为什么需要依赖注入？">一、为什么需要依赖注入？</h2>
<p>在 Go 项目中，我们常常会遇到这样的依赖关系：</p>
<ul>
<li><code>Handler</code> 依赖 <code>Service</code></li>
<li><code>Service</code> 依赖 <code>DAO</code></li>
<li><code>DAO</code> 依赖 <code>数据库连接</code></li>
</ul>
<p>如果手动初始化，会出现类似这样的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := initDB()</span><br><span class="line">    userDAO := NewUserDAO(db)</span><br><span class="line">    userService := NewUserService(userDAO)</span><br><span class="line">    userHandler := NewUserHandler(userService)</span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, userHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看似简单，但随着依赖层级变多，维护和修改变得繁琐。<br>
<strong>依赖注入（DI）</strong> 的思想就是：让依赖关系的初始化逻辑交由框架或工具自动生成，从而保持代码简洁、解耦。</p>
<p>Google 提供的 <a href="https://github.com/google/wire"><code>wire</code></a> 就是 Go 中常用的 <strong>编译时依赖注入工具</strong>。</p>
<hr>
<h2 id="二、Wire-的核心思想">二、Wire 的核心思想</h2>
<p><code>wire</code> 不是一个运行时框架，它会在编译时生成依赖注入的代码，生成后再由我们项目编译。<br>
流程如下：</p>
<ol>
<li>定义各层的 <strong>构造函数（Provider）</strong></li>
<li>在 <code>wire.go</code> 中声明依赖关系</li>
<li>执行 <code>wire</code> 命令生成 <code>wire_gen.go</code></li>
<li>使用生成的代码运行项目</li>
</ol>
<p>这样，我们就不需要手写繁琐的依赖初始化逻辑。</p>
<hr>
<h2 id="三、示例项目结构">三、示例项目结构</h2>
<p>我们以一个用户服务（User Service）为例，项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── dao</span><br><span class="line">│   └── user_dao.go</span><br><span class="line">├── service</span><br><span class="line">│   └── user_service.go</span><br><span class="line">├── handler</span><br><span class="line">│   └── user_handler.go</span><br><span class="line">├── main.go</span><br><span class="line">├── wire.go</span><br><span class="line">└── go.mod</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、编写各层代码">四、编写各层代码</h2>
<h3 id="1-DAO-层">1. DAO 层</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dao/user_dao.go</span></span><br><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;database/sql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserDAO <span class="keyword">struct</span> &#123;</span><br><span class="line">    db *sql.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserDAO</span><span class="params">(db *sql.DB)</span></span> *UserDAO &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserDAO&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *UserDAO)</span></span> GetUser(id <span class="type">int</span>) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟从数据库获取用户</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User#&quot;</span> + <span class="type">string</span>(<span class="type">rune</span>(id))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-Service-层">2. Service 层</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// service/user_service.go</span></span><br><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;myapp/dao&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    dao *dao.UserDAO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">(dao *dao.UserDAO)</span></span> *UserService &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserService&#123;dao: dao&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span></span> GetUserName(id <span class="type">int</span>) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.dao.GetUser(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-Handler-层">3. Handler 层</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler/user_handler.go</span></span><br><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;myapp/service&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    service *service.UserService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserHandler</span><span class="params">(service *service.UserService)</span></span> *UserHandler &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserHandler&#123;service: service&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *UserHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    name := h.service.GetUserName(<span class="number">1</span>)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="五、使用-Wire-管理依赖">五、使用 Wire 管理依赖</h2>
<h3 id="1-安装-wire">1. 安装 wire</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/google/wire/cmd/wire@latest</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-创建-wire-go">2. 创建 wire.go</h3>
<p>在项目根目录新建 <code>wire.go</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:build wireinject</span></span><br><span class="line"><span class="comment">// +build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;myapp/dao&quot;</span></span><br><span class="line">    <span class="string">&quot;myapp/handler&quot;</span></span><br><span class="line">    <span class="string">&quot;myapp/service&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> *sql.DB &#123;</span><br><span class="line">    <span class="comment">// 这里简单模拟返回一个 *sql.DB</span></span><br><span class="line">    <span class="keyword">return</span> &amp;sql.DB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化整个应用依赖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitApp</span><span class="params">()</span></span> *handler.UserHandler &#123;</span><br><span class="line">    wire.Build(</span><br><span class="line">        initDB,</span><br><span class="line">        dao.NewUserDAO,</span><br><span class="line">        service.NewUserService,</span><br><span class="line">        handler.NewUserHandler,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> &amp;handler.UserHandler&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>//go:build wireinject</code> + <code>// +build wireinject</code> 用于标记此文件只在 <code>wire</code> 生成代码时使用，编译时会被忽略。</li>
<li><code>wire.Build</code> 声明了依赖关系，Wire 会自动推导构造函数的调用顺序。</li>
</ul>
<hr>
<h3 id="3-生成-wire-gen-go">3. 生成 wire_gen.go</h3>
<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wire</span><br></pre></td></tr></table></figure>
<p>会生成 <code>wire_gen.go</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitApp</span><span class="params">()</span></span> *handler.UserHandler &#123;</span><br><span class="line">    db := initDB()</span><br><span class="line">    userDAO := dao.NewUserDAO(db)</span><br><span class="line">    userService := service.NewUserService(userDAO)</span><br><span class="line">    userHandler := handler.NewUserHandler(userService)</span><br><span class="line">    <span class="keyword">return</span> userHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、在-main-go-中使用">六、在 main.go 中使用</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := InitApp()</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">&quot;Server running on :8080&quot;</span>)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，一个完整的 <strong>Handler + Service + DAO</strong> 依赖关系，就通过 Wire 自动管理了。</p>
<hr>
<h2 id="七、最佳实践">七、最佳实践</h2>
<ol>
<li>
<p><strong>保持 Provider 函数简单</strong></p>
<ul>
<li>每个 Provider 只做一件事：返回依赖对象。</li>
<li>不要把复杂逻辑塞进 Provider。</li>
</ul>
</li>
<li>
<p><strong>分组管理 ProviderSet</strong><br>
可以为每层定义一个 <code>wire.ProviderSet</code>，保持清晰。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DaoSet = wire.NewSet(NewUserDAO)</span><br><span class="line"><span class="keyword">var</span> ServiceSet = wire.NewSet(NewUserService)</span><br><span class="line"><span class="keyword">var</span> HandlerSet = wire.NewSet(NewUserHandler)</span><br></pre></td></tr></table></figure>
<p>然后在 <code>wire.go</code> 中引入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitApp</span><span class="params">()</span></span> *handler.UserHandler &#123;</span><br><span class="line">    wire.Build(</span><br><span class="line">        initDB,</span><br><span class="line">        dao.DaoSet,</span><br><span class="line">        service.ServiceSet,</span><br><span class="line">        handler.HandlerSet,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> &amp;handler.UserHandler&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>避免全局变量</strong></p>
<ul>
<li>不要使用全局 <code>db</code>、全局 <code>service</code>，让依赖通过注入管理。</li>
</ul>
</li>
<li>
<p><strong>结合接口提高可测试性</strong></p>
<ul>
<li>Service 层依赖 <code>DAO</code> 接口，而不是具体实现，这样单测可以用 mock 替代。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserDAOInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetUser(id <span class="type">int</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    dao UserDAOInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>只在应用根目录使用 Wire</strong></p>
<ul>
<li>Wire 适合管理项目整体依赖，不要在子包随意生成 <code>wire_gen.go</code>，否则维护困难。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="八、总结">八、总结</h2>
<p>通过 <code>wire</code>，我们实现了：</p>
<ul>
<li><strong>自动化依赖管理</strong>（不用手写依赖链条）</li>
<li><strong>分层解耦</strong>（Handler、Service、DAO 清晰分工）</li>
<li><strong>更易测试</strong>（通过接口 + 依赖注入替换实现）</li>
</ul>
<p>Wire 的最大优势在于 <strong>编译期生成代码</strong>，无运行时开销，非常适合 Go 的项目架构。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之Swaggo</title>
    <url>/2025/09/02/Go%E8%AF%AD%E8%A8%80%E4%B9%8BSwaggo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h1 id="使用-Swaggo-为-Gin-项目自动生成-Swagger-文档">使用 Swaggo 为 Gin 项目自动生成 Swagger 文档</h1>
<p>在开发 Go Web 项目的时候，API 文档的维护一直是一个痛点。手写文档容易过时，缺乏统一标准，而 Swaggo 为我们提供了一种 <strong>自动化生成 Swagger 文档</strong> 的方式，尤其适合和 Gin 框架搭配使用。本文将介绍 Swaggo 的基本用法，并结合 Gin 展示最佳实践。</p>
<hr>
<h2 id="一、为什么选择-Swaggo-Gin？">一、为什么选择 Swaggo + Gin？</h2>
<ul>
<li><strong>Swaggo (<a href="http://github.com/swaggo/swag">github.com/swaggo/swag</a>)</strong> 是 Go 语言最常用的 Swagger 文档生成工具。</li>
<li>它通过 <strong>注释（Annotation）</strong> 自动解析 API 信息，生成 <code>swagger.json</code>/<code>swagger.yaml</code> 文件。</li>
<li>Gin 作为高性能 Web 框架，与 Swaggo 配合，可以让我们在写路由和 Handler 时，顺便写上注释，做到 <strong>代码即文档</strong>。</li>
</ul>
<p>最终效果是：</p>
<ul>
<li>在浏览器访问 <code>http://localhost:8080/swagger/index.html</code></li>
<li>自动看到漂亮的 Swagger UI 界面，方便前后端联调。</li>
</ul>
<hr>
<h2 id="二、安装与初始化">二、安装与初始化</h2>
<h3 id="1-安装依赖">1. 安装依赖</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br><span class="line">go get -u github.com/swaggo/swag/cmd/swag</span><br><span class="line">go get -u github.com/swaggo/files</span><br><span class="line">go get -u github.com/swaggo/gin-swagger</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>swag</code> 是命令行工具，用于扫描项目注释生成文档。</p>
</blockquote>
<h3 id="2-初始化-Swagger">2. 初始化 Swagger</h3>
<p>进入项目根目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swag init</span><br></pre></td></tr></table></figure>
<p>该命令会扫描 <code>main.go</code> 和其他源文件的注释，生成 <code>docs/</code> 目录，里面包含 <code>docs.go</code> 和 <code>swagger.json</code> 等。</p>
<hr>
<h2 id="三、在-Gin-中接入-Swaggo">三、在 Gin 中接入 Swaggo</h2>
<h3 id="1-项目结构推荐">1. 项目结构推荐</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── main.go</span><br><span class="line">├── docs/         # swag 自动生成</span><br><span class="line">├── router/       # 路由管理</span><br><span class="line">├── controller/   # 业务逻辑</span><br><span class="line">└── model/        # 数据模型</span><br></pre></td></tr></table></figure>
<h3 id="2-在-main-go-添加-Swagger-配置">2. 在 <code>main.go</code> 添加 Swagger 配置</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;your_project/docs&quot;</span> <span class="comment">// 这里要引入 docs 包，确保 swagger 文档能被注册</span></span><br><span class="line"></span><br><span class="line">	ginSwagger <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/swaggo/files&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @title           Gin + Swaggo 示例 API</span></span><br><span class="line"><span class="comment">// @version         1.0</span></span><br><span class="line"><span class="comment">// @description     一个使用 Swaggo 自动生成文档的 Gin 项目</span></span><br><span class="line"><span class="comment">// @host            localhost:8080</span></span><br><span class="line"><span class="comment">// @BasePath        /api/v1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册 Swagger 路由</span></span><br><span class="line">	r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册业务路由</span></span><br><span class="line">	api := r.Group(<span class="string">&quot;/api/v1&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		api.GET(<span class="string">&quot;/ping&quot;</span>, PingHandler)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PingHandler godoc</span></span><br><span class="line"><span class="comment">// @Summary      健康检查</span></span><br><span class="line"><span class="comment">// @Description  返回 pong</span></span><br><span class="line"><span class="comment">// @Tags         系统</span></span><br><span class="line"><span class="comment">// @Produce      json</span></span><br><span class="line"><span class="comment">// @Success      200  &#123;string&#125;  string &quot;pong&quot;</span></span><br><span class="line"><span class="comment">// @Router       /ping [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PingHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行 <code>swag init &amp;&amp; go run main.go</code>，访问：</p>
<p>👉 <code>http://localhost:8080/swagger/index.html</code><br>
即可看到 Swagger UI 页面。</p>
<hr>
<h2 id="四、常用注释写法">四、常用注释写法</h2>
<p>Swaggo 注释写在 <strong>Handler 函数上方</strong>，以下是常见标签：</p>
<ul>
<li><code>@Summary</code>：API 简短说明</li>
<li><code>@Description</code>：详细描述</li>
<li><code>@Tags</code>：接口分类（分组）</li>
<li><code>@Param</code>：请求参数</li>
<li><code>@Success</code>：返回成功响应</li>
<li><code>@Failure</code>：返回失败响应</li>
<li><code>@Router</code>：路由及方法（必须，格式：<code>/path [method]</code>）</li>
</ul>
<h3 id="示例：带参数的接口">示例：带参数的接口</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetUser godoc</span></span><br><span class="line"><span class="comment">// @Summary      获取用户</span></span><br><span class="line"><span class="comment">// @Description  根据ID获取用户信息</span></span><br><span class="line"><span class="comment">// @Tags         用户</span></span><br><span class="line"><span class="comment">// @Param        id   path      int  true  &quot;用户ID&quot;</span></span><br><span class="line"><span class="comment">// @Produce      json</span></span><br><span class="line"><span class="comment">// @Success      200  &#123;object&#125;  model.User</span></span><br><span class="line"><span class="comment">// @Failure      400  &#123;object&#125;  map[string]string</span></span><br><span class="line"><span class="comment">// @Router       /user/&#123;id&#125; [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUser</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	id := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;id&quot;</span>: id, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>model.User</code> 是我们定义的数据模型，可以在 Swagger 文档中自动展示。</p>
<hr>
<h2 id="五、最佳实践">五、最佳实践</h2>
<h3 id="1-项目启动时自动生成文档">1. 项目启动时自动生成文档</h3>
<p>在 CI/CD 或本地开发时，可以把 <code>swag init</code> 放到 <code>Makefile</code> 或脚本里，避免手动执行。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">swagger:</span></span><br><span class="line">	swag init --parseDependency --parseInternal</span><br></pre></td></tr></table></figure>
<h3 id="2-合理使用-Tags">2. 合理使用 <code>@Tags</code></h3>
<p>把接口分组（如 用户、订单、系统），这样在 Swagger UI 页面结构清晰。</p>
<h3 id="3-模型定义与返回值一致">3. 模型定义与返回值一致</h3>
<p>如果接口返回 JSON 结构，最好在 <code>model/</code> 中定义结构体，并在注释里引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在注释里写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Success 200 &#123;object&#125; model.User</span></span><br></pre></td></tr></table></figure>
<p>这样前端在 Swagger UI 上就能看到完整的返回结构。</p>
<h3 id="4-避免文档与代码不一致">4. 避免文档与代码不一致</h3>
<ul>
<li>尽量在写 Handler 的时候就写好注释。</li>
<li>定期运行 <code>swag init</code> 确保文档更新。</li>
<li>可以在 CI 里加个检查，避免遗漏。</li>
</ul>
<h3 id="5-安全认证（JWT-API-Key）">5. 安全认证（JWT / API Key）</h3>
<p>Swaggo 也支持在文档中描述认证方式，比如 JWT：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Security BearerAuth</span></span><br></pre></td></tr></table></figure>
<p>需要在 <code>main.go</code> 顶部添加：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @securityDefinitions.apikey BearerAuth</span></span><br><span class="line"><span class="comment">// @in header</span></span><br><span class="line"><span class="comment">// @name Authorization</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之context应用场景</title>
    <url>/2025/08/26/Go%E8%AF%AD%E8%A8%80%E4%B9%8Bcontext%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0-速览：牢记的五条铁律">0. 速览：牢记的五条铁律</h1>
<ol>
<li><code>context.Context</code> 始终放在函数<strong>第一个参数</strong>。</li>
<li><strong>不要存进结构体字段</strong>；逐层传递。</li>
<li>派生了 <code>WithTimeout/WithCancel</code> 就<strong>必须调用 <code>cancel()</code></strong>（循环里千万别 <code>defer</code>）。</li>
<li><strong>只</strong>用 <code>WithValue</code> 传<strong>小而只读</strong>的请求元数据（traceID、locale、userID…）。</li>
<li>取消是<strong>协作式</strong>的：在你的阻塞点 <code>select &lt;-ctx.Done()</code>，不检查就不会停。</li>
</ol>
<hr>
<h1 id="1-HTTP-请求全链路：入口统一时间预算-级联取消">1) HTTP 请求全链路：入口统一时间预算 + 级联取消</h1>
<h2 id="场景">场景</h2>
<ul>
<li>统一限制每个请求的耗时（比如 2s）。</li>
<li>下游（DB/外部 HTTP、缓存）全部遵循同一预算。</li>
<li>携带 traceID / userID 等请求范围元数据。</li>
</ul>
<h2 id="代码（handler-→-service-→-dao）">代码（handler → service → dao）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- keys.go ---</span></span><br><span class="line"><span class="keyword">package</span> keys</span><br><span class="line"><span class="keyword">type</span> ctxKey <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    KeyTraceID ctxKey = <span class="string">&quot;traceID&quot;</span></span><br><span class="line">    KeyUserID  ctxKey = <span class="string">&quot;userID&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTraceID</span><span class="params">(ctx context.Context, id <span class="type">string</span>)</span></span> context.Context &#123; <span class="keyword">return</span> context.WithValue(ctx, KeyTraceID, id) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraceID</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">bool</span>) &#123; v, ok := ctx.Value(KeyTraceID).(<span class="type">string</span>); <span class="keyword">return</span> v, ok &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- handler.go ---</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProfileHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1) 入口统一预算：2s</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(r.Context(), <span class="number">2</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 附加请求元数据（traceID / userID）</span></span><br><span class="line">    <span class="keyword">if</span> reqID := r.Header.Get(<span class="string">&quot;X-Request-ID&quot;</span>); reqID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        ctx = keys.WithTraceID(ctx, reqID)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假设从鉴权中取到 userID</span></span><br><span class="line">    ctx = context.WithValue(ctx, keys.KeyUserID, <span class="string">&quot;u123&quot;</span>)</span><br><span class="line"></span><br><span class="line">    prof, err := svc.GetProfile(ctx, <span class="string">&quot;u123&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 3) 细节：区分超时/用户取消/内部错误</span></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> errors.Is(err, context.DeadlineExceeded):</span><br><span class="line">            http.Error(w, <span class="string">&quot;timeout&quot;</span>, http.StatusGatewayTimeout)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> errors.Is(err, context.Canceled):</span><br><span class="line">            <span class="comment">// 客户端断开常见会导致这里出现；通常直接返回或写个 408/499（无标准常量）</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            http.Error(w, <span class="string">&quot;internal error&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    _, _ = w.Write([]<span class="type">byte</span>(prof))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- service.go ---</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">    DAO *DAO</span><br><span class="line">    Http *http.Client</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> GetProfile(ctx context.Context, uid <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 4) 可在 service 层“缩短”预算（不能延长）</span></span><br><span class="line">    <span class="comment">//    推荐先看现有剩余时间，避免不必要的二次定时器</span></span><br><span class="line">    <span class="keyword">if</span> dl, ok := ctx.Deadline(); ok &amp;&amp; time.Until(dl) &lt; <span class="number">300</span>*time.Millisecond &#123;</span><br><span class="line">        <span class="comment">// 剩余时间太短，直接失败或降级</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;no budget: %w&quot;</span>, context.DeadlineExceeded)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 组合调用演示：并行查 DB + 外部画像服务（errgroup）</span></span><br><span class="line">    g, ctx := errgroup.WithContext(ctx)</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        base <span class="type">string</span></span><br><span class="line">        enrich <span class="type">string</span></span><br><span class="line">    )</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        v, err := s.DAO.QueryBase(ctx, uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        base = v; <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="comment">// 外部服务遵循 ctx：NewRequestWithContext</span></span><br><span class="line">        req, _ := http.NewRequestWithContext(ctx, <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://api.example.com/enrich?uid=&quot;</span>+uid, <span class="literal">nil</span>)</span><br><span class="line">        resp, err := s.Http.Do(req)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">        b, _ := io.ReadAll(resp.Body)</span><br><span class="line">        enrich = <span class="type">string</span>(b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">`&#123;&quot;base&quot;:%q,&quot;enrich&quot;:%q&#125;`</span>, base, enrich), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- dao.go ---</span></span><br><span class="line"><span class="keyword">type</span> DAO <span class="keyword">struct</span> &#123; DB *sql.DB &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DAO)</span></span> QueryBase(ctx context.Context, uid <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 6) 一定使用 *Context API</span></span><br><span class="line">    row := d.DB.QueryRowContext(ctx, <span class="string">&quot;SELECT name FROM users WHERE id=?&quot;</span>, uid)</span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">    <span class="keyword">if</span> err := row.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键细节（最佳实践）">关键细节（最佳实践）</h3>
<ul>
<li><strong>入口即预算</strong>：在 <code>handler</code> 一次性设置；下游只“遵循”不再另设更长超时。</li>
<li><strong>errgroup.WithContext</strong>：任一子任务失败/取消会<strong>自动取消其它</strong>。</li>
<li><strong>外部请求</strong>用 <code>NewRequestWithContext</code>，DB 用 <code>QueryRowContext/ExecContext</code>。</li>
<li><strong>错误判别</strong>：使用 <code>errors.Is(err, context.DeadlineExceeded)</code> / <code>context.Canceled</code>。</li>
<li><strong>不要假设 499 常量存在</strong>（没有标准常量），想返回可用数字或直接中断。</li>
</ul>
<hr>
<h1 id="2-优雅关停（graceful-shutdown）：服务整体的“父”上下文">2) 优雅关停（graceful shutdown）：服务整体的“父”上下文</h1>
<h2 id="场景-2">场景</h2>
<ul>
<li>收到 <code>SIGINT/SIGTERM</code> 时停止接收新请求，让在途请求在 5s 内收尾。</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">srv := &amp;http.Server&#123;Addr: <span class="string">&quot;:8080&quot;</span>, Handler: mux&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = srv.ListenAndServe() &#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 1.16+：直接用信号派生 Context</span></span><br><span class="line">ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"><span class="keyword">defer</span> stop()</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done() <span class="comment">// 收到信号</span></span><br><span class="line"></span><br><span class="line">shutdownCtx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">_ = srv.Shutdown(shutdownCtx) <span class="comment">// 等待在途完成；超时则强制关闭连接</span></span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li>关闭顺序：<strong>先</strong>停止新连接（<code>Shutdown</code>），<strong>再</strong>等待在途完成。</li>
<li><code>Shutdown</code> 里会把 <code>r.Context()</code> 取消，下游协程应响应 <code>Done()</code>。</li>
<li>记录<strong>最长耗时的在途请求</strong>，以便调整 <code>Shutdown</code> 的预算。</li>
</ul>
<hr>
<h1 id="3-并发流水线与-worker：每一环都要“感知取消”">3) 并发流水线与 worker：每一环都要“感知取消”</h1>
<h2 id="场景-3">场景</h2>
<ul>
<li>jobs → stage1 → stage2 → sink 的流水线；或一组 worker 从队列消费。</li>
</ul>
<h2 id="代码-2">代码</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上游生产</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        <span class="keyword">case</span> out &lt;- i:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 stage（可并行开 N 份）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stageDouble</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>, out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        <span class="keyword">case</span> v, ok := &lt;-in:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">            <span class="comment">// 计算本身如耗时，也要支持 ctx（见 ctx-aware sleep）</span></span><br><span class="line">            <span class="keyword">if</span> err := Sleep(ctx, <span class="number">10</span>*time.Millisecond); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            out &lt;- <span class="number">2</span> * v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx-aware Sleep（不要直接 time.Sleep）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sleep</span><span class="params">(ctx context.Context, d time.Duration)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    t := time.NewTimer(d)</span><br><span class="line">    <span class="keyword">defer</span> t.Stop()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><strong>所有阻塞点</strong>（读写通道、休眠、IO）都要能被 <code>ctx.Done()</code> 打断。</li>
<li><code>ticker</code>/<code>timer</code> 注意 <code>Stop()</code>，避免泄漏。</li>
<li>关闭通道的一端<strong>由生产者</strong>负责，避免 data race。</li>
</ul>
<hr>
<h1 id="4-带重试的外部调用（遵守剩余预算）">4) 带重试的外部调用（遵守剩余预算）</h1>
<h2 id="场景-4">场景</h2>
<ul>
<li>对不稳定的外部依赖做重试 + 退避，但<strong>不突破整体时间预算</strong>。</li>
</ul>
<h2 id="代码-3">代码</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallWithRetry</span><span class="params">(ctx context.Context, do <span class="keyword">func</span>(context.Context)</span></span> <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">    backoff := <span class="number">100</span> * time.Millisecond</span><br><span class="line">    <span class="keyword">for</span> attempt := <span class="number">0</span>; ; attempt++ &#123;</span><br><span class="line">        <span class="comment">// 每次尝试都用“子 ctx”，确保单次尝试不会拖垮总预算</span></span><br><span class="line">        tryCtx, cancel := context.WithTimeout(ctx, <span class="number">500</span>*time.Millisecond)</span><br><span class="line">        err := do(tryCtx)</span><br><span class="line">        cancel()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) &#123;</span><br><span class="line">            <span class="comment">// 上层取消/无预算，或本次尝试已超时，检查总 ctx</span></span><br><span class="line">            <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.Err()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 退避前先判断是否还有预算</span></span><br><span class="line">        <span class="keyword">if</span> deadline, ok := ctx.Deadline(); ok &amp;&amp; time.Now().Add(backoff).After(deadline) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no time to retry: %w&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := Sleep(ctx, backoff); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        <span class="keyword">if</span> backoff &lt; <span class="number">2</span>*time.Second &#123; backoff *= <span class="number">2</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><strong>单次尝试</strong>设置小超时；<strong>总预算</strong>由外层 <code>ctx</code> 保证。</li>
<li>退避用 <code>Sleep(ctx, …)</code>，可随时被取消。</li>
<li>返回错误时保留 <strong>原始原因</strong>（可配合 <code>WithCancelCause</code>，见 §9）。</li>
</ul>
<hr>
<h1 id="5-数据库事务（BeginTx）与上下文传播">5) 数据库事务（<code>BeginTx</code>）与上下文传播</h1>
<h2 id="场景-5">场景</h2>
<ul>
<li>事务内多次读写，任何一步失败或取消都要回滚。</li>
</ul>
<h2 id="代码-4">代码</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DAO)</span></span> Transfer(ctx context.Context, from, to <span class="type">int64</span>, amt <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    tx, err := d.DB.BeginTx(ctx, &amp;sql.TxOptions&#123;Isolation: sql.LevelSerializable&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = tx.Rollback() &#125;() <span class="comment">// 安全回滚，成功时由 Commit 覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err := tx.ExecContext(ctx, <span class="string">&quot;UPDATE acct SET bal=bal-? WHERE id=?&quot;</span>, amt, from); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := tx.ExecContext(ctx, <span class="string">&quot;UPDATE acct SET bal=bal+? WHERE id=?&quot;</span>, amt, to); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><code>BeginTx</code> 用传入的 <code>ctx</code>，<strong>整个事务</strong>共享预算。</li>
<li><code>defer Rollback()</code> + 最后 <code>Commit()</code> 是惯用对。</li>
<li>发生取消/超时时，驱动应中断阻塞的等待（依赖具体 driver 实现）。</li>
</ul>
<hr>
<h1 id="6-gRPC（服务端-客户端）与元数据">6) gRPC（服务端/客户端）与元数据</h1>
<h2 id="场景-6">场景</h2>
<ul>
<li>gRPC 天生携带 <code>context</code>；中间件读取/注入 trace、auth。</li>
</ul>
<h2 id="代码（客户端）">代码（客户端）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">800</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">md := metadata.Pairs(<span class="string">&quot;x-trace-id&quot;</span>, <span class="string">&quot;abc-123&quot;</span>)</span><br><span class="line">ctx = metadata.NewOutgoingContext(ctx, md)</span><br><span class="line"></span><br><span class="line">resp, err := client.GetUser(ctx, &amp;pb.GetUserRequest&#123;Id: <span class="string">&quot;u123&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><strong>把 HTTP 入站的 ctx</strong> 原封不动传给 gRPC 出站，保证链路一致。</li>
<li>服务器端可在 interceptor 中读取 metadata 并写入 logger/trace。</li>
</ul>
<hr>
<h1 id="7-CLI-批处理：Ctrl-C-取消-子任务清理">7) CLI / 批处理：Ctrl+C 取消 + 子任务清理</h1>
<h2 id="场景-7">场景</h2>
<ul>
<li>命令行工具长时间运行，用户 Ctrl+C 或系统发信号时<strong>全局取消</strong>。</li>
</ul>
<h2 id="代码-5">代码</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">defer</span> stop()</span><br><span class="line">    <span class="keyword">if</span> err := run(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    g, ctx := errgroup.WithContext(ctx)</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> taskA(ctx) &#125;)</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> taskB(ctx) &#125;)</span><br><span class="line">    <span class="keyword">return</span> g.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><code>signal.NotifyContext</code> 是最简范式。</li>
<li>子任务<strong>必须</strong>遵循 <code>ctx</code>，否则无法“干净退出”。</li>
</ul>
<hr>
<h1 id="8-中间件：统一注入-读取-Value，但克制使用">8) 中间件：统一注入/读取 <code>Value</code>，但克制使用</h1>
<h2 id="场景-8">场景</h2>
<ul>
<li>在 middleware 中解析鉴权、构造 logger/traceID，并把<strong>小型只读</strong>信息放到 <code>ctx</code>。</li>
</ul>
<h2 id="代码（示意）">代码（示意）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InjectMetadata</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        ctx := r.Context()</span><br><span class="line">        <span class="keyword">if</span> rid := r.Header.Get(<span class="string">&quot;X-Request-ID&quot;</span>); rid != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            ctx = keys.WithTraceID(ctx, rid)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放轻量字段即可；logger 客体建议用依赖注入传参，不要塞进 ctx</span></span><br><span class="line">        next.ServeHTTP(w, r.WithContext(ctx))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><strong>不要</strong>把可变大对象/配置/连接句柄塞 <code>ctx</code>。</li>
<li><code>Value</code> 仅用于<strong>跨接口传递小元数据</strong>；更复杂的依赖用构造函数/DI 注入。</li>
</ul>
<hr>
<h1 id="9-进阶：携带“取消原因”（Go-1-20-）">9) 进阶：携带“取消原因”（Go 1.20+）</h1>
<h2 id="场景-9">场景</h2>
<ul>
<li>希望上游知道“是谁/为什么取消”的更具体原因（比如熔断、限流）。</li>
</ul>
<h2 id="代码-6">代码</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithCancelCause(parent)</span><br><span class="line"><span class="keyword">defer</span> cancel(<span class="literal">nil</span>) <span class="comment">// 正常结束时传 nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某处触发</span></span><br><span class="line">cancel(fmt.Errorf(<span class="string">&quot;rate limited by token bucket&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上游读取</span></span><br><span class="line"><span class="keyword">if</span> cause := context.Cause(ctx); cause != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 更细粒度记录：cause.Error()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><code>WithCancelCause</code> + <code>context.Cause(ctx)</code> 可精准定位来源。</li>
<li>仅在<strong>链路诊断</strong>确实需要时使用，避免过度复杂化。</li>
</ul>
<hr>
<h1 id="10-常见坑位对照表">10) 常见坑位对照表</h1>
<table>
<thead>
<tr>
<th>场景</th>
<th>错误做法</th>
<th>正确做法</th>
</tr>
</thead>
<tbody>
<tr>
<td>循环里派生 <code>WithTimeout</code></td>
<td><code>defer cancel()</code>（在循环里堆积）</td>
<td><code>cancel()</code> 放到每轮末尾立即调用</td>
</tr>
<tr>
<td>只 <code>time.After()</code> 等待</td>
<td>上层取消时还在“傻等”</td>
<td>用 <code>select &#123; case &lt;-t.C: …; case &lt;-ctx.Done(): … &#125;</code></td>
</tr>
<tr>
<td>在库里随意设置超时</td>
<td>与上层预算冲突</td>
<td>入口统一预算；库层最多<strong>缩短</strong>预算</td>
</tr>
<tr>
<td>传 <code>nil</code> context</td>
<td>下游 panic</td>
<td>没有就 <code>context.Background()</code>/<code>TODO()</code></td>
</tr>
<tr>
<td><code>Value</code> 传大对象/配置</td>
<td>变成“万能垃圾袋”</td>
<td>仅传小型只读元信息，依赖显式注入</td>
</tr>
<tr>
<td>想“立刻终止”协程</td>
<td>误解取消为抢占式</td>
<td>在阻塞点检查 <code>ctx.Done()</code> 自己退出</td>
</tr>
<tr>
<td>忘记 <code>timer/ticker.Stop()</code></td>
<td>goroutine/资源泄漏</td>
<td><code>defer t.Stop()</code>/<code>defer tk.Stop()</code></td>
</tr>
<tr>
<td>事务里没用 <code>*Context</code> 方法</td>
<td>取消不生效</td>
<td><code>BeginTx/ExecContext/QueryContext</code> 全用带 Context 版本</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="11-可直接复用的小工具">11) 可直接复用的小工具</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 剩余预算检测：不足 min 时直接失败</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EnsureBudget</span><span class="params">(ctx context.Context, min time.Duration)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl, ok := ctx.Deadline(); ok &amp;&amp; time.Until(dl) &lt; min &#123;</span><br><span class="line">        <span class="keyword">return</span> context.DeadlineExceeded</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在父 ctx 基础上“缩短”预算（如果父没有截止，则设置）：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tighten</span><span class="params">(ctx context.Context, d time.Duration)</span></span> (context.Context, context.CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> dl, ok := ctx.Deadline(); ok &#123;</span><br><span class="line">        <span class="comment">// 已有截止：取更早者</span></span><br><span class="line">        <span class="keyword">if</span> now := time.Now(); dl.Sub(now) &lt; d &#123; <span class="comment">// 父更短</span></span><br><span class="line">            <span class="comment">// 不再额外创建，返回 no-op cancel</span></span><br><span class="line">            <span class="keyword">return</span> ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context.WithTimeout(ctx, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="12-在你的三层项目里落地的“配方清单”">12) 在你的三层项目里落地的“配方清单”</h1>
<ul>
<li><strong>handler</strong>：统一 <code>WithTimeout</code>（例如 2s）；在入站中间件注入 traceID/userID；<strong>不再额外加更长超时</strong>。</li>
<li><strong>service</strong>：并发：用 <code>errgroup.WithContext</code>；重试：<code>CallWithRetry</code>；任何阻塞点 <code>select ctx.Done()</code>；必要时 <code>Tighten</code> 缩短。</li>
<li><strong>dao</strong>：全部 <code>*Context</code> API；事务 <code>BeginTx</code> + <code>ExecContext/QueryContext</code>；错误上抛，不混淆 <code>context.Canceled/DeadlineExceeded</code>。</li>
<li><strong>全局</strong>：<code>signal.NotifyContext</code> 做优雅停机；日志里输出 <code>traceID</code>（从 <code>ctx</code> 读）。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之Zap实战教程</title>
    <url>/2025/09/05/Go%E8%AF%AD%E8%A8%80%E4%B9%8BZap%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-应用中的-Zap-日志框架实战：Gin-Viper-Wire">Go 应用中的 Zap 日志框架实战：Gin + Viper + Wire</h1>
<p>在现代 Go Web 应用开发中，日志系统是不可或缺的一环。一个设计良好、功能强大的日志框架不仅能帮助我们快速定位和解决问题，还能在生产环境中提供关键的监控数据。</p>
<p>我们将分步解析一个实际的项目案例，从日志库的封装、配置管理、依赖注入，到 Gin 中间件的应用，让你全面掌握 Zap 在生产环境中的最佳实践。</p>
<h2 id="1-核心设计理念">1. 核心设计理念</h2>
<p>在开始编码之前，我们先明确本次日志框架的核心设计目标：</p>
<ul>
<li><strong>封装与解耦</strong>：将 Zap 的初始化和配置逻辑封装在一个独立的包中，使其与其他业务逻辑解耦。</li>
<li><strong>集中式配置</strong>：通过 Viper 从外部配置文件（<code>config.yaml</code>）加载所有日志配置，便于管理和修改。</li>
<li><strong>依赖注入</strong>：利用 Google Wire 实现日志实例的依赖注入，确保 Logger 在应用生命周期中只被初始化一次，并能在任何需要的地方方便地获取和使用。</li>
<li><strong>多输出与格式化</strong>：支持同时将日志输出到文件和控制台，并根据环境（开发/生产）选择不同的日志格式（彩色/JSON）。</li>
<li><strong>安全与健壮</strong>：利用 <code>lumberjack</code> 实现日志文件的自动切割、压缩和清理，防止日志文件无限增长。</li>
</ul>
<h2 id="2-日志库封装：pkg-logger-logger-go">2. 日志库封装：<code>pkg/logger/logger.go</code></h2>
<p><code>logger.go</code> 是整个日志系统的核心，它负责封装 Zap 的初始化逻辑，并对外提供简单易用的日志函数。</p>
<h3 id="代码解析">代码解析</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局日志实例：公共</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Logger *zap.Logger</span><br><span class="line">	Sugar  *zap.SugaredLogger</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Config 日志配置</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ... (省略配置结构体定义)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line"><span class="keyword">var</span> defaultConfig = Config&#123;</span><br><span class="line">	<span class="comment">// ... (省略默认配置)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLogger 是一个依赖注入函数，返回Logger实例，用于wire依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">(config *configs.Config)</span></span> *zap.Logger &#123;</span><br><span class="line">	<span class="comment">// 将从Viper加载的配置转换为logger包的配置格式</span></span><br><span class="line">	loggerConfig := &amp;Config&#123;</span><br><span class="line">		Level:       config.Logger.Level,</span><br><span class="line">		FilePath:    config.Logger.FilePath,</span><br><span class="line">		Console:     config.Logger.Console,</span><br><span class="line">		Development: config.Logger.Development,</span><br><span class="line">		MaxSize:     config.Logger.MaxSize,</span><br><span class="line">		MaxAge:      config.Logger.MaxAge,</span><br><span class="line">		MaxBackups:  config.Logger.MaxBackups,</span><br><span class="line">		Compress:    config.Logger.Compress,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化日志</span></span><br><span class="line">	err := Init(loggerConfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 初始化失败时使用默认配置再次尝试，确保应用能正常启动</span></span><br><span class="line">		log.Printf(<span class="string">&quot;Failed to initialize logger with config: %v, using default config&quot;</span>, err)</span><br><span class="line">		Init(<span class="literal">nil</span>) <span class="comment">// 使用默认配置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(cfg *Config)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cfg == <span class="literal">nil</span> &#123;</span><br><span class="line">		cfg = &amp;defaultConfig</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保日志目录存在</span></span><br><span class="line">	logDir := filepath.Dir(cfg.FilePath)</span><br><span class="line">	<span class="keyword">if</span> err := os.MkdirAll(logDir, <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;创建日志目录失败: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析日志级别</span></span><br><span class="line">	level := getLogLevel(cfg.Level)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建编码器配置</span></span><br><span class="line">	encoderConfig := getEncoderConfig(cfg.Development)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建Core，Zap的核心接口，用于组合不同的输出</span></span><br><span class="line">	<span class="keyword">var</span> cores []zapcore.Core</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 文件输出</span></span><br><span class="line">	fileWriter := getFileWriter(cfg)</span><br><span class="line">	fileCore := zapcore.NewCore(</span><br><span class="line">		zapcore.NewJSONEncoder(encoderConfig), <span class="comment">// 使用JSON格式编码</span></span><br><span class="line">		zapcore.AddSync(fileWriter),</span><br><span class="line">		level,</span><br><span class="line">	)</span><br><span class="line">	cores = <span class="built_in">append</span>(cores, fileCore)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制台输出</span></span><br><span class="line">	<span class="keyword">if</span> cfg.Console &#123;</span><br><span class="line">		consoleEncoder := zapcore.NewConsoleEncoder(encoderConfig)</span><br><span class="line">		consoleCore := zapcore.NewCore(</span><br><span class="line">			consoleEncoder,</span><br><span class="line">			zapcore.AddSync(os.Stdout),</span><br><span class="line">			level,</span><br><span class="line">		)</span><br><span class="line">		cores = <span class="built_in">append</span>(cores, consoleCore)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用zapcore.NewTee组合多个Core，实现多输出</span></span><br><span class="line">	core := zapcore.NewTee(cores...)</span><br><span class="line">	Logger = zap.New(core, getOptions(cfg.Development)...)</span><br><span class="line">	<span class="comment">// 创建SugaredLogger，提供更友好的格式化日志函数</span></span><br><span class="line">	Sugar = Logger.Sugar()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 替换全局Logger，方便在任何地方直接使用zap.L()</span></span><br><span class="line">	zap.ReplaceGlobals(Logger)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getLogLevel 获取日志级别</span></span><br><span class="line"><span class="comment">// ... (省略代码)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getEncoderConfig 获取编码器配置</span></span><br><span class="line"><span class="comment">// 根据Development模式决定日志格式</span></span><br><span class="line"><span class="comment">// ... (省略代码)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// timeEncoder 自定义时间编码器</span></span><br><span class="line"><span class="comment">// ... (省略代码)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFileWriter 获取文件写入器</span></span><br><span class="line"><span class="comment">// 结合lumberjack实现日志文件自动切割</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileWriter</span><span class="params">(cfg *Config)</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">	lumberJackLogger := &amp;lumberjack.Logger&#123;</span><br><span class="line">		Filename:   cfg.FilePath,</span><br><span class="line">		MaxSize:    cfg.MaxSize,</span><br><span class="line">		MaxBackups: cfg.MaxBackups,</span><br><span class="line">		MaxAge:     cfg.MaxAge,</span><br><span class="line">		Compress:   cfg.Compress,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> zapcore.AddSync(lumberJackLogger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getOptions 获取日志选项</span></span><br><span class="line"><span class="comment">// 添加调用者信息和跳过层级，确保日志能正确显示调用位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOptions</span><span class="params">(development <span class="type">bool</span>)</span></span> []zap.Option &#123;</span><br><span class="line">	options := []zap.Option&#123;</span><br><span class="line">		zap.AddCaller(),      <span class="comment">// 记录调用文件和行号</span></span><br><span class="line">		zap.AddCallerSkip(<span class="number">1</span>), <span class="comment">// 跳过封装函数，显示调用方的真实位置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> development &#123;</span><br><span class="line">		options = <span class="built_in">append</span>(options, zap.Development())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Debug, Info, Warn, Error ...</span></span><br><span class="line"><span class="comment">// 对外封装的日志函数，方便直接调用</span></span><br><span class="line"><span class="comment">// ... (省略代码)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync 同步日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sync</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Logger.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点解析：</strong></p>
<ol>
<li><strong><code>NewLogger</code> 函数</strong>：这个函数是专为 <strong>Google Wire</strong> 设计的。它接受一个配置对象，进行日志初始化，并返回一个 <code>*zap.Logger</code> 实例。Wire 会识别这个函数并将其作为依赖提供者。</li>
<li><strong><code>Init</code> 函数</strong>：这是真正的日志初始化入口。它处理了配置的转换、日志目录的创建、Zap <code>Core</code> 的构建，以及最终 <code>Logger</code> 和 <code>SugaredLogger</code> 的创建。</li>
<li><strong>多 Core 合并</strong>：<code>zapcore.NewTee</code> 是一个非常强大的功能。它允许我们将多个 <code>Core</code> 组合在一起，实现同时输出到多个目的地，如文件（<code>fileCore</code>）和控制台（<code>consoleCore</code>）。</li>
<li><strong><code>lumberjack</code> 集成</strong>：通过 <code>lumberjack.Logger</code>，我们无需自己编写复杂的日志切割逻辑。它会自动处理日志文件的轮转、压缩和清理，大大简化了文件日志的管理。</li>
<li><strong>自定义封装函数</strong>：提供 <code>Info</code>、<code>Errorf</code> 等一系列封装函数，让业务代码无需直接与 <code>zap.Logger</code> 或 <code>zap.SugaredLogger</code> 实例打交道，保持 API 的一致性。</li>
</ol>
<h2 id="3-配置管理：config-yaml-和-configs-config-go">3. 配置管理：<code>config.yaml</code> 和 <code>configs/config.go</code></h2>
<p>通过 <strong>Viper</strong> 从配置文件加载配置，是实现日志系统灵活性的关键。</p>
<h3 id="config-yaml"><code>config.yaml</code></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logger:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">&quot;info&quot;</span></span><br><span class="line">  <span class="attr">file_path:</span> <span class="string">&quot;logs/nexus.log&quot;</span></span><br><span class="line">  <span class="attr">console:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">development:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">max_size:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">max_age:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">max_backups:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">compress:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>这份配置清晰地定义了日志的各项参数，业务开发人员可以根据环境轻松调整。</p>
<h3 id="configs-config-go"><code>configs/config.go</code></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> configs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/fsnotify/fsnotify&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Config 包含了应用的所有配置</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ... (其他配置)</span></span><br><span class="line">	Logger LoggerConfig <span class="string">`mapstructure:&quot;logger&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoggerConfig 定义了日志配置</span></span><br><span class="line"><span class="keyword">type</span> LoggerConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ... (日志配置结构体定义)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadConfig 用于Wire依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConfig</span><span class="params">()</span></span> (*Config, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// ... (加载配置逻辑)</span></span><br><span class="line">	workDir, err := os.Getwd()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">	viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">	viper.AddConfigPath(workDir)</span><br><span class="line"></span><br><span class="line">	err = viper.ReadInConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> config Config</span><br><span class="line">	err = viper.Unmarshal(&amp;config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监视配置文件变化，实现热更新</span></span><br><span class="line">	viper.WatchConfig()</span><br><span class="line">	viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Config file changed:&quot;</span>, e.Name)</span><br><span class="line">		<span class="keyword">if</span> err := viper.Unmarshal(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;viper.Unmarshal on config change failed, err: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;Configuration loaded successfully!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> &amp;config, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点解析：</strong></p>
<ul>
<li><strong><code>mapstructure</code> 标签</strong>：通过 <code>mapstructure</code> 标签，Viper 能够将配置文件中的 <code>logger</code> 部分正确映射到 <code>LoggerConfig</code> 结构体中。</li>
<li><strong><code>LoadConfig</code> 函数</strong>：同样是为 Google Wire 准备的依赖提供者。它负责从 <code>config.yaml</code> 加载并解析配置，返回一个配置实例。</li>
</ul>
<h2 id="4-依赖注入：cmd-wire-go-和-cmd-main-go">4. 依赖注入：<code>cmd/wire.go</code> 和 <code>cmd/main.go</code></h2>
<p><strong>Google Wire</strong> 在这里扮演了“胶水”的角色，它将配置、日志等各个模块连接在一起，构建出最终的应用实例。</p>
<h3 id="cmd-wire-go"><code>cmd/wire.go</code></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:build wireinject</span></span><br><span class="line"><span class="comment">// +build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (导入包)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ... (应用结构体)</span></span><br><span class="line">	Logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewApp 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	// ... (其他参数)</span></span></span><br><span class="line">	logger *zap.Logger,</span><br><span class="line">) *App &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;App&#123;</span><br><span class="line">		<span class="comment">// ... (初始化)</span></span><br><span class="line">		Logger: logger,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wire Provider Set</span></span><br><span class="line"><span class="keyword">var</span> ProviderSet = wire.NewSet(</span><br><span class="line">	<span class="comment">// ... (其他依赖)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Config</span></span><br><span class="line">	configs.LoadConfig,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Logger</span></span><br><span class="line">	logger.NewLogger,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// App</span></span><br><span class="line">	NewApp,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeApp</span><span class="params">()</span></span> (*App, <span class="type">error</span>) &#123;</span><br><span class="line">	wire.Build(ProviderSet)</span><br><span class="line">	<span class="keyword">return</span> &amp;App&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点解析：</strong></p>
<ul>
<li><strong><code>ProviderSet</code></strong>：这是 Wire 的核心。我们将 <code>configs.LoadConfig</code> 和 <code>logger.NewLogger</code> 都添加到集合中。</li>
<li><strong><code>wire.Build</code></strong>：当 Wire 运行时，它会分析 <code>NewApp</code> 的依赖（需要 <code>*configs.Config</code> 和 <code>*zap.Logger</code>），然后从 <code>ProviderSet</code> 中找到对应的提供者 (<code>LoadConfig</code> 和 <code>NewLogger</code>)，自动生成代码来构建 <code>App</code> 实例。</li>
</ul>
<h3 id="cmd-main-go"><code>cmd/main.go</code></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (导入包)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过Wire初始化整个应用</span></span><br><span class="line">	app, err := InitializeApp()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Failed to initialize app: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保日志在程序退出时正确同步</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := logger.Sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Failed to sync logger: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动Web服务</span></span><br><span class="line">	router := app.Router.SetupRouter()</span><br><span class="line">	logger.Info(<span class="string">&quot;Server starting&quot;</span>, zap.Int(<span class="string">&quot;port&quot;</span>, app.Config.Server.Port))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (优雅关闭逻辑)</span></span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-quit</span><br><span class="line">	logger.Info(<span class="string">&quot;Shutting down server...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点解析：</strong></p>
<ul>
<li><strong><code>InitializeApp()</code></strong>：在主函数中，我们只需要调用这个函数，即可获得一个完全初始化好的 <code>App</code> 实例，其中包含了配置和日志实例。</li>
<li><strong><code>defer logger.Sync()</code></strong>：在程序退出前调用 <code>Sync()</code> 是一个好习惯。它会确保所有缓冲的日志都写入磁盘，防止日志丢失。</li>
</ul>
<h2 id="5-Gin-中间件：internal-middleware-logger-go">5. Gin 中间件：<code>internal/middleware/logger.go</code></h2>
<p>在 Gin 中，我们可以创建两个中间件来处理日志和错误恢复，这极大地增强了应用的健壮性。</p>
<h3 id="代码解析-2">代码解析</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (导入包)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZapLogger 是基于zap的日志中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZapLogger</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		path := c.Request.URL.Path</span><br><span class="line">		query := c.Request.URL.RawQuery</span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		end := time.Now()</span><br><span class="line">		latency := end.Sub(start)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.Errors) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 记录包含错误的请求</span></span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> c.Errors.Errors() &#123;</span><br><span class="line">				logger.Error(e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 记录正常的请求</span></span><br><span class="line">			logger.Info(<span class="string">&quot;Request&quot;</span>,</span><br><span class="line">				zap.Int(<span class="string">&quot;status&quot;</span>, c.Writer.Status()),</span><br><span class="line">				zap.String(<span class="string">&quot;method&quot;</span>, c.Request.Method),</span><br><span class="line">				zap.String(<span class="string">&quot;path&quot;</span>, path),</span><br><span class="line">				zap.String(<span class="string">&quot;query&quot;</span>, query),</span><br><span class="line">				zap.String(<span class="string">&quot;ip&quot;</span>, c.ClientIP()),</span><br><span class="line">				zap.String(<span class="string">&quot;user-agent&quot;</span>, c.Request.UserAgent()),</span><br><span class="line">				zap.Duration(<span class="string">&quot;latency&quot;</span>, latency),</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZapRecovery 是基于zap的恢复中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZapRecovery</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 记录堆栈信息</span></span><br><span class="line">				logger.Error(<span class="string">&quot;Panic recovered&quot;</span>,</span><br><span class="line">					zap.Any(<span class="string">&quot;error&quot;</span>, err),</span><br><span class="line">					zap.String(<span class="string">&quot;request&quot;</span>, c.Request.URL.Path),</span><br><span class="line">				)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 返回500响应</span></span><br><span class="line">				c.AbortWithStatus(<span class="number">500</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点解析：</strong></p>
<ol>
<li><strong><code>ZapLogger</code></strong>：该中间件在请求处理前后记录关键信息，如 HTTP 方法、路径、状态码、延迟等。通过 <code>c.Errors</code> 判断请求是否出错，并记录错误日志。</li>
<li><strong><code>ZapRecovery</code></strong>：这是 Gin 官方 <code>Recovery</code> 中间件的 Zap 版本。它使用 <code>recover()</code> 捕获 <code>panic</code>，记录详细的错误日志（包括堆栈信息），并返回 500 状态码，避免应用崩溃。</li>
</ol>
<h2 id="6-注册到路由：internal-router-router-go">6. 注册到路由：<code>internal/router/router.go</code></h2>
<p>最后，将中间件注册到 Gin 路由中，使其对所有请求生效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.New()</span><br><span class="line">r.Use(router.middlewareManager.ErrorHandler(),</span><br><span class="line">	router.middlewareManager.CORSMiddleware(),</span><br><span class="line">	router.middlewareManager.Logger(),</span><br><span class="line">	router.middlewareManager.Recovery())</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们确保了每个请求都经过日志和恢复中间件的处理，为整个应用提供了统一、健壮的日志和错误处理能力。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之new关键字</title>
    <url>/2025/07/06/Go%E8%AF%AD%E8%A8%80%E4%B9%8Bnew%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Go 语言中，内存分配主要有两种方式：一种是使用内建函数 <code>new</code>，另一种是使用复合字面量（如结构体字面量）或者 <code>make</code>。相比之下，<code>new</code> 看起来不常用，甚至被一些初学者误解为“类似 C++ 的 new”。</p>
<span id="more"></span>
<h1 id="Go-语言中的-new-关键字详解与最佳实践">Go 语言中的 <code>new</code> 关键字详解与最佳实践</h1>
<h2 id="一、new-的基本语法">一、<code>new</code> 的基本语法</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ptr := <span class="built_in">new</span>(Type)</span><br></pre></td></tr></table></figure>
<h3 id="说明：">说明：</h3>
<ul>
<li><code>Type</code> 是任意类型（如结构体、数组、基本类型等）。</li>
<li><code>new(Type)</code> 会分配一块内存来存储一个 <code>Type</code> 类型的零值，并返回一个指向该内存的指针。</li>
<li>返回值类型为 <code>*Type</code>。</li>
</ul>
<h3 id="示例：">示例：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    fmt.Println(*x) <span class="comment">// 输出 0，因为是 int 类型的零值</span></span><br><span class="line">    *x = <span class="number">42</span></span><br><span class="line">    fmt.Println(*x) <span class="comment">// 输出 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、new-与复合字面量的区别">二、<code>new</code> 与复合字面量的区别</h2>
<p>Go 中更常见的写法其实是结构体的复合字面量，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u1 := <span class="built_in">new</span>(User)           <span class="comment">// 返回 *User，字段是零值</span></span><br><span class="line">u2 := &amp;User&#123;&#125;             <span class="comment">// 返回 *User，字段是零值（更常用）</span></span><br><span class="line">u3 := &amp;User&#123;Name: <span class="string">&quot;Tom&quot;</span>&#125;  <span class="comment">// 返回 *User，指定字段初始化</span></span><br></pre></td></tr></table></figure>
<p><code>new(User)</code> 和 <code>&amp;User&#123;&#125;</code> 在结果上是一样的，都是分配内存并返回指针，但后者更直观、灵活，并且在实际代码中更具可读性。</p>
<hr>
<h2 id="三、使用-new-的典型场景">三、使用 <code>new</code> 的典型场景</h2>
<p>虽然 Go 的编码风格更倾向于使用复合字面量，但 <code>new</code> 并不是没有价值的，以下是一些适合使用 <code>new</code> 的场景：</p>
<h3 id="1-简洁地分配基本类型指针">1. 简洁地分配基本类型指针</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">bool</span>)  <span class="comment">// 分配一个布尔变量并返回指针</span></span><br><span class="line">*q := <span class="built_in">new</span>(<span class="type">float64</span>)</span><br></pre></td></tr></table></figure>
<p>适合用于需要修改值并传递指针的场景，如状态标志、配置项等。</p>
<h3 id="2-用于通用函数返回指针">2. 用于通用函数返回指针</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewZero</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">()</span></span> *T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在泛型中，<code>new</code> 是一个非常通用的方式，用于为任意类型分配零值内存。</p>
<hr>
<h2 id="四、不推荐使用-new-的场景">四、不推荐使用 <code>new</code> 的场景</h2>
<h3 id="❌-不建议用于结构体初始化：">❌ 不建议用于结构体初始化：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line">p := &amp;Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">30</span>&#125; <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure>
<p>使用复合字面量初始化更清晰直观，尤其是当需要初始化字段时。</p>
<hr>
<h2 id="五、最佳实践建议">五、最佳实践建议</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本类型需要指针</td>
<td><code>new(int)</code></td>
<td>简洁、语义明确</td>
</tr>
<tr>
<td>结构体初始化</td>
<td><code>&amp;Struct&#123;&#125;</code></td>
<td>更清晰，方便指定字段值</td>
</tr>
<tr>
<td>泛型函数中初始化任意类型</td>
<td><code>new(T)</code></td>
<td>泛型中几乎是唯一方式</td>
</tr>
<tr>
<td>与 <code>make</code> 混淆的情况</td>
<td>避免使用 <code>new</code></td>
<td><code>make</code> 主要用于 slice、map、chan</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="六、new-vs-make">六、<code>new</code> vs <code>make</code></h2>
<table>
<thead>
<tr>
<th>特点</th>
<th><code>new</code></th>
<th><code>make</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值</td>
<td>指向类型的指针 <code>*T</code></td>
<td>初始化好的类型值（非指针）</td>
</tr>
<tr>
<td>适用类型</td>
<td>所有类型</td>
<td>仅限 slice、map、chan</td>
</tr>
<tr>
<td>初始化行为</td>
<td>零值初始化</td>
<td>返回可用实例（如具有长度的 slice）</td>
</tr>
</tbody>
</table>
<h3 id="示例：-2">示例：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">new</span>([]<span class="type">int</span>)   <span class="comment">// *[]int，指向一个 nil 的 slice</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">// []int，已经有长度为 5 的可用 slice</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="七、总结">七、总结</h2>
<ul>
<li><code>new</code> 是 Go 的内建函数，用于分配一块零值内存并返回指针。</li>
<li>对于基本类型或泛型，<code>new</code> 是一个便捷且清晰的选择。</li>
<li>在结构体初始化时，更推荐使用 <code>&amp;T&#123;&#125;</code> 风格。</li>
<li>不要将 <code>new</code> 与 <code>make</code> 混淆，它们服务于完全不同的目的。</li>
</ul>
<hr>
<h2 id="八、参考示例项目">八、参考示例项目</h2>
<p>一个真实的小项目中，如果你需要传入一个状态布尔指针，可以这样使用 <code>new</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitFeature</span><span class="params">(enabled *<span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> enabled != <span class="literal">nil</span> &amp;&amp; *enabled &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Feature enabled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag := <span class="built_in">new</span>(<span class="type">bool</span>)</span><br><span class="line">    *flag = <span class="literal">true</span></span><br><span class="line">    InitFeature(flag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法避免了引入多余的布尔变量，同时又保留了指针语义。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之nunu学习记录</title>
    <url>/2025/08/29/Go%E8%AF%AD%E8%A8%80%E4%B9%8Bnunu%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关键知识点系统整理成 9 个章节：<strong>cobra、survey、wire、模板 + embed、context、filepath、signal、fsnotify、常见 syscall</strong></p>
<hr>
<h2 id="目录">目录</h2>
<ol>
<li><a href="#cobra">Cobra：命令行框架与命令树</a></li>
<li><a href="#survey">Survey：交互式问答（选择/输入/校验）</a></li>
<li><a href="#wire">Wire：依赖注入与对象装配</a></li>
<li><a href="#embed">模板 + embed：把模板打包进二进制并生成文件</a></li>
<li><a href="#context">Context：取消、超时与并发协作</a></li>
<li><a href="#filepath">filepath：跨平台路径与文件遍历</a></li>
<li><a href="#signal">signal：优雅退出与中断处理</a></li>
<li><a href="#fsnotify">fsnotify：文件变更监听与热更新</a></li>
<li><a href="#syscall">常见 syscall：低层能力与高层替代建议</a></li>
</ol>
<hr>
<p><a id="cobra"></a></p>
<h2 id="1-Cobra：命令行框架与命令树">1. Cobra：命令行框架与命令树</h2>
<p><strong>它是啥</strong>：<code>spf13/cobra</code> 是 Go 里最常用的 CLI 框架，支持子命令、旗标（flags）、自动补全、帮助文档等。典型结构是一个 <code>root</code> 根命令挂一串子命令（<code>new</code>, <code>init</code>, <code>build</code>, <code>dev</code> 等）。</p>
<p><strong>脚手架中的用途</strong>：</p>
<ul>
<li><code>root</code>：显示版本/全局 flags（例如 <code>--verbose</code>, <code>--config</code>）。</li>
<li>子命令：
<ul>
<li><code>new</code>/<code>init</code>：交互式生成项目骨架（结合 survey + embed 模板）。</li>
<li><code>dev</code>：本地开发（结合 fsnotify 监听变化、signal 优雅退出）。</li>
<li><code>build</code>：打包产物（结合 context 控时与并发）。</li>
</ul>
</li>
</ul>
<h3 id="快速上手目录结构">快速上手目录结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mycli/</span><br><span class="line">  cmd/</span><br><span class="line">    root.go</span><br><span class="line">    new.go</span><br><span class="line">  internal/</span><br><span class="line">    generator/</span><br><span class="line">      generator.go</span><br><span class="line">  main.go</span><br><span class="line">  go.mod</span><br></pre></td></tr></table></figure>
<h3 id="代码示例">代码示例</h3>
<p><strong>main.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;mycli/cmd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; cmd.Execute() &#125;</span><br></pre></td></tr></table></figure>
<p><strong>cmd/root.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    cfgFile <span class="type">string</span></span><br><span class="line">    verbose <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">&quot;mycli&quot;</span>,</span><br><span class="line">    Short: <span class="string">&quot;A modern project scaffolding CLI&quot;</span>,</span><br><span class="line">    Long:  <span class="string">`mycli 是一个用于快速生成 Go 项目骨架的 CLI 工具。`</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123; _ = rootCmd.Execute() &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rootCmd.PersistentFlags().StringVarP(&amp;cfgFile, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;配置文件路径&quot;</span>)</span><br><span class="line">    rootCmd.PersistentFlags().BoolVarP(&amp;verbose, <span class="string">&quot;verbose&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;输出更多日志&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cmd/new.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> projectName <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">&quot;new&quot;</span>,</span><br><span class="line">    Short: <span class="string">&quot;创建新项目&quot;</span>,</span><br><span class="line">    RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="comment">// 给每个子命令一个可取消的 context</span></span><br><span class="line">        ctx, cancel := context.WithTimeout(cmd.Context(), <span class="number">30</span>*time.Second)</span><br><span class="line">        <span class="keyword">defer</span> cancel()</span><br><span class="line">        fmt.Println(<span class="string">&quot;✨ 创建项目:&quot;</span>, projectName)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 调用 generator 生成模板</span></span><br><span class="line">        _ = ctx</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rootCmd.AddCommand(newCmd)</span><br><span class="line">    newCmd.Flags().StringVarP(&amp;projectName, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;demo&quot;</span>, <span class="string">&quot;项目名称&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小技巧与坑">小技巧与坑</h3>
<ul>
<li><strong>PersistentFlags vs Flags</strong>：前者对下游子命令可见；后者只对当前命令生效。</li>
<li><strong>命令上下文</strong>：Cobra 1.7+ 支持 <code>cmd.Context()</code>，便于和 <code>context</code> 打通（超时/取消）。</li>
<li><strong>自动补全</strong>：可用 <code>cobra.GenBashCompletion()</code> 等生成脚本。</li>
<li><strong>PreRun/PostRun</strong>：做参数校验/统一的前后置逻辑。</li>
</ul>
<hr>
<p><a id="survey"></a></p>
<h2 id="2-Survey：交互式问答（选择-输入-校验）">2. Survey：交互式问答（选择/输入/校验）</h2>
<p><strong>它是啥</strong>：<code>AlecAivazis/survey/v2</code> 提供人性化的命令行交互组件：输入、单选、多选、编辑器、密码、确认等。</p>
<p><strong>脚手架中的用途</strong>：在 <code>mycli new</code> 时向用户询问模块名、所选框架、是否启用数据库、License 等，再把答案灌入模板。</p>
<h3 id="常用题型与校验">常用题型与校验</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> prompt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    survey <span class="string">&quot;github.com/AlecAivazis/survey/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Answers <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    License <span class="type">string</span></span><br><span class="line">    Features []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ask</span><span class="params">()</span></span> (*Answers, <span class="type">error</span>) &#123;</span><br><span class="line">    a := &amp;Answers&#123;&#125;</span><br><span class="line"></span><br><span class="line">    qName := &amp;survey.Input&#123;Message: <span class="string">&quot;项目名:&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> err := survey.AskOne(qName, &amp;a.Name, survey.WithValidator(survey.Required)); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span>, err &#125;</span><br><span class="line"></span><br><span class="line">    qLicense := &amp;survey.Select&#123;</span><br><span class="line">        Message: <span class="string">&quot;选择 License:&quot;</span>,</span><br><span class="line">        Options: []<span class="type">string</span>&#123;<span class="string">&quot;MIT&quot;</span>, <span class="string">&quot;Apache-2.0&quot;</span>, <span class="string">&quot;GPL-3.0&quot;</span>&#125;,</span><br><span class="line">        Default: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := survey.AskOne(qLicense, &amp;a.License); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span>, err &#125;</span><br><span class="line"></span><br><span class="line">    qFeatures := &amp;survey.MultiSelect&#123;</span><br><span class="line">        Message: <span class="string">&quot;启用特性:&quot;</span>,</span><br><span class="line">        Options: []<span class="type">string</span>&#123;<span class="string">&quot;HTTP API&quot;</span>, <span class="string">&quot;CLI&quot;</span>, <span class="string">&quot;DB(MySQL)&quot;</span>, <span class="string">&quot;Config(viper)&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := survey.AskOne(qFeatures, &amp;a.Features); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span>, err &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&gt; 你的选择：%+v\n&quot;</span>, *a)</span><br><span class="line">    <span class="keyword">return</span> a, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最佳实践</strong></p>
<ul>
<li>使用 <code>survey.WithValidator</code> 做<strong>必填</strong>、正则校验、长度限制等。</li>
<li><code>AskOne</code> 适合单题，<code>survey.Ask</code> 适合集合题并支持 struct tag：<code>survey:&quot;field&quot;</code>。</li>
<li>Windows 终端兼容性较好，但遇到中文输入法问题可回退到基础 <code>fmt</code> 输入。</li>
</ul>
<hr>
<p><a id="wire"></a></p>
<h2 id="3-Wire：依赖注入与对象装配">3. Wire：依赖注入与对象装配</h2>
<p><strong>它是啥</strong>：<code>google/wire</code> 是<strong>编译期</strong>依赖注入工具。通过生成代码把构造函数（providers）组合起来，避免手写装配过程，既类型安全又清晰。</p>
<p><strong>脚手架中的用途</strong>：在 <code>new</code>/<code>build</code> 子命令里，用 Wire 统一装配 <code>Logger</code>、<code>Config</code>、<code>Generator</code>、<code>Renderer</code> 等依赖；让业务代码只关心接口。</p>
<h3 id="基本示例">基本示例</h3>
<p><strong>internal/generator/generator.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123; ProjectName <span class="type">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123; Infof(<span class="type">string</span>, ...any) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SimpleLogger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(SimpleLogger)</span></span> Infof(f <span class="type">string</span>, a ...any) &#123; fmt.Printf(f+<span class="string">&quot;\n&quot;</span>, a...) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务对象</span></span><br><span class="line"> <span class="keyword">type</span> Generator <span class="keyword">struct</span> &#123;</span><br><span class="line">    cfg Config</span><br><span class="line">    log Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfig</span><span class="params">(name <span class="type">string</span>)</span></span> Config &#123; <span class="keyword">return</span> Config&#123;ProjectName: name&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">()</span></span> Logger &#123; <span class="keyword">return</span> SimpleLogger&#123;&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenerator</span><span class="params">(cfg Config, log Logger)</span></span> *Generator &#123; <span class="keyword">return</span> &amp;Generator&#123;cfg: cfg, log: log&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span></span> Run() &#123; g.log.Infof(<span class="string">&quot;generate %s ...&quot;</span>, g.cfg.ProjectName) &#125;</span><br></pre></td></tr></table></figure>
<p><strong>internal/generator/wire.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:build wireinject</span></span><br><span class="line"><span class="comment">// +build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> generator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGenerator</span><span class="params">(projectName <span class="type">string</span>)</span></span> *Generator &#123;</span><br><span class="line">    wire.Build(NewConfig, NewLogger, NewGenerator)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>internal/generator/wire_gen.go</strong>（生成文件，勿手写）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行: go run github.com/google/wire/cmd/wire@latest ./...</span></span><br><span class="line"><span class="comment">// 生成后会出现本文件，里面把 providers 串起来。</span></span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;mycli/internal/generator&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g := generator.InitGenerator(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">    g.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最佳实践与坑</strong></p>
<ul>
<li><code>wire</code> 通过 <code>go:build wireinject</code> 隔离注入入口，生成物落到同目录 <code>wire_gen.go</code>。</li>
<li>Provider 要么是构造函数（<code>func NewX(...) (*X, error)</code>），要么是值/接口绑定（<code>wire.Bind</code>）。</li>
<li>不要在 provider 中做 I/O 副作用，把副作用放到运行时方法里，便于测试。</li>
</ul>
<hr>
<p><a id="embed"></a></p>
<h2 id="4-模板-embed：把模板打包进二进制并生成文件">4. 模板 + embed：把模板打包进二进制并生成文件</h2>
<p><strong>它是啥</strong>：Go 1.16+ 的 <code>embed</code> 允许在编译时把静态资源（模板、脚本、README 等）打到二进制里，无需在用户机器上再下载。结合 <code>text/template</code> 或 <code>tmpl</code> 系统即可渲染生成项目。</p>
<h3 id="目录与代码">目录与代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">templates/</span><br><span class="line">  go.mod.tmpl</span><br><span class="line">  main.go.tmpl</span><br><span class="line">  README.md.tmpl</span><br></pre></td></tr></table></figure>
<p><strong>internal/tpl/tpl.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tpl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;embed&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/fs&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;text/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed templates/*</span></span><br><span class="line"><span class="keyword">var</span> templatesFS embed.FS</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcMap = template.FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;ToLower&quot;</span>: strings.ToLower,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderDir 把 embed 中的模板渲染到目标目录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RenderDir</span><span class="params">(dst <span class="type">string</span>, data any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.WalkDir(templatesFS, <span class="string">&quot;templates&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, d fs.DirEntry, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        <span class="keyword">if</span> d.IsDir() &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        rel, _ := filepath.Rel(<span class="string">&quot;templates&quot;</span>, path)</span><br><span class="line">        <span class="comment">// 去掉 .tmpl 后缀</span></span><br><span class="line">        out := filepath.Join(dst, strings.TrimSuffix(rel, <span class="string">&quot;.tmpl&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err := os.MkdirAll(filepath.Dir(out), <span class="number">0o755</span>); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        b, err := fs.ReadFile(templatesFS, path)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        t, err := template.New(rel).Funcs(funcMap).Parse(<span class="type">string</span>(b))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        f, err := os.OpenFile(out, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0o644</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">        <span class="keyword">if</span> err := t.Execute(f, data); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;+&quot;</span>, out)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 <code>new</code> 命令里调用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data 可以来自 survey 的答案</span></span><br><span class="line">_ = tpl.RenderDir(projectName, <span class="keyword">struct</span>&#123; Name <span class="type">string</span> &#125;&#123;Name: projectName&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>最佳实践</strong></p>
<ul>
<li>模板文件建议以 <code>.tmpl</code> 结尾，避免和真实文件冲突。</li>
<li>注意 Windows 的换行符与可执行权限（用 <code>0o755</code>/<code>0o644</code> 明确文件权限）。</li>
<li>复杂模板建议拆函数：使用 <code>template.FuncMap</code> 自定义方法（如驼峰/蛇形转换）。</li>
</ul>
<hr>
<p><a id="context"></a></p>
<h2 id="5-Context：取消、超时与并发协作">5. Context：取消、超时与并发协作</h2>
<p><strong>它是啥</strong>：<code>context</code> 通过树状的截止时间、取消信号、键值对，在 goroutine 之间传递“<strong>应该停止了</strong>”的信息。</p>
<p>比较麻烦，另外再出文章</p>
<hr>
<p><a id="filepath"></a></p>
<h2 id="6-filepath：跨平台路径与文件遍历">6. filepath：跨平台路径与文件遍历</h2>
<p><strong>它是啥</strong>：标准库 <code>path/filepath</code> 处理<strong>本地文件系统</strong>路径（区分 <code>\</code> 与 <code>/</code>、盘符、符号链接）。</p>
<p><strong>脚手架中的用途</strong>：创建项目目录、相对路径、模板展开、忽略列表等。</p>
<h3 id="常用-API-速查">常用 API 速查</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := filepath.Join(<span class="string">&quot;/home&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;project&quot;</span>) <span class="comment">// 拼接</span></span><br><span class="line">abs, _ := filepath.Abs(<span class="string">&quot;./..&quot;</span>)                     <span class="comment">// 绝对路径</span></span><br><span class="line">rel, _ := filepath.Rel(<span class="string">&quot;/home/user&quot;</span>, <span class="string">&quot;/home/user/project/app&quot;</span>) <span class="comment">// 相对</span></span><br><span class="line">clean := filepath.Clean(<span class="string">&quot;/a/../b//c/&quot;</span>)            <span class="comment">// 规范化</span></span><br><span class="line">match, _ := filepath.Match(<span class="string">&quot;*.go&quot;</span>, <span class="string">&quot;main.go&quot;</span>)     <span class="comment">// 简单匹配</span></span><br><span class="line">files, _ := filepath.Glob(<span class="string">&quot;**/*.tmpl&quot;</span>)            <span class="comment">// 通配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历（优先用 WalkDir，开销更小）</span></span><br><span class="line">filepath.WalkDir(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, d fs.DirEntry, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>符号链接与真实路径</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">real</span>, err := filepath.EvalSymlinks(path)</span><br></pre></td></tr></table></figure>
<p><strong>最佳实践</strong></p>
<ul>
<li>统一使用 <code>filepath</code>（<strong>不是</strong> <code>path</code>）处理本地路径。</li>
<li>用户输入的路径先 <code>Clean</code> 再使用，避免路径穿越。</li>
<li>大型目录遍历时考虑忽略 <code>.git</code>、<code>node_modules</code>、<code>vendor</code> 等目录。</li>
</ul>
<hr>
<p><a id="signal"></a></p>
<h2 id="7-signal：优雅退出与中断处理">7. signal：优雅退出与中断处理</h2>
<p><strong>它是啥</strong>：<code>os/signal</code> 捕获来自操作系统的中断信号（如 Ctrl+C -&gt; <code>SIGINT</code>、<code>SIGTERM</code>），用于<strong>优雅关闭</strong>。</p>
<p><strong>脚手架中的用途</strong>：<code>dev</code> 子命令启动本地进程/服务器时，用户按下 Ctrl+C，停止 watcher、杀子进程并清理临时文件。</p>
<h3 id="典型用法（与-Context-打通）">典型用法（与 Context 打通）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)</span><br><span class="line"><span class="keyword">defer</span> stop()</span><br><span class="line"><span class="keyword">if</span> err := run(ctx); err != <span class="literal">nil</span> &#123; log.Fatal(err) &#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：启动子进程并随信号退出</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    cmd := exec.CommandContext(ctx, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line">    <span class="comment">// 若需要把子进程放入新进程组，便于整组杀死（类 Unix）</span></span><br><span class="line">    <span class="keyword">if</span> runtime.GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">        cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;Setpgid: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">    <span class="comment">// 等待或被 ctx 取消</span></span><br><span class="line">    <span class="keyword">return</span> cmd.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最佳实践</strong></p>
<ul>
<li>用 <code>signal.NotifyContext</code> 替代手动 channel。</li>
<li>若有<strong>多个</strong>后台任务，用 <code>errgroup</code> 收口，任一失败触发取消。</li>
<li>Windows 上信号语义不同（没有 <code>SIGTERM</code>），可退化为 <code>os.Interrupt</code>。</li>
</ul>
<hr>
<p><a id="fsnotify"></a></p>
<h2 id="8-fsnotify：文件变更监听与热更新">8. fsnotify：文件变更监听与热更新</h2>
<p><strong>它是啥</strong>：<code>fsnotify/fsnotify</code> 提供跨平台的文件系统事件监听（Create/Write/Rename/Remove/Chmod）。</p>
<p><strong>脚手架中的用途</strong>：监听模板目录或配置文件，一旦变更则重新生成或重载。</p>
<h3 id="最小示例（带防抖）">最小示例（带防抖）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> watch</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/fsnotify/fsnotify&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WatchDir</span><span class="params">(dir <span class="type">string</span>, onChange <span class="keyword">func</span>()</span></span>) <span class="type">error</span> &#123;</span><br><span class="line">    w, err := fsnotify.NewWatcher()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">    <span class="keyword">defer</span> w.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归监听</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(d <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filepath.WalkDir(d, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, de fs.DirEntry, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line">            <span class="keyword">if</span> de.IsDir() &#123; <span class="keyword">return</span> w.Add(path) &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := add(dir); err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> err &#125;</span><br><span class="line"></span><br><span class="line">    timer := time.NewTimer(time.Hour)</span><br><span class="line">    timer.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e := &lt;-w.Events:</span><br><span class="line">            log.Println(<span class="string">&quot;fs: &quot;</span>, e)</span><br><span class="line">            <span class="comment">// 防抖：聚合 300ms 内的事件</span></span><br><span class="line">            timer.Reset(<span class="number">300</span> * time.Millisecond)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">            onChange()</span><br><span class="line">        <span class="keyword">case</span> err := &lt;-w.Errors:</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最佳实践</strong></p>
<ul>
<li>监听<strong>目录</strong>优于单文件；Rename/Remove 可能导致监听失效，需要<strong>重新 Add</strong>。</li>
<li>合理的<strong>防抖</strong>与<strong>节流</strong>，避免重复构建/重载。</li>
<li>Linux inotify、Mac FSEvents、Windows ReadDirectoryChangesW 行为略有差异，注意测试。</li>
</ul>
<hr>
<p><a id="syscall"></a></p>
<h2 id="9-常见-syscall：低层能力与高层替代建议">9. 常见 syscall：低层能力与高层替代建议</h2>
<p><strong>它是啥</strong>：<code>syscall</code> 暴露系统调用接口；但 <strong>Go 官方建议</strong>：新代码尽量使用更高层的标准库或 <code>golang.org/x/sys/*</code>（如 <code>x/sys/unix</code>）。</p>
<p><strong>脚手架中的用途</strong>：少量场景需要低层控制，例如：</p>
<ul>
<li>设置进程组（便于一键终止子进程组）。</li>
<li>文件锁（防并发执行两个生成器实例）。</li>
<li>修改文件权限/Umask。</li>
</ul>
<h3 id="示例-1：文件锁（类-Unix）">示例 1：文件锁（类 Unix）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go:build !windows</span></span><br><span class="line"><span class="keyword">package</span> lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/sys/unix&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileLock <span class="keyword">struct</span> &#123; f *os.File &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TryLock</span><span class="params">(path <span class="type">string</span>)</span></span> (*FileLock, <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, <span class="number">0o644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span>, err &#125;</span><br><span class="line">    <span class="keyword">if</span> err := unix.Flock(<span class="type">int</span>(f.Fd()), unix.LOCK_EX|unix.LOCK_NB); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        f.Close(); <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;another process holds the lock: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;FileLock&#123;f: f&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *FileLock)</span></span> Unlock() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.f.Close()</span><br><span class="line">    <span class="keyword">return</span> unix.Flock(<span class="type">int</span>(l.f.Fd()), unix.LOCK_UN)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2：设置进程组-杀全组（类-Unix）">示例 2：设置进程组 + 杀全组（类 Unix）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd := exec.Command(<span class="string">&quot;your-server&quot;</span>)</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;Setpgid: <span class="literal">true</span>&#125;</span><br><span class="line">_ = cmd.Start()</span><br><span class="line"><span class="comment">// 终止整个进程组</span></span><br><span class="line">pgid, _ := syscall.Getpgid(cmd.Process.Pid)</span><br><span class="line">_ = syscall.Kill(-pgid, syscall.SIGTERM) <span class="comment">// 负号表示进程组</span></span><br></pre></td></tr></table></figure>
<p><strong>高层替代建议表</strong></p>
<table>
<thead>
<tr>
<th>需求</th>
<th>建议优先使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程信号</td>
<td><code>os/signal</code>, <code>exec.CommandContext</code></td>
</tr>
<tr>
<td>文件权限</td>
<td><code>os.OpenFile</code> + 明确 <code>0o644/0o755</code>；<code>os.Chmod</code></td>
</tr>
<tr>
<td>文件锁</td>
<td><code>x/sys/unix</code>.Flock 或 跨平台第三方库</td>
</tr>
<tr>
<td>定时/取消</td>
<td><code>context</code> + <code>time</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>⚠️ 注意：Windows 上没有 POSIX 信号/锁的完全等价物，需用平台特定方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之再谈异常处理</title>
    <url>/2025/07/07/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%8D%E8%B0%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go语言中的异常处理机制：panic、recover-和-defer-的正确使用方式">Go语言中的异常处理机制：panic、recover 和 defer 的正确使用方式</h1>
<p>Go 语言没有传统意义上的 <code>try-catch-finally</code> 异常处理机制，而是以一种更轻量的方式来应对运行时错误。本文将系统地讲解 Go 的异常处理机制，包括：</p>
<ul>
<li>什么是 <code>panic</code>、<code>recover</code> 和 <code>defer</code></li>
<li>它们的使用规则和底层原理</li>
<li>开发中的最佳实践</li>
<li>常见陷阱与解决方案</li>
</ul>
<hr>
<h2 id="一、Go-的异常处理设计理念">一、Go 的异常处理设计理念</h2>
<p>Go 语言的核心哲学是<strong>明确错误而非隐藏错误</strong>，所以它鼓励使用显式的 <code>error</code> 类型进行错误处理。只有在真正无法处理的问题（如程序逻辑崩溃）时，才建议使用 <code>panic</code>。</p>
<blockquote>
<p>✅ <strong>常规错误用 <code>error</code> 返回，极端错误才用 <code>panic</code> 抛出。</strong></p>
</blockquote>
<hr>
<h2 id="二、三个关键词详解：panic、recover、defer">二、三个关键词详解：<code>panic</code>、<code>recover</code>、<code>defer</code></h2>
<h3 id="1-panic">1. panic</h3>
<p><code>panic</code> 会让程序立即停止当前函数的执行，沿调用栈向上传播，直到遇到 <code>recover()</code> 或程序彻底崩溃。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;程序发生严重错误&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;这行不会被执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-defer">2. defer</h3>
<p><code>defer</code> 会在当前函数返回前执行，无论是否发生 <code>panic</code>。它非常适合用来做清理工作（关闭文件、回收资源等）或配合 <code>recover</code> 捕捉异常。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;这个一定会执行&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始</span><br><span class="line">这个一定会执行</span><br></pre></td></tr></table></figure>
<h3 id="3-recover">3. recover</h3>
<p><code>recover</code> 是一个内置函数，<strong>只能在 defer 中调用</strong>。它可以捕捉到 panic 并让程序继续运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Recovered from panic:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;崩溃啦！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Recovered from panic: 崩溃啦！</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、recover-的使用场景与最佳实践">三、recover 的使用场景与最佳实践</h2>
<h3 id="✅-示例-1：安全的-Web-请求处理">✅ 示例 1：安全的 Web 请求处理</h3>
<p>在 Web 应用中，为了防止某个请求 panic 导致整个服务崩溃，推荐写一个中间件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverMiddleware</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				http.Error(w, <span class="string">&quot;Internal Server Error&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">				log.Printf(<span class="string">&quot;panic: %v\n&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		next.ServeHTTP(w, r)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样即使某个请求触发了 panic，也不会影响服务器整体运行。</p>
<hr>
<h3 id="✅-示例-2：异步任务中的防护（goroutine）">✅ 示例 2：异步任务中的防护（goroutine）</h3>
<p>如果你在 goroutine 中没有捕捉 panic，整个程序仍可能崩溃：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeGo</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Println(<span class="string">&quot;goroutine panic:&quot;</span>, r)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		f()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	safeGo(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;异步任务崩溃！&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式是高并发场景下的重要保障手段。</p>
<hr>
<h3 id="✅-示例-3：清理资源">✅ 示例 3：清理资源</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openFile</span><span class="params">(filename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;关闭文件&quot;</span>)</span><br><span class="line">		f.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使中途 <code>panic</code>，文件也能被安全关闭。</p>
<hr>
<h2 id="四、何时该-panic，何时该-return-error？">四、何时该 panic，何时该 return error？</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>使用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户输入错误 / 网络超时等可预期错误</td>
<td>返回 <code>error</code></td>
</tr>
<tr>
<td>数组越界 / nil dereference 等程序 bug</td>
<td>使用 <code>panic</code></td>
</tr>
<tr>
<td>初始化失败（例如配置文件丢失）</td>
<td>允许 panic 或 log.Fatal</td>
</tr>
<tr>
<td>多线程崩溃防护</td>
<td>使用 goroutine + recover</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五、常见陷阱与误区">五、常见陷阱与误区</h2>
<h3 id="❌-recover-不在-defer-中使用">❌ recover 不在 defer 中使用</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bad</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123; <span class="comment">// ❌ 失效</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;won&#x27;t work&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>recover</code> 只能在 <code>defer</code> 函数内才能捕获 <code>panic</code>，否则永远返回 <code>nil</code>。</p>
<hr>
<h3 id="❌-忽略-panic-的后果">❌ 忽略 panic 的后果</h3>
<p>如果你写库函数时随意 <code>panic</code>，调用者没有准备好 <code>recover</code>，就可能导致整个程序崩溃。<strong>库函数应该优先返回 error。</strong></p>
<hr>
<h2 id="六、一个完整的最佳实践模板">六、一个完整的最佳实践模板</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeRun</span><span class="params">(handler <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;panic recovered: %v\n&quot;</span>, err)</span><br><span class="line">			debug.PrintStack() <span class="comment">// 打印堆栈</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	handler()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	SafeRun(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 模拟严重错误</span></span><br><span class="line">		<span class="keyword">var</span> list []<span class="type">int</span></span><br><span class="line">		fmt.Println(list[<span class="number">100</span>]) <span class="comment">// panic: index out of range</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;程序没有崩溃&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panic recovered: runtime error: index out of range [100] with length 0</span><br><span class="line">...堆栈信息...</span><br><span class="line">程序没有崩溃</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="七、总结">七、总结</h2>
<table>
<thead>
<tr>
<th>关键词</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>panic()</code></td>
<td>抛出异常，程序中断执行</td>
</tr>
<tr>
<td><code>recover()</code></td>
<td>捕获异常并恢复执行，仅在 defer 中有效</td>
</tr>
<tr>
<td><code>defer</code></td>
<td>注册延迟执行函数，可配合 recover 做错误处理</td>
</tr>
<tr>
<td>最佳实践</td>
<td>panic 用于不可恢复错误，其他返回 error；goroutine 要保护；中间件要兜底</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之嵌入的使用场景</title>
    <url>/2025/07/09/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%B5%8C%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go语言中结构体嵌入与普通字段：到底该怎么选？">Go语言中结构体嵌入与普通字段：到底该怎么选？</h1>
<p>在 Go 语言中，结构体字段有两种主要的定义方式：<strong>嵌入结构体（Embedding）</strong> 和 <strong>定义为普通字段（Named Field）</strong>。虽然语法看起来相似，背后的设计意图和行为却大不相同。</p>
<p>本文将深入讲解这两种方式的差异，帮助你判断在实际开发中该如何选择。</p>
<hr>
<h2 id="🧩-一、什么是结构体嵌入（Embedding）？">🧩 一、什么是结构体嵌入（Embedding）？</h2>
<p>结构体嵌入是 Go 的一个语法特性，允许你将一个类型嵌入到另一个结构体中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	HorsePower <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">	Engine <span class="comment">// 嵌入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于将 <code>Engine</code> 的字段“提升”为 <code>Car</code> 的字段，你可以直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">car := Car&#123;Engine&#123;HorsePower: <span class="number">150</span>&#125;&#125;</span><br><span class="line">fmt.Println(car.HorsePower) <span class="comment">// 而不是 car.Engine.HorsePower</span></span><br></pre></td></tr></table></figure>
<p>同时，<code>Car</code> 也“继承”了 <code>Engine</code> 的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Engine)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Engine started&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.Start() <span class="comment">// 自动调用 Engine 的方法</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🏷️-二、什么是普通字段定义？">🏷️ 二、什么是普通字段定义？</h2>
<p>与嵌入结构体不同，普通字段是显式命名的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	HorsePower <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">	Eng Engine <span class="comment">// 普通字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时必须指定完整路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(car.Eng.HorsePower)</span><br></pre></td></tr></table></figure>
<p>不会发生字段提升或方法提升，也不会影响命名空间。</p>
<hr>
<h2 id="🧠-三、对比嵌入与普通字段">🧠 三、对比嵌入与普通字段</h2>
<table>
<thead>
<tr>
<th>比较维度</th>
<th>嵌入结构体</th>
<th>普通字段</th>
</tr>
</thead>
<tbody>
<tr>
<td>字段访问</td>
<td>字段会“提升”到外部结构体</td>
<td>必须通过字段名访问</td>
</tr>
<tr>
<td>方法调用</td>
<td>外部结构体可直接调用嵌入结构体方法</td>
<td>只能通过字段间接调用</td>
</tr>
<tr>
<td>是否命名</td>
<td>没有字段名（匿名）</td>
<td>有字段名</td>
</tr>
<tr>
<td>命名冲突</td>
<td>容易产生字段名或方法冲突</td>
<td>明确隔离，不冲突</td>
</tr>
<tr>
<td>语义</td>
<td>组合 + 类似继承（行为复用）</td>
<td>拥有属性的组合（数据建模）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🚀-四、什么时候使用嵌入结构体？">🚀 四、什么时候使用嵌入结构体？</h2>
<p>嵌入结构体适合用于：</p>
<h3 id="1-行为复用（类似继承）">1. <strong>行为复用（类似继承）</strong></h3>
<p>如果你希望一个结构体“拥有”另一个结构体的方法或字段功能，可以使用嵌入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Logger)</span></span> Log(msg <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Log:&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">	Logger <span class="comment">// 嵌入，让 Service 直接调用 Log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">svc := Service&#123;&#125;</span><br><span class="line">svc.Log(<span class="string">&quot;starting service...&quot;</span>) <span class="comment">// 像继承一样调用</span></span><br></pre></td></tr></table></figure>
<h3 id="2-扩展已有结构体">2. <strong>扩展已有结构体</strong></h3>
<p>例如在 Web 应用中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AdminUser <span class="keyword">struct</span> &#123;</span><br><span class="line">	User <span class="comment">// 嵌入 User 的所有字段</span></span><br><span class="line">	Level <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以直接访问 <code>AdminUser.Name</code>，而不用 <code>AdminUser.User.Name</code>。</p>
<h3 id="3-实现接口的复用">3. <strong>实现接口的复用</strong></h3>
<p>多个结构体嵌入实现了接口的结构体，从而间接实现该接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">	Notify(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmailNotifier <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EmailNotifier)</span></span> Notify(msg <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Email:&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">	EmailNotifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App 自动实现 Notifier 接口</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧱-五、什么时候使用普通字段？">🧱 五、什么时候使用普通字段？</h2>
<p>普通字段更适用于数据建模和明确属性划分的场景：</p>
<h3 id="1-结构体中的独立组件">1. <strong>结构体中的独立组件</strong></h3>
<p>如果 <code>Car</code> 拥有一个引擎，而不是“就是一个引擎”，就应该用普通字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">	Eng Engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-避免命名冲突">2. <strong>避免命名冲突</strong></h3>
<p>当嵌入多个结构体时容易产生方法或字段名冲突，使用普通字段可显式控制命名空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GPS <span class="keyword">struct</span> &#123;</span><br><span class="line">	Location <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WiFi <span class="keyword">struct</span> &#123;</span><br><span class="line">	Location <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Device <span class="keyword">struct</span> &#123;</span><br><span class="line">	GPS</span><br><span class="line">	WiFi <span class="comment">// 冲突：Device.Location 不明确，需通过 Device.GPS.Location</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用普通字段更清晰：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Device <span class="keyword">struct</span> &#123;</span><br><span class="line">	Gps  GPS</span><br><span class="line">	Wifi WiFi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-表达“组成”关系，而非“行为继承”">3. <strong>表达“组成”关系，而非“行为继承”</strong></h3>
<p>比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> House <span class="keyword">struct</span> &#123;</span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Home House <span class="comment">// 表达“拥有一个家”关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是让 <code>Person</code> 看起来“像是一个 House”。</p>
<hr>
<h2 id="🧭-六、最佳实践总结">🧭 六、最佳实践总结</h2>
<table>
<thead>
<tr>
<th>选择场景</th>
<th>推荐用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>想要行为复用、方法继承</td>
<td>✅ 使用嵌入</td>
</tr>
<tr>
<td>明确字段名，避免冲突</td>
<td>✅ 使用普通字段</td>
</tr>
<tr>
<td>数据建模，表达“拥有”关系</td>
<td>✅ 使用普通字段</td>
</tr>
<tr>
<td>需要结构体自动实现接口</td>
<td>✅ 使用嵌入</td>
</tr>
<tr>
<td>结构体组成多个模块组件</td>
<td>✅ 使用普通字段更清晰</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="📝-七、小结">📝 七、小结</h2>
<blockquote>
<p>结构体嵌入并不是语法糖，它承载了 Go 语言组合优先的设计哲学。相比面向对象语言中的继承，Go 更倾向于“<strong>通过组合实现复用</strong>”，结构体嵌入正是这种思路的体现。</p>
</blockquote>
<p>请记住：</p>
<ul>
<li><strong>嵌入是行为复用（is-a/like-a）</strong></li>
<li><strong>普通字段是属性组合（has-a）</strong></li>
</ul>
<hr>
<p>如果你正在设计自己的 Go 应用，不妨多问问自己一句：</p>
<blockquote>
<p>“我这是要<strong>继承行为</strong>，还是只是<strong>拥有数据</strong>？”</p>
</blockquote>
<p>用对方式，代码更优雅，维护更轻松。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之调试利器Air</title>
    <url>/2025/07/26/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8Air/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、Air-是什么？">一、Air 是什么？</h2>
<p><a href="https://github.com/cosmtrek/air">Air</a> 是一个专为 Go 应用打造的 <strong>热重载工具</strong>。它能够在你保存代码时，自动帮你完成编译、重启应用的流程，让你专注于代码开发，无需手动操作重启程序。</p>
<p>使用 Air，就像在 Node.js 世界中使用 nodemon、在前端使用 webpack 的 watch 模式，极大地提升了开发体验。</p>
<hr>
<h2 id="二、Air-的核心特性">二、Air 的核心特性</h2>
<ul>
<li>✅ 自动监听 <code>.go</code> 文件变更并重启程序</li>
<li>✅ 支持自定义构建命令和路径</li>
<li>✅ 支持忽略特定目录或文件（如 <code>vendor/</code>、<code>test/</code>）</li>
<li>✅ 支持 <code>.toml</code> 格式配置文件，易读易写</li>
<li>✅ 无需修改代码，开箱即用</li>
</ul>
<hr>
<h2 id="三、如何安装-Air？">三、如何安装 Air？</h2>
<h3 id="方式一：使用-Go-安装（推荐）">方式一：使用 Go 安装（推荐）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/cosmtrek/air@latest</span><br></pre></td></tr></table></figure>
<p>注意：确保 <code>$GOPATH/bin</code> 或 <code>~/go/bin</code> 已加入环境变量 <code>$PATH</code>。</p>
<h3 id="方式二：使用-Homebrew（macOS）">方式二：使用 Homebrew（macOS）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install air</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、快速上手">四、快速上手</h2>
<p>在你的 Go 项目根目录下，直接运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">air</span><br></pre></td></tr></table></figure>
<p>如果第一次运行，会自动生成 <code>.air.toml</code> 配置文件。</p>
<p>Air 会自动监听你的 Go 源文件（如 <code>main.go</code>），并在检测到变动后自动构建和运行程序。</p>
<hr>
<h2 id="五、自定义配置：-air-toml">五、自定义配置：<code>.air.toml</code></h2>
<p>Air 支持通过 <code>.air.toml</code> 文件来自定义行为，比如构建命令、忽略目录等。以下是一个常见的示例配置：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .air.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build]</span></span><br><span class="line">  <span class="attr">cmd</span> = <span class="string">&quot;go build -o tmp/app .&quot;</span>    <span class="comment"># 构建命令</span></span><br><span class="line">  <span class="attr">bin</span> = <span class="string">&quot;tmp/app&quot;</span>                  <span class="comment"># 编译后的二进制路径</span></span><br><span class="line">  <span class="attr">include_ext</span> = [<span class="string">&quot;go&quot;</span>, <span class="string">&quot;tpl&quot;</span>, <span class="string">&quot;html&quot;</span>]   <span class="comment"># 监听这些扩展名</span></span><br><span class="line">  <span class="attr">exclude_dir</span> = [<span class="string">&quot;vendor&quot;</span>, <span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;logs&quot;</span>]  <span class="comment"># 忽略目录</span></span><br><span class="line">  <span class="attr">exclude_file</span> = [<span class="string">&quot;*_test.go&quot;</span>]     <span class="comment"># 忽略文件</span></span><br><span class="line">  <span class="attr">delay</span> = <span class="number">1000</span>                     <span class="comment"># 防抖延迟（ms）</span></span><br><span class="line"></span><br><span class="line"><span class="section">[log]</span></span><br><span class="line">  <span class="attr">time</span> = <span class="literal">true</span>                      <span class="comment"># 显示时间戳</span></span><br></pre></td></tr></table></figure>
<p>然后运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">air -c .air.toml</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、项目目录结构建议">六、项目目录结构建议</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your-project/</span><br><span class="line">├── main.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── .air.toml</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>推荐在项目根目录放置 <code>.air.toml</code> 文件。</p>
<hr>
<h2 id="七、配合-Gin-等-Web-框架使用">七、配合 Gin 等 Web 框架使用</h2>
<p>Air 非常适合用于开发基于 Gin、Fiber、Echo 等 Web 框架的应用。只要你把入口文件设置正确（一般是 <code>main.go</code>），Air 就能帮你自动热重载，非常适合调试接口、Web 服务等项目。</p>
<hr>
<h2 id="八、Air-vs-其他热重载工具">八、Air vs 其他热重载工具</h2>
<table>
<thead>
<tr>
<th>工具名</th>
<th>语言适配</th>
<th>热重载</th>
<th>配置支持</th>
<th>社区活跃</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Air</strong></td>
<td>Go</td>
<td>✅</td>
<td><code>.toml</code></td>
<td>非常活跃</td>
</tr>
<tr>
<td>fresh</td>
<td>Go</td>
<td>✅</td>
<td>简单</td>
<td>一般</td>
</tr>
<tr>
<td>reflex</td>
<td>通用</td>
<td>✅</td>
<td>正则匹配</td>
<td>一般</td>
</tr>
<tr>
<td>CompileDaemon</td>
<td>Go</td>
<td>✅</td>
<td>简单</td>
<td>一般</td>
</tr>
</tbody>
</table>
<p>在 Go 项目中，<strong>Air 是目前最推荐的选择</strong>。</p>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hardhat-ignition</title>
    <url>/2025/05/04/Hardhat-ignition/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Hardhat Ignition</strong> 是 Hardhat 的一个插件，用于管理和自动化智能合约的部署流程。它特别适合复杂的部署场景，例如需要部署多个合约、处理合约依赖关系或按特定顺序部署的场景。以下是 Hardhat Ignition 的常见用法和详细介绍：</p>
<hr>
<h2 id="1-安装-Hardhat-Ignition"><strong>1. 安装 Hardhat Ignition</strong></h2>
<p>首先，确保你已经安装了 Hardhat 和 Hardhat Ignition：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-ignition</span><br></pre></td></tr></table></figure>
<p>然后在 <code>hardhat.config.js</code> 中引入插件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-ignition&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-定义部署模块"><strong>2. 定义部署模块</strong></h2>
<p>Hardhat Ignition 的核心概念是 <strong>模块（Module）</strong>。一个模块是一个独立的部署单元，可以包含多个合约部署和配置。</p>
<h3 id="基本模块定义"><strong>基本模块定义</strong></h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; buildModule &#125; = <span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-ignition/modules&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> myContract = m.<span class="title function_">contract</span>(<span class="string">&quot;MyContract&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; myContract &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>buildModule</code>：定义一个模块。</p>
</li>
<li>
<p><code>&quot;MyModule&quot;</code>：模块的名称。</p>
</li>
<li>
<p><code>m.contract(&quot;MyContract&quot;)</code>：部署名为 <code>MyContract</code> 的合约。</p>
</li>
<li>
<p><code>return &#123; myContract &#125;</code>：返回部署后的合约实例。</p>
</li>
</ul>
<hr>
<h3 id="带参数的模块"><strong>带参数的模块</strong></h3>
<p>你可以通过 <code>m.getParameter</code> 动态设置部署参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialValue = m.<span class="title function_">getParameter</span>(<span class="string">&quot;initialValue&quot;</span>, <span class="number">100</span>); <span class="comment">// 默认值为 100</span></span><br><span class="line">  <span class="keyword">const</span> myContract = m.<span class="title function_">contract</span>(<span class="string">&quot;MyContract&quot;</span>, [initialValue]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; myContract &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="部署多个合约"><strong>部署多个合约</strong></h3>
<p>在一个模块中可以部署多个合约，并处理它们之间的依赖关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> contractA = m.<span class="title function_">contract</span>(<span class="string">&quot;ContractA&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> contractB = m.<span class="title function_">contract</span>(<span class="string">&quot;ContractB&quot;</span>, [contractA.<span class="property">address</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; contractA, contractB &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>contractB</code> 依赖于 <code>contractA</code> 的地址，Hardhat Ignition 会自动按正确顺序部署。</li>
</ul>
<hr>
<h3 id="调用合约函数"><strong>调用合约函数</strong></h3>
<p>在部署过程中，你可以调用合约的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> myContract = m.<span class="title function_">contract</span>(<span class="string">&quot;MyContract&quot;</span>);</span><br><span class="line">  m.<span class="title function_">call</span>(myContract, <span class="string">&quot;initialize&quot;</span>, [<span class="number">42</span>]); <span class="comment">// 调用 initialize 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; myContract &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用库合约"><strong>使用库合约</strong></h3>
<p>如果合约依赖于库合约，可以先部署库合约，然后将其链接到主合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> myLibrary = m.<span class="title function_">library</span>(<span class="string">&quot;MyLibrary&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> myContract = m.<span class="title function_">contract</span>(<span class="string">&quot;MyContract&quot;</span>, [], &#123;</span><br><span class="line">    <span class="attr">libraries</span>: &#123;</span><br><span class="line">      <span class="title class_">MyLibrary</span>: myLibrary.<span class="property">address</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; myContract &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-运行部署"><strong>3. 运行部署</strong></h2>
<p>使用 <code>ignition.deploy</code> 运行部署模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ignition &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; myContract &#125; = <span class="keyword">await</span> ignition.<span class="title function_">deploy</span>(<span class="string">&quot;./path/to/MyModule&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyContract deployed to:&quot;</span>, myContract.<span class="property">address</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>
<p>运行部署脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network localhost</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-高级功能"><strong>4. 高级功能</strong></h2>
<h3 id="分阶段部署"><strong>分阶段部署</strong></h3>
<p>Hardhat Ignition 支持分阶段部署，例如先部署合约，然后初始化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> myContract = m.<span class="title function_">contract</span>(<span class="string">&quot;MyContract&quot;</span>);</span><br><span class="line"></span><br><span class="line">  m.<span class="title function_">stage</span>(<span class="string">&quot;Initialize&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> myContract.<span class="title function_">initialize</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; myContract &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="条件部署"><strong>条件部署</strong></h3>
<p>你可以根据条件决定是否部署某个合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldDeploy = m.<span class="title function_">getParameter</span>(<span class="string">&quot;shouldDeploy&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldDeploy) &#123;</span><br><span class="line">    <span class="keyword">const</span> myContract = m.<span class="title function_">contract</span>(<span class="string">&quot;MyContract&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; myContract &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用现有合约"><strong>使用现有合约</strong></h3>
<p>如果某个合约已经部署，可以直接使用其地址，而不重新部署：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">buildModule</span>(<span class="string">&quot;MyModule&quot;</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> existingContract = m.<span class="title function_">getParameter</span>(<span class="string">&quot;existingContract&quot;</span>, <span class="string">&quot;0x...&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> myContract = m.<span class="title function_">contractAt</span>(<span class="string">&quot;MyContract&quot;</span>, existingContract);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; myContract &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="多网络支持"><strong>多网络支持</strong></h3>
<p>Hardhat Ignition 支持多网络配置。你可以在 <code>hardhat.config.js</code> 中定义不同的网络，并在部署时指定网络：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">networks</span>: &#123;</span><br><span class="line">    <span class="attr">localhost</span>: &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;http://localhost:8545&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mainnet</span>: &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID&quot;</span>,</span><br><span class="line">      <span class="attr">accounts</span>: [<span class="string">&quot;0x...&quot;</span>], <span class="comment">// 私钥</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行部署时指定网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network mainnet</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-使用场景"><strong>5. 使用场景</strong></h2>
<h3 id="复杂部署流程"><strong>复杂部署流程</strong></h3>
<ul>
<li>
<p>部署多个合约并处理依赖关系。</p>
</li>
<li>
<p>按特定顺序初始化合约。</p>
</li>
</ul>
<h3 id="多环境部署"><strong>多环境部署</strong></h3>
<ul>
<li>
<p>在测试网和主网之间切换部署配置。</p>
</li>
<li>
<p>动态调整部署参数（如初始值、管理员地址等）。</p>
</li>
</ul>
<h3 id="自动化测试"><strong>自动化测试</strong></h3>
<ul>
<li>在测试中自动部署合约并初始化状态。</li>
</ul>
<h3 id="升级合约"><strong>升级合约</strong></h3>
<ul>
<li>部署新版本的合约并迁移数据。</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>web3</tag>
        <tag>hardhat</tag>
      </tags>
  </entry>
  <entry>
    <title>Hardhat上手指南</title>
    <url>/2025/05/04/Hardhat%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hardhat 是一个用于开发、测试和部署智能合约的开发环境。它提供了强大的工具和插件，帮助开发者更高效地构建以太坊和其他区块链应用。以下是 Hardhat 的基本使用指南：</p>
<h3 id="1-安装-Hardhat">1. 安装 Hardhat</h3>
<p>首先，确保你已经安装了 Node.js 和 npm。然后，可以通过以下命令全局安装 Hardhat：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hardhat</span><br></pre></td></tr></table></figure>
<p>或者在项目目录中局部安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure>
<h3 id="2-初始化项目">2. 初始化项目</h3>
<p>在项目目录中运行以下命令来初始化一个新的 Hardhat 项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat</span><br></pre></td></tr></table></figure>
<p>这将启动一个交互式命令行界面，你可以选择创建一个新的 Hardhat 项目或使用示例项目。</p>
<h3 id="3-项目结构">3. 项目结构</h3>
<p>初始化后，项目目录结构通常如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── contracts/           # 存放智能合约</span><br><span class="line">├── scripts/             # 存放部署脚本</span><br><span class="line">├── test/                # 存放测试脚本</span><br><span class="line">├── hardhat.config.js    # Hardhat 配置文件</span><br><span class="line">└── package.json         # Node.js 项目配置文件</span><br></pre></td></tr></table></figure>
<h3 id="4-编写智能合约">4. 编写智能合约</h3>
<p>在 <code>contracts/</code> 目录中编写你的智能合约。例如，创建一个简单的 <code>Greeter.sol</code> 合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Greeter &#123;</span><br><span class="line">    string private greeting;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _greeting) &#123;</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function greet() public view returns (string memory) &#123;</span><br><span class="line">        return greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setGreeting(string memory _greeting) public &#123;</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-编译合约">5. 编译合约</h3>
<p>使用以下命令编译合约：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure>
<p>编译后的文件将存储在 <code>artifacts/</code> 目录中。</p>
<h3 id="6-编写测试">6. 编写测试</h3>
<p>在 <code>test/</code> 目录中编写测试脚本。例如，创建一个 <code>Greeter.test.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;Greeter&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;Should return the new greeting once it&#x27;s changed&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Greeter</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;Greeter&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> greeter = <span class="keyword">await</span> <span class="title class_">Greeter</span>.<span class="title function_">deploy</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> greeter.<span class="title function_">deployed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> greeter.<span class="title function_">greet</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> setGreetingTx = <span class="keyword">await</span> greeter.<span class="title function_">setGreeting</span>(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until the transaction is mined</span></span><br><span class="line">    <span class="keyword">await</span> setGreetingTx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> greeter.<span class="title function_">greet</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="7-运行测试">7. 运行测试</h3>
<p>使用以下命令运行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat test</span><br></pre></td></tr></table></figure>
<h3 id="8-部署合约">8. 部署合约</h3>
<p>在 <code>scripts/</code> 目录中编写部署脚本。例如，创建一个 <code>deploy.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Greeter</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;Greeter&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> greeter = <span class="keyword">await</span> <span class="title class_">Greeter</span>.<span class="title function_">deploy</span>(<span class="string">&quot;Hello, Hardhat!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> greeter.<span class="title function_">deployed</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greeter deployed to:&quot;</span>, greeter.<span class="property">address</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> process.<span class="title function_">exit</span>(<span class="number">0</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>然后使用以下命令部署合约：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js</span><br></pre></td></tr></table></figure>
<h3 id="9-配置网络">9. 配置网络</h3>
<p>在 <code>hardhat.config.js</code> 中配置网络。例如，配置本地网络和以太坊测试网络：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomiclabs/hardhat-waffle&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.4&quot;</span>,</span><br><span class="line">  <span class="attr">networks</span>: &#123;</span><br><span class="line">    <span class="attr">localhost</span>: &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8545&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ropsten</span>: &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">`https://ropsten.infura.io/v3/YOUR_INFURA_PROJECT_ID`</span>,</span><br><span class="line">      <span class="attr">accounts</span>: [<span class="string">`0x<span class="subst">$&#123;YOUR_PRIVATE_KEY&#125;</span>`</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10-使用插件">10. 使用插件</h3>
<p>Hardhat 支持许多插件，例如：</p>
<ul>
<li>
<p><code>@nomiclabs/hardhat-ethers</code>：用于与以太坊交互。</p>
</li>
<li>
<p><code>@nomiclabs/hardhat-waffle</code>：用于测试。</p>
</li>
<li>
<p><code>hardhat-gas-reporter</code>：用于报告 Gas 使用情况。</p>
</li>
</ul>
<p>可以通过 npm 安装这些插件，并在 <code>hardhat.config.js</code> 中配置。</p>
<h3 id="11-其他命令">11. 其他命令</h3>
<ul>
<li>
<p><code>npx hardhat clean</code>：清理编译缓存。</p>
</li>
<li>
<p><code>npx hardhat node</code>：启动本地以太坊节点。</p>
</li>
<li>
<p><code>npx hardhat console</code>：启动 Hardhat 控制台。</p>
</li>
</ul>
<p>Hardhat 的强大之处在于其丰富的插件生态系统，这些插件可以帮助开发者更高效地进行智能合约开发、测试和部署。以下是一些常用的 Hardhat 插件及其功能：</p>
<hr>
<h3 id="1-nomiclabs-hardhat-ethers">1. <strong>@nomiclabs/hardhat-ethers</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 集成 <code>ethers.js</code> 库，用于与以太坊网络交互。</p>
</li>
<li>
<p><strong>用途</strong>: 部署合约、发送交易、调用合约方法等。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @nomiclabs/hardhat-ethers ethers</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomiclabs/hardhat-ethers&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="2-nomiclabs-hardhat-waffle">2. <strong>@nomiclabs/hardhat-waffle</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 集成 <code>Waffle</code> 测试框架，用于编写和运行智能合约测试。</p>
</li>
<li>
<p><strong>用途</strong>: 提供 Chai 匹配器和工具，方便测试智能合约。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @nomiclabs/hardhat-waffle ethereum-waffle chai</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomiclabs/hardhat-waffle&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-hardhat-deploy">3. <strong>hardhat-deploy</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 提供更强大的合约部署功能，支持命名部署、依赖管理和部署脚本的组织。</p>
</li>
<li>
<p><strong>用途</strong>: 管理复杂的部署流程，支持多网络部署。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-deploy</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-deploy&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-hardhat-gas-reporter">4. <strong>hardhat-gas-reporter</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 在运行测试时报告 Gas 使用情况。</p>
</li>
<li>
<p><strong>用途</strong>: 优化合约的 Gas 消耗。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-gas-reporter</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-gas-reporter&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">gasReporter</span>: &#123;</span><br><span class="line">    <span class="attr">currency</span>: <span class="string">&#x27;USD&#x27;</span>, <span class="comment">// 设置货币单位</span></span><br><span class="line">    <span class="attr">gasPrice</span>: <span class="number">21</span>,    <span class="comment">// 设置 Gas 价格</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-solidity-coverage">5. <strong>solidity-coverage</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 生成智能合约的代码覆盖率报告。</p>
</li>
<li>
<p><strong>用途</strong>: 确保测试覆盖了合约的所有代码路径。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install solidity-coverage</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;solidity-coverage&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用</strong>:<br>
运行以下命令生成覆盖率报告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat coverage</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="6-nomicfoundation-hardhat-toolbox">6. <strong>@nomicfoundation/hardhat-toolbox</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 集成了多个常用插件（如 <code>hardhat-ethers</code>、<code>hardhat-waffle</code>、<code>hardhat-gas-reporter</code> 等）。</p>
</li>
<li>
<p><strong>用途</strong>: 快速启动项目，避免手动安装多个插件。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @nomicfoundation/hardhat-toolbox</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="7-hardhat-etherscan">7. <strong>hardhat-etherscan</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 用于验证合约源码并发布到 Etherscan。</p>
</li>
<li>
<p><strong>用途</strong>: 在 Etherscan 上公开合约源码，方便用户查看和验证。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @nomiclabs/hardhat-etherscan</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomiclabs/hardhat-etherscan&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">etherscan</span>: &#123;</span><br><span class="line">    <span class="attr">apiKey</span>: <span class="string">&quot;YOUR_ETHERSCAN_API_KEY&quot;</span>, <span class="comment">// 替换为你的 Etherscan API Key</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用</strong>:<br>
运行以下命令验证合约：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat verify --network &lt;network_name&gt; &lt;contract_address&gt; &lt;constructor_args&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="8-hardhat-abi-exporter">8. <strong>hardhat-abi-exporter</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 自动导出合约的 ABI 到指定目录。</p>
</li>
<li>
<p><strong>用途</strong>: 方便前端或其他应用使用合约的 ABI。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-abi-exporter</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-abi-exporter&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">abiExporter</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;./abi&#x27;</span>, <span class="comment">// 导出目录</span></span><br><span class="line">    <span class="attr">clear</span>: <span class="literal">true</span>,   <span class="comment">// 每次编译前清空目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="9-hardhat-contract-sizer">9. <strong>hardhat-contract-sizer</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 分析合约的字节码大小。</p>
</li>
<li>
<p><strong>用途</strong>: 确保合约不超过以太坊的字节码大小限制。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-contract-sizer</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-contract-sizer&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="10-hardhat-ignition">10. <strong>hardhat-ignition</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 提供更高级的部署管理功能，支持模块化部署。</p>
</li>
<li>
<p><strong>用途</strong>: 管理复杂的部署流程，支持依赖关系和条件部署。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-ignition</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-ignition&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="11-hardhat-typechain">11. <strong>hardhat-typechain</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 自动生成 TypeScript 类型定义文件。</p>
</li>
<li>
<p><strong>用途</strong>: 在 TypeScript 项目中提供类型安全的合约交互。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @typechain/hardhat typechain @typechain/ethers-v5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@typechain/hardhat&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">typechain</span>: &#123;</span><br><span class="line">    <span class="attr">outDir</span>: <span class="string">&#x27;typechain&#x27;</span>, <span class="comment">// 类型定义文件输出目录</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;ethers-v5&#x27;</span>, <span class="comment">// 目标框架</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="12-hardhat-storage-layout">12. <strong>hardhat-storage-layout</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 导出合约的存储布局信息。</p>
</li>
<li>
<p><strong>用途</strong>: 分析合约的存储结构，方便升级和调试。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-storage-layout</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-storage-layout&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="13-hardhat-tracer">13. <strong>hardhat-tracer</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 提供更详细的交易调试信息。</p>
</li>
<li>
<p><strong>用途</strong>: 调试复杂的交易和合约调用。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-tracer</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-tracer&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="14-hardhat-interface-generator">14. <strong>hardhat-interface-generator</strong></h3>
<ul>
<li>
<p><strong>功能</strong>: 自动生成合约的接口文件。</p>
</li>
<li>
<p><strong>用途</strong>: 方便其他合约或应用与当前合约交互。</p>
</li>
<li>
<p><strong>安装</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hardhat-interface-generator</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置</strong>:<br>
在 <code>hardhat.config.js</code> 中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-interface-generator&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>web3</tag>
        <tag>hardhat</tag>
      </tags>
  </entry>
  <entry>
    <title>Http安全header</title>
    <url>/2025/07/07/Http%E5%AE%89%E5%85%A8header/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="理解常见的-HTTP-安全响应头">理解常见的 HTTP 安全响应头</h1>
<p>在现代 Web 应用开发中，安全性是一个绕不过去的重要话题。HTTP 响应头（HTTP Response Headers）为我们提供了一些简单却强大的手段，能帮助防御常见的攻击，比如 XSS、点击劫持、MIME 类型混淆等。</p>
<p>在 Alex Edwards 所著的《Let’s Go》一书中，就提到了如下这组安全相关的 HTTP Header：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; style-src &#x27;self&#x27; fonts.googleapis.com; font-src fonts.gstatic.com</span><br><span class="line">Referrer-Policy: origin-when-cross-origin</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-Frame-Options: deny</span><br><span class="line">X-XSS-Protection: 0</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1-Content-Security-Policy-CSP">1. Content-Security-Policy (CSP)</h2>
<h3 id="示例：">示例：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; style-src &#x27;self&#x27; fonts.googleapis.com; font-src fonts.gstatic.com</span><br></pre></td></tr></table></figure>
<h3 id="作用：">作用：</h3>
<p><code>Content-Security-Policy</code> 是一个强大的防御 XSS 和数据注入攻击的工具，它通过定义哪些资源是“可信的”来限制页面加载的内容。</p>
<h3 id="解释：">解释：</h3>
<ul>
<li>
<p><code>default-src 'self'</code><br>
默认资源来源限制为同源（即当前域名下的资源）。</p>
</li>
<li>
<p><code>style-src 'self' fonts.googleapis.com</code><br>
样式文件（CSS）只能从当前站点或 <code>fonts.googleapis.com</code> 加载，后者是 Google Fonts 提供 CSS 的域名。</p>
</li>
<li>
<p><code>font-src fonts.gstatic.com</code><br>
字体文件只能从 <code>fonts.gstatic.com</code> 加载，这也是 Google Fonts 字体 CDN 的地址。</p>
</li>
</ul>
<h3 id="举个例子：">举个例子：</h3>
<p>如果某人试图通过注入 <code>&lt;script&gt;</code> 或 <code>&lt;link&gt;</code> 标签从第三方地址加载恶意脚本或样式，浏览器会因为 CSP 策略的限制而阻止加载。</p>
<h3 id="最佳实践：">最佳实践：</h3>
<ul>
<li>CSP 是强烈推荐启用的安全机制，但也可能造成资源加载失败，尤其是使用第三方库、字体或 CDN 时，请务必明确白名单。</li>
<li>在开发初期使用 <code>Content-Security-Policy-Report-Only</code> 来测试策略是否合理。</li>
</ul>
<hr>
<h2 id="2-Referrer-Policy">2. Referrer-Policy</h2>
<h3 id="示例：-2">示例：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Referrer-Policy: origin-when-cross-origin</span><br></pre></td></tr></table></figure>
<h3 id="作用：-2">作用：</h3>
<p>控制浏览器在进行跳转或资源请求时，<code>Referer</code> 头部包含的信息量，以保护用户隐私。</p>
<h3 id="解释：-2">解释：</h3>
<ul>
<li>
<p><code>origin-when-cross-origin</code> 表示：</p>
<ul>
<li>同源请求发送完整 URL。</li>
<li>跨域请求只发送 origin（例如：<code>https://example.com</code> 而不是 <code>https://example.com/page.html</code>）。</li>
</ul>
</li>
</ul>
<h3 id="举个例子：-2">举个例子：</h3>
<p>用户从你的网页跳转到外部站点，如果使用该策略，对方服务器只能知道请求来自 <code>https://yourdomain.com</code>，而不知道具体页面路径。这有助于保护用户浏览行为隐私。</p>
<hr>
<h2 id="3-X-Content-Type-Options">3. X-Content-Type-Options</h2>
<h3 id="示例：-3">示例：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure>
<h3 id="作用：-3">作用：</h3>
<p>防止浏览器“猜测”资源类型，强制它按照 Content-Type 来处理资源。</p>
<h3 id="解释：-3">解释：</h3>
<p>有些浏览器会根据文件内容猜测 MIME 类型（而不是依赖服务器声明的 Content-Type），攻击者可能利用这一点诱使浏览器将非脚本内容作为脚本执行。</p>
<ul>
<li>设置为 <code>nosniff</code> 后，浏览器将拒绝加载 MIME 类型与实际内容不匹配的资源。</li>
</ul>
<h3 id="举个例子：-3">举个例子：</h3>
<p>攻击者上传了一个 <code>.jpg</code> 文件，实际内容却是 JavaScript。如果没有 <code>nosniff</code>，浏览器可能执行这个脚本。</p>
<hr>
<h2 id="4-X-Frame-Options">4. X-Frame-Options</h2>
<h3 id="示例：-4">示例：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Frame-Options: deny</span><br></pre></td></tr></table></figure>
<h3 id="作用：-4">作用：</h3>
<p>防止网页被嵌套在 <code>&lt;iframe&gt;</code> 中，用于防御点击劫持（Clickjacking）攻击。</p>
<h3 id="解释：-4">解释：</h3>
<ul>
<li>
<p><code>deny</code>：不允许任何来源嵌套当前页面。</p>
</li>
<li>
<p>其他选项：</p>
<ul>
<li><code>sameorigin</code>：只允许同源页面嵌套。</li>
<li><code>allow-from &lt;url&gt;</code>：允许指定页面嵌套（已被大多数浏览器弃用）。</li>
</ul>
</li>
</ul>
<h3 id="举个例子：-4">举个例子：</h3>
<p>攻击者构造一个恶意网页，将你的站点以透明 iframe 嵌入，然后诱导用户点击某个按钮，实际上却是在点击你的页面上的敏感操作，这种攻击被称为点击劫持。设置该 Header 可有效防御此类攻击。</p>
<hr>
<h2 id="5-X-XSS-Protection">5. X-XSS-Protection</h2>
<h3 id="示例：-5">示例：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-XSS-Protection: 0</span><br></pre></td></tr></table></figure>
<h3 id="作用：-5">作用：</h3>
<p>关闭浏览器自带的 XSS 过滤器。</p>
<h3 id="解释：-5">解释：</h3>
<ul>
<li><code>0</code> 表示禁用浏览器 XSS 保护机制。</li>
<li>这是一个较具争议的选项。部分旧版浏览器（如 IE、旧版 Chrome）提供了一个 XSS Auditor，在检测到疑似反射型 XSS 时会拦截请求。但这个机制有时会误报，甚至可以被绕过。</li>
</ul>
<h3 id="为什么设为-0？">为什么设为 0？</h3>
<p>现代 Web 开发更推荐使用 CSP 作为 XSS 防护手段。CSP 更可靠，而浏览器内建的 XSS 过滤器有时反而会带来安全隐患（如信息泄漏、绕过攻击），因此很多现代应用选择禁用它。</p>
<hr>
<h2 id="总结与最佳实践">总结与最佳实践</h2>
<table>
<thead>
<tr>
<th>Header</th>
<th>作用</th>
<th>建议值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content-Security-Policy</td>
<td>限制资源加载来源</td>
<td>根据实际资源设置白名单</td>
</tr>
<tr>
<td>Referrer-Policy</td>
<td>控制 referer 信息暴露</td>
<td><code>origin-when-cross-origin</code></td>
</tr>
<tr>
<td>X-Content-Type-Options</td>
<td>阻止 MIME 类型猜测</td>
<td><code>nosniff</code></td>
</tr>
<tr>
<td>X-Frame-Options</td>
<td>防止点击劫持</td>
<td><code>deny</code> 或 <code>sameorigin</code></td>
</tr>
<tr>
<td>X-XSS-Protection</td>
<td>控制浏览器 XSS 保护</td>
<td><code>0</code>（建议依赖 CSP）</td>
</tr>
</tbody>
</table>
<p>这些安全头部虽然看似简单，但配置得当可以大幅提高 Web 应用的安全性。无论是开发个人博客，还是构建企业级服务，理解并合理使用它们都是非常重要的安全基础。</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>JSXorJS</title>
    <url>/2025/05/04/JSXorJS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在React项目中，文件扩展名通常使用 <code>.js</code> 或 <code>.jsx</code>，选择其中一个主要取决于以下几个因素：</p>
<hr>
<h3 id="1-语法区别">1. <strong>语法区别</strong></h3>
<ul>
<li>
<p><code>.jsx</code> 文件通常用于包含 <strong>JSX 语法</strong>（即类似 HTML 的语法，用于描述 UI 结构）。</p>
</li>
<li>
<p><code>.js</code> 文件可以包含普通的 JavaScript 代码，通常用于逻辑、数据处理、工具函数等，不一定涉及 JSX 代码。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p><strong><code>App.jsx</code>（包含JSX的组件）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, React!&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p><strong><code>utils.js</code>（普通JS代码，无JSX）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-社区惯例">2. <strong>社区惯例</strong></h3>
<p>在早期，React 社区通常使用 <code>.jsx</code> 作为包含 JSX 语法的文件，以便区分哪些文件使用了 JSX。但随着现代 JavaScript 生态（比如 Webpack、Babel 等工具）普遍支持 JSX 解析，许多开发者认为 <code>.jsx</code> 变得不那么必要，直接使用 <code>.js</code> 也可以处理 JSX 代码。</p>
<p><strong>实际情况：</strong></p>
<ul>
<li>
<p>有些团队或个人仍然喜欢用 <code>.jsx</code> 以明确文件用途。</p>
</li>
<li>
<p>但大部分现代 React 项目（如 Create React App、Next.js）默认使用 <code>.js</code>，因为 Babel 已自动处理 JSX 语法，无需显式区分。</p>
</li>
</ul>
<hr>
<h3 id="3-工具链支持">3. <strong>工具链支持</strong></h3>
<p>如果你使用的工具链（如 ESLint、Prettier、Babel）对 <code>.jsx</code> 有特殊的 lint 规则或格式化方式，可能更适合使用 <code>.jsx</code>。否则，<code>.js</code> 足够满足需求。</p>
<hr>
<h3 id="4-团队一致性">4. <strong>团队一致性</strong></h3>
<ul>
<li>
<p>在团队协作中，统一使用 <code>.js</code> 或 <code>.jsx</code> 有助于提高代码一致性，减少认知负担。</p>
</li>
<li>
<p>一些团队更倾向于将逻辑分离：</p>
<ul>
<li>
<p>逻辑处理（无 JSX）使用 <code>.js</code></p>
</li>
<li>
<p>组件（有 JSX）使用 <code>.jsx</code></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-Next-js-的惯例">5. <strong>Next.js 的惯例</strong></h3>
<p>Next.js 官方建议直接使用 <code>.js</code> 或 <code>.ts</code>，因为它的编译工具默认支持 JSX 解析。因此，在 Next.js 项目中，通常不会使用 <code>.jsx</code> 扩展名。</p>
<hr>
<h3 id="总结：何时使用哪种？"><strong>总结：何时使用哪种？</strong></h3>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>适用扩展名</th>
<th>推荐实践</th>
</tr>
</thead>
<tbody>
<tr>
<td>纯 JavaScript 逻辑</td>
<td><code>.js</code></td>
<td>✅</td>
</tr>
<tr>
<td>React 组件 (JSX)</td>
<td><code>.jsx</code> 或 <code>.js</code></td>
<td>随项目规范选择</td>
</tr>
<tr>
<td>TypeScript 文件</td>
<td><code>.ts</code> 或 <code>.tsx</code></td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>如果你喜欢明确区分组件，使用 <code>.jsx</code>。如果你想保持简单，直接用 <code>.js</code> 也是完全可以的。</p>
<hr>
<p>如果你是一个人开发或团队没有特别规定，推荐统一使用 <code>.js</code> 以减少额外的区分工作。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>PEKS加密</title>
    <url>/2025/07/02/PEKS%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通俗地讲解一下 <strong>PEKS（Public Key Encryption with Keyword Search）</strong> 的 <strong>加密流程</strong>。</p>
<span id="more"></span>
<h2 id="🧠-先建立思维图景">🧠 先建立思维图景</h2>
<blockquote>
<p>我们的目标是：用公开密钥对关键词加密（不是整个文件！），使得服务端可以根据你提交的“搜索陷门”（Trapdoor）来判断哪些加密关键词是匹配的，但却<strong>无法得知关键词是什么</strong>。</p>
</blockquote>
<hr>
<h2 id="📦-一、PEKS-体系结构四个核心算法">📦 一、PEKS 体系结构四个核心算法</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Gen()</code></td>
<td>生成密钥对（公钥/私钥）</td>
</tr>
<tr>
<td><code>PEKS(PK, w)</code></td>
<td>用公钥对关键词 <code>w</code> 进行加密（得出 PEKS 密文）</td>
</tr>
<tr>
<td><code>Trapdoor(SK, w)</code></td>
<td>用私钥为关键词 <code>w</code> 生成一个陷门</td>
</tr>
<tr>
<td><code>Test(C, Tw)</code></td>
<td>判断 PEKS 密文 <code>C</code> 是否和陷门 <code>Tw</code> 匹配（服务器用）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🧪-二、流程演示：一步步来（通俗化-图示）">🧪 二、流程演示：一步步来（通俗化 + 图示）</h2>
<p>假设数据拥有者 Alice，想上传包含关键词 “salary” 的加密文档，并让未来某人（或她自己）能搜索这个关键词。</p>
<h3 id="第一步：密钥生成">第一步：密钥生成</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(PK, SK) ← Gen()</span><br></pre></td></tr></table></figure>
<ul>
<li>Alice 生成一对公钥 PK 和私钥 SK。</li>
<li>公钥会用于加密关键词。</li>
<li>私钥仅自己保留，用于生成搜索陷门。</li>
</ul>
<hr>
<h3 id="第二步：关键词加密（PEKS）">第二步：关键词加密（PEKS）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">C ← PEKS(PK, <span class="string">&quot;salary&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Alice 把关键词 <code>&quot;salary&quot;</code> 用公钥加密，生成一个密文 <code>C</code>（不是加密文本，而是加密关键词！）</li>
<li>这个 <code>C</code> 会与文档一起存入云端。</li>
</ul>
<p>云平台只知道：文件 X 关联了某个加密标签 <code>C</code>，但不知道 <code>C</code> 是哪个词。</p>
<hr>
<h3 id="第三步：搜索陷门生成（Trapdoor）">第三步：搜索陷门生成（Trapdoor）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Tw ← Trapdoor(SK, <span class="string">&quot;salary&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>用户 Bob 想找包含“salary”的文件。</li>
<li>他从 Alice 得到 SK 或她帮忙生成陷门。</li>
<li>用私钥对 “salary” 生成陷门 <code>Tw</code>，并交给服务器。</li>
</ul>
<hr>
<h3 id="第四步：云端匹配（Test）">第四步：云端匹配（Test）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Test(C, Tw) → <span class="literal">true</span> or <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>云端服务器使用 <code>Test</code> 算法，把陷门 <code>Tw</code> 和存储的密文 <code>C</code> 一一比较。</li>
<li>如果 <code>Test(C, Tw) == true</code>，说明该文件匹配关键词“salary”。</li>
</ul>
<p>服务器从头到尾：</p>
<ul>
<li>看不到关键词原文；</li>
<li>无法解密文件内容；</li>
<li>只能做“是否匹配”的判断。</li>
</ul>
<hr>
<h2 id="🔐-三、底层原理简述（略技术）">🔐 三、底层原理简述（略技术）</h2>
<p>PEKS 原始论文（Boneh et al., 2004）提出的方案用到了：</p>
<ul>
<li>RSA 或双线性对（Bilinear Pairings）</li>
<li>加密哈希函数：对关键词做哈希再加密</li>
<li>Trapdoor 是构造能与密文比较的“钥匙”</li>
</ul>
<p>大致思路是：</p>
<ul>
<li>对关键词 <code>w</code> 做哈希 <code>H(w)</code></li>
<li>然后用某种加密算法处理这个值（如群指数、椭圆曲线）</li>
<li>使得陷门 <code>Tw</code> 能被用于与密文 <code>PEKS(w')</code> 作数学上的“测试”</li>
</ul>
<hr>
<h2 id="🧾-四、实际应用示意图">🧾 四、实际应用示意图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------------------+</span><br><span class="line">|   数据拥有者 Alice       |</span><br><span class="line">|--------------------------|</span><br><span class="line">| 文档内容 + &quot;salary&quot;     |</span><br><span class="line">| 生成 PK, SK              |</span><br><span class="line">| PEKS(PK, &quot;salary&quot;) → C   |</span><br><span class="line">| 上传文档 + C 到云端      |</span><br><span class="line">+--------------------------+</span><br><span class="line">              ↓</span><br><span class="line">+--------------------------+</span><br><span class="line">|    云平台服务器          |</span><br><span class="line">|--------------------------|</span><br><span class="line">| 存了文档 + C             |</span><br><span class="line">| 收到 Trapdoor(SK, &quot;salary&quot;) → Tw |</span><br><span class="line">| Test(C, Tw) → true      |</span><br><span class="line">| 返回匹配的文档ID         |</span><br><span class="line">+--------------------------+</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之双线性映射</title>
    <url>/2025/07/02/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当然可以！下面是对“一、双线性对：通俗讲解复习”这一节的<strong>重新编写</strong>，内容更详细、比喻更丰富，完全为没有抽象代数基础的读者设计，确保真正理解双线性对的<strong>是什么、有什么用、为什么重要</strong>。</p>
<hr>
<h2 id="🧩-一、双线性对：从0开始的通俗讲解">🧩 一、双线性对：从0开始的通俗讲解</h2>
<h3 id="🟢-1-从最熟悉的数学说起：加法和乘法的关系">🟢 1. 从最熟悉的数学说起：加法和乘法的关系</h3>
<p>小时候一定学过这样的规律：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>⋅</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⋅</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \cdot b) + (a \cdot c) = a \cdot (b + c)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></span></p>
<p>这说明：乘法对加法是“线性的”——乘法可以分布在加法上。</p>
<p>数学家把“具有线性特性”的东西统称为 <strong>线性映射</strong>。<br>
而当一个函数在<strong>两个变量上都具有线性特性</strong>时，它就叫<strong>双线性映射（Bilinear Mapping）</strong>。</p>
<p>我们来看个简单的例子：</p>
<hr>
<h3 id="🧮-2-什么是“双线性”函数？（举例子）">🧮 2. 什么是“双线性”函数？（举例子）</h3>
<p>假设有这样一个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x, y) = x \cdot y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，你可以试试：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>⋅</mo><mn>3</mn><mo>=</mo><mn>6</mn><mspace linebreak="newline"></mspace><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>18</mn><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(2, 3) = 2 \cdot 3 = 6 \\
f(2+4, 3) = f(6, 3) = 18 = f(2, 3) + f(4, 3)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></p>
<p>也就是说：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1 + x_2, y) = f(x_1, y) + f(x_2, y)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span></p>
<p>同时也成立：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x, y_1 + y_2) = f(x, y_1) + f(x, y_2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>这样的函数，我们就称之为“双线性函数”。</p>
<hr>
<h3 id="🔁-3-那什么是“双线性对”？（pairing）">🔁 3. 那什么是“双线性对”？（pairing）</h3>
<p>现在我们把场景搬到密码学使用的群结构中。</p>
<p>我们引入三个群：</p>
<table>
<thead>
<tr>
<th>群</th>
<th>是什么</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>第一个群，元素可以是椭圆曲线上的点</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>第二个群，也是一组特殊点</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">G_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>目标群，用来存储结果（通常是整数或其他字段元素）</td>
</tr>
</tbody>
</table>
<p>我们定义一个函数：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo>:</mo><msub><mi>G</mi><mn>1</mn></msub><mo>×</mo><msub><mi>G</mi><mn>2</mn></msub><mo>→</mo><msub><mi>G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">e: G_1 \times G_2 \rightarrow G_T
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这就是<strong>pairing 函数</strong>，也叫<strong>双线性对</strong>。</p>
<p>它接收两个输入，分别来自 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，输出一个值在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">G_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中。</p>
<hr>
<h3 id="🎯-4-pairing-函数必须满足什么条件？">🎯 4. pairing 函数必须满足什么条件？</h3>
<h4 id="✅-1-双线性（最重要的魔法）">✅ 1. 双线性（最重要的魔法）</h4>
<p>对于任意整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span></span></span>，点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∈</mo><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>Q</mi><mo>∈</mo><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P \in G_1, Q \in G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，有：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>a</mi><mi>P</mi><mo separator="true">,</mo><mi>b</mi><mi>Q</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>Q</mi><msup><mo stretchy="false">)</mo><mrow><mi>a</mi><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e(aP, bQ) = e(P, Q)^{ab}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ab</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这相当于说：</p>
<ul>
<li>如果你把 P 点放大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 倍、Q 点放大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 倍</li>
<li>那么 pairing 的结果就相当于：原始 pairing 的结果再“提升到 ab 次方”</li>
</ul>
<p>📌 <strong>这个指数转换能力是 pairing 最大的魔力</strong><br>
它能把点之间的运算变成指数之间的关系！</p>
<hr>
<h4 id="✅-2-非退化（不能恒等于-1）">✅ 2. 非退化（不能恒等于 1）</h4>
<p>我们希望 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>Q</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">e(P, Q) \neq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>（也就是说，不是无论输入什么都输出 1），这样 pairing 才有实际用途。</p>
<h4 id="✅-3-可计算（算法能在合理时间内算出来）">✅ 3. 可计算（算法能在合理时间内算出来）</h4>
<p>pairing 必须要能用程序实现，不能只是数学理论。</p>
<hr>
<h3 id="🔁-5-pairing-的形象比喻（非常重要）">🔁 5. pairing 的形象比喻（非常重要）</h3>
<p>你可以把 pairing 函数想象成一个“智能转换器”，它的作用是：</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
<th>保留了什么</th>
</tr>
</thead>
<tbody>
<tr>
<td>椭圆曲线上的点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo separator="true">,</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P, Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span></span></span></span></td>
<td>数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></td>
<td>指数关系，例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>P</mi><mo separator="true">,</mo><mi>b</mi><mi>Q</mi><mo>→</mo><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">aP, bQ \rightarrow ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span></span></span></span></td>
</tr>
</tbody>
</table>
<hr>
<h4 id="🎨-类比生活场景：">🎨 类比生活场景：</h4>
<p>假设：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>：代表一封加密邮件</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>：代表一个用户身份</li>
<li>pairing 就是一个验证器</li>
</ul>
<p>它能算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(P, Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)</span></span></span></span>，并且这个值具有很强的<strong>一致性和可验证性</strong>，而且别人不能仿造！</p>
<hr>
<h3 id="🚀-6-pairing-在密码学的用处">🚀 6. pairing 在密码学的用处</h3>
<p>因为 pairing 保留了倍数/指数的关系，它非常适合做这些事：</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>pairing 做了什么</th>
</tr>
</thead>
<tbody>
<tr>
<td>身份加密（IBE）</td>
<td>让邮箱当公钥，不用发证书</td>
</tr>
<tr>
<td>可搜索加密（PEKS）</td>
<td>让云端可以搜索关键词但看不到原文</td>
</tr>
<tr>
<td>BLS 签名</td>
<td>用 pairing 验证签名合法性，签名特别短</td>
</tr>
<tr>
<td>属性加密</td>
<td>用 pairing 判断用户是否满足访问条件</td>
</tr>
</tbody>
</table>
<blockquote>
<p>pairing 是这些现代密码机制的“发动机”。</p>
</blockquote>
<hr>
<h2 id="💻-二、Go-实现-pairing-验证（基础）">💻 二、Go 实现 pairing 验证（基础）</h2>
<p>使用 <a href="https://pkg.go.dev/github.com/cloudflare/bn256">Cloudflare 的 bn256</a> 库。</p>
<h3 id="✅-pairing-验证公式：">✅ pairing 验证公式：</h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>a</mi><mi>P</mi><mo separator="true">,</mo><mi>b</mi><mi>Q</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>Q</mi><msup><mo stretchy="false">)</mo><mrow><mi>a</mi><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e(aP, bQ) = e(P, Q)^{ab}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ab</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/cloudflare/bn256&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, _ := rand.Int(rand.Reader, bn256.Order)</span><br><span class="line">	b, _ := rand.Int(rand.Reader, bn256.Order)</span><br><span class="line"></span><br><span class="line">	P := <span class="built_in">new</span>(bn256.G1).ScalarBaseMult(big.NewInt(<span class="number">1</span>))</span><br><span class="line">	Q := <span class="built_in">new</span>(bn256.G2).ScalarBaseMult(big.NewInt(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">	aP := <span class="built_in">new</span>(bn256.G1).ScalarMult(P, a)</span><br><span class="line">	bQ := <span class="built_in">new</span>(bn256.G2).ScalarMult(Q, b)</span><br><span class="line"></span><br><span class="line">	p1 := bn256.Pair(aP, bQ)</span><br><span class="line">	p2 := bn256.Pair(P, Q)</span><br><span class="line">	ab := <span class="built_in">new</span>(big.Int).Mul(a, b)</span><br><span class="line">	p2.Exp(p2, ab)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;e(aP,bQ) == e(P,Q)^ab ?&quot;</span>, p1.String() == p2.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e(aP,bQ) == e(P,Q)^ab ? true</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🔍-三、什么是-PEKS？">🔍 三、什么是 PEKS？</h2>
<h3 id="✅-问题背景">✅ 问题背景</h3>
<ul>
<li>你加密了一堆邮件或文件，存在云端</li>
<li>你希望“搜索关键词”（如 “salary”）而<strong>不暴露内容</strong></li>
<li>更重要的是，云服务商<strong>不能解密原文</strong></li>
</ul>
<h3 id="✅-PEKS（Public-Key-Encryption-with-Keyword-Search）">✅ PEKS（Public Key Encryption with Keyword Search）</h3>
<p>PEKS 是一种加密方法，它可以：</p>
<ul>
<li>让云端使用“陷门”检查某密文是否包含某关键词</li>
<li>但云端无法知道关键词或密文内容</li>
</ul>
<p>它的核心机制就依赖 <strong>pairing（双线性对）</strong>。</p>
<hr>
<h2 id="⚙️-四、PEKS-架构与原理">⚙️ 四、PEKS 架构与原理</h2>
<p>参考 Boneh 等人在 2004 年提出的 PEKS 系统。</p>
<h3 id="参与者">参与者</h3>
<ul>
<li><strong>发送方</strong>：加密关键词</li>
<li><strong>接收方</strong>：生成陷门（trapdoor）</li>
<li><strong>服务器</strong>：判断密文是否匹配陷门（不可得出关键词）</li>
</ul>
<h3 id="核心结构">核心结构</h3>
<ol>
<li>
<p>公钥系统：基于 pairing 的椭圆曲线系统</p>
</li>
<li>
<p>PEKS 密文结构：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mo>⋅</mo><mi>P</mi><mo separator="true">,</mo><mi>H</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>⊕</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mrow><mi>p</mi><mi>u</mi><mi>b</mi></mrow></msub><mo separator="true">,</mo><mi>H</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, B) = (r \cdot P, H(w) \oplus e(P_{pub}, H(w))^r)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>判断式（在服务器上）：<br>
检查：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>H</mi><mo stretchy="false">(</mo><msup><mi>w</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">e(A, H(w&#x27;)) = B&#x27;
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ol>
<hr>
<h2 id="🛠️-五、Go-实现-PEKS-系统">🛠️ 五、Go 实现 PEKS 系统</h2>
<p>一个简化版系统：</p>
<ul>
<li>使用 SHA256 代替曲线上的 hash-to-point</li>
<li>模拟关键步骤，让你理解 PEKS 的 pairing 工作方式</li>
</ul>
<h3 id="📁-go-mod">📁 go.mod</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module peks-demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.20</span></span><br><span class="line"></span><br><span class="line">require github.com/cloudflare/bn256 v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20230823074015</span><span class="number">-81</span>eab1aa433a</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="📄-main-go">📄 main.go</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/cloudflare/bn256&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把关键词转为 G1 群中的点（模拟 hash-to-curve）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashToG1</span><span class="params">(keyword <span class="type">string</span>)</span></span> *bn256.G1 &#123;</span><br><span class="line">	hash := sha256.Sum256([]<span class="type">byte</span>(keyword))</span><br><span class="line">	h := <span class="built_in">new</span>(big.Int).SetBytes(hash[:])</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(bn256.G1).ScalarBaseMult(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥对结构</span></span><br><span class="line"><span class="keyword">type</span> KeyPair <span class="keyword">struct</span> &#123;</span><br><span class="line">	Priv *big.Int</span><br><span class="line">	Pub  *bn256.G2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成密钥对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateKeyPair</span><span class="params">()</span></span> KeyPair &#123;</span><br><span class="line">	x, _ := rand.Int(rand.Reader, bn256.Order)</span><br><span class="line">	Pub := <span class="built_in">new</span>(bn256.G2).ScalarBaseMult(x)</span><br><span class="line">	<span class="keyword">return</span> KeyPair&#123;Priv: x, Pub: Pub&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PEKS 加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PEKS</span><span class="params">(pubKey *bn256.G2, keyword <span class="type">string</span>)</span></span> (A *bn256.G1, B *bn256.GT) &#123;</span><br><span class="line">	r, _ := rand.Int(rand.Reader, bn256.Order)</span><br><span class="line">	Hw := hashToG1(keyword)</span><br><span class="line">	A = <span class="built_in">new</span>(bn256.G1).ScalarBaseMult(r)</span><br><span class="line">	B = bn256.Pair(Hw, pubKey)</span><br><span class="line">	B.Exp(B, r)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成陷门</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trapdoor</span><span class="params">(privKey *big.Int, keyword <span class="type">string</span>)</span></span> *bn256.G1 &#123;</span><br><span class="line">	Hw := hashToG1(keyword)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(bn256.G1).ScalarMult(Hw, privKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查关键词是否匹配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(A *bn256.G1, B *bn256.GT, Tw *bn256.G1)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	pair := bn256.Pair(A, Tw)</span><br><span class="line">	<span class="keyword">return</span> pair.String() == B.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 关键词加密方</span></span><br><span class="line">	keyword := <span class="string">&quot;salary&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用户生成密钥对</span></span><br><span class="line">	keys := generateKeyPair()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加密关键词</span></span><br><span class="line">	A, B := PEKS(keys.Pub, keyword)</span><br><span class="line">	fmt.Println(<span class="string">&quot;🔐 PEKS 密文生成完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 收件人生成陷门</span></span><br><span class="line">	tw := Trapdoor(keys.Priv, <span class="string">&quot;salary&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器测试匹配</span></span><br><span class="line">	result := Test(A, B, tw)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;💡 关键词匹配结果: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误关键词测试</span></span><br><span class="line">	twWrong := Trapdoor(keys.Priv, <span class="string">&quot;bonus&quot;</span>)</span><br><span class="line">	resultWrong := Test(A, B, twWrong)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;🧪 错误关键词测试结果: %v\n&quot;</span>, resultWrong)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧪-示例输出">🧪 示例输出</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">🔐 PEKS 密文生成完毕</span><br><span class="line">💡 关键词匹配结果: true</span><br><span class="line">🧪 错误关键词测试结果: false</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>科研</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>PKEET加密</title>
    <url>/2025/07/09/PKEET%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="带等式测试的公钥加密（PKEET）通俗讲解与数学原理分析">带等式测试的公钥加密（PKEET）通俗讲解与数学原理分析</h1>
<h2 id="一、什么是-PKEET？">一、什么是 PKEET？</h2>
<p><strong>带等式测试的公钥加密（Public Key Encryption with Equality Test, PKEET）</strong>，是一种在<strong>保密信息</strong>的同时，允许受信方判断两个密文是否加密了<strong>相同明文</strong>的加密方案。</p>
<p>你可以把它看作是“带比较功能的加密”，即：</p>
<blockquote>
<p><strong>不解密、不泄密、可判断内容是否一致。</strong></p>
</blockquote>
<hr>
<h2 id="二、为什么需要-PKEET？">二、为什么需要 PKEET？</h2>
<p>现实中有很多隐私场景中，我们只想知道两个值是否一样，而不想暴露值本身，例如：</p>
<ul>
<li>医院之间是否接诊了同一个癌症患者？</li>
<li>银行之间是否共享了同一个风险客户？</li>
<li>匿名用户之间是否喜欢了同一部电影？</li>
<li>云存储中是否上传了重复的加密文件？</li>
</ul>
<p>这时候就需要一种“<strong>可比较但不可识破</strong>”的加密机制，PKEET 就是为这些场景而生的。</p>
<hr>
<h2 id="三、PKEET-的基本功能">三、PKEET 的基本功能</h2>
<p>PKEET 主要提供六个算法组件：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Setup</td>
<td>系统初始化，生成主密钥</td>
</tr>
<tr>
<td>KeyGen</td>
<td>用户生成自己的公钥和私钥</td>
</tr>
<tr>
<td>Encrypt</td>
<td>加密明文并生成可测试的密文</td>
</tr>
<tr>
<td>Decrypt</td>
<td>使用私钥恢复明文</td>
</tr>
<tr>
<td>TestKeyGen</td>
<td>为受信方生成等式测试密钥</td>
</tr>
<tr>
<td>Test</td>
<td>判断两个密文是否加密了相同的明文</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四、类比生活：加密后的“指纹比对”">四、类比生活：加密后的“指纹比对”</h2>
<p>我们可以把 PKEET 想象成：</p>
<ul>
<li>把明文变成一个只有授权人才能识别的“指纹”；</li>
<li>密文中藏着这个“指纹”；</li>
<li>授权方可以把两个指纹对一下，判断是否是同一个人；</li>
<li>但看不出指纹代表谁。</li>
</ul>
<hr>
<h2 id="五、数学原理解析：一个基于双线性对的-PKEET-实现">五、数学原理解析：一个基于双线性对的 PKEET 实现</h2>
<p>现在我们深入到一个经典实现：基于**双线性对（Bilinear Pairing）**的 PKEET。</p>
<h3 id="1-数学基础">1. 数学基础</h3>
<p>设：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G_1, G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是两个椭圆曲线群，阶为素数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><msub><mi>G</mi><mn>1</mn></msub><mo>×</mo><msub><mi>G</mi><mn>2</mn></msub><mo>→</mo><msub><mi>G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">e: G_1 \times G_2 \rightarrow G_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个非退化、双线性、可计算的配对函数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>∈</mo><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">g_1 \in G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>2</mn></msub><mo>∈</mo><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">g_2 \in G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是生成元</li>
</ul>
<h3 id="2-算法结构">2. 算法结构</h3>
<hr>
<h4 id="🔧-Setup（系统初始化）">🔧 Setup（系统初始化）</h4>
<ul>
<li>选择私有主密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\alpha \in \mathbb{Z}_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>设置主公钥为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>p</mi><mi>u</mi><mi>b</mi></mrow></msub><mo>=</mo><msubsup><mi>g</mi><mn>2</mn><mi>α</mi></msubsup><mo>∈</mo><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_{pub} = g_2^\alpha \in G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9125em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>系统参数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mi>T</mi></msub><mo separator="true">,</mo><mi>e</mi><mo separator="true">,</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mrow><mi>p</mi><mi>u</mi><mi>b</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G_1, G_2, G_T, e, g_1, g_2, P_{pub})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<hr>
<h4 id="🔐-KeyGen（用户密钥生成）">🔐 KeyGen（用户密钥生成）</h4>
<p>用户选择私钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>k</mi><mo>=</mo><mi>x</mi><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">sk = x \in \mathbb{Z}_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>计算公钥：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo><msubsup><mi>g</mi><mn>1</mn><mi>x</mi></msubsup><mo>∈</mo><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">pk_1 = g_1^x \in G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9125em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msub><mi>k</mi><mn>2</mn></msub><mo>=</mo><msubsup><mi>g</mi><mn>2</mn><mi>x</mi></msubsup><mo>∈</mo><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">pk_2 = g_2^x \in G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9125em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<hr>
<h4 id="🔏-Encrypt（加密）">🔏 Encrypt（加密）</h4>
<p>给定明文 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">m \in \mathbb{Z}_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，选择随机 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">r \in \mathbb{Z}_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><msubsup><mi>g</mi><mn>1</mn><mi>r</mi></msubsup><mo>∈</mo><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1 = g_1^r \in G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9125em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub><mo>=</mo><mi>p</mi><msubsup><mi>k</mi><mn>2</mn><mi>r</mi></msubsup><mo>∈</mo><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2 = pk_2^r \in G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9425em;vertical-align:-0.2481em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>3</mn></msub><mo>=</mo><mi>m</mi><mo>⋅</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mrow><mi>p</mi><mi>u</mi><mi>b</mi></mrow></msub><mo separator="true">,</mo><mi>p</mi><msub><mi>k</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mo>∈</mo><msub><mi>G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">C_3 = m \cdot e(P_{pub}, pk_2)^r \in G_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><strong>Tag = H(m)</strong>（哈希明文生成标签）</li>
</ul>
<p>最终密文为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>3</mn></msub><mo separator="true">,</mo><mi>T</mi><mi>a</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CT = (C_1, C_2, C_3, Tag)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span></p>
<hr>
<h4 id="🔓-Decrypt（解密）">🔓 Decrypt（解密）</h4>
<p>用私钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>k</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">sk = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 解密：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><mfrac><msub><mi>C</mi><mn>3</mn></msub><mrow><mi>e</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>p</mi><msubsup><mi>k</mi><mn>2</mn><mi>α</mi></msubsup><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><msub><mi>C</mi><mn>3</mn></msub><mrow><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>g</mi><mn>1</mn><mi>r</mi></msubsup><mo separator="true">,</mo><msubsup><mi>g</mi><mn>2</mn><mrow><mi>x</mi><mi>α</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">m = \frac{C_3}{e(C_1, pk_2^\alpha)} = \frac{C_3}{e(g_1^r, g_2^{x\alpha})}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3126em;vertical-align:-0.9523em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6462em;"><span style="top:-2.4337em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9523em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3126em;vertical-align:-0.9523em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6462em;"><span style="top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6462em;"><span style="top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">xα</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9523em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>因为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>C</mi><mn>3</mn></msub><mo>=</mo><mi>m</mi><mo>⋅</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mrow><mi>p</mi><mi>u</mi><mi>b</mi></mrow></msub><mo separator="true">,</mo><mi>p</mi><msub><mi>k</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mo>=</mo><mi>m</mi><mo>⋅</mo><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>g</mi><mn>2</mn><mi>α</mi></msubsup><mo separator="true">,</mo><msubsup><mi>g</mi><mn>2</mn><mi>x</mi></msubsup><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mo>=</mo><mi>m</mi><mo>⋅</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mrow><mi>α</mi><mi>x</mi><mi>r</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C_3 = m \cdot e(P_{pub}, pk_2)^r = m \cdot e(g_2^\alpha, g_2^x)^r = m \cdot e(g_2, g_2)^{\alpha x r}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">αx</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<h4 id="🧪-TestKeyGen（生成等式测试密钥）">🧪 TestKeyGen（生成等式测试密钥）</h4>
<p>系统为某个用户生成等式测试密钥：</p>
<ul>
<li>令该用户的授权密钥为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>K</mi><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">TK = \alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>，只暴露等式测试功能</li>
</ul>
<p>或者直接发布一个用于测试的函数，输入两个 Tag 对比即可。</p>
<hr>
<h4 id="✅-Test（等式测试）">✅ Test（等式测试）</h4>
<p>判断两个密文是否是相同明文加密：</p>
<ul>
<li>比较两者的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>：即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Tag</mtext><mn>1</mn></msub><mo><mover><mo><mo>=</mo></mo><mo stretchy="false" lspace="0em" rspace="0em">?</mo></mover></mo><msub><mtext>Tag</mtext><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\text{Tag}_1 \stackrel{?}{=} \text{Tag}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3971em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord text"><span class="mord">Tag</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.153em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mclose mtight">?</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9275em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord text"><span class="mord">Tag</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>由于 Tag 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，而 H 是不可逆的哈希，无法通过 Tag 恢复 m，但相等说明原始 m 相等。</p>
<hr>
<h2 id="六、安全性分析">六、安全性分析</h2>
<h3 id="安全目标">安全目标</h3>
<table>
<thead>
<tr>
<th>安全性质</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>语义安全性</td>
<td>未授权者不能从密文中恢复明文</td>
</tr>
<tr>
<td>标签隐藏性</td>
<td>Tag 不可逆，即使泄露也无法获取明文</td>
</tr>
<tr>
<td>可控等式测试</td>
<td>只有授权者才能执行 Test 操作</td>
</tr>
</tbody>
</table>
<h3 id="抗攻击性">抗攻击性</h3>
<ul>
<li>对标签的保护依赖于哈希函数抗碰撞性；</li>
<li>对明文保护依赖双线性对的 Decisional Bilinear Diffie-Hellman 假设（DBDH）。</li>
</ul>
<hr>
<h2 id="七、PKEET-应用实例">七、PKEET 应用实例</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>医疗病例比对</td>
<td>医院之间加密病例，通过等式测试判断是否是同一患者</td>
</tr>
<tr>
<td>银行黑名单共享</td>
<td>不泄露客户身份的前提下识别重复嫌疑人</td>
</tr>
<tr>
<td>社交匹配平台</td>
<td>双方兴趣标签加密，通过等式测试发现匹配</td>
</tr>
<tr>
<td>云存储去重</td>
<td>加密文件上传，平台判断是否重复</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="八、小结与展望">八、小结与展望</h2>
<p>PKEET 是在传统加密之上增强了一种“加密下可比较性”的能力，它既保留了隐私保护的优点，又提升了数据的交互性和可用性。在数据共享日益频繁而隐私问题突出的今天，PKEET 可能会在医疗、金融、社交和云计算等多个领域成为核心加密工具。</p>
<p>未来研究还可能聚焦在：</p>
<ul>
<li>支持模糊匹配的 PKEET</li>
<li>高效标签生成与压缩</li>
<li>与可搜索加密（PEKS）的融合</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言之接口指针误区</title>
    <url>/2025/07/05/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%8E%A5%E5%8F%A3%E6%8C%87%E9%92%88%E8%AF%AF%E5%8C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🧠-Go语言接口误区解析：为什么不能使用-Interface？">🧠 Go语言接口误区解析：为什么不能使用 <code>[]*Interface</code>？</h1>
<h2 id="📝-前言">📝 前言</h2>
<p>在 Go 语言中，接口是实现“面向抽象编程”的关键工具。很多初学者在使用接口切片时会犯一个<strong>常见错误</strong>：将接口类型声明为指针切片 <code>[]*Interface</code>。一旦这样写，Go 编译器就会报出如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cannot use x (variable of type *MyStruct) as *MyInterface value in argument to append:</span><br><span class="line">*MyStruct does not implement *MyInterface (type *MyInterface is pointer to interface, not interface)</span><br></pre></td></tr></table></figure>
<p>这到底是为什么？本篇文章将从实战场景出发，深入剖析背后的机制，并给出正确写法。</p>
<hr>
<h2 id="❌-错误示例：-Interface-是什么？">❌ 错误示例：*Interface 是什么？</h2>
<p>假设我们想维护一个接口类型的切片，并将实现类注册进去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    DoWork()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> System <span class="keyword">struct</span> &#123;</span><br><span class="line">    Workers []*MyInterface  <span class="comment">// ❌ 错误：不应该是指针接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这个接口的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> DoWork() &#123;</span><br><span class="line">    fmt.Println(w.Name, <span class="string">&quot;is working&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们想注册一个 <code>*Worker</code> 实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sys := &amp;System&#123;&#125;</span><br><span class="line">worker := &amp;Worker&#123;Name: <span class="string">&quot;Alice&quot;</span>&#125;</span><br><span class="line">sys.Workers = <span class="built_in">append</span>(sys.Workers, worker)</span><br></pre></td></tr></table></figure>
<p>结果编译器报错：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot use worker (<span class="keyword">type</span> *Worker) as <span class="keyword">type</span> *MyInterface in <span class="built_in">append</span></span><br></pre></td></tr></table></figure>
<h3 id="😵-原因解析">😵 原因解析</h3>
<blockquote>
<p><code>*MyInterface</code> 是“<strong>指向接口的指针</strong>”，但在 Go 中接口本身已经是一个引用类型！</p>
</blockquote>
<p>换句话说：</p>
<ul>
<li>
<p><code>MyInterface</code> 是接口 ✅</p>
</li>
<li>
<p><code>*MyInterface</code> 是“指向接口的指针” ❌ —— Go 根本不允许这种类型的存在！</p>
</li>
</ul>
<hr>
<h2 id="✅-正确做法：接口是引用类型，直接用-MyInterface">✅ 正确做法：接口是引用类型，直接用 <code>[]MyInterface</code></h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> System <span class="keyword">struct</span> &#123;</span><br><span class="line">    Workers []MyInterface  <span class="comment">// ✅ 正确：接口本身是引用类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以放心地将实现接口的结构体指针加入进去：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sys := &amp;System&#123;&#125;</span><br><span class="line">worker := &amp;Worker&#123;Name: <span class="string">&quot;Alice&quot;</span>&#125;</span><br><span class="line">sys.Workers = <span class="built_in">append</span>(sys.Workers, worker)  <span class="comment">// ✅ 正常</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>*Worker</code> 实现了 <code>MyInterface</code>，可以自动被赋值给 <code>MyInterface</code> 类型。</p>
<hr>
<h2 id="📦-延伸知识：结构体-vs-指针接收者实现接口">📦 延伸知识：结构体 vs 指针接收者实现接口</h2>
<p>在 Go 中，<strong>只有结构体或其指针的“方法集”完整实现接口的方法集，才能认为实现了接口</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    DoWork()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span></span> DoWork() &#123; ... &#125;      <span class="comment">// 实现了接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> DoWork() &#123; ... &#125;     <span class="comment">// 也可以实现接口（常见）</span></span><br></pre></td></tr></table></figure>
<h3 id="总结：">总结：</h3>
<table>
<thead>
<tr>
<th>方法定义</th>
<th>能否让 <code>Worker</code> 实现接口</th>
<th>能否让 <code>*Worker</code> 实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(w Worker)</code></td>
<td>✅ 是</td>
<td>✅ 是（值自动取地址）</td>
</tr>
<tr>
<td><code>(*w Worker)</code></td>
<td>❌ 否（值不能用）</td>
<td>✅ 是</td>
</tr>
</tbody>
</table>
<p>建议：<strong>接口方法接收者多数使用 <code>*T</code>，以便避免值复制和保持一致性。</strong></p>
<hr>
<h2 id="💡-实战建议">💡 实战建议</h2>
<ul>
<li>
<p>始终使用 <code>[]Interface</code>，不要使用 <code>[]*Interface</code></p>
</li>
<li>
<p>实现接口的结构体通常使用指针接收者（<code>*T</code>）</p>
</li>
<li>
<p>接口是引用类型，不要再取地址（<code>&amp;iface</code> 是没有意义的）</p>
</li>
<li>
<p>若你持有的是多个类型实例，实现接口是最佳解耦方式</p>
</li>
</ul>
<hr>
<h2 id="🧾-小结">🧾 小结</h2>
<table>
<thead>
<tr>
<th>错误写法</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]*Interface</code></td>
<td>Go 中接口本身就是引用类型，无需加 <code>*</code></td>
</tr>
<tr>
<td><code>*Interface</code> 参数</td>
<td>Go 不允许指针指向接口类型</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>正确写法</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]Interface</code></td>
<td>保持接口多态、模块解耦</td>
</tr>
<tr>
<td><code>*Struct</code> 实现接口</td>
<td>避免值复制，更灵活</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Python速通</title>
    <url>/2025/09/20/Python%E9%80%9F%E9%80%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python-实用速成教程（科研导向，完整版）">Python 实用速成教程（科研导向，完整版）</h1>
<blockquote>
<p>面向已经掌握其他编程语言的程序员，帮助快速掌握 Python 的科研常用技能。强调<strong>实用性、完整性和清晰表达</strong>，避免炫技写法。</p>
</blockquote>
<hr>
<h2 id="1-环境准备">1. 环境准备</h2>
<p>推荐方式：使用虚拟环境管理依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">python3 -m venv venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate   <span class="comment"># Linux / Mac</span></span><br><span class="line">venv\Scripts\activate      <span class="comment"># Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装科学计算常用包</span></span><br><span class="line">pip install numpy scipy pandas matplotlib jupyter</span><br></pre></td></tr></table></figure>
<p>启动 Jupyter Notebook：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-基本语法">2. 基本语法</h2>
<h3 id="2-1-变量与数据类型">2.1 变量与数据类型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>           <span class="comment"># 整数</span></span><br><span class="line">pi = <span class="number">3.14</span>        <span class="comment"># 浮点数</span></span><br><span class="line">name = <span class="string">&quot;Alan&quot;</span>    <span class="comment"># 字符串</span></span><br><span class="line">flag = <span class="literal">True</span>      <span class="comment"># 布尔值</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-条件语句">2.2 条件语句</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正数&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;零&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;负数&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-循环">2.3 循环</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环&quot;</span>, count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-常用数据结构">3. 常用数据结构</h2>
<h3 id="3-1-列表">3.1 列表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">nums.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="3-2-字典">3.2 字典</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alan&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安全访问</span></span><br><span class="line"><span class="built_in">print</span>(person.get(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;未知&quot;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="3-3-集合">3.3 集合</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.add(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-函数与模块">4. 函数与模块</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(greet(<span class="string">&quot;Alan&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>导入模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">16</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-文件与数据读写">5. 文件与数据读写</h2>
<h3 id="5-1-文本文件">5.1 文本文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line.strip())</span><br></pre></td></tr></table></figure>
<h3 id="5-2-CSV-文件">5.2 CSV 文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>
<h3 id="5-3-JSON-文件">5.3 JSON 文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.json&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&quot;param&quot;</span>])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-NumPy-基础">6. NumPy 基础</h2>
<h3 id="6-1-创建数组">6.1 创建数组</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure>
<h3 id="6-2-数值运算">6.2 数值运算</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(arr + <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.mean())</span><br><span class="line"><span class="built_in">print</span>(arr.<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure>
<h3 id="6-3-矩阵运算">6.3 矩阵运算</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">B = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A + B)</span><br><span class="line"><span class="built_in">print</span>(A @ B)  <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-pandas-数据分析">7. pandas 数据分析</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 CSV 文件</span></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;data.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看前几行</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本统计</span></span><br><span class="line"><span class="built_in">print</span>(df.describe())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选数据</span></span><br><span class="line"><span class="built_in">print</span>(df[df[<span class="string">&quot;value&quot;</span>] &gt; <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组统计</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby(<span class="string">&quot;group&quot;</span>)[<span class="string">&quot;value&quot;</span>].mean())</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="8-Matplotlib-绘图">8. Matplotlib 绘图</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, label=<span class="string">&quot;sin(x)&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;sin(x)&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;正弦函数&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-SciPy-常用功能">9. SciPy 常用功能</h2>
<h3 id="9-1-优化">9.1 优化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line">res = minimize(<span class="keyword">lambda</span> x: (x-<span class="number">3</span>)**<span class="number">2</span>, x0=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(res.x)</span><br></pre></td></tr></table></figure>
<h3 id="9-2-统计检验">9.2 统计检验</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line">t, p = stats.ttest_ind([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1.1</span>,<span class="number">2.1</span>,<span class="number">3.1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t=&quot;</span>, t, <span class="string">&quot;p=&quot;</span>, p)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="10-并行与性能">10. 并行与性能</h2>
<h3 id="10-1-多进程">10.1 多进程</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Pool(<span class="number">4</span>) <span class="keyword">as</span> p:</span><br><span class="line">    results = p.<span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>
<h3 id="10-2-向量化替代循环">10.2 向量化替代循环</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 慢：for 循环</span></span><br><span class="line">out = [np.sin(v) <span class="keyword">for</span> v <span class="keyword">in</span> arr]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快：向量化</span></span><br><span class="line">out = np.sin(arr)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="11-实用技巧与常见陷阱">11. 实用技巧与常见陷阱</h2>
<ul>
<li>使用 <code>f&quot;...&quot;</code> 进行格式化输出。</li>
<li>文件操作时总用 <code>with open</code>，避免忘记关闭。</li>
<li>默认参数不要用可变对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, lst=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> lst <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        lst = []</span><br><span class="line">    lst.append(x)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<ul>
<li>浮点数比较时使用 <code>math.isclose()</code>。</li>
</ul>
<hr>
<h2 id="12-实践案例：科研数据分析流程">12. 实践案例：科研数据分析流程</h2>
<h3 id="步骤：读取-→-清洗-→-分析-→-可视化-→-保存结果">步骤：读取 → 清洗 → 分析 → 可视化 → 保存结果</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;experiment.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据清洗</span></span><br><span class="line">df = df.dropna()  <span class="comment"># 去掉缺失值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 基本统计</span></span><br><span class="line"><span class="built_in">print</span>(df.describe())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 分组统计</span></span><br><span class="line">summary = df.groupby(<span class="string">&quot;group&quot;</span>)[<span class="string">&quot;value&quot;</span>].mean()</span><br><span class="line"><span class="built_in">print</span>(summary)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 可视化</span></span><br><span class="line">summary.plot(kind=<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Group&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Mean Value&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;实验结果对比&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 保存结果</span></span><br><span class="line">summary.to_csv(<span class="string">&quot;summary.csv&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="13-推荐资源">13. 推荐资源</h2>
<ul>
<li><a href="https://docs.python.org/3/tutorial/">Python 官方教程</a></li>
<li><a href="https://numpy.org/doc/stable/user/index.html">NumPy 用户指南</a></li>
<li><a href="https://pandas.pydata.org/docs/">pandas 文档</a></li>
<li><a href="https://matplotlib.org/stable/tutorials/index.html">Matplotlib 教程</a></li>
<li>书籍：《Python for Data Analysis》</li>
</ul>
<hr>
<h2 id="总结">总结</h2>
<ul>
<li>Python 语法简单，重点是熟悉科学计算库。</li>
<li>科研最常用的工具链：<strong>NumPy + pandas + Matplotlib + SciPy</strong>。</li>
<li>建议从实际任务出发，边做边学。</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>科研</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity中的不可变量和常量</title>
    <url>/2025/05/04/Solidity%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="1-Constants（常量）">1. <strong>Constants（常量）</strong></h3>
<p>• <strong>定义</strong>：常量是编译时确定且永不改变的值，必须在声明时初始化。<br>
• <strong>特点</strong>：<br>
• 值在编译时硬编码到合约字节码中，不占用存储空间（节省 Gas）。<br>
• 必须是值类型（如 <code>uint</code>, <code>address</code>）或固定长度的简单类型（如 <code>bytes32</code>）。<br>
• 命名通常全大写（约定俗成）。<br>
• <strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public constant MAX_SUPPLY = 1000;</span><br><span class="line">address public constant OWNER = 0x123...;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-Immutables（不可变量）">2. <strong>Immutables（不可变量）</strong></h3>
<p>• <strong>定义</strong>：不可变量在构造函数中初始化一次，之后不可更改，但在部署时才能确定值。<br>
• <strong>特点</strong>：<br>
• 值存储在合约的代码区（而非存储槽），访问成本低于普通状态变量。<br>
• 可以是任意类型（包括复杂类型如 <code>address payable</code>）。<br>
• 适合在部署时动态赋值（如合约创建者的地址）。<br>
• <strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public immutable maxSupply;</span><br><span class="line">address public immutable owner;</span><br><span class="line"></span><br><span class="line">constructor(uint256 _maxSupply) &#123;</span><br><span class="line">    maxSupply = _maxSupply;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-关键区别">3. <strong>关键区别</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Constants</th>
<th>Immutables</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>初始化时机</strong></td>
<td>编译时</td>
<td>构造函数运行时</td>
</tr>
<tr>
<td><strong>支持类型</strong></td>
<td>简单值类型</td>
<td>任意类型</td>
</tr>
<tr>
<td><strong>Gas 成本</strong></td>
<td>最低（直接内联）</td>
<td>低（代码区存储）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>固定已知值</td>
<td>部署时动态确定的值</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="4-最佳实践">4. <strong>最佳实践</strong></h3>
<h4 id="对于-Constants：">对于 Constants：</h4>
<p>• <strong>适用场景</strong>：<br>
• 固定参数（如数学常数、固定代币小数位）。<br>
• 无需部署时动态赋值的值（如 <code>DECIMALS = 18</code>）。<br>
• <strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 public constant DECIMALS = 18;</span><br><span class="line">bytes32 public constant DEFAULT_ADMIN_ROLE = keccak256(&quot;ADMIN&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="对于-Immutables：">对于 Immutables：</h4>
<p>• <strong>适用场景</strong>：<br>
• 部署时确定的参数（如管理员地址、合约创建时间）。<br>
• 需要节省 Gas 的动态值（如代币的最大供应量）。<br>
• <strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address payable public immutable treasury;</span><br><span class="line">uint256 public immutable deploymentTime;</span><br><span class="line"></span><br><span class="line">constructor(address payable _treasury) &#123;</span><br><span class="line">    treasury = _treasury;</span><br><span class="line">    deploymentTime = block.timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通用建议：">通用建议：</h4>
<ol>
<li>
<p><strong>优先使用 Immutables</strong>：如果值需要在部署时动态赋值（如 <code>msg.sender</code>），用 <code>immutable</code>。</p>
</li>
<li>
<p><strong>优化 Gas</strong>：对频繁访问的不变量使用 <code>immutable</code> 或 <code>constant</code>，减少存储读取开销。</p>
</li>
<li>
<p><strong>安全性</strong>：通过不可变性保护关键参数（如管理员地址），防止后续被篡改。</p>
</li>
<li>
<p><strong>命名清晰</strong>：全大写命名 <code>CONSTANTS</code>，驼峰命名 <code>immutables</code>（如 <code>maxSupply</code>）。</p>
</li>
</ol>
<hr>
<h3 id="5-反模式与注意事项">5. <strong>反模式与注意事项</strong></h3>
<p>• <strong>避免滥用 Constants</strong>：复杂计算或动态值无法用 <code>constant</code>。<br>
• <strong>构造函数赋值限制</strong>：<code>immutable</code> 只能在构造函数中赋值一次。<br>
• <strong>验证输入</strong>：对 <code>immutable</code> 的构造函数参数做校验（如非零地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(address _admin) &#123;</span><br><span class="line">    require(_admin != address(0), &quot;Invalid address&quot;);</span><br><span class="line">    admin = _admin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Solidity学习</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity中的自定义错误</title>
    <url>/2025/05/03/Solidity%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Solidity 0.8.4 引入了自定义错误(Custom Errors)功能，这是一种比传统 <code>require</code> 语句更高效的错误处理方式，可以显著节省 Gas 消耗。</p>
<h2 id="为什么自定义错误能节省-Gas">为什么自定义错误能节省 Gas</h2>
<ol>
<li>
<p><strong>更小的字节码</strong>：自定义错误不需要存储错误字符串</p>
</li>
<li>
<p><strong>更低的运行时成本</strong>：回滚时只需传递 4 字节的选择器，而不是完整的字符串</p>
</li>
<li>
<p><strong>更少的存储开销</strong>：字符串错误信息需要存储在合约字节码中</p>
</li>
</ol>
<h2 id="基本语法">基本语法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义自定义错误</span><br><span class="line">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        uint256 balance = address(this).balance;</span><br><span class="line">        if (balance &lt; amount) &#123;</span><br><span class="line">            revert InsufficientBalance(balance, amount);</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最佳实践">最佳实践</h2>
<h3 id="1-为常见错误条件定义明确的错误">1. 为常见错误条件定义明确的错误</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error Unauthorized();</span><br><span class="line">error InvalidAddress();</span><br><span class="line">error ValueTooLow(uint256 min, uint256 actual);</span><br><span class="line">error DeadlineExpired(uint256 deadline);</span><br></pre></td></tr></table></figure>
<h3 id="2-在复杂合约中组织错误">2. 在复杂合约中组织错误</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library Errors &#123;</span><br><span class="line">    error Unauthorized();</span><br><span class="line">    error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    using Errors for *;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        if (msg.sender != owner) revert Errors.Unauthorized();</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-提供有用的上下文信息">3. 提供有用的上下文信息</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error TransferFailed(address from, address to, uint256 amount);</span><br><span class="line"></span><br><span class="line">function transfer(address to, uint256 amount) public &#123;</span><br><span class="line">    bool success = _transfer(msg.sender, to, amount);</span><br><span class="line">    if (!success) revert TransferFailed(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-与-require-对比">4. 与 require 对比</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 传统方式 - 消耗更多 Gas</span><br><span class="line">require(balance &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">// 自定义错误方式 - 更高效</span><br><span class="line">if (balance &lt; amount) revert InsufficientBalance(balance, amount);</span><br></pre></td></tr></table></figure>
<h3 id="5-在接口中定义错误">5. 在接口中定义错误</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IERC20 &#123;</span><br><span class="line">    error InsufficientBalance();</span><br><span class="line">    error InsufficientAllowance();</span><br><span class="line">    </span><br><span class="line">    function transfer(address to, uint256 amount) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Gas-节省示例">Gas 节省示例</h2>
<p>假设一个简单的转账合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 require</span><br><span class="line">function transferWithRequire(address to, uint256 amount) public &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[to] += amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自定义错误</span><br><span class="line">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line"></span><br><span class="line">function transferWithError(address to, uint256 amount) public &#123;</span><br><span class="line">    uint256 available = balances[msg.sender];</span><br><span class="line">    if (available &lt; amount) revert InsufficientBalance(available, amount);</span><br><span class="line">    balances[msg.sender] = available - amount;</span><br><span class="line">    balances[to] += amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Gas 消耗比较</strong>：<br>
• <code>require</code> 版本：约 22,000 Gas（成功时），失败时更高<br>
• 自定义错误版本：约 21,500 Gas（成功时），失败时显著更低</p>
<p>失败时的 Gas 节省更为明显，因为不需要存储和传递错误字符串。</p>
<h2 id="结论">结论</h2>
<p>自定义错误是 Solidity 中优化 Gas 消耗的重要工具，特别是在频繁可能失败的函数中。通过遵循这些最佳实践，你可以编写出更高效、更清晰的智能合约代码。</p>
]]></content>
      <categories>
        <category>Solidity学习</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity中的转账</title>
    <url>/2025/05/04/Solidity%E4%B8%AD%E7%9A%84%E8%BD%AC%E8%B4%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Solidity 中，<code>transfer</code>、<code>send</code> 和 <code>call</code> 是用于向外部地址发送 ETH 的三种方法，但它们的行为和安全性存在显著差异。以下是它们的用法、区别及最佳实践。</p>
<hr>
<h3 id="1-transfer-不推荐使用">1. <strong><code>transfer</code> (不推荐使用)</strong></h3>
<p><strong>用法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address payable recipient = payable(0x123...);</span><br><span class="line">recipient.transfer(amount);</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：<br>
• <strong>Gas 限制</strong>：固定 2300 gas，足够触发接收合约的 <code>receive()</code> 或 <code>fallback()</code> 函数，但不足以执行复杂逻辑。<br>
• <strong>错误处理</strong>：如果发送失败（如接收合约抛出异常或 gas 不足），<code>transfer</code> 会抛出异常并回滚整个交易。<br>
• <strong>弃用警告</strong>：自 Solidity 0.8.0 起，<code>transfer</code> 和 <code>send</code> 不再推荐使用，因为固定的 2300 gas 可能在未来网络中不足（如 EIP-1884 提高了部分操作码的 gas 消耗）。</p>
<hr>
<h3 id="2-send-不推荐使用">2. <strong><code>send</code> (不推荐使用)</strong></h3>
<p><strong>用法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address payable recipient = payable(0x123...);</span><br><span class="line">bool success = recipient.send(amount);</span><br><span class="line">if (!success) &#123;</span><br><span class="line">    // 处理发送失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：<br>
• <strong>Gas 限制</strong>：与 <code>transfer</code> 相同（2300 gas）。<br>
• <strong>错误处理</strong>：失败时返回 <code>false</code> 而非抛出异常，需手动检查返回值。<br>
• <strong>弃用原因</strong>：与 <code>transfer</code> 相同，2300 gas 可能不足。</p>
<hr>
<h3 id="3-call-推荐方式">3. <strong><code>call</code> (推荐方式)</strong></h3>
<p><strong>用法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address payable recipient = payable(0x123...);</span><br><span class="line">(bool success, bytes memory data) = recipient.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">require(success, &quot;ETH transfer failed&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：<br>
• <strong>Gas 限制</strong>：无硬编码限制，默认传递所有剩余 gas（可通过 <code>gas</code> 参数自定义，如 <code>.call&#123;value: amount, gas: 50000&#125;(&quot;&quot;)</code>）。<br>
• <strong>错误处理</strong>：返回 <code>(bool success, bytes data)</code>，需手动检查 <code>success</code>。<br>
• <strong>灵活性</strong>：支持调用任意函数（如 <code>.call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;foo(uint256)&quot;, 123))</code>），但需警惕重入攻击。<br>
• <strong>最佳实践</strong>：当前推荐用于 ETH 转账，因其兼容性更好（如支持智能合约的复杂逻辑）。</p>
<hr>
<h3 id="关键区别"><strong>关键区别</strong></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>Gas 限制</th>
<th>错误处理</th>
<th>推荐程度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transfer</code></td>
<td>固定 2300 gas</td>
<td>抛出异常</td>
<td>❌ 弃用</td>
<td>简单转账（旧代码）</td>
</tr>
<tr>
<td><code>send</code></td>
<td>固定 2300 gas</td>
<td>返回 <code>bool</code></td>
<td>❌ 弃用</td>
<td>需手动处理失败的转账</td>
</tr>
<tr>
<td><code>call</code></td>
<td>可自定义 gas</td>
<td>返回 <code>(bool, bytes)</code></td>
<td>✅ 推荐</td>
<td>现代合约（需防重入）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="最佳实践"><strong>最佳实践</strong></h3>
<ol>
<li><strong>使用 <code>call</code> 并检查返回值</strong></li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool success, ) = recipient.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">require(success, &quot;Transfer failed&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>防范重入攻击</strong><br>
• 在调用外部合约前执行所有状态变更（遵循 <a href="https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern">Checks-Effects-Interactions</a> 模式）。<br>
• 使用重入锁（如 OpenZeppelin 的 <code>ReentrancyGuard</code>）：</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line">contract MyContract is ReentrancyGuard &#123;</span><br><span class="line">    function safeTransfer(address payable recipient) external payable nonReentrant &#123;</span><br><span class="line">        (bool success, ) = recipient.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class="line">        require(success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>明确 gas 限制</strong><br>
如果接收方是合约，且不确定其逻辑是否安全，可限制 gas：</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recipient.call&#123;value: amount, gas: 50000&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>避免使用 <code>transfer</code> 和 <code>send</code></strong><br>
除非维护旧代码，否则优先使用 <code>call</code>。</li>
</ol>
<hr>
<h3 id="总结"><strong>总结</strong></h3>
<p>• <strong>简单转账</strong>：用 <code>call</code> + <code>require</code> 检查。<br>
• <strong>合约交互</strong>：用 <code>call</code> 自定义 gas 并防范重入。<br>
• <strong>弃用方法</strong>：避免 <code>transfer</code> 和 <code>send</code>，因其 gas 限制可能导致未来兼容性问题。</p>
]]></content>
      <categories>
        <category>Solidity学习</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>UTXO模型解析</title>
    <url>/2025/06/08/UTXO%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="通俗理解-UTXO-模型：为什么比特币不像银行卡那样“记余额”？">通俗理解 UTXO 模型：为什么比特币不像银行卡那样“记余额”？</h1>
<p>如果你用过支付宝、微信或者银行App，你肯定很熟悉“账户余额”这个概念。你存了多少钱、花了多少钱，系统都会直接加减金额，很直观。</p>
<p>但比特币却不是这么做的。</p>
<p>比特币并没有为每个用户记一个“账户余额”。它使用一种叫做 <strong>UTXO</strong> 的模型来管理你的比特币。</p>
<hr>
<h2 id="一、什么是-UTXO？">一、什么是 UTXO？</h2>
<p><strong>UTXO 是 “未花费交易输出” 的缩写</strong>。你可以把它想象成一张张“找零纸币”，每次收钱和花钱，其实就是一张张纸币的流转。</p>
<p>它就像你口袋里的一堆零钱，而不是银行账户里的一串数字。</p>
<hr>
<h2 id="二、举个例子：小明请客吃饭">二、举个例子：小明请客吃饭</h2>
<h3 id="场景：">场景：</h3>
<p>小明钱包里有：</p>
<ul>
<li>一张 50 元</li>
<li>一张 30 元</li>
<li>一张 20 元</li>
</ul>
<p>这些就是他的 <strong>UTXO</strong> —— 还能用的钱。</p>
<p>现在他要请小红吃饭，花了 70 元。</p>
<hr>
<h3 id="用账户模型的思维是这样：">用账户模型的思维是这样：</h3>
<ul>
<li>账户原有：100 元</li>
<li>花掉：70 元</li>
<li>剩下：30 元</li>
</ul>
<p>但比特币不是这么处理的。</p>
<hr>
<h3 id="在-UTXO-模型下，小明必须选择纸币来支付">在 UTXO 模型下，小明必须选择纸币来支付</h3>
<p>他选择用：</p>
<ul>
<li>一张 50 元</li>
<li>一张 30 元</li>
</ul>
<p>合计：80 元</p>
<p>饭钱 70 元，那多出来的 10 元怎么办？</p>
<blockquote>
<p>✅ 自动找零！系统会再给他一张 10 元，回到他钱包里。</p>
</blockquote>
<hr>
<h2 id="三、比特币交易到底长什么样？">三、比特币交易到底长什么样？</h2>
<p>继续上面例子，小明发起一个交易：</p>
<h3 id="输入（小明拿出来用的）：">输入（小明拿出来用的）：</h3>
<ul>
<li>50 元</li>
<li>30 元</li>
</ul>
<h3 id="输出（这笔钱要给谁）：">输出（这笔钱要给谁）：</h3>
<ul>
<li>70 元 → 小红（餐费）</li>
<li>10 元 → 小明（找零）</li>
</ul>
<p>注意！这次花的钱，不是“账户减少70元”，而是“把原来的两张纸币销毁”，再新发两张纸币出来，一张给小红，一张自己。</p>
<p>而且原来那两张 50 元和 30 元 <strong>就被视为“已花费”，再也不能用了</strong>。</p>
<hr>
<h2 id="四、UTXO-和账户模型有什么区别？">四、UTXO 和账户模型有什么区别？</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>UTXO 模型（比特币）</th>
<th>账户模型（以太坊/支付宝）</th>
</tr>
</thead>
<tbody>
<tr>
<td>钱的表现</td>
<td>一张张“零钱”（UTXO）</td>
<td>账户里的一个余额数字</td>
</tr>
<tr>
<td>花钱方式</td>
<td>选几张零钱 → 分成若干份输出</td>
<td>直接余额减一笔钱</td>
</tr>
<tr>
<td>找零机制</td>
<td>系统自动返回一笔UTXO</td>
<td>不存在找零</td>
</tr>
<tr>
<td>隐私性</td>
<td>更高（每笔钱可用新地址）</td>
<td>低（账户固定）</td>
</tr>
<tr>
<td>处理方式</td>
<td>类似现金</td>
<td>类似银行</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五、再举一个完整例子：看起来复杂，其实就是花钱找零">五、再举一个完整例子：看起来复杂，其实就是花钱找零</h2>
<p><strong>场景：</strong></p>
<p>小红有三笔比特币：</p>
<ul>
<li>0.2 BTC</li>
<li>0.4 BTC</li>
<li>0.6 BTC<br>
她一共拥有 1.2 BTC</li>
</ul>
<p>现在她要支付 0.7 BTC 给 Bob。</p>
<p>她钱包自动选择：</p>
<ul>
<li>0.6 BTC</li>
<li>0.2 BTC</li>
</ul>
<p>总共 0.8 BTC，用于支付。</p>
<p>系统处理如下：</p>
<h3 id="输入：">输入：</h3>
<ul>
<li>0.6 BTC（小红）</li>
<li>0.2 BTC（小红）</li>
</ul>
<h3 id="输出：">输出：</h3>
<ul>
<li>0.7 BTC（给 Bob）</li>
<li>0.1 BTC（回给小红自己，找零）</li>
</ul>
<p>这就是一笔 UTXO 交易。</p>
<hr>
<h2 id="六、钱包软件在帮你自动做这些事">六、钱包软件在帮你自动做这些事</h2>
<p>你在比特币钱包里看到的是“余额：1.2 BTC”，但其实这个余额是很多个 UTXO 叠加的总和。</p>
<p>钱包会：</p>
<ul>
<li>选择哪些 UTXO 来组合成你要支付的金额</li>
<li>自动生成找零地址</li>
<li>组装交易</li>
<li>计算手续费</li>
<li>签名并发送交易</li>
</ul>
<p>你只需要点一下“发送”，但背后做了很多 UTXO 的“搭配”和“更新”。</p>
<hr>
<h2 id="七、UTXO-模型的好处">七、UTXO 模型的好处</h2>
<ul>
<li>✅ <strong>简单可靠</strong>：每笔钱从哪来、给了谁，链上都能查</li>
<li>✅ <strong>匿名性好</strong>：每次可以用新地址收款，不容易关联身份</li>
<li>✅ <strong>更安全清晰</strong>：每个“纸币”只能用一次，不会出现双花</li>
</ul>
<hr>
<h2 id="八、但它也有点麻烦…">八、但它也有点麻烦…</h2>
<ul>
<li>❌ <strong>你有太多零钱（UTXO）时</strong>，会导致交易变大，手续费变高</li>
<li>❌ <strong>开发智能合约不方便</strong>，因为它不像账户模型有“变量状态”</li>
</ul>
<hr>
<h2 id="九、结语：把比特币的钱看作现金，你就理解了">九、结语：把比特币的钱看作现金，你就理解了</h2>
<p>UTXO 模型其实就像现实生活的现金支付，每次掏出几张钞票，然后收回找零。和我们在银行App里看到的“账户减余额”的方式很不一样。</p>
<p>但这种方式，正是比特币设计的初衷：<strong>简单、清晰、不可篡改</strong>。</p>
<hr>
]]></content>
      <tags>
        <tag>web3</tag>
      </tags>
  </entry>
  <entry>
    <title>UniswapV2算法概述</title>
    <url>/2025/06/02/UniswappV2%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="解锁-DeFi-世界的钥匙：深入剖析-Uniswap-v2-算法">解锁 DeFi 世界的钥匙：深入剖析 Uniswap v2 算法</h2>
<p>近年来，去中心化金融 (DeFi) 的浪潮席卷全球，而在这场变革中，去中心化交易所 (DEX) 无疑扮演着至关重要的角色。Uniswap，作为最受欢迎的 DEX 之一，其背后的算法是理解 DeFi 运作方式的关键。</p>
<h3 id="背景：中心化交易所的局限与-DEX-的崛起">背景：中心化交易所的局限与 DEX 的崛起</h3>
<p>在 DeFi 出现之前，我们进行加密货币交易主要依赖中心化交易所 (CEX)，如币安、Coinbase 等。这些平台虽然交易体验良好，但也存在一些固有的局限性：</p>
<ul>
<li><strong>托管风险：</strong> 用户的资产需要存放在交易所的钱包中，存在被黑客攻击或交易所跑路的风险。</li>
<li><strong>审查风险：</strong> 交易所可以根据自身政策或监管要求限制用户的交易。</li>
<li><strong>单点故障：</strong> 交易所的服务器一旦出现故障，整个交易系统都会瘫痪。</li>
</ul>
<p>为了解决这些问题，去中心化交易所 (DEX) 应运而生。DEX 的核心特点在于：</p>
<ul>
<li><strong>非托管：</strong> 用户始终掌控自己的私钥和资产。</li>
<li><strong>无需许可：</strong> 任何人都可以参与交易和提供流动性。</li>
<li><strong>透明公开：</strong> 交易记录和智能合约代码通常是公开可查的。</li>
</ul>
<p>Uniswap 就是这样一款具有代表性的 DEX。</p>
<h3 id="Uniswap-的作用：连接加密资产的桥梁">Uniswap 的作用：连接加密资产的桥梁</h3>
<p>Uniswap 的核心作用是<strong>实现不同加密资产之间的无需许可的兑换</strong>。它通过一种称为<strong>自动做市商 (Automated Market Maker, AMM)</strong> 的机制，允许用户在没有传统订单簿的情况下进行交易。</p>
<p>你可以将 Uniswap 想象成一个自动化的货币兑换点，你不需要找到一个想用另一种货币和你交易的人，只需要按照预先设定的规则（也就是算法）进行兑换即可。</p>
<h3 id="Uniswap-v2-的原理：恒定乘积做市商">Uniswap v2 的原理：恒定乘积做市商</h3>
<p>Uniswap v2 的核心原理是<strong>恒定乘积公式</strong>。对于任何一个交易对（例如 ETH/USDT），Uniswap v2 维护着一个<strong>流动性池 (Liquidity Pool)</strong>，这个池子里存放着等值的两种资产。</p>
<p>假设一个流动性池中包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 数量的代币 A 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 数量的代币 B，Uniswap v2 的核心思想是维持池中两种代币数量的乘积为一个常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\qquad x \times y = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p>
<p>这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 在没有新的流动性加入或移除，且忽略交易手续费的情况下，是保持不变的。</p>
<p><strong>交易过程：</strong></p>
<p>当你想要用一定数量的代币 A 兑换代币 B 时，你会将你的代币 A 加入到流动性池中，并从池中取出相应数量的代币 B。由于池中的代币 A 数量增加，为了维持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x \times y = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 不变，池中的代币 B 数量必须减少。</p>
<p><strong>价格的决定：</strong></p>
<p>交易的实际兑换比例（即价格）是由交易前后流动性池中两种代币的比例决定的。如果你投入更多的代币 A，你会相对获得较少的代币 B，这反映了代币 A 相对于代币 B 的价格上涨。</p>
<h3 id="Uniswap-v2-的核心算法">Uniswap v2 的核心算法</h3>
<p>现在，我们来更具体地看一下交易的算法：</p>
<p>假设流动性池中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 个代币 A 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 个代币 B。你想要用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\Delta x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">x</span></span></span></span> 个代币 A 来兑换代币 B。</p>
<ol>
<li>
<p><strong>加入代币 A：</strong> 流动性池中代币 A 的数量变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x + \Delta x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">x</span></span></span></span>。</p>
</li>
<li>
<p><strong>计算可获得的代币 B：</strong> 为了维持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值（在扣除手续费之前），新的代币 B 数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 应该满足：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>x</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>k</mi><mo>=</mo><mi>x</mi><mo>×</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\qquad (x + \Delta x) \times y&#x27; = k = x \times y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Δ</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><br>
因此，理论上你可以获得的代币 B 的数量是：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><mi>x</mi><mo>×</mo><mi>y</mi></mrow><mrow><mi>x</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\qquad y&#x27; = \frac{x \times y}{x + \Delta x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2578em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8544em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
那么，你将获得的代币 B 的数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\Delta y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><mi mathvariant="normal">Δ</mi><mi>y</mi><mo>=</mo><mi>y</mi><mo>−</mo><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>y</mi><mo>−</mo><mfrac><mrow><mi>x</mi><mo>×</mo><mi>y</mi></mrow><mrow><mi>x</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>y</mi><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mfrac><mi>x</mi><mrow><mi>x</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow></mfrac><mo fence="true">)</mo></mrow><mo>=</mo><mi>y</mi><mfrac><mrow><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow><mrow><mi>x</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\qquad \Delta y = y - y&#x27; = y - \frac{x \times y}{x + \Delta x} = y \left( 1 - \frac{x}{x + \Delta x} \right) = y \frac{\Delta x}{x + \Delta x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2578em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8544em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2533em;vertical-align:-0.4033em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2757em;vertical-align:-0.4033em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p><strong>交易手续费：</strong> Uniswap v2 对每笔交易收取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.3</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">0.3\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">0.3%</span></span></span></span> 的手续费，这部分手续费会按比例分配给流动性提供者。因此，实际加入到池中的代币 A 数量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>x</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.003</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Delta x \times (1 - 0.003)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0.003</span><span class="mclose">)</span></span></span></span>。</p>
<p>所以，实际获得的代币 B 的数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>y</mi><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta y_{actual}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><mi mathvariant="normal">Δ</mi><msub><mi>y</mi><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>y</mi><mo>−</mo><mfrac><mrow><mi>x</mi><mo>×</mo><mi>y</mi></mrow><mrow><mi>x</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>x</mi><mo>×</mo><mn>0.997</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\qquad \Delta y_{actual} = y - \frac{x \times y}{x + \Delta x \times 0.997}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2578em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8544em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">x</span><span class="mbin mtight">×</span><span class="mord mtight">0.997</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
</ol>
<p><strong>总结一下交易过程：</strong></p>
<p>当你用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\Delta x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">x</span></span></span></span> 个代币 A 交易代币 B 时，实际支付给流动性池的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>x</mi><mo>×</mo><mn>0.997</mn></mrow><annotation encoding="application/x-tex">\Delta x \times 0.997</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.997</span></span></span></span> 个代币 A。根据恒定乘积公式，系统会计算出你应该收到的代币 B 的数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>y</mi><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta y_{actual}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使得交易后池中两种代币数量的乘积依然（近似）等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</p>
<h3 id="举例说明：ETH-USDT-交易">举例说明：ETH/USDT 交易</h3>
<p>假设 Uniswap v2 的 ETH/USDT 流动性池中有 100 ETH 和 300,000 USDT。那么，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>100</mn><mo>×</mo><mn>300</mn><mo separator="true">,</mo><mn>000</mn><mo>=</mo><mn>30</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">k = 100 \times 300,000 = 30,000,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">300</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">30</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span>。当前的 ETH 价格隐含在池子的比例中，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>300</mn><mo separator="true">,</mo><mn>000</mn><mi mathvariant="normal">/</mi><mn>100</mn><mo>=</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">300,000 / 100 = 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">300</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000/100</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3000</span></span></span></span> USDT/ETH。</p>
<p>现在，你想用 1 ETH 来兑换 USDT。</p>
<ol>
<li>你实际加入到池中的 ETH 数量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>0.997</mn><mo>=</mo><mn>0.997</mn></mrow><annotation encoding="application/x-tex">1 \times 0.997 = 0.997</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.997</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.997</span></span></span></span> ETH。</li>
<li>池中 ETH 的总数变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>+</mo><mn>0.997</mn><mo>=</mo><mn>100.997</mn></mrow><annotation encoding="application/x-tex">100 + 0.997 = 100.997</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.997</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100.997</span></span></span></span> ETH。</li>
<li>为了维持乘积 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，新的 USDT 数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 应该是：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><mn>100.997</mn><mo>×</mo><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mn>30</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">\qquad 100.997 \times y&#x27; = 30,000,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord">100.997</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">30</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><mn>30</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn></mrow><mn>100.997</mn></mfrac><mo>≈</mo><mn>297037.83</mn></mrow><annotation encoding="application/x-tex">\qquad y&#x27; = \frac{30,000,000}{100.997} \approx 297037.83</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2422em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8972em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100.997</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span><span class="mpunct mtight">,</span><span class="mord mtight">000</span><span class="mpunct mtight">,</span><span class="mord mtight">000</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">297037.83</span></span></span></span> USDT</li>
<li>因此，你将获得的 USDT 数量是：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><mi mathvariant="normal">Δ</mi><msub><mi>y</mi><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>=</mo><mn>300</mn><mo separator="true">,</mo><mn>000</mn><mo>−</mo><mn>297037.83</mn><mo>≈</mo><mn>2962.17</mn></mrow><annotation encoding="application/x-tex">\qquad \Delta y_{actual} = 300,000 - 297037.83 \approx 2962.17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">300</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">297037.83</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2962.17</span></span></span></span> USDT</li>
</ol>
<p>可以看到，你用 1 ETH 换得了大约 2962.17 USDT。实际的兑换价格是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2962.17</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo>≈</mo><mn>2962.17</mn></mrow><annotation encoding="application/x-tex">2962.17 / 1 \approx 2962.17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2962.17/1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2962.17</span></span></span></span> USDT/ETH，略低于池子当前的隐含价格 3000 USDT/ETH。这就是<strong>滑点 (Slippage)</strong> 的体现，当你交易的规模相对于流动性池的大小越大时，滑点会越明显。</p>
<h3 id="总结">总结</h3>
<p>Uniswap v2 通过简单的恒定乘积公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x \times y = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 实现了无需许可的加密资产兑换。其核心算法涉及到根据交易量和流动性池的规模动态调整价格，并通过收取交易手续费来激励流动性提供者。</p>
]]></content>
      <categories>
        <category>uniswap系列</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>uniswap</tag>
      </tags>
  </entry>
  <entry>
    <title>Caliper在Fabric网络上的入门示例</title>
    <url>/2025/10/28/caliper%E4%B8%8Efabric%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hyperledger-Caliper-在-Fabric-上进行性能测试入门教程-Go-语言链码">Hyperledger Caliper 在 Fabric 上进行性能测试入门教程 (Go 语言链码)</h1>
<h2 id="概述">概述</h2>
<p>Hyperledger Caliper 是一个区块链性能基准测试工具，支持多种区块链平台。本教程将指导您使用 Caliper 在 Hyperledger Fabric 上运行性能测试案例。</p>
<p>本教程基于 Fabric Samples 的 test-network 和 asset-transfer-basic 的 <strong>Go 语言链码</strong>版本，演示如何测试区块链上的基本资产创建和读取操作。</p>
<h2 id="安装和设置">安装和设置</h2>
<h3 id="1-安装-Fabric-Samples">1. 安装 Fabric Samples</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples.git</span><br><span class="line"><span class="built_in">cd</span> fabric-samples</span><br></pre></td></tr></table></figure>
<h3 id="2-启动-Fabric-网络">2. 启动 Fabric 网络</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> test-network</span><br><span class="line">./network.sh up createChannel -ca -s couchdb</span><br><span class="line">./network.sh deployCC -ccp ../asset-transfer-basic/chaincode-go -ccn basic -ccl go</span><br></pre></td></tr></table></figure>
<p><strong>命令参数解释</strong>:</p>
<ul>
<li><code>up createChannel</code>: 启动网络并创建应用通道</li>
<li><code>-ca</code>: 使用证书颁发机构 (CA) 生成证书</li>
<li><code>-s couchdb</code>: 使用 CouchDB 作为状态数据库 (而不是默认的 LevelDB)</li>
<li><code>deployCC</code>: 部署链码 (智能合约)</li>
<li><code>-ccp</code>: 指定链码路径 (chaincode path) - 这里使用 Go 语言链码</li>
<li><code>-ccn</code>: 指定链码名称 (chaincode name)</li>
<li><code>-ccl</code>: 指定链码语言 (chaincode language) - 这里使用 go</li>
</ul>
<p>这将启动一个包含 2 个组织的 Fabric 网络，并部署 <code>basic</code> Go 语言链码。</p>
<h3 id="3-创建-Caliper-工作区">3. 创建 Caliper 工作区</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">mkdir</span> caliper-workspace</span><br><span class="line"><span class="built_in">cd</span> caliper-workspace</span><br></pre></td></tr></table></figure>
<h3 id="4-安装-Caliper">4. 安装 Caliper</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --only=prod @hyperledger/caliper-cli@0.6.0</span><br></pre></td></tr></table></figure>
<p><strong>命令参数解释</strong>:</p>
<ul>
<li><code>install</code>: 安装 npm 包</li>
<li><code>--only=prod</code>: 只安装生产依赖，不安装开发依赖</li>
<li><code>@hyperledger/caliper-cli@0.6.0</code>: 指定安装 Caliper CLI 版本 0.6.0</li>
</ul>
<h3 id="5-绑定-Fabric-SDK">5. 绑定 Fabric SDK</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx caliper <span class="built_in">bind</span> --caliper-bind-sut fabric:fabric-gateway</span><br></pre></td></tr></table></figure>
<p><strong>命令参数解释</strong>:</p>
<ul>
<li><code>bind</code>: 绑定 Caliper 到指定的区块链平台和 SDK</li>
<li><code>--caliper-bind-sut</code>: 指定系统类型 (fabric:fabric-gateway 表示使用 Fabric Gateway SDK)</li>
</ul>
<h2 id="关键配置文件">关键配置文件</h2>
<h3 id="网络配置文件-network-yaml">网络配置文件 (network.yaml)</h3>
<p>创建 <code>network.yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">caliper:</span></span><br><span class="line">  <span class="attr">blockchain:</span> <span class="string">fabric</span></span><br><span class="line"></span><br><span class="line"><span class="attr">organizations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mspid:</span> <span class="string">Org1MSP</span></span><br><span class="line">    <span class="attr">identities:</span></span><br><span class="line">      <span class="attr">certificates:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">admin:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">clientPrivateKey:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">../test-network/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore/priv_sk</span></span><br><span class="line">        <span class="attr">clientSignedCert:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">../test-network/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/Admin@org1.example.com-cert.pem</span></span><br><span class="line">    <span class="attr">connectionProfile:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">../test-network/organizations/peerOrganizations/org1.example.com/connection-org1.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">channelName:</span> <span class="string">mychannel</span></span><br><span class="line">    <span class="attr">contracts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure>
<p><strong>关键配置说明</strong>:</p>
<ul>
<li><code>version: '2.0.0'</code>: 配置文件版本</li>
<li><code>organizations</code>: 定义参与测试的组织及其身份</li>
<li><code>channels</code>: 指定测试的通道和链码</li>
<li>路径必须相对于工作区正确</li>
</ul>
<h3 id="基准测试配置文件-benchmark-yaml">基准测试配置文件 (benchmark.yaml)</h3>
<p>创建 <code>benchmark.yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">basic-asset-benchmark</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">A</span> <span class="string">benchmark</span> <span class="string">for</span> <span class="string">the</span> <span class="string">asset-transfer-basic</span> <span class="string">chaincode</span></span><br><span class="line">  <span class="attr">workers:</span></span><br><span class="line">    <span class="attr">number:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">rounds:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">createAsset</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Create</span> <span class="string">a</span> <span class="string">new</span> <span class="string">asset</span></span><br><span class="line">      <span class="attr">txNumber:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">rateControl:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">fixed-rate</span></span><br><span class="line">        <span class="attr">opts:</span></span><br><span class="line">          <span class="attr">tps:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">workload:</span></span><br><span class="line">        <span class="attr">module:</span> <span class="string">workloads/createAsset.js</span></span><br><span class="line">        <span class="attr">arguments:</span></span><br><span class="line">          <span class="attr">contractId:</span> <span class="string">basic</span></span><br><span class="line">          <span class="attr">assetSize:</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">readAsset</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Read</span> <span class="string">an</span> <span class="string">existing</span> <span class="string">asset</span></span><br><span class="line">      <span class="attr">txNumber:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">rateControl:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">fixed-rate</span></span><br><span class="line">        <span class="attr">opts:</span></span><br><span class="line">          <span class="attr">tps:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">workload:</span></span><br><span class="line">        <span class="attr">module:</span> <span class="string">workloads/readAsset.js</span></span><br><span class="line">        <span class="attr">arguments:</span></span><br><span class="line">          <span class="attr">contractId:</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure>
<p><strong>关键配置说明</strong>:</p>
<ul>
<li><code>workers.number</code>: 工作节点数量</li>
<li><code>rounds</code>: 测试轮次，每个轮次定义交易数量、速率控制和工作负载</li>
<li><code>rateControl</code>: 控制交易发送速率</li>
<li><code>workload</code>: 指定工作负载模块和参数</li>
</ul>
<h3 id="工作负载模块">工作负载模块</h3>
<p>创建 <code>workloads/</code> 目录，并创建工作负载文件。</p>
<h4 id="createAsset-js">createAsset.js</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">WorkloadModuleBase</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@hyperledger/caliper-core&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreateAssetWorkload</span> <span class="keyword">extends</span> <span class="title class_ inherited__">WorkloadModuleBase</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">txIndex</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">submitTransaction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">txIndex</span>++;</span><br><span class="line">        <span class="keyword">const</span> assetID = <span class="string">`asset_<span class="subst">$&#123;<span class="variable language_">this</span>.workerIndex&#125;</span>_<span class="subst">$&#123;<span class="variable language_">this</span>.txIndex&#125;</span>`</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> args = &#123;</span><br><span class="line">            <span class="attr">contractId</span>: <span class="variable language_">this</span>.<span class="property">roundArguments</span>.<span class="property">contractId</span>,</span><br><span class="line">            <span class="attr">contractFunction</span>: <span class="string">&#x27;CreateAsset&#x27;</span>,</span><br><span class="line">            <span class="attr">contractArguments</span>: [assetID, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;Alan&#x27;</span>, <span class="string">&#x27;150&#x27;</span>],</span><br><span class="line">            <span class="attr">readOnly</span>: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">sutAdapter</span>.<span class="title function_">sendRequests</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWorkloadModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CreateAssetWorkload</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">createWorkloadModule</span> = createWorkloadModule;</span><br></pre></td></tr></table></figure>
<h4 id="readAsset-js">readAsset.js</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">WorkloadModuleBase</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@hyperledger/caliper-core&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadAssetWorkload</span> <span class="keyword">extends</span> <span class="title class_ inherited__">WorkloadModuleBase</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">txIndex</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">submitTransaction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">txIndex</span>++;</span><br><span class="line">        <span class="keyword">const</span> assetID = <span class="string">`asset_<span class="subst">$&#123;<span class="variable language_">this</span>.workerIndex&#125;</span>_<span class="subst">$&#123;<span class="variable language_">this</span>.txIndex&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> args = &#123;</span><br><span class="line">            <span class="attr">contractId</span>: <span class="variable language_">this</span>.<span class="property">roundArguments</span>.<span class="property">contractId</span>,</span><br><span class="line">            <span class="attr">contractFunction</span>: <span class="string">&#x27;ReadAsset&#x27;</span>,</span><br><span class="line">            <span class="attr">contractArguments</span>: [assetID],</span><br><span class="line">            <span class="attr">readOnly</span>: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">sutAdapter</span>.<span class="title function_">sendRequests</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWorkloadModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadAssetWorkload</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">createWorkloadModule</span> = createWorkloadModule;</span><br></pre></td></tr></table></figure>
<h2 id="运行测试">运行测试</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/caliper launch manager --caliper-workspace . --caliper-benchconfig benchmark.yaml --caliper-networkconfig network.yaml</span><br></pre></td></tr></table></figure>
<p><strong>命令参数解释</strong>:</p>
<ul>
<li><code>launch manager</code>: 启动 Caliper 管理器进程来协调测试</li>
<li><code>--caliper-workspace .</code>: 指定工作区目录 (当前目录)</li>
<li><code>--caliper-benchconfig benchmark.yaml</code>: 指定基准测试配置文件</li>
<li><code>--caliper-networkconfig network.yaml</code>: 指定网络配置文件</li>
</ul>
<h2 id="结果分析">结果分析</h2>
<p>测试完成后，会生成 <code>report.html</code> 文件，包含：</p>
<ul>
<li>交易成功/失败统计</li>
<li>发送速率 (TPS)</li>
<li>延迟统计 (最大、最小、平均)</li>
<li>吞吐量 (TPS)</li>
<li>图表可视化</li>
</ul>
<h2 id="注意点">注意点</h2>
<ol>
<li>
<p><strong>路径配置</strong>: 所有文件路径必须相对于工作区根目录正确。注意相对路径的解析。</p>
</li>
<li>
<p><strong>版本兼容性</strong>: 确保 Fabric 版本与 Caliper 绑定的 SDK 版本兼容。</p>
</li>
<li>
<p><strong>网络状态</strong>: 在运行测试前，确保 Fabric 网络正常运行且链码已部署。</p>
</li>
<li>
<p><strong>资源管理</strong>: 根据测试规模调整 Docker 资源限制。</p>
</li>
<li>
<p><strong>安全配置</strong>: 在生产环境中，妥善管理私钥和证书。</p>
</li>
<li>
<p><strong>工作负载设计</strong>: 工作负载应模拟真实的业务场景，避免过度简化。</p>
</li>
</ol>
<h2 id="常见问题解答">常见问题解答</h2>
<h3 id="1-工作负载模块一定要用-JavaScript-写吗？">1. 工作负载模块一定要用 JavaScript 写吗？</h3>
<p><strong>不一定</strong>，但 JavaScript 是最常用和推荐的选择。</p>
<p><strong>支持的语言选项</strong>：</p>
<ul>
<li><strong>JavaScript/Node.js</strong> (推荐): 最成熟，社区支持最好</li>
<li><strong>TypeScript</strong>: 提供类型安全，编译为 JavaScript</li>
<li><strong>其他语言</strong>: 理论上支持，但需要额外配置</li>
</ul>
<p><strong>为什么推荐 JavaScript</strong>：</p>
<ul>
<li>Caliper 核心基于 Node.js</li>
<li>丰富的 Fabric SDK 支持</li>
<li>易于与现有工作负载示例集成</li>
</ul>
<p><strong>如果要使用其他语言</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 benchmark.yaml 中指定</span></span><br><span class="line"><span class="attr">workload</span>:</span><br><span class="line">  <span class="attr">module</span>: workloads/myWorkload.<span class="property">ts</span>  <span class="comment">// TypeScript 文件</span></span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  <span class="attr">module</span>: workloads/myWorkload.<span class="property">py</span>  <span class="comment">// Python (需要额外配置)</span></span><br></pre></td></tr></table></figure>
<h3 id="2-链码具体怎么写？规范是什么？">2. 链码具体怎么写？规范是什么？</h3>
<p><strong>不是简单改造</strong>，需要完全重写以符合 Fabric 链码规范。</p>
<h4 id="Fabric-链码规范要求">Fabric 链码规范要求</h4>
<p><strong>核心接口</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须实现的接口</span></span><br><span class="line"><span class="keyword">type</span> ContractInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 链码初始化</span></span><br><span class="line">    InitLedger(ctx contractapi.TransactionContextInterface) <span class="type">error</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 业务函数</span></span><br><span class="line">    <span class="comment">// 您的函数将在这里定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准链码结构</span></span><br><span class="line"><span class="keyword">type</span> SmartContract <span class="keyword">struct</span> &#123;</span><br><span class="line">    contractapi.Contract</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span></span> InitLedger(ctx contractapi.TransactionContextInterface) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键规范</strong>：</p>
<ol>
<li><strong>状态管理</strong>: 使用 <code>ctx.GetStub().PutState()</code> 和 <code>GetState()</code> 替代内存变量</li>
<li><strong>确定性</strong>: 所有操作必须是确定性的，不能使用随机数或时间</li>
<li><strong>错误处理</strong>: 必须返回错误，不能 panic</li>
<li><strong>序列化</strong>: 复杂对象需要 JSON 序列化存储</li>
<li><strong>背书策略</strong>: 需要配置适当的背书策略</li>
</ol>
<h4 id="从您的-blockchain-go-迁移的映射关系">从您的 blockchain.go 迁移的映射关系</h4>
<table>
<thead>
<tr>
<th>原代码</th>
<th>Fabric 链码改造</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BlockChain</code> 结构体</td>
<td><code>SmartContract</code> 结构体</td>
</tr>
<tr>
<td><code>RegisterCSP()</code> 方法</td>
<td><code>RegisterCSP()</code> 链码函数</td>
</tr>
<tr>
<td><code>Verify()</code> 方法</td>
<td><code>VerifyConsistency()</code> 链码函数</td>
</tr>
<tr>
<td>内存 <code>RegisteredCSPs</code> map</td>
<td>账本状态 <code>csp_registry</code></td>
</tr>
<tr>
<td>内存证明存储</td>
<td>账本状态 <code>proofs_&#123;dataID&#125;</code></td>
</tr>
</tbody>
</table>
<h3 id="3-工作负载模块的每个代码就是模拟算法中的每一个步骤吗？">3. 工作负载模块的每个代码就是模拟算法中的每一个步骤吗？</h3>
<p><strong>是的</strong>，工作负载模块模拟算法执行流程的各个步骤。</p>
<h4 id="工作负载设计原则">工作负载设计原则</h4>
<p><strong>每个工作负载模块代表一个业务操作类型</strong>：</p>
<ul>
<li><code>registerCSP.js</code>: 模拟 CSP 注册流程</li>
<li><code>uploadData.js</code>: 模拟数据上传和元数据记录</li>
<li><code>auditRequest.js</code>: 模拟 DO 发起审计请求</li>
<li><code>submitProof.js</code>: 模拟 CSP 生成和提交证明</li>
<li><code>verifyConsistency.js</code>: 模拟区块链验证两个 CSP 的数据一致性</li>
</ul>
<p><strong>工作负载 ≠ 算法步骤</strong>，而是<strong>用户行为模拟</strong>：</p>
<ul>
<li>一个工作负载模块 = 一个用户操作类型</li>
<li>内部可以包含多个算法步骤</li>
<li>重点是模拟真实用户的调用模式和频率</li>
</ul>
<h4 id="工作负载执行流程">工作负载执行流程</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户行为 → 工作负载模块 → 链码函数调用 → 算法执行 → 账本更新</span><br><span class="line">     ↓</span><br><span class="line">性能收集 → Caliper 报告</span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>：<code>verifyConsistency.js</code> 工作负载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个工作负载模拟：</span></span><br><span class="line"><span class="comment">// 1. 选择要验证的两个 CSP (算法中的&quot;选择验证对&quot;步骤)</span></span><br><span class="line"><span class="comment">// 2. 调用链码验证函数 (算法中的&quot;执行验证&quot;步骤)</span></span><br><span class="line"><span class="comment">// 3. 收集验证结果 (性能测试需要)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Web3学习路线0.1</title>
    <url>/2025/06/02/Web3%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>宇宙安全申明：本文观点纯主观，web3行业风险较大，请自行斟酌<br>
阅读建议：可以先看一下鼠鼠的总结章节，再从头了解</p>
</blockquote>
<h1 id="成为-Web3-开发者：一份循序渐进的学习指南">成为 Web3 开发者：一份循序渐进的学习指南</h1>
<p>Web3 的世界正在以前所未有的速度发展，为开发者带来了令人兴奋的机遇。如果你也想踏入这个充满创新和潜力的领域，那么这份学习路线图将为你指明方向。</p>
<p>本文从鼠鼠个人经验角度来分析如何一步步成长为一个 Web3 开发者。</p>
<h2 id="第一步：基础知识">第一步：基础知识</h2>
<p>在深入代码之前，理解 Web3 的核心概念至关重要。</p>
<ul>
<li><strong>区块链基础 (Blockchain Basics):</strong>
<ul>
<li>了解什么是区块链，它是如何工作的。</li>
<li>学习去中心化、不可篡改性、透明性等核心特性。</li>
<li>熟悉常见的区块链类型（如：以太坊、比特币等，以及他们的共识机制POW、POS）。</li>
</ul>
</li>
<li><strong>加密货币 (Cryptocurrencies):</strong>
<ul>
<li>理解加密货币的概念及其运作方式。</li>
<li>了解钱包、交易、挖矿等基本概念。</li>
</ul>
</li>
<li><strong>去中心化应用 (DApps):</strong>
<ul>
<li>理解什么是 DApp，以及它与传统 Web 应用的区别。</li>
<li>了解 DApp 的基本架构和组件。</li>
</ul>
</li>
</ul>
<h2 id="第二步：从以太坊生态出发">第二步：从以太坊生态出发</h2>
<p>以太坊是目前最流行的智能合约平台，学习以太坊生态对于成为 Web3 开发者至关重要。</p>
<ul>
<li><strong>智能合约 (Smart Contracts):</strong>
<ul>
<li>学习什么是智能合约，以及它们如何在区块链上执行。</li>
<li>掌握 Solidity 编程语言（由浅入深），这是以太坊上编写智能合约的主要语言。</li>
<li>了解智能合约的部署、测试和交互。</li>
</ul>
</li>
<li><strong>以太坊工具 (Ethereum Tools):</strong>
<ul>
<li>熟悉常用的开发工具，如 Hardhat 或 Foundry（用于开发、测试和部署智能合约）。</li>
<li>了解 Web3.js 、 Ethers.js 和 Viem.js（用于与以太坊区块链进行交互的 JavaScript 库）。</li>
<li>熟悉 MetaMask 等常用钱包的使用。</li>
</ul>
</li>
</ul>
<h2 id="第三步：前端-Web3-开发">第三步：前端 Web3 开发</h2>
<p>要构建用户可以与之交互的 DApp，你需要掌握前端 Web3 开发技能。</p>
<ul>
<li><strong>Web3 前端库:</strong>
<ul>
<li>学习如何使用 Web3.js 或 Ethers.js 在前端与智能合约进行交互。</li>
<li>了解如何连接用户钱包（如 MetaMask）。</li>
<li>学习如何在前端展示和处理区块链数据。</li>
</ul>
</li>
<li><strong>熟悉 React 或其他前端框架:</strong>
<ul>
<li>虽然不是必须的，但掌握一个现代 JavaScript 框架（如 React、Vue 或 Angular）将极大地提升开发效率。</li>
</ul>
</li>
</ul>
<h2 id="第四步：探索更广阔的-Web3-世界">第四步：探索更广阔的 Web3 世界</h2>
<p>一旦你掌握了以太坊开发的基础，就可以开始探索 Web3 中更广泛的领域。</p>
<ul>
<li><strong>Layer 2 扩展方案 (Layer 2 Scaling Solutions):</strong>
<ul>
<li>了解 Optimism、Arbitrum、Polygon 等 Layer 2 技术的原理和应用。</li>
<li>可能涉及到其他的编程语言，例如Rust、python等等，选择性学习</li>
</ul>
</li>
<li><strong>去中心化金融 (DeFi):</strong>
<ul>
<li>重中之重，这是最大应用场景，换句话说是最容易找到工作的赛道</li>
<li>学习 DeFi 的基本概念和常见的协议算法（如 DEX、借贷平台等）。</li>
</ul>
</li>
<li><strong>非同质化代币 (NFTs):</strong>
<ul>
<li>了解 NFT 的标准（如 ERC-721、ERC-1155）及其应用。</li>
</ul>
</li>
<li><strong>IPFS 和 Filecoin (Decentralized Storage):</strong>
<ul>
<li>了解去中心化存储的原理和常用方案</li>
</ul>
</li>
<li><strong>其他公链上的开发</strong>
<ul>
<li>自行探索哈哈哈</li>
</ul>
</li>
</ul>
<h2 id="第五步：职业规划与选择赛道">第五步：职业规划与选择赛道</h2>
<p>Web3 领域提供了多种职业发展方向。在学习了一定的基础知识后，你可以根据自己的兴趣和技能选择一个或多个细分领域深耕。</p>
<ul>
<li><strong>智能合约工程师 (Smart Contract Engineer):</strong> 专注于设计、开发、测试和部署智能合约。需要深入理解区块链底层原理和 Solidity 等语言。</li>
<li><strong>Web3 前端工程师 (Web3 Frontend Engineer):</strong> 专注于构建 DApp 的用户界面，与智能合约进行交互，并提供流畅的用户体验。需要熟悉前端技术栈和 Web3 前端库。</li>
<li><strong>DeFi 开发者 (DeFi Developer):</strong> 专注于构建去中心化金融协议和应用。需要了解金融概念和智能合约开发。</li>
<li><strong>NFT 开发者 (NFT Developer):</strong> 专注于创建和管理 NFT 项目，包括智能合约开发、元数据管理等。</li>
<li><strong>区块链协议工程师 (Blockchain Protocol Engineer):</strong> 参与底层区块链协议的开发和改进（通常需要更强的计算机科学背景）。</li>
<li><strong>Web3 安全工程师 (Web3 Security Engineer):</strong> 专注于识别和修复 Web3 应用和智能合约中的安全漏洞。</li>
</ul>
<p>考虑你对哪个领域最感兴趣，以及你的技能和背景更适合哪个方向。你可以先广泛了解，然后逐步聚焦。</p>
<h2 id="鼠鼠的总结">鼠鼠的总结</h2>
<ul>
<li>这里不比web2，每一个领域都完全成熟，所以不必太较劲，有些东西非常难，所以不好下手，例如DeFi算法，可以先体验体验DeFi的产品多交互交互，回头再看会简单一些</li>
<li>摸索的这段时间反而更觉得基础更重要，缺少了基础很难走的远，例如web2开发基础、自己的主编程语言的熟练度、区块链的底层原理</li>
<li>学习资源尽量在墙外找，很简单，把搜索引擎换成Google哈哈哈，不过英文的钓鱼网站也比较多，注意甄别</li>
<li>对于币圈的看法：这个看个人兴趣，喜欢投资（dubo）或者有金融知识储备的可以玩，对于开发者来说也不算坏事，我个人是不太感冒</li>
<li>可以多参与web3上的一些活动，例如撸空投、土狗、DAO等等，当然开发者最推荐的还是参加黑客松比赛，因为可以往简历上写哈哈哈，有兴趣的道友欢迎联系</li>
<li>在web3里最好是有志同道合的朋友一起学习，因为这一块的学习资源还是比较难整理的，比较乱，卖课骗子很多</li>
<li>学习技术最好是同时学好英文，对于求职比较有帮助，共勉</li>
<li>最后就是千万不要上当受骗，web3里的骗子实在是多的逆天，鼠鼠也上过一次当，还好只被骗了5U哈哈，总之千万要小心，路边的钱包不要捡、奇怪的网站不要信、陌生的签名不要签</li>
<li>还有就是关注政策法规，别把自己送进去了就白搭了</li>
</ul>
<h2 id="结语">结语</h2>
<p>感谢看完的道友，一起进步加油！塔塔开</p>
]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title>ethers和viem快速入门</title>
    <url>/2025/05/04/ethers%E5%92%8Cviem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Ethers">Ethers</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; ethers, Wallet &#125; from &quot;ethers&quot;;</span><br><span class="line">import &#123; abi, bytecode &#125; from &quot;./erc20&quot;;</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line"></span><br><span class="line">    // 基本使用： 获取当前块高，钱包地址，钱包余额，发送交易等等</span><br><span class="line">    const url = &quot;http://localhost:8545&quot;</span><br><span class="line">    const provider = new ethers.JsonRpcProvider(url);</span><br><span class="line">    const blockNumber = await provider.getBlockNumber();</span><br><span class="line">    console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class="line"></span><br><span class="line">    const privateKey = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;</span><br><span class="line">    const wallet = new Wallet(privateKey, provider);</span><br><span class="line">    const walletAddress = await wallet.getAddress();</span><br><span class="line">    console.log(`Wallet address: $&#123;walletAddress&#125;`);</span><br><span class="line"></span><br><span class="line">    const balance = await provider.getBalance(walletAddress);</span><br><span class="line">    console.log(`Wallet balance: $&#123;ethers.formatEther(balance)&#125; ETH`);</span><br><span class="line"></span><br><span class="line">    const transaction = &#123;</span><br><span class="line">        to: &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class="line">        value: &quot;1000000000000000000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    const tx = await wallet.sendTransaction(transaction);</span><br><span class="line">    await tx.wait()</span><br><span class="line">    console.log(`Transaction hash: $&#123;tx.hash&#125;`);</span><br><span class="line"></span><br><span class="line">    const newBalance = await provider.getBalance(walletAddress);</span><br><span class="line">    console.log(`New wallet balance: $&#123;ethers.formatEther(newBalance)&#125; ETH`);</span><br><span class="line"></span><br><span class="line">    // 合约交互： 部署合约，调用合约方法等等</span><br><span class="line">    const contract = new ethers.ContractFactory(abi,bytecode,wallet);</span><br><span class="line">    const contractInstance = await contract.deploy(&quot;name&quot;,&quot;symbol&quot;,18,100000);</span><br><span class="line">    await contractInstance.waitForDeployment();// 等待合约部署完成(打包到区块链)</span><br><span class="line">    const contractAddress = contractInstance.target.toString();</span><br><span class="line">    console.log(`Contract address: $&#123;contractInstance.target&#125;`);</span><br><span class="line"></span><br><span class="line">    const readContract = new ethers.Contract(contractAddress,abi,provider);</span><br><span class="line">    const totalSupply = await readContract.totalSupply();</span><br><span class="line">    console.log(`Total supply: $&#123;totalSupply&#125;`);</span><br><span class="line"></span><br><span class="line">    const writeContract = new ethers.Contract(contractAddress,abi,wallet);</span><br><span class="line">    const contractTransaction = await writeContract.transfer(&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,12345);</span><br><span class="line">    await contractTransaction.wait();</span><br><span class="line">    const erc20Balance = await readContract.balanceOf(&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;);</span><br><span class="line">    console.log(`New balance: $&#123;erc20Balance&#125;`);</span><br><span class="line"></span><br><span class="line">    // 事件监听： 监听合约事件等等</span><br><span class="line">    provider.on(&quot;block&quot;, async (blockNumber) =&gt; &#123;</span><br><span class="line">        console.log(`New block number: $&#123;blockNumber&#125;`);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="Viem">Viem</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createPublicClient, createWalletClient, defineChain, getContract, hexToBigInt, http &#125; from &quot;viem&quot;;</span><br><span class="line">import &#123; privateKeyToAccount &#125; from &quot;viem/accounts&quot;;</span><br><span class="line">import &#123; abi, bytecode &#125; from &quot;./erc20&quot;;</span><br><span class="line"></span><br><span class="line">export const localChain = (url: string) =&gt; defineChain(&#123;</span><br><span class="line">    id: 31337,</span><br><span class="line">    name: &quot;testnet&quot;,</span><br><span class="line">    network: &quot;testnet&quot;,</span><br><span class="line">    nativeCurrency: &#123;</span><br><span class="line">        decimals: 18,</span><br><span class="line">        name: &quot;Ether&quot;,</span><br><span class="line">        symbol: &quot;ETH&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    rpcUrls: &#123;</span><br><span class="line">        default: &#123;</span><br><span class="line">            http: [url],</span><br><span class="line">        &#125;,</span><br><span class="line">        public: &#123;</span><br><span class="line">            http: [url],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    testnet: true,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">    const url = &quot;http://127.0.0.1:8545&quot;;</span><br><span class="line">    const publicClient = createPublicClient(&#123;</span><br><span class="line">        chain: localChain(url),</span><br><span class="line">        transport: http(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Public client</span><br><span class="line">    const blockNumber = await publicClient.getBlockNumber();</span><br><span class="line">    console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class="line"></span><br><span class="line">    const pk = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;</span><br><span class="line">    const wallet = privateKeyToAccount(pk);</span><br><span class="line">    const address = wallet.address;</span><br><span class="line">    console.log(`Wallet address: $&#123;address&#125;`);</span><br><span class="line">    const balance = await publicClient.getBalance(&#123; address &#125;);</span><br><span class="line">    console.log(`Wallet balance: $&#123;balance&#125;`);</span><br><span class="line"></span><br><span class="line">    // Wallet client</span><br><span class="line">    const walletClient = createWalletClient(&#123;</span><br><span class="line">        account: wallet,</span><br><span class="line">        chain: localChain(url),</span><br><span class="line">        transport: http(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const tx = await walletClient.sendTransaction(&#123;</span><br><span class="line">        to: &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class="line">        value: hexToBigInt(&quot;0x100&quot;),</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(`Transaction hash: $&#123;tx&#125;`);</span><br><span class="line"></span><br><span class="line">    // Deploy contract (return hash)</span><br><span class="line">    const formattedBytecode = `0x$&#123;bytecode&#125;`;</span><br><span class="line">    const contract = await walletClient.deployContract(&#123;</span><br><span class="line">        abi,</span><br><span class="line">        bytecode: formattedBytecode,</span><br><span class="line">        account: wallet,</span><br><span class="line">        args: [&quot;Test Token&quot;, &quot;TST&quot;, 18, BigInt(10000)],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Get contract address</span><br><span class="line">    const receipt = await publicClient.waitForTransactionReceipt(&#123; hash: contract &#125;);</span><br><span class="line">    if (!receipt.contractAddress) &#123;</span><br><span class="line">        throw new Error(&quot;Contract deployment failed or no contract address returned.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    const contractAddress = receipt.contractAddress;</span><br><span class="line">    console.log(`Contract address: $&#123;contractAddress&#125;`);</span><br><span class="line"></span><br><span class="line">    // Call contract</span><br><span class="line">    const totalSupply = await publicClient.readContract(&#123;</span><br><span class="line">        address: contractAddress, // TypeScript now ensures this is non-null</span><br><span class="line">        abi,</span><br><span class="line">        functionName: &quot;totalSupply&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(`Total supply: $&#123;totalSupply&#125;`);</span><br><span class="line"></span><br><span class="line">    // Transfer tokens</span><br><span class="line">    const writeContract = getContract(&#123;</span><br><span class="line">        address: contractAddress,</span><br><span class="line">        abi: abi,</span><br><span class="line">        client: walletClient,</span><br><span class="line">    &#125;)</span><br><span class="line">    const tx2 = await writeContract.write.transfer([</span><br><span class="line">        &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class="line">        321,</span><br><span class="line">    ]);</span><br><span class="line">    const erc20balance = await publicClient.readContract(&#123;</span><br><span class="line">        address: contractAddress,</span><br><span class="line">        abi: abi,</span><br><span class="line">        functionName: &quot;balanceOf&quot;,</span><br><span class="line">        args: [&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;],</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(`ERC20 balance: $&#123;erc20balance&#125;`);</span><br><span class="line"></span><br><span class="line">    // Watch block</span><br><span class="line">    publicClient.watchBlockNumber(&#123;</span><br><span class="line">        onBlockNumber: (blockNumber) =&gt; &#123;</span><br><span class="line">            console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch((error) =&gt; &#123;</span><br><span class="line">    console.error(&quot;An error occurred:&quot;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>web3</tag>
        <tag>ethers</tag>
        <tag>viem</tag>
      </tags>
  </entry>
  <entry>
    <title>gnark零知识证明实战指南</title>
    <url>/2025/10/11/ganrk%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="gnark-零知识证明实战指南">gnark 零知识证明实战指南</h1>
<blockquote>
<p>从零到一掌握 zkSNARK 开发：理论、实践与应用场景全解析</p>
</blockquote>
<h2 id="📚-目录">📚 目录</h2>
<ol>
<li><a href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E5%9F%BA%E7%A1%80">零知识证明基础</a></li>
<li><a href="#gnark-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D">gnark 框架介绍</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3">核心概念详解</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98">开发实战</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li>
</ol>
<hr>
<h2 id="零知识证明基础">零知识证明基础</h2>
<h3 id="什么是零知识证明？">什么是零知识证明？</h3>
<p>零知识证明（Zero-Knowledge Proof, ZKP）是一种密码学协议，允许一方（证明者 Prover）向另一方（验证者 Verifier）证明某个陈述是真实的，而<strong>无需透露任何额外信息</strong>。</p>
<h4 id="经典例子：阿里巴巴的洞穴">经典例子：阿里巴巴的洞穴</h4>
<p>想象一个环形洞穴，中间有一扇需要密码才能打开的门：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   入口</span><br><span class="line">    |</span><br><span class="line"> /--+--\</span><br><span class="line">A       B</span><br><span class="line"> \     /</span><br><span class="line">  \门/</span><br></pre></td></tr></table></figure>
<ul>
<li>Alice 声称她知道密码</li>
<li>Bob 想验证但不想知道密码</li>
<li>Alice 进入洞穴，随机选择 A 或 B 路径</li>
<li>Bob 在入口随机喊 “从 A 出来” 或 “从 B 出来”</li>
<li>如果 Alice 真的知道密码，她总能从指定出口出来</li>
<li>重复多次后，Bob 确信 Alice 知道密码，但他自己并不知道密码是什么</li>
</ul>
<h3 id="三大核心属性">三大核心属性</h3>
<ol>
<li>
<p><strong>完备性（Completeness）</strong></p>
<ul>
<li>如果陈述为真，诚实的证明者总能说服验证者</li>
<li>正确的输入 → 证明一定通过</li>
</ul>
</li>
<li>
<p><strong>可靠性（Soundness）</strong></p>
<ul>
<li>如果陈述为假，欺诈的证明者无法欺骗验证者</li>
<li>错误的输入 → 证明一定失败</li>
<li>即使攻击者有巨大算力也无法伪造</li>
</ul>
</li>
<li>
<p><strong>零知识性（Zero-Knowledge）</strong></p>
<ul>
<li>验证者除了&quot;陈述为真&quot;之外，学不到任何其他信息</li>
<li>私有数据保持完全隐私</li>
</ul>
</li>
</ol>
<h3 id="zkSNARK-vs-zkSTARK">zkSNARK vs zkSTARK</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>zkSNARK</th>
<th>zkSTARK</th>
</tr>
</thead>
<tbody>
<tr>
<td>全称</td>
<td>Zero-Knowledge Succinct Non-Interactive ARgument of Knowledge</td>
<td>Zero-Knowledge Scalable Transparent ARgument of Knowledge</td>
</tr>
<tr>
<td>证明大小</td>
<td>很小（~200 bytes）</td>
<td>较大（~100 KB）</td>
</tr>
<tr>
<td>验证速度</td>
<td>极快（~1 ms）</td>
<td>快（~10 ms）</td>
</tr>
<tr>
<td>生成速度</td>
<td>快</td>
<td>较慢</td>
</tr>
<tr>
<td>可信设置</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>量子抗性</td>
<td>❌ 无</td>
<td>✅ 有</td>
</tr>
<tr>
<td>适用场景</td>
<td>区块链、隐私交易</td>
<td>大规模计算证明</td>
</tr>
</tbody>
</table>
<p>本教程聚焦于 <strong>zkSNARK（Groth16）</strong>，它是目前最成熟、应用最广的方案。</p>
<hr>
<h2 id="gnark-框架介绍">gnark 框架介绍</h2>
<h3 id="为什么选择-gnark？">为什么选择 gnark？</h3>
<p><a href="https://github.com/ConsenSys/gnark">gnark</a> 是 ConsenSys 开发的高性能 Go 语言 zkSNARK 框架。</p>
<h4 id="核心优势">核心优势</h4>
<p>✅ <strong>高性能</strong></p>
<ul>
<li>生产级性能优化</li>
<li>支持并行计算</li>
<li>编译速度快</li>
</ul>
<p>✅ <strong>易用性</strong></p>
<ul>
<li>简洁的 API 设计</li>
<li>强类型检查</li>
<li>丰富的文档</li>
</ul>
<p>✅ <strong>多后端支持</strong></p>
<ul>
<li>Groth16（最流行）</li>
<li>PlonK</li>
<li>即将支持 STARK</li>
</ul>
<p>✅ <strong>工业级应用</strong></p>
<ul>
<li>被多个区块链项目采用</li>
<li>经过大量审计</li>
<li>活跃的社区支持</li>
</ul>
<p>✅ <strong>完整生态</strong></p>
<ul>
<li>gnark-crypto：底层密码学库</li>
<li>gnark：电路编译和证明生成</li>
<li>丰富的标准库（哈希、签名、Merkle 树等）</li>
</ul>
<h3 id="框架对比">框架对比</h3>
<table>
<thead>
<tr>
<th>框架</th>
<th>语言</th>
<th>后端</th>
<th>成熟度</th>
<th>学习曲线</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>gnark</strong></td>
<td>Go</td>
<td>Groth16, PlonK</td>
<td>⭐⭐⭐⭐⭐</td>
<td>中等</td>
</tr>
<tr>
<td>circom</td>
<td>JavaScript</td>
<td>Groth16, PlonK</td>
<td>⭐⭐⭐⭐⭐</td>
<td>较低</td>
</tr>
<tr>
<td>bellman</td>
<td>Rust</td>
<td>Groth16</td>
<td>⭐⭐⭐⭐</td>
<td>较高</td>
</tr>
<tr>
<td>libsnark</td>
<td>C++</td>
<td>Groth16</td>
<td>⭐⭐⭐⭐</td>
<td>高</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="核心概念详解">核心概念详解</h2>
<h3 id="1-电路（Circuit）">1. 电路（Circuit）</h3>
<p>电路是零知识证明的核心，定义了要证明的计算逻辑。</p>
<h4 id="电路结构">电路结构</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 私有输入（证明者知道，但不会泄露）</span></span><br><span class="line">    PrivateInput frontend.Variable <span class="string">`gnark:&quot;private_input&quot;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公开输入（所有人都能看到）</span></span><br><span class="line">    PublicInput frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公开输出（计算结果）</span></span><br><span class="line">    Output frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约束定义">约束定义</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *MyCircuit)</span></span> Define(api frontend.API) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 定义计算逻辑和约束条件</span></span><br><span class="line">    <span class="comment">// 所有约束必须满足，证明才能生成</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：output = private_input + public_input</span></span><br><span class="line">    sum := api.Add(circuit.PrivateInput, circuit.PublicInput)</span><br><span class="line">    api.AssertIsEqual(circuit.Output, sum)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-约束系统（Constraint-System）">2. 约束系统（Constraint System）</h3>
<p>约束系统是电路的数学表示形式。</p>
<h4 id="R1CS（Rank-1-Constraint-System）">R1CS（Rank-1 Constraint System）</h4>
<p>R1CS 是最常见的约束系统，每个约束的形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a₁·x₁ + a₂·x₂ + ... ) · (b₁·x₁ + b₂·x₂ + ... ) = (c₁·x₁ + c₂·x₂ + ... )</span><br></pre></td></tr></table></figure>
<p>gnark 自动将高级电路代码编译为 R1CS。</p>
<h4 id="约束类型">约束类型</h4>
<ul>
<li><strong>等式约束</strong>：<code>api.AssertIsEqual(a, b)</code></li>
<li><strong>不等式约束</strong>：<code>api.AssertIsLessOrEqual(a, b)</code></li>
<li><strong>布尔约束</strong>：<code>api.AssertIsBoolean(a)</code></li>
<li><strong>算术约束</strong>：<code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code></li>
</ul>
<h3 id="3-见证（Witness）">3. 见证（Witness）</h3>
<p>见证是电路中所有变量的具体赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建见证</span></span><br><span class="line">assignment := MyCircuit&#123;</span><br><span class="line">    PrivateInput: <span class="number">42</span>,    <span class="comment">// 私有值</span></span><br><span class="line">    PublicInput:  <span class="number">10</span>,    <span class="comment">// 公开值</span></span><br><span class="line">    Output:       <span class="number">52</span>,    <span class="comment">// 输出值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">witness, _ := frontend.NewWitness(&amp;assignment, ecc.BN254.ScalarField())</span><br></pre></td></tr></table></figure>
<h3 id="4-证明系统流程">4. 证明系统流程</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│                     Setup 阶段（一次性）                  │</span><br><span class="line">│  1. 定义电路                                             │</span><br><span class="line">│  2. 编译为 R1CS                                          │</span><br><span class="line">│  3. 生成证明密钥 (pk) 和验证密钥 (vk)                    │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br><span class="line">                           │</span><br><span class="line">                           ↓</span><br><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│                   Prove 阶段（每次证明）                  │</span><br><span class="line">│  1. 准备见证（私有+公开输入）                             │</span><br><span class="line">│  2. 使用 pk 生成证明                                     │</span><br><span class="line">│  3. 输出：proof + 公开输入                                │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br><span class="line">                           │</span><br><span class="line">                           ↓</span><br><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│                  Verify 阶段（快速验证）                  │</span><br><span class="line">│  1. 接收：proof + 公开输入                                │</span><br><span class="line">│  2. 使用 vk 验证                                         │</span><br><span class="line">│  3. 输出：✅ 通过 / ❌ 拒绝                               │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="开发实战">开发实战</h2>
<h3 id="案例-1：年龄验证（入门）">案例 1：年龄验证（入门）</h3>
<p><strong>场景</strong>：证明你年满 18 岁，但不泄露具体年龄。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/consensys/gnark-crypto/ecc&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/consensys/gnark/backend/groth16&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/consensys/gnark/frontend&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/consensys/gnark/frontend/cs/r1cs&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AgeCircuit 证明年龄 &gt;= 18</span></span><br><span class="line"><span class="keyword">type</span> AgeCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age       frontend.Variable <span class="string">`gnark:&quot;age&quot;`</span>        <span class="comment">// 私有：实际年龄</span></span><br><span class="line">    AgeLimit  frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span>    <span class="comment">// 公开：年龄限制（18）</span></span><br><span class="line">    IsAdult   frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span>    <span class="comment">// 公开：是否成年</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *AgeCircuit)</span></span> Define(api frontend.API) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 约束1：年龄必须 &gt;= 限制</span></span><br><span class="line">    api.AssertIsLessOrEqual(circuit.AgeLimit, circuit.Age)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 约束2：isAdult 必须为 1（表示成年）</span></span><br><span class="line">    api.AssertIsEqual(circuit.IsAdult, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Setup</span></span><br><span class="line">    <span class="keyword">var</span> circuit AgeCircuit</span><br><span class="line">    ccs, _ := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &amp;circuit)</span><br><span class="line">    pk, vk, _ := groth16.Setup(ccs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Prove：Alice 25 岁</span></span><br><span class="line">    assignment := AgeCircuit&#123;</span><br><span class="line">        Age:      <span class="number">25</span>,  <span class="comment">// 私有</span></span><br><span class="line">        AgeLimit: <span class="number">18</span>,  <span class="comment">// 公开</span></span><br><span class="line">        IsAdult:  <span class="number">1</span>,   <span class="comment">// 公开</span></span><br><span class="line">    &#125;</span><br><span class="line">    witness, _ := frontend.NewWitness(&amp;assignment, ecc.BN254.ScalarField())</span><br><span class="line">    publicWitness, _ := witness.Public()</span><br><span class="line">    proof, _ := groth16.Prove(ccs, pk, witness)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Verify</span></span><br><span class="line">    err := groth16.Verify(proof, vk, publicWitness)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;✅ 验证通过：用户年满 18 岁&quot;</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;   但我们不知道用户的具体年龄！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li>验证者只看到 <code>AgeLimit=18</code> 和 <code>IsAdult=1</code></li>
<li>实际年龄 <code>Age=25</code> 完全保密</li>
<li>无法伪造（如果年龄 &lt; 18，证明生成会失败）</li>
</ul>
<h3 id="案例-2：数独解答验证（进阶）">案例 2：数独解答验证（进阶）</h3>
<p><strong>场景</strong>：证明你知道数独的解，但不泄露答案。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SudokuCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 私有：完整的解答（81个数字）</span></span><br><span class="line">    Solution [<span class="number">81</span>]frontend.Variable <span class="string">`gnark:&quot;solution&quot;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公开：初始谜题（0 表示空格）</span></span><br><span class="line">    Puzzle [<span class="number">81</span>]frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *SudokuCircuit)</span></span> Define(api frontend.API) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 约束1：谜题中的非零数字必须与解答一致</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">81</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 如果谜题位置有数字，解答必须相同</span></span><br><span class="line">        isGiven := api.IsZero(circuit.Puzzle[i])</span><br><span class="line">        match := api.IsZero(api.Sub(circuit.Puzzle[i], circuit.Solution[i]))</span><br><span class="line">        api.AssertIsEqual(api.Or(isGiven, match), <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 约束2：每行包含 1-9（无重复）</span></span><br><span class="line">    <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; <span class="number">9</span>; row++ &#123;</span><br><span class="line">        checkUnique(api, circuit.Solution[row*<span class="number">9</span>:(row+<span class="number">1</span>)*<span class="number">9</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 约束3：每列包含 1-9（无重复）</span></span><br><span class="line">    <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; <span class="number">9</span>; col++ &#123;</span><br><span class="line">        <span class="keyword">var</span> column [<span class="number">9</span>]frontend.Variable</span><br><span class="line">        <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; <span class="number">9</span>; row++ &#123;</span><br><span class="line">            column[row] = circuit.Solution[row*<span class="number">9</span>+col]</span><br><span class="line">        &#125;</span><br><span class="line">        checkUnique(api, column[:])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 约束4：每个 3x3 宫格包含 1-9（无重复）</span></span><br><span class="line">    <span class="comment">// ... 类似实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用价值</strong>：</p>
<ul>
<li>在线游戏：验证玩家解答正确性</li>
<li>竞赛系统：防止作弊但保护答案</li>
<li>教育平台：自动批改但不泄露标准答案</li>
</ul>
<h3 id="案例-3：密码登录（实用）">案例 3：密码登录（实用）</h3>
<p><strong>场景</strong>：证明知道密码，但不在网络上传输密码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PasswordCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 私有：用户的密码</span></span><br><span class="line">    Password frontend.Variable <span class="string">`gnark:&quot;password&quot;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公开：密码的哈希（服务器存储）</span></span><br><span class="line">    PasswordHash frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *PasswordCircuit)</span></span> Define(api frontend.API) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 计算密码的哈希</span></span><br><span class="line">    mimc, _ := mimc.NewMiMC(api)</span><br><span class="line">    mimc.Write(circuit.Password)</span><br><span class="line">    computedHash := mimc.Sum()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证哈希匹配</span></span><br><span class="line">    api.AssertIsEqual(circuit.PasswordHash, computedHash)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优势</strong>：</p>
<ul>
<li>密码永不传输（即使被监听也安全）</li>
<li>服务器只存储哈希</li>
<li>抗量子攻击（取决于哈希函数选择）</li>
</ul>
<h3 id="案例-4：Merkle-树成员证明（高级）">案例 4：Merkle 树成员证明（高级）</h3>
<p><strong>场景</strong>：证明某个数据在 Merkle 树中，但不泄露其他数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/consensys/gnark/std/accumulator/merkle&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MerkleCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 私有：叶子节点数据</span></span><br><span class="line">    Leaf frontend.Variable <span class="string">`gnark:&quot;leaf&quot;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有：Merkle 路径</span></span><br><span class="line">    Path []frontend.Variable <span class="string">`gnark:&quot;path&quot;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公开：Merkle 根</span></span><br><span class="line">    Root frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(circuit *MerkleCircuit)</span></span> Define(api frontend.API) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 从叶子节点向上计算到根</span></span><br><span class="line">    currentHash := circuit.Leaf</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(circuit.Path); i++ &#123;</span><br><span class="line">        mimc, _ := mimc.NewMiMC(api)</span><br><span class="line">        mimc.Write(currentHash)</span><br><span class="line">        mimc.Write(circuit.Path[i])</span><br><span class="line">        currentHash = mimc.Sum()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证计算出的根与公开的根一致</span></span><br><span class="line">    api.AssertIsEqual(currentHash, circuit.Root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong>：</p>
<ul>
<li>区块链：轻客户端验证交易</li>
<li>隐私投票：证明投票权但不泄露身份</li>
<li>空投资格：证明在白名单中但不公开列表</li>
</ul>
<hr>
<h2 id="应用场景">应用场景</h2>
<h3 id="1-区块链与加密货币">1. 区块链与加密货币</h3>
<h4 id="隐私交易（如-Zcash）">隐私交易（如 Zcash）</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统交易：</span><br><span class="line">Alice → Bob: 10 ETH</span><br><span class="line">↑ 所有人都能看到金额和地址</span><br><span class="line"></span><br><span class="line">ZK 隐私交易：</span><br><span class="line">Alice → Bob: ??? ETH</span><br><span class="line">↑ 只能看到交易有效，金额和地址保密</span><br></pre></td></tr></table></figure>
<h4 id="Layer-2-扩容（如-zkSync-StarkNet）">Layer 2 扩容（如 zkSync, StarkNet）</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链上：只存储证明（小）</span><br><span class="line">链下：执行大量交易</span><br><span class="line"></span><br><span class="line">验证成本：O(1)</span><br><span class="line">交易吞吐量：↑↑↑</span><br></pre></td></tr></table></figure>
<h3 id="2-身份认证">2. 身份认证</h3>
<h4 id="年龄验证">年龄验证</h4>
<ul>
<li>进入成人网站</li>
<li>购买酒精/烟草</li>
<li>不泄露出生日期</li>
</ul>
<h4 id="信用评分">信用评分</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CreditScoreCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Score      frontend.Variable <span class="string">`gnark:&quot;score&quot;`</span>        <span class="comment">// 私有</span></span><br><span class="line">    Threshold  frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span>      <span class="comment">// 公开：如 700</span></span><br><span class="line">    IsQualified frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span>     <span class="comment">// 公开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>贷款审批</li>
<li>信用卡申请</li>
<li>不泄露具体分数</li>
</ul>
<h3 id="3-数据隐私">3. 数据隐私</h3>
<h4 id="医疗数据">医疗数据</h4>
<ul>
<li>证明已接种疫苗，不泄露其他健康信息</li>
<li>证明符合临床试验条件，不泄露病史</li>
</ul>
<h4 id="财务审计">财务审计</h4>
<ul>
<li>证明收入在某个范围，不泄露具体金额</li>
<li>证明纳税合规，不泄露交易细节</li>
</ul>
<h3 id="4-游戏与娱乐">4. 游戏与娱乐</h3>
<h4 id="公平游戏">公平游戏</h4>
<ul>
<li>扑克：证明出牌合法但不泄露手牌</li>
<li>彩票：可验证的随机性</li>
</ul>
<h4 id="成就系统">成就系统</h4>
<ul>
<li>证明游戏通关但不泄露策略</li>
<li>证明技能达标但不泄露练习数据</li>
</ul>
<h3 id="5-供应链与物流">5. 供应链与物流</h3>
<h4 id="产品溯源">产品溯源</h4>
<ul>
<li>证明产品来自认证供应商</li>
<li>不泄露供应链细节（商业机密）</li>
</ul>
<h4 id="合规证明">合规证明</h4>
<ul>
<li>证明符合环保标准</li>
<li>不泄露生产工艺</li>
</ul>
<h3 id="6-机器学习">6. 机器学习</h3>
<h4 id="模型推理">模型推理</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户：我的数据 + 模型</span><br><span class="line">服务商：推理结果</span><br><span class="line"></span><br><span class="line">ZK 保护：</span><br><span class="line">- 用户数据不泄露</span><br><span class="line">- 模型参数不泄露</span><br><span class="line">- 结果可验证</span><br></pre></td></tr></table></figure>
<h4 id="联邦学习">联邦学习</h4>
<ul>
<li>证明模型训练正确</li>
<li>不泄露本地数据</li>
</ul>
<hr>
<h2 id="性能优化">性能优化</h2>
<h3 id="1-减少约束数量">1. 减少约束数量</h3>
<p>约束数量直接影响性能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 低效：多次哈希</span></span><br><span class="line">hash1 := hashOnce(data)</span><br><span class="line">hash2 := hashOnce(hash1)</span><br><span class="line">hash3 := hashOnce(hash2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 高效：批量哈希</span></span><br><span class="line">hashBatch(data, iterations)</span><br></pre></td></tr></table></figure>
<h3 id="2-选择-ZK-友好的操作">2. 选择 ZK 友好的操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>约束成本</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法/减法</td>
<td>低</td>
<td>✅ 优先使用</td>
</tr>
<tr>
<td>乘法</td>
<td>中</td>
<td>✅ 适量使用</td>
</tr>
<tr>
<td>除法</td>
<td>高</td>
<td>⚠️ 尽量避免</td>
</tr>
<tr>
<td>SHA256</td>
<td>极高（~25K）</td>
<td>❌ 避免</td>
</tr>
<tr>
<td>MiMC</td>
<td>低（~200）</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td>Poseidon</td>
<td>低（~150）</td>
<td>✅ 最优</td>
</tr>
</tbody>
</table>
<h3 id="3-使用查找表">3. 使用查找表</h3>
<p>对于固定映射关系，使用查找表比计算更高效：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找表：输入 → 输出</span></span><br><span class="line">table := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>&#125; <span class="comment">// x²</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电路中使用</span></span><br><span class="line">api.Lookup(input, table)</span><br></pre></td></tr></table></figure>
<h3 id="4-并行化">4. 并行化</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Setup 可以离线并行化</span></span><br><span class="line"><span class="comment">// Prove 可以多核加速</span></span><br><span class="line"><span class="comment">// Verify 本身就很快（1-2ms）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量验证多个证明</span></span><br><span class="line">groth16.BatchVerify(proofs, vks, publicWitnesses)</span><br></pre></td></tr></table></figure>
<h3 id="5-选择合适的椭圆曲线">5. 选择合适的椭圆曲线</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BN254：最流行，以太坊兼容</span></span><br><span class="line">ecc.BN254</span><br><span class="line"></span><br><span class="line"><span class="comment">// BLS12-381：更安全，Filecoin/Chia 使用</span></span><br><span class="line">ecc.BLS12_381</span><br><span class="line"></span><br><span class="line"><span class="comment">// BLS12-377：适合递归证明</span></span><br><span class="line">ecc.BLS12_377</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最佳实践">最佳实践</h2>
<h3 id="1-电路设计原则">1. 电路设计原则</h3>
<h4 id="明确隐私边界">明确隐私边界</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WellDesignedCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ✅ 明确标记私有/公开</span></span><br><span class="line">    Secret frontend.Variable <span class="string">`gnark:&quot;secret&quot;`</span></span><br><span class="line">    Public frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小化公开信息">最小化公开信息</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 过度公开</span></span><br><span class="line"><span class="keyword">type</span> BadCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age     frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span>  <span class="comment">// 不需要公开具体年龄</span></span><br><span class="line">    IsAdult frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 最小公开</span></span><br><span class="line"><span class="keyword">type</span> GoodCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age     frontend.Variable <span class="string">`gnark:&quot;age&quot;`</span>      <span class="comment">// 私有</span></span><br><span class="line">    IsAdult frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span>  <span class="comment">// 只公开结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-安全考虑">2. 安全考虑</h3>
<h4 id="可信设置">可信设置</h4>
<p>Groth16 需要可信设置，必须安全进行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案1：使用已有的可信设置（如 Powers of Tau）</span><br><span class="line">方案2：举办多方计算（MPC）仪式</span><br><span class="line">方案3：使用不需要可信设置的后端（PlonK, STARK）</span><br></pre></td></tr></table></figure>
<h4 id="防止侧信道攻击">防止侧信道攻击</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 危险：条件分支可能泄露信息</span></span><br><span class="line"><span class="keyword">if</span> secret &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="comment">// ... 不同的计算路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 安全：恒定时间操作</span></span><br><span class="line">result := api.Select(api.Cmp(secret, <span class="number">100</span>), branch1, branch2)</span><br></pre></td></tr></table></figure>
<h3 id="3-测试策略">3. 测试策略</h3>
<h4 id="完整的测试覆盖">完整的测试覆盖</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCircuit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 测试1：正常情况</span></span><br><span class="line">    testValid(t)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试2：边界情况</span></span><br><span class="line">    testBoundary(t)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试3：异常情况（应该失败）</span></span><br><span class="line">    testInvalid(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模糊测试">模糊测试</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用随机输入测试电路鲁棒性</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    randomInput := generateRandom()</span><br><span class="line">    testCircuit(randomInput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-生产部署">4. 生产部署</h3>
<h4 id="密钥管理">密钥管理</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Setup 阶段：</span><br><span class="line">1. 在安全环境中生成 pk, vk</span><br><span class="line">2. 销毁 Setup 的随机性（toxic waste）</span><br><span class="line">3. pk 加密存储（证明生成方）</span><br><span class="line">4. vk 可以公开（验证方）</span><br></pre></td></tr></table></figure>
<h4 id="版本控制">版本控制</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Circuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Version frontend.Variable <span class="string">`gnark:&quot;,public&quot;`</span></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保证明和电路版本匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="监控与日志">监控与日志</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录关键指标</span></span><br><span class="line">log.Printf(<span class="string">&quot;Prove time: %v&quot;</span>, proveTime)</span><br><span class="line">log.Printf(<span class="string">&quot;Constraints: %d&quot;</span>, ccs.GetNbConstraints())</span><br><span class="line">log.Printf(<span class="string">&quot;Proof size: %d bytes&quot;</span>, <span class="built_in">len</span>(proof))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="常见问题">常见问题</h2>
<h3 id="Q1-如何选择合适的哈希函数？">Q1: 如何选择合适的哈希函数？</h3>
<p><strong>A:</strong> 根据场景选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通用场景：MiMC 或 Poseidon</span><br><span class="line">需要与外部系统兼容：SHA256（但性能差）</span><br><span class="line">递归证明：Poseidon（专门优化）</span><br><span class="line">最佳性能：Poseidon</span><br></pre></td></tr></table></figure>
<h3 id="Q2-约束数量如何影响性能？">Q2: 约束数量如何影响性能？</h3>
<p><strong>A:</strong></p>
<ul>
<li><strong>Prove 时间</strong>：线性相关（约束越多越慢）</li>
<li><strong>Verify 时间</strong>：几乎恒定（~1-2ms，与约束数量无关！）</li>
<li><strong>Proof 大小</strong>：Groth16 固定（~200 bytes）</li>
</ul>
<h3 id="Q3-如何调试电路？">Q3: 如何调试电路？</h3>
<p><strong>A:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：打印中间值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Debug value: %v\n&quot;</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用 gnark 的调试模式</span></span><br><span class="line">frontend.Compile(..., frontend.WithDebug())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：单元测试每个约束</span></span><br><span class="line">testConstraint(t, constraint1)</span><br><span class="line">testConstraint(t, constraint2)</span><br></pre></td></tr></table></figure>
<h3 id="Q4-能否在电路中使用浮点数？">Q4: 能否在电路中使用浮点数？</h3>
<p><strong>A:</strong> 不能直接使用。ZK 电路工作在有限域上（整数运算）。</p>
<p>解决方案：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定点数：放大 10^6 倍</span></span><br><span class="line">price := <span class="number">123.45</span></span><br><span class="line">priceInCircuit := <span class="number">123450000</span>  <span class="comment">// 乘以 10^6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电路内计算后再还原</span></span><br></pre></td></tr></table></figure>
<h3 id="Q5-如何处理大数组？">Q5: 如何处理大数组？</h3>
<p><strong>A:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 不推荐：数组太大</span></span><br><span class="line"><span class="keyword">type</span> Circuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data [<span class="number">10000</span>]frontend.Variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐：使用 Merkle 树</span></span><br><span class="line"><span class="keyword">type</span> Circuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    MerkleRoot frontend.Variable</span><br><span class="line">    MerklePath []frontend.Variable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q6-Groth16-vs-PlonK-如何选择？">Q6: Groth16 vs PlonK 如何选择？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Groth16</th>
<th>PlonK</th>
</tr>
</thead>
<tbody>
<tr>
<td>可信设置</td>
<td>每个电路需要</td>
<td>通用设置（一次性）</td>
</tr>
<tr>
<td>证明大小</td>
<td>更小（~200B）</td>
<td>较大（~400B）</td>
</tr>
<tr>
<td>验证速度</td>
<td>最快</td>
<td>快</td>
</tr>
<tr>
<td>灵活性</td>
<td>低</td>
<td>高（支持自定义门）</td>
</tr>
<tr>
<td>成熟度</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
</tr>
</tbody>
</table>
<p><strong>建议</strong>：</p>
<ul>
<li>生产环境、性能关键 → Groth16</li>
<li>快速迭代、频繁修改电路 → PlonK</li>
</ul>
<h3 id="Q7-如何实现递归证明？">Q7: 如何实现递归证明？</h3>
<p>递归证明：在电路内验证另一个证明。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RecursiveCircuit <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内部证明</span></span><br><span class="line">    InnerProof frontend.Variable</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证密钥</span></span><br><span class="line">    InnerVK frontend.Variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RecursiveCircuit)</span></span> Define(api frontend.API) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 在电路内验证 InnerProof</span></span><br><span class="line">    verifier := groth16.NewVerifier(api)</span><br><span class="line">    verifier.Verify(c.InnerProof, c.InnerVK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用</strong>：区块链压缩（证明链压缩为单个证明）</p>
<hr>
<h2 id="学习资源">学习资源</h2>
<h3 id="官方文档">官方文档</h3>
<ul>
<li><a href="https://github.com/ConsenSys/gnark">gnark GitHub</a></li>
<li><a href="https://docs.gnark.consensys.net/">gnark 文档</a></li>
<li><a href="https://github.com/ConsenSys/gnark-crypto">gnark-crypto</a></li>
</ul>
<h3 id="推荐阅读">推荐阅读</h3>
<h4 id="理论基础">理论基础</h4>
<ul>
<li>📘 <a href="https://zkp.science/">ZK 学习资源</a></li>
<li>📘 <a href="https://eprint.iacr.org/2016/260">Groth16 论文</a></li>
<li>📘 <a href="https://arxiv.org/abs/1906.07221">Why and How zk-SNARK Works</a></li>
</ul>
<h4 id="实战教程">实战教程</h4>
<ul>
<li>💻 <a href="https://github.com/ConsenSys/gnark/tree/master/examples">gnark 官方示例</a></li>
<li>💻 <a href="https://zkhack.dev/">ZK Hack</a></li>
<li>💻 <a href="https://learn.0xparc.org/">0xPARC Learning Resources</a></li>
</ul>
<hr>
<h2 id="项目实战：构建完整系统">项目实战：构建完整系统</h2>
<h3 id="端到端示例：隐私投票系统">端到端示例：隐私投票系统</h3>
<p>完整代码见本仓库的 <code>lesson*.go</code> 文件。</p>
<h4 id="系统架构">系统架构</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│   客户端    │ → 生成投票证明</span><br><span class="line">└──────┬──────┘</span><br><span class="line">       │ proof + 公开信息</span><br><span class="line">       ↓</span><br><span class="line">┌─────────────┐</span><br><span class="line">│   服务器    │ → 验证证明</span><br><span class="line">└──────┬──────┘</span><br><span class="line">       │ 记录投票</span><br><span class="line">       ↓</span><br><span class="line">┌─────────────┐</span><br><span class="line">│  区块链/DB  │ → 存储结果</span><br><span class="line">└─────────────┘</span><br></pre></td></tr></table></figure>
<h4 id="核心特性">核心特性</h4>
<p>✅ 投票隐私（不知道谁投给谁）<br>
✅ 一人一票（防止重复投票）<br>
✅ 可验证性（任何人都能验证结果）<br>
✅ 抗强制（无法证明你的投票）</p>
<hr>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>ZK</tag>
      </tags>
  </entry>
  <entry>
    <title>go-blockchain学习笔记01</title>
    <url>/2025/06/09/go-blockchain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前言：近日看到一篇非常棒的中文文章，讲解使用 Golang 一步步构建一个基本的区块链系统，鼠鼠直接双厨狂喜，一口气看了小一半，受益匪浅。随着不断地更新代码，鼠鼠感觉有必要写一个总结记录一下这个很棒的项目，本文无 AI 总结，观点来自鼠鼠个人，请自行斟酌</p>
<h3 id="基本认识">基本认识</h3>
<p>首先，区块链顾名思义就是由区块构成的链表，而区块则作为区块链的基本元素。区块链的核心特性是<strong>去中心化、不可篡改和透明可追溯</strong>。那么该如何实现以上三个特性呢？具体到数据结构上来说可以总结为：</p>
<ul>
<li>
<p><strong>去中心化：</strong></p>
<ul>
<li>
<p><strong>分布式账本（Distributed Ledger）</strong></p>
</li>
<li>
<p><strong>共识机制（Consensus Mechanism）</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>不可篡改：</strong></p>
<ul>
<li>
<p><strong>区块哈希（Hash Block）</strong></p>
</li>
<li>
<p><strong>默克尔树（Merkle Tree）</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>透明可追溯：</strong></p>
<ul>
<li>
<p><strong>区块头（Block Header）</strong></p>
</li>
<li>
<p><strong>交易记录（Transaction Records）</strong></p>
</li>
<li>
<p><strong>地址（Addresses）</strong></p>
</li>
</ul>
</li>
</ul>
<p>其中关于分布式系统、默克尔树以及地址相关的内容后面再讨论，我们先设计一个最基本的区块链结构，首先是区块结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block.go</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Timestamp <span class="type">int64</span></span><br><span class="line">	Hash      []<span class="type">byte</span></span><br><span class="line">	PrevHash  []<span class="type">byte</span></span><br><span class="line">	Target    []<span class="type">byte</span></span><br><span class="line">	Nonce     <span class="type">int64</span></span><br><span class="line">	<span class="comment">// Data      []byte</span></span><br><span class="line">	Transactions []*transaction.Transaction <span class="comment">// real data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区块中的关键元素：区块头（时间戳、区块哈希、前一块哈希、挖矿目标、随机数）+交易记录</p>
<p>时间戳比较好理解，时间戳在区块链中是确保数据按时间顺序排列、防范双重支付、维护共识安全以及提供历史证据的关键数字印记。</p>
<p>区块中的“哈希指针”是通过将前一区块的哈希值包含在当前区块中，形成了环环相扣的链式结构。任何对历史区块数据的微小改动都会导致其哈希值发生变化，进而导致后续所有区块的哈希值失效，从而被网络轻易检测到。</p>
<p>之于挖矿目标和随机数后文涉及到再进行解释。</p>
<p>然后我们定义区块链：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blockchain.go</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	Blocks []*Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们已经有了区块链系统的基本元素，下面就是让他动起来，赋予他们一些方法</p>
<h3 id="哈希机制">哈希机制</h3>
<p>哈希是区块之间逻辑上的连接手段，哈希结果也包含了区块的所有信息，所以哈希也可以作为区块的唯一表示（ID），这个思想也用在交易这个概念上，这个后面会提到。下面我们来具体看一下怎么创建区块和计算区块哈希的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block.go</span></span><br><span class="line"><span class="comment">// package txs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> BackTrasactionSummary() []<span class="type">byte</span> &#123;</span><br><span class="line">	txIDs := <span class="built_in">make</span>([][]<span class="type">byte</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> b.Transactions &#123;</span><br><span class="line">		txIDs = <span class="built_in">append</span>(txIDs, tx.ID)</span><br><span class="line">	&#125;</span><br><span class="line">	summary := bytes.Join(txIDs, []<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> summary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute and set block hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> SetHash() &#123;</span><br><span class="line">	information := bytes.Join(</span><br><span class="line">		[][]<span class="type">byte</span>&#123;</span><br><span class="line">			utils.ToHexInt(b.Timestamp),</span><br><span class="line">			b.PrevHash,</span><br><span class="line">			utils.ToHexInt(b.Nonce),</span><br><span class="line">			b.Target,</span><br><span class="line">			b.BackTrasactionSummary(),</span><br><span class="line">		&#125;,</span><br><span class="line">		[]<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	hash := sha256.Sum256(information)</span><br><span class="line">	b.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是将信息打包，然后使用 sha256 算法进行哈希运算，其中 SHA-256 算法是一种<strong>广泛应用于加密货币和信息安全的哈希函数</strong>，它能将任意长度的输入数据转换成一个固定长度的 256 位（32 字节）哈希值，且该过程是单向的，微小的输入变化都会导致输出哈希值发生巨大改变</p>
<h3 id="创建区块">创建区块</h3>
<p>首先是普通区块的创建，需要前置哈希和交易信息，另外就是 POW 相关的两个参数，后面也会专门来介绍：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlock</span><span class="params">(prevhash []<span class="type">byte</span>, txs []*transaction.Transaction)</span></span> *Block &#123;</span><br><span class="line">	block := Block&#123;</span><br><span class="line">		Timestamp:    time.Now().Unix(),</span><br><span class="line">		Hash:         []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		PrevHash:     prevhash,</span><br><span class="line">		Target:       []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		Nonce:        <span class="number">0</span>,</span><br><span class="line">		Transactions: txs,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// compute target and hash</span></span><br><span class="line">	block.Target = block.GetTarget()</span><br><span class="line">	block.Nonce = block.FindNonce()</span><br><span class="line">	block.SetHash()</span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而区块链中的第一个区块叫做“创世区块”，他是没有前驱的，我们来构建一个创世区块（先不用管交易相关）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenesisBlock</span><span class="params">()</span></span> *Block &#123;</span><br><span class="line">	<span class="comment">// make a base-tx: generate init coin for the God</span></span><br><span class="line">	tx := transaction.BaseTx([]<span class="type">byte</span>(<span class="string">&quot;alan&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> CreateBlock([]<span class="type">byte</span>&#123;&#125;, []*transaction.Transaction&#123;tx&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="共识机制（POW-工作量证明）">共识机制（POW 工作量证明）</h3>
<p>网络中所有节点都可以构造区块然后添加到链上，但是这是不可能，因为区块链是一条链表而不是树形结构，所以就需要一种机制来保证每次只能有一个区块产生并添加到链上，并且要让其他所有的节点都认可这个新产生的区块，这就是共识机制。这里采用的是最最最最经典的比特币的共识机制，即<strong>工作量证明（Proof Of Work）</strong>。</p>
<p>采用原文的比喻就是“要在相对公平的条件下让想要添加自己的候选区块进区块链的节点内卷，通过竞争选择出一个大家公认的节点来添加它的区块进入区块链。整个共识机制被分为两部分，首先是竞争，然后是共识”。</p>
<p>游戏的规则是这样的：所有的网络节点（矿工）都做同一种工作，像是一种竞赛（挖矿），率先完成的节点得到记账权，也就是打包发布区块的权利。既然是 game 就一定有奖励，而奖励就是发布区块的节点可以得到“出块奖励”，例如比特币，这也是大家争相内卷的原因。</p>
<p>具体到工作的细节，这样一件工作非常的公平，比拼的因素只有一个就是算力，谁的算力高，谁就更有机会成为最终卷王，那么既然要求算力，计算过程究竟是什么呢？其实非常的简单，就是找一个随机数（nonce），把他打包到自己的候选区块中区进行哈希运算，转换成数之后和一个目标（target）对比，如果小于这个目标则视为计算成功，而这个目标则可以通过难度系数（difficulty）进行控制。</p>
<p><strong>这个“区块寻找”游戏设计得非常精妙：</strong></p>
<ul>
<li>
<p>首先，每个节点需要找到的 <strong>nonce</strong>只对它自己提议的区块有效，这杜绝了“抄袭”的可能，确保了每个节点都必须独立完成任务。</p>
</li>
<li>
<p>其次，寻找这个 <strong>nonce</strong> 的过程是纯粹随机的，没有任何捷径可言；找到 <strong>nonce</strong> 的时间主要取决于网络设定的难度目标和节点自身的计算能力，但即使是性能较弱的节点，也有公平的机会赢得胜利。</p>
</li>
<li>
<p>最后，虽然寻找 <strong>nonce</strong> 可能需要投入大量的时间和计算资源，但验证一个节点是否真的找到了正确的 <strong>nonce</strong> 却非常迅速且几乎不消耗资源。可以说，这个被找到的 <strong>nonce</strong> 就是该节点“实力”的直接证明。</p>
</li>
</ul>
<p>说完了基本的规则，我们来看一下如何实现：</p>
<p>首先我们设定一个难度值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constcoe.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Difficulty = <span class="number">12</span></span><br><span class="line">	Initcoin = <span class="number">1_000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后我们就可以计算目标了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proofofwork.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// difficulty larger =&gt; target smaller</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> GetTarget() []<span class="type">byte</span> &#123;</span><br><span class="line">	target := big.NewInt(<span class="number">1</span>)</span><br><span class="line">	target.Lsh(target, <span class="type">uint</span>(<span class="number">256</span>-constcoe.Difficulty))</span><br><span class="line">	<span class="keyword">return</span> target.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了目标之后，我们就可以填入不同的 nonce 来进行“挖矿”竞争卷王了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proofofwork.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join with nonce</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> GetBase4Nonce(nonce <span class="type">int64</span>) []<span class="type">byte</span>&#123;</span><br><span class="line">	data := bytes.Join(</span><br><span class="line">		[][]<span class="type">byte</span>&#123;</span><br><span class="line">			utils.ToHexInt(b.Timestamp),</span><br><span class="line">			b.PrevHash,</span><br><span class="line">			utils.ToHexInt(<span class="type">int64</span>(nonce)),</span><br><span class="line">			b.Target,</span><br><span class="line">			b.BackTrasactionSummary(),</span><br><span class="line">		&#125;,</span><br><span class="line">		[]<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find right nonce (mine)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span>FindNonce() <span class="type">int64</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> intHash big.Int</span><br><span class="line">	<span class="keyword">var</span> intTarget big.Int</span><br><span class="line">	<span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> nonce <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	intTarget.SetBytes(b.Target)</span><br><span class="line">	<span class="keyword">for</span> nonce &lt; math.MaxInt64 &#123;</span><br><span class="line">		data := b.GetBase4Nonce(nonce)</span><br><span class="line">		hash = sha256.Sum256(data)</span><br><span class="line">		intHash.SetBytes(hash[:])</span><br><span class="line">		<span class="keyword">if</span> intHash.Cmp(&amp;intTarget) == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			nonce ++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nonce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实过程非常非常简单，就是一个个的尝试 nonce 的值进行计算和 target 来比较，另外我们也可以是设置一个方法来验证区块的有效性，如上文所说校验是非常简单的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proofofwork.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the block: compare with the target</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> ValidatePoW() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intHash big.Int</span><br><span class="line">	<span class="keyword">var</span> intTarget big.Int</span><br><span class="line">	<span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">	intTarget.SetBytes(b.Target)</span><br><span class="line">	data := b.GetBase4Nonce(b.Nonce)</span><br><span class="line">	hash = sha256.Sum256(data)</span><br><span class="line">	intHash.SetBytes(hash[:])</span><br><span class="line">	<span class="keyword">if</span> intHash.Cmp(&amp;intTarget) == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们的区块链系统已经初具雏形了</p>
<h3 id="交易机制（UTXO）">交易机制（UTXO）</h3>
<p>在上面的介绍中多次提到了交易，那么什么是交易？比特币系统中的交易又是什么样的呢？这一小节我来给大家介绍一下。</p>
<p>传统意义上的交易指的是用户之间的转账记录，例如 A 给 B 转了 1 个 bitcoin。但随着这个区块链领域的不断发展，即使在金融领域之外，我们还是习惯把区块里有用的数据条目称为“交易信息”（txs）。</p>
<p>一般来说，我们接触到的最常见的交易也许在银行，假设你有 100 ￥，你到银行转了 50 ￥给我，我去银行机器查看，发现余额多了 50 ￥，那么这样一次交易就完成了。但是，如果突然这个银行没了，那么如何证明我们之间的这笔交易存在呢？甚至该如何证明我们拥有资产？</p>
<p>问题的关键就是有一样东西消失了，在这个例子中就是银行，他是中心化设施的代表，也就是说我们所有的用户相信它，我们的资产才得以存在价值。银行记录了记录了我们的资产信息，可以轻松验证所有交易的有效性，只需要查看银行余额，因为我们相信这个余额。</p>
<p>那么，是否可以不要这样一个可信第三方，区块链就是旨在构建这样一个去中心化的分布式系统。而比特币系统就提出了这样一个模型：<strong>UTXO 模型</strong> 也就是“追溯历史交易”，要验证“A 转给 B 五块钱”是否有效，我们可以往前查找所有 A 作为接收方的交易记录，然后把这些交易中的金额加起来。如果总金额大于或等于 5，那么这笔转账就是有效的。</p>
<p>对于 UTXO 建议移步鼠鼠的另一篇文章了解，站内搜索即可快速访问，这里不在赘述。</p>
<p>我们直接用代码来构建“交易”，我会用大量的注释来代替讲解，聪明的你一定能看懂：</p>
<p>首先是 UTXO 模型中的输入输出的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inoutput.go</span></span><br><span class="line"><span class="keyword">package</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;bytes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TxOutput <span class="keyword">struct</span>&#123;</span><br><span class="line">	Value <span class="type">int</span> <span class="comment">// output amount</span></span><br><span class="line">	ToAddress []<span class="type">byte</span> <span class="comment">// output address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TxInput <span class="keyword">struct</span>&#123;</span><br><span class="line">	TxId []<span class="type">byte</span> <span class="comment">// pre-tx id</span></span><br><span class="line">	OutIdx <span class="type">int</span> <span class="comment">// index of pre-tx output</span></span><br><span class="line">	FromAddress []<span class="type">byte</span> <span class="comment">// input-from equals output-to</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// utils check address</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *TxInput)</span></span> FromAddressRight(address []<span class="type">byte</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.Equal(in.FromAddress, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(out *TxOutput)</span></span> ToAddressRight(address []<span class="type">byte</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.Equal(out.ToAddress, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们定义交易：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transaction.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Transaction 表示一笔交易，包含交易 ID、输入和输出</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID      []<span class="type">byte</span>     <span class="comment">// 交易 ID，是该交易内容的哈希值</span></span><br><span class="line">	Inputs  []TxInput  <span class="comment">// 输入数组（引用以前交易输出）</span></span><br><span class="line">	Outputs []TxOutput <span class="comment">// 输出数组（给哪些地址转了多少钱）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置交易哈希：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transaction.go</span></span><br><span class="line"><span class="comment">// TxHash 计算当前交易的哈希值（即交易 ID）</span></span><br><span class="line"><span class="comment">// 哈希值是对整个交易序列化后求 sha256，保证内容唯一性和不可篡改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> TxHash() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> encoded bytes.Buffer <span class="comment">// 存储序列化后的交易数据</span></span><br><span class="line">	<span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span>        <span class="comment">// 存储计算出的哈希结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 gob 对交易结构体进行序列化（编码）</span></span><br><span class="line">	encoder := gob.NewEncoder(&amp;encoded)</span><br><span class="line">	err := encoder.Encode(tx)     <span class="comment">// 将 tx 编码写入 encoded 缓冲区</span></span><br><span class="line">	utils.Handle(err)             <span class="comment">// 错误统一处理函数（例如 panic）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对序列化后的字节进行 SHA-256 哈希</span></span><br><span class="line">	hash = sha256.Sum256(encoded.Bytes())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 hash 的切片（[:] 从数组变成切片）</span></span><br><span class="line">	<span class="keyword">return</span> hash[:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> SetID() &#123;</span><br><span class="line">	tx.ID = tx.TxHash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，创世块里也打包了一个初始交易，他没有输入而凭空产生输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transaction.go</span></span><br><span class="line"><span class="comment">// tx in gensis-block, mine init-coin for the god alan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BaseTx</span><span class="params">(ToAddress []<span class="type">byte</span>)</span></span> *Transaction&#123;</span><br><span class="line">	txIn := TxInput&#123;</span><br><span class="line">		TxId: []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">		OutIdx: <span class="number">-1</span>,</span><br><span class="line">		FromAddress: []<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	txOut := TxOutput&#123;</span><br><span class="line">		Value: constcoe.Initcoin,</span><br><span class="line">		ToAddress: ToAddress,</span><br><span class="line">	&#125;</span><br><span class="line">	tx := &amp;Transaction&#123;</span><br><span class="line">		ID: []<span class="type">byte</span>(<span class="string">&quot;This is base tx!&quot;</span>),</span><br><span class="line">		Inputs: []TxInput&#123;txIn&#125;,</span><br><span class="line">		Outputs: []TxOutput&#123;txOut&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> IsBase()<span class="type">bool</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(tx.Inputs) == <span class="number">1</span> &amp;&amp; tx.Inputs[<span class="number">0</span>].OutIdx == <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，再回头看之前的区块的相关定义，所有的信息都对上了。</p>
<h3 id="构建交易">构建交易</h3>
<p>万事俱备，现在我们来看如何构建一个交易并把它打包发布到区块链上。</p>
<p>我们先明确一个思路：</p>
<ul>
<li>
<p>我们直观上的一笔交易构成：发送者、接收者、数量</p>
</li>
<li>
<p>而实际 UTXO 系统内部的数据结构构成：交易哈希（ID）、若干输入（TxInput）、若干输出（TxOutput）</p>
</li>
<li>
<p>其中的<strong>输入是过往的一些交易的输出（这点是理解 UTXO 的关键）</strong>，并且是没有被花掉的输出，在 UTXO 的系统中我们没有余额的概念，我们在交易中使用的是当前地址没有使用过的某些输出。</p>
</li>
<li>
<p>并且在 UTXO 中花费就意味着全部使用，例如 A 有一个 100 的输入，但是本次交易只需要 50，那么交易的输出则有两个：50 输出给目标 B，50 作为找零再输出给 A，而原本的 100 则视为用过，不在有效。</p>
</li>
</ul>
<p>下面直接上代码，通过详细的注释，我想大家一定能弄懂：</p>
<p>创建交易相关：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blockchain.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Key: How To Create A Traction ?</span></span><br><span class="line"><span class="comment">// get user&#x27;s all unspent txs（交易图回溯算法）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindUnspentTransactions(from []<span class="type">byte</span>) []transaction.Transaction &#123;</span><br><span class="line">	<span class="keyword">var</span> unSpentTxs []transaction.Transaction <span class="comment">// 用于记录当前用户的未使用交易切片</span></span><br><span class="line">	spentTxs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)       <span class="comment">// 用于标记交易的输出已经被使用（仅仅标记已经被使用），交易ID =&gt; &#123;输出的某个索引&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// range blocks in the blockchain</span></span><br><span class="line">	<span class="keyword">for</span> idx := <span class="built_in">len</span>(bc.Blocks) - <span class="number">1</span>; idx &gt;= <span class="number">0</span>; idx-- &#123; <span class="comment">// 从新到旧地遍历区块，避免重复访问</span></span><br><span class="line">		block := bc.Blocks[idx]</span><br><span class="line">		<span class="comment">// range txs in the block</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			txID := hex.EncodeToString(tx.ID)</span><br><span class="line"></span><br><span class="line">		IterOutputs:</span><br><span class="line">			<span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> tx.Outputs &#123; <span class="comment">// 检查每一个交易的输出（目标：将没有使用过的加入切片）</span></span><br><span class="line">				<span class="keyword">if</span> spentTxs[txID] != <span class="literal">nil</span> &#123; <span class="comment">// 检查已经使用的输出的前提是，存在已经使用的输出，否则直接到下一个if</span></span><br><span class="line">					<span class="keyword">for</span> _, spentOut := <span class="keyword">range</span> spentTxs[txID] &#123; <span class="comment">// 检查当前交易中的每一个已经使用过的并标记过的输出（索引）</span></span><br><span class="line">						<span class="keyword">if</span> spentOut == outIdx &#123; <span class="comment">// 恰好为当前输出</span></span><br><span class="line">							<span class="keyword">continue</span> IterOutputs <span class="comment">// 则不用添加，直接检查下一个输出即可，label语法用于跳出\跳过多层循环</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> out.ToAddressRight(from) &#123; <span class="comment">// 检查是否是输出到当前用户，否则和当前用户无关</span></span><br><span class="line">					unSpentTxs = <span class="built_in">append</span>(unSpentTxs, *tx) <span class="comment">// 添加到当前用户的未使用交易的切片中</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !tx.IsBase() &#123;</span><br><span class="line">				<span class="keyword">for</span> _, in := <span class="keyword">range</span> tx.Inputs &#123; <span class="comment">// 检查每一个交易的输入（目标：将每一个源输出标记为已经使用过）</span></span><br><span class="line">					<span class="keyword">if</span> in.FromAddressRight(from) &#123; <span class="comment">// 前提是当前用户的源输出，否则和当前用户无关</span></span><br><span class="line">						inTxID := hex.EncodeToString(in.TxId)</span><br><span class="line">						spentTxs[inTxID] = <span class="built_in">append</span>(spentTxs[inTxID], in.OutIdx) <span class="comment">// 将过去那个输出标记为已经使用</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unSpentTxs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get user&#x27;s all unspent-outputs(UTXOs)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindUTXOs(address []<span class="type">byte</span>) (<span class="type">int</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) &#123;</span><br><span class="line">	unspentOuts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)               <span class="comment">// 当前用户所有未使用的输出（交易ID+输出索引 确定一个输出）</span></span><br><span class="line">	unspentTxs := bc.FindUnspentTransactions(address) <span class="comment">// 当前用户所有未使用的交易</span></span><br><span class="line">	accumulated := <span class="number">0</span></span><br><span class="line">Work:</span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> unspentTxs &#123;</span><br><span class="line">		txID := hex.EncodeToString(tx.ID)</span><br><span class="line">		<span class="keyword">for</span> index, out := <span class="keyword">range</span> tx.Outputs &#123;</span><br><span class="line">			<span class="keyword">if</span> out.ToAddressRight(address) &#123;</span><br><span class="line">				accumulated += out.Value</span><br><span class="line">				unspentOuts[txID] = index</span><br><span class="line">				<span class="comment">// one transaction can only have one output referred to adderss</span></span><br><span class="line">				<span class="comment">// so rediect to next tx ,then check its outputs</span></span><br><span class="line">				<span class="comment">// use lable to cross serveral for</span></span><br><span class="line">				<span class="keyword">continue</span> Work</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> accumulated, unspentOuts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get user&#x27;s target unspent-outputs(UTXOs) for a tx-amount</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindSpendableOutputs(address []<span class="type">byte</span>, amount <span class="type">int</span>) (<span class="type">int</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) &#123;</span><br><span class="line">	unspentOuts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	unspentTxs := bc.FindUnspentTransactions(address)</span><br><span class="line">	accumulated := <span class="number">0</span></span><br><span class="line">Work:</span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> unspentTxs &#123;</span><br><span class="line">		txID := hex.EncodeToString(tx.ID)</span><br><span class="line">		<span class="keyword">for</span> index, out := <span class="keyword">range</span> tx.Outputs &#123;</span><br><span class="line">			<span class="keyword">if</span> out.ToAddressRight(address) &#123;</span><br><span class="line">				accumulated += out.Value</span><br><span class="line">				unspentOuts[txID] = index</span><br><span class="line">				<span class="comment">// enough</span></span><br><span class="line">				<span class="keyword">if</span> accumulated &gt;= amount &#123;</span><br><span class="line">					<span class="keyword">break</span> Work</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span> Work</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> accumulated, unspentOuts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new tx</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CreateTransaction(from, to []<span class="type">byte</span>, amount <span class="type">int</span>) (*transaction.Transaction, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 直观上的一笔交易构成：发送者、接收者、数量</span></span><br><span class="line">	<span class="comment">// 实际UTXO系统内部的数据结构构成：交易哈希（ID）、若干输入（TxInput）、若干输出（TxOutput）</span></span><br><span class="line"></span><br><span class="line">	txInputs := <span class="built_in">make</span>([]transaction.TxInput, <span class="number">0</span>)</span><br><span class="line">	txOutputs := <span class="built_in">make</span>([]transaction.TxOutput, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 1. build TxInputs: inputs come from outputs(UTXOs)</span></span><br><span class="line">	total, unspentOuts := bc.FindSpendableOutputs(from, amount)</span><br><span class="line">	<span class="keyword">if</span> total &lt; amount &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Not enough coins!&quot;</span>)</span><br><span class="line">		<span class="comment">// return nil,false (this is better actually)</span></span><br><span class="line">		<span class="keyword">return</span> &amp;transaction.Transaction&#123;&#125;, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> txId, outIndex := <span class="keyword">range</span> unspentOuts &#123;</span><br><span class="line">		id, err := hex.DecodeString(txId)</span><br><span class="line">		utils.Handle(err)</span><br><span class="line">		txInput := transaction.TxInput&#123;</span><br><span class="line">			TxId:        id,</span><br><span class="line">			OutIdx:      outIndex,</span><br><span class="line">			FromAddress: from,</span><br><span class="line">		&#125;</span><br><span class="line">		txInputs = <span class="built_in">append</span>(txInputs, txInput)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. build TxOutputs: output can divde into change-back and sent-amount</span></span><br><span class="line">	txOutputs = <span class="built_in">append</span>(txOutputs, transaction.TxOutput&#123;</span><br><span class="line">		Value:     amount,</span><br><span class="line">		ToAddress: to,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> total &gt; amount &#123;</span><br><span class="line">		txOutputs = <span class="built_in">append</span>(txOutputs, transaction.TxOutput&#123;</span><br><span class="line">			Value:     total - amount,</span><br><span class="line">			ToAddress: from,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. set hash</span></span><br><span class="line">	tx := transaction.Transaction&#123;</span><br><span class="line">		<span class="comment">// ID: []byte&#123;&#125;,</span></span><br><span class="line">		ID:      <span class="literal">nil</span>,</span><br><span class="line">		Inputs:  txInputs,</span><br><span class="line">		Outputs: txOutputs,</span><br><span class="line">	&#125;</span><br><span class="line">	tx.SetID()</span><br><span class="line">	<span class="keyword">return</span> &amp;tx, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打包发布相关：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blockchain.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add new block into blockchain(package txs)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> AddBlock(txs []*transaction.Transaction) &#123;</span><br><span class="line">	newBlock := CreateBlock(bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Hash, txs)</span><br><span class="line">	bc.Blocks = <span class="built_in">append</span>(bc.Blocks, newBlock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// simulate packaging and mining</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Mine(txs []*transaction.Transaction) &#123;</span><br><span class="line">	bc.AddBlock(txs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也许查询 UTXO 的地方会比较难，如果是第一次接触的话确实不好理解，不过如果真的静下心来研究的话其实并不复杂。</p>
<p>至此，一个简易的区块链系统就完成了，主要实现了：<strong>基本区块哈希结构的定义</strong>、<strong>POW 共识机制的实现</strong>和<strong>UTXO 交易机制的实现</strong></p>
<p>后面鼠鼠继续学习再更新，再探再报。。。</p>
]]></content>
      <tags>
        <tag>go</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>conda常用命令</title>
    <url>/2025/05/20/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Anaconda 是一个流行的 Python 数据科学平台，主要用于管理虚拟环境和包。以下是常用的 Anaconda 命令分类整理：</p>
<hr>
<p><strong>1. 环境管理</strong><br>
• 查看所有环境</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure>
<p>• 创建新环境</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create --name myenv python=3.9  <span class="comment"># 指定 Python 版本</span></span><br></pre></td></tr></table></figure>
<p>• 激活/退出环境</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate myenv    <span class="comment"># 激活环境</span></span><br><span class="line">conda deactivate        <span class="comment"># 退出当前环境</span></span><br></pre></td></tr></table></figure>
<p>• 删除环境</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> remove --name myenv</span><br></pre></td></tr></table></figure>
<p>• 导出/导入环境配置</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> &gt; environment.yml    <span class="comment"># 导出</span></span><br><span class="line">conda <span class="built_in">env</span> create -f environment.yml   <span class="comment"># 导入</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>2. 包管理</strong><br>
• 安装包</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install numpy        <span class="comment"># 安装指定包</span></span><br><span class="line">conda install numpy=1.21    <span class="comment"># 指定版本</span></span><br><span class="line">pip install package_name    <span class="comment"># 使用 pip 安装（conda 不支持的包）</span></span><br></pre></td></tr></table></figure>
<p>• 卸载包</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda uninstall numpy</span><br></pre></td></tr></table></figure>
<p>• 更新包</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda update numpy         <span class="comment"># 更新单个包</span></span><br><span class="line">conda update --all         <span class="comment"># 更新所有包</span></span><br></pre></td></tr></table></figure>
<p>• 搜索包</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda search numpy</span><br></pre></td></tr></table></figure>
<p>• 列出已安装包</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>3. Anaconda 自身管理</strong><br>
• 更新 Conda</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>
<p>• 更新 Anaconda</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure>
<p>• 清理缓存/无用包</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda clean --all</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>4. Jupyter Notebook 相关</strong><br>
• 在特定环境中安装 Jupyter</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install nb_conda       <span class="comment"># 支持环境切换</span></span><br></pre></td></tr></table></figure>
<p>• 启动 Jupyter Notebook</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>• 生成 Jupyter 内核（针对虚拟环境）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --user --name myenv --display-name <span class="string">&quot;Python (myenv)&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>5. 其他实用命令</strong><br>
• 查看 Conda 信息</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure>
<p>• 检查 Conda 版本</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure>
<p>• 从 requirements.txt 安装包（pip 格式）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>常见问题解决</strong></p>
<ol>
<li>
<p>Conda 命令慢/卡顿<br>
• 更换国内镜像源（如清华源）：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>• 恢复默认源：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
]]></content>
      <tags>
        <tag>科研</tag>
        <tag>python</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>gobyexample学习笔记01</title>
    <url>/2025/05/12/gobyexample%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-语言学习笔记-Lesson-01">Go 语言学习笔记 - Lesson 01</h1>
<p>项目地址：<a href="https://gitee.com/alan223/gobyexample">https://gitee.com/alan223/gobyexample</a></p>
<h2 id="1-基础语法特点">1. 基础语法特点</h2>
<h3 id="1-1-包管理">1.1 包管理</h3>
<ul>
<li>Go 语言使用 <code>package</code> 关键字声明包</li>
<li>主程序必须使用 <code>package main</code></li>
<li>导入包使用 <code>import</code> 关键字，支持多种导入方式：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-变量声明">1.2 变量声明</h3>
<ul>
<li>使用 <code>var</code> 关键字声明变量</li>
<li>支持类型推导：<code>:=</code> 操作符</li>
<li>变量声明后必须使用，否则会编译错误</li>
<li>支持多变量声明：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">c, d := <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-常量">1.3 常量</h3>
<ul>
<li>使用 <code>const</code> 关键字声明常量</li>
<li>常量可以是字符、字符串、布尔值或数值</li>
<li>常量不能使用 <code>:=</code> 语法声明</li>
</ul>
<h2 id="2-数据结构">2. 数据结构</h2>
<h3 id="2-1-数组和切片">2.1 数组和切片</h3>
<ul>
<li>数组：固定长度，声明时需要指定长度<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
</li>
<li>切片：动态数组，更灵活<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>切片操作：
<ul>
<li>追加：<code>append()</code></li>
<li>截取：<code>s[low:high]</code></li>
<li>长度：<code>len()</code></li>
<li>容量：<code>cap()</code></li>
</ul>
</li>
</ul>
<h3 id="2-2-Map">2.2 Map</h3>
<ul>
<li>键值对集合</li>
<li>声明和初始化：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">42</span></span><br></pre></td></tr></table></figure>
</li>
<li>检查键是否存在：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, exists := m[<span class="string">&quot;key&quot;</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-控制结构">3. 控制结构</h2>
<h3 id="3-1-循环">3.1 循环</h3>
<ul>
<li>Go 只有 <code>for</code> 循环，没有 <code>while</code></li>
<li>支持多种 for 循环形式：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-条件语句">3.2 条件语句</h3>
<ul>
<li><code>if</code> 语句可以包含初始化语句<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><code>switch</code> 语句：
<ul>
<li>不需要 <code>break</code></li>
<li>可以使用 <code>fallthrough</code></li>
<li>支持多条件</li>
</ul>
</li>
</ul>
<h2 id="4-函数特性">4. 函数特性</h2>
<h3 id="4-1-函数声明">4.1 函数声明</h3>
<ul>
<li>支持多返回值</li>
<li>支持命名返回值</li>
<li>支持可变参数<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-闭包">4.2 闭包</h3>
<ul>
<li>函数可以返回函数</li>
<li>闭包可以访问外部变量</li>
<li>常用于实现函数工厂</li>
</ul>
<h2 id="5-面向对象特性">5. 面向对象特性</h2>
<h3 id="5-1-结构体">5.1 结构体</h3>
<ul>
<li>使用 <code>struct</code> 关键字</li>
<li>支持匿名字段</li>
<li>可以定义方法</li>
</ul>
<h3 id="5-2-方法">5.2 方法</h3>
<ul>
<li>可以为任何类型定义方法</li>
<li>方法接收者可以是值或指针<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-3-接口">5.3 接口</h3>
<ul>
<li>隐式实现接口</li>
<li>接口可以包含多个方法</li>
<li>空接口 <code>interface&#123;&#125;</code> 可以存储任何类型</li>
</ul>
<h2 id="6-指针">6. 指针</h2>
<ul>
<li>使用 <code>&amp;</code> 获取地址</li>
<li>使用 <code>*</code> 获取值</li>
<li>支持指针接收者方法</li>
</ul>
<h2 id="7-字符串和符文">7. 字符串和符文</h2>
<ul>
<li>字符串是不可变的字节序列</li>
<li>使用 <code>rune</code> 处理 Unicode 字符</li>
<li>支持字符串切片和连接</li>
</ul>
<h2 id="8-递归">8. 递归</h2>
<ul>
<li>支持函数递归调用</li>
<li>常用于树结构和分治算法</li>
</ul>
<h2 id="9-范围遍历">9. 范围遍历</h2>
<ul>
<li>使用 <code>range</code> 遍历数组、切片、map 等</li>
<li>可以获取索引和值<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>Go 语言强调简洁性和实用性</li>
<li>错误处理通常使用返回值而不是异常</li>
<li>代码格式化使用 <code>go fmt</code></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>gowebexamples学习笔记01</title>
    <url>/2025/06/04/gowebexamples%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-Web-开发笔记总结">Go Web 开发笔记总结</h1>
<p>本笔记根据 <code>gowebexamples</code> 项目的代码示例，总结 Go Web 开发中的常见操作。</p>
<h2 id="ch01-Hello-World">ch01 - Hello World</h2>
<ul>
<li><strong>核心概念</strong>: 构建最简单的 HTTP 服务器，响应客户端请求。</li>
<li><strong>实现</strong>: 使用 <code>net/http</code> 包的 <code>http.HandleFunc</code> 注册路由，<code>http.ListenAndServe</code> 启动服务器。</li>
<li><strong>示例</strong>: 在根路径 <code>/</code> 上响应 “Hello, you’ve requested: [path]”。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w,<span class="string">&quot;Hello, you&#x27;ve requested: %s\n&quot;</span>,r.URL.Path)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>http.HandleFunc(&quot;/&quot;, ...)</code>: 注册一个 HTTP 处理函数，当用户访问根路径 <code>/</code> 时，会执行匿名函数。</li>
<li><code>func(w http.ResponseWriter, r *http.Request)</code>: 这是 HTTP 处理函数的签名，<code>w</code> 用于写入响应，<code>r</code> 包含请求信息。</li>
<li><code>fmt.Fprintf(w, ...)</code>: 将格式化的字符串写入 HTTP 响应。</li>
<li><code>http.ListenAndServe(&quot;:8080&quot;, nil)</code>: 启动一个 HTTP 服务器，监听在 <code>8080</code> 端口。<code>nil</code> 表示使用默认的 ServeMux。</li>
</ul>
<h2 id="ch02-HTTP-Server">ch02 - HTTP Server</h2>
<ul>
<li><strong>核心概念</strong>: 在 HTTP 服务器中提供静态文件服务。</li>
<li><strong>实现</strong>: 使用 <code>http.FileServer</code> 创建文件服务器，<code>http.StripPrefix</code> 移除 URL 前缀，然后通过 <code>http.Handle</code> 注册到特定路径。</li>
<li><strong>示例</strong>: 将 <code>static/</code> 目录下的文件通过 <code>/static/</code> 路径暴露。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w,<span class="string">&quot;welcome to my website&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set file server</span></span><br><span class="line">	fs := http.FileServer(http.Dir(<span class="string">&quot;static/&quot;</span>))</span><br><span class="line">	http.Handle(<span class="string">&quot;/static/&quot;</span>,http.StripPrefix(<span class="string">&quot;/static/&quot;</span>,fs))</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>http.FileServer(http.Dir(&quot;static/&quot;))</code>: 创建一个文件服务器，它会从 <code>static/</code> 目录下提供文件。</li>
<li><code>http.StripPrefix(&quot;/static/&quot;, fs)</code>: 移除请求 URL 中的 <code>/static/</code> 前缀，这样文件服务器就能正确地找到 <code>static/</code> 目录下的文件。</li>
<li><code>http.Handle(&quot;/static/&quot;, ...)</code>: 将文件服务器注册到 <code>/static/</code> 路径，所有以 <code>/static/</code> 开头的请求都会由这个文件服务器处理。</li>
</ul>
<h2 id="ch03-Routing">ch03 - Routing</h2>
<ul>
<li><strong>核心概念</strong>: 路由是根据 URL 路径将请求分发到不同的处理函数。虽然示例代码为空，但在实际应用中，路由是构建复杂 Web 应用的基础。</li>
<li><strong>常用库</strong>: <code>gorilla/mux</code> 是一个流行的第三方路由库，提供了更强大的路由匹配和中间件支持。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := mux.NewRouter()</span><br><span class="line">	r.HandleFunc(<span class="string">&quot;/products/&#123;key&#125;&quot;</span>, ProductHandler)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	vars := mux.Vars(r)</span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Category: %v\n&quot;</span>, vars[<span class="string">&quot;key&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>mux.NewRouter()</code>: 创建一个新的 <code>mux</code> 路由器。</li>
<li><code>r.HandleFunc(&quot;/products/&#123;key&#125;&quot;, ProductHandler)</code>: 注册一个带有路径参数的路由。<code>&#123;key&#125;</code> 是一个占位符，可以匹配任何值。</li>
<li><code>ProductHandler</code>: 处理 <code>/products/&#123;key&#125;</code> 路径的请求。</li>
<li><code>mux.Vars(r)</code>: 从请求中提取路径参数。</li>
<li><code>http.ListenAndServe(&quot;:8080&quot;, r)</code>: 启动 HTTP 服务器并使用 <code>mux</code> 路由器处理请求。</li>
</ul>
<h2 id="ch04-Database">ch04 - Database</h2>
<ul>
<li><strong>核心概念</strong>: Go 语言中数据库操作，以 MySQL 为例，涵盖连接、创建表、插入、查询和删除等基本 CRUD 操作。</li>
<li><strong>实现</strong>: 使用 <code>database/sql</code> 包进行数据库交互，通过 <code>_ &quot;github.com/go-sql-driver/mysql&quot;</code> 导入 MySQL 驱动。</li>
<li><strong>操作</strong>:
<ul>
<li><code>sql.Open</code>: 连接数据库。</li>
<li><code>db.Ping</code>: 检查数据库连接。</li>
<li><code>db.Exec</code>: 执行 DDL (如 <code>CREATE TABLE</code>) 和 DML (如 <code>INSERT</code>, <code>DELETE</code>) 语句。</li>
<li><code>db.QueryRow</code>: 查询单行数据。</li>
<li><code>db.Query</code>: 查询多行数据。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// connect to mysql</span></span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:password@(localhost:3306)/database?parseTime=true&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;connected!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a new table</span></span><br><span class="line">	query := <span class="string">`</span></span><br><span class="line"><span class="string">            CREATE TABLE IF NOT EXISTS users(</span></span><br><span class="line"><span class="string">                id INT AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">                username TEXT NOT NULL,</span></span><br><span class="line"><span class="string">                password TEXT NOT NULL,</span></span><br><span class="line"><span class="string">                created_at DATETIME,</span></span><br><span class="line"><span class="string">                PRIMARY KEY (id)</span></span><br><span class="line"><span class="string">            );`</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> _, err := db.Exec(query); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert a user</span></span><br><span class="line">	username := <span class="string">&quot;testuser&quot;</span></span><br><span class="line">	password := <span class="string">&quot;testpass&quot;</span></span><br><span class="line">	create_at := time.Now()</span><br><span class="line"></span><br><span class="line">	insertQuery := <span class="string">`INSERT INTO users (username,password,created_at) VALUES (?,?,?)`</span></span><br><span class="line"></span><br><span class="line">	res, err := db.Exec(insertQuery, username, password, create_at)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	id, err := res.LastInsertId()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Inserted user with ID:&quot;</span>, id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>sql.Open(&quot;mysql&quot;, ...)</code>: 打开一个到 MySQL 数据库的连接。请替换连接字符串中的 <code>root:password@(localhost:3306)/database</code> 为您的实际数据库凭据。</li>
<li><code>db.Ping()</code>: 验证数据库连接是否仍然活跃。</li>
<li><code>db.Exec(query)</code>: 执行 SQL 语句，例如创建表或插入数据。对于 <code>INSERT</code> 操作，<code>res.LastInsertId()</code> 可以获取新插入行的 ID。</li>
</ul>
<h2 id="ch05-Template">ch05 - Template</h2>
<ul>
<li><strong>核心概念</strong>: 使用 Go 的 <code>html/template</code> 包进行 HTML 模板渲染，将动态数据填充到 HTML 页面中。</li>
<li><strong>实现</strong>:
<ul>
<li><code>template.ParseFiles</code>: 解析模板文件。</li>
<li><code>template.Must</code>: 辅助函数，用于处理模板解析错误。</li>
<li><code>tmp.Execute</code>: 将数据与模板结合并写入 <code>http.ResponseWriter</code>。</li>
</ul>
</li>
<li><strong>数据结构</strong>: 定义结构体来封装需要传递给模板的数据。</li>
<li><strong>常用库</strong>: <code>gorilla/mux</code> 用于路由。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Todo <span class="keyword">struct</span>&#123;</span><br><span class="line">	Title <span class="type">string</span></span><br><span class="line">	Done <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPageData <span class="keyword">struct</span> &#123;</span><br><span class="line">	PageTitle <span class="type">string</span></span><br><span class="line">	Todos []Todo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tmp := template.Must(template.ParseFiles(<span class="string">&quot;layout.html&quot;</span>))</span><br><span class="line">	</span><br><span class="line">	r := mux.NewRouter()</span><br><span class="line">	r.HandleFunc(<span class="string">&quot;/&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="comment">// encapsulate data</span></span><br><span class="line">		data := TodoPageData&#123;</span><br><span class="line">			PageTitle: <span class="string">&quot;Todo-List&quot;</span>,</span><br><span class="line">			Todos: []Todo&#123;</span><br><span class="line">				&#123;<span class="string">&quot;eat&quot;</span>,<span class="literal">true</span>&#125;,</span><br><span class="line">				&#123;<span class="string">&quot;drink&quot;</span>,<span class="literal">true</span>&#125;,</span><br><span class="line">				&#123;<span class="string">&quot;sleep&quot;</span>,<span class="literal">false</span>&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// return template</span></span><br><span class="line">		tmp.Execute(w,data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start server</span></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>type Todo struct&#123;...&#125;</code> 和 <code>type TodoPageData struct&#123;...&#125;</code>: 定义了用于模板渲染的数据结构。</li>
<li><code>template.Must(template.ParseFiles(&quot;layout.html&quot;))</code>: 解析名为 <code>layout.html</code> 的模板文件。<code>template.Must</code> 会在解析失败时 panic。</li>
<li><code>tmp.Execute(w, data)</code>: 将 <code>data</code> 结构体中的数据填充到模板中，并将结果写入 <code>http.ResponseWriter</code>。</li>
</ul>
<h2 id="ch06-Asset-and-File">ch06 - Asset and File</h2>
<ul>
<li><strong>核心概念</strong>: 提供静态资源（如 CSS、JavaScript、图片）服务，与 ch02 类似，但更侧重于“资产”的概念。</li>
<li><strong>实现</strong>: 同样使用 <code>http.FileServer</code> 和 <code>http.StripPrefix</code>。</li>
<li><strong>示例</strong>: 将 <code>asset/</code> 目录下的文件通过 <code>/static/</code> 路径暴露。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fs := http.FileServer(http.Dir(<span class="string">&quot;asset/&quot;</span>))</span><br><span class="line">	http.Handle(<span class="string">&quot;/static/&quot;</span>, http.StripPrefix(<span class="string">&quot;/static/&quot;</span>, fs))</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>http.FileServer(http.Dir(&quot;asset/&quot;))</code>: 创建一个文件服务器，用于提供 <code>asset/</code> 目录下的静态文件。</li>
<li><code>http.StripPrefix(&quot;/static/&quot;, fs)</code>: 移除请求 URL 中的 <code>/static/</code> 前缀，确保文件服务器能正确映射到 <code>asset/</code> 目录。</li>
<li><code>http.Handle(&quot;/static/&quot;, ...)</code>: 将文件服务器注册到 <code>/static/</code> 路径，使得所有 <code>/static/</code> 开头的请求都由该文件服务器处理。</li>
</ul>
<h2 id="ch07-Form">ch07 - Form</h2>
<ul>
<li><strong>核心概念</strong>: 处理 HTML 表单提交，获取表单数据。</li>
<li><strong>实现</strong>:
<ul>
<li>根据 HTTP 请求方法 (<code>r.Method</code>) 判断是 GET 请求（显示表单）还是 POST 请求（处理表单数据）。</li>
<li>使用 <code>r.FormValue(&quot;field_name&quot;)</code> 获取表单字段的值。</li>
</ul>
</li>
<li><strong>模板</strong>: 结合 <code>html/template</code> 来渲染表单页面和显示提交结果。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContactDetail <span class="keyword">struct</span> &#123;</span><br><span class="line">	Email   <span class="type">string</span></span><br><span class="line">	Subject <span class="type">string</span></span><br><span class="line">	Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tmpl := template.Must(template.ParseFiles(<span class="string">&quot;forms.html&quot;</span>))</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">			tmpl.Execute(w,<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		contactDetail := ContactDetail&#123;</span><br><span class="line">			Email: r.FormValue(<span class="string">&quot;email&quot;</span>),</span><br><span class="line">			Subject: r.FormValue(<span class="string">&quot;subject&quot;</span>),</span><br><span class="line">			Message: r.FormValue(<span class="string">&quot;message&quot;</span>),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// do something with it...</span></span><br><span class="line">		tmpl.Execute(w,contactDetail)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>type ContactDetail struct&#123;...&#125;</code>: 定义一个结构体来存储表单提交的数据。</li>
<li><code>tmpl := template.Must(template.ParseFiles(&quot;forms.html&quot;))</code>: 解析用于显示表单的 HTML 模板。</li>
<li><code>if r.Method != http.MethodPost</code>: 判断请求方法，如果是 GET 请求则显示表单，如果是 POST 请求则处理表单数据。</li>
<li><code>r.FormValue(&quot;email&quot;)</code>: 获取表单中 <code>name=&quot;email&quot;</code> 的字段值。<code>FormValue</code> 会自动解析 <code>application/x-www-form-urlencoded</code> 和 <code>multipart/form-data</code> 类型的表单数据。</li>
</ul>
<h2 id="ch08-Middleware">ch08 - Middleware</h2>
<ul>
<li><strong>核心概念</strong>: 中间件是在请求到达最终处理函数之前或之后执行的代码，用于实现日志记录、认证、压缩等横切关注点。</li>
<li><strong>基本实现</strong>: 通过包装 <code>http.HandlerFunc</code> 来实现简单的中间件，例如日志记录。</li>
<li><strong>高级实现</strong>: 定义 <code>Middleware</code> 类型 (<code>func(http.HandlerFunc) http.HandlerFunc</code>)，并实现 <code>Chain</code> 函数来链式调用多个中间件，提供更灵活的中间件管理。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Middleware <span class="function"><span class="keyword">func</span><span class="params">(http.HandlerFunc)</span></span> http.HandlerFunc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logging</span><span class="params">()</span></span> Middleware&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(hf http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			start := time.Now()</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">				log.Println(r.URL.Path,time.Since(start))</span><br><span class="line">			&#125;()</span><br><span class="line">			hf(w,r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chain</span><span class="params">(f http.HandlerFunc,ms... Middleware)</span></span> http.HandlerFunc&#123;</span><br><span class="line">	<span class="keyword">for</span> _,middleware := <span class="keyword">range</span> ms&#123;</span><br><span class="line">		f = middleware(f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">	fmt.Fprintln(w,<span class="string">&quot;Hello there&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>,Chain(hello,Logging()))</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>type Middleware func(http.HandlerFunc) http.HandlerFunc</code>: 定义了一个 <code>Middleware</code> 类型，它是一个函数，接受一个 <code>http.HandlerFunc</code> 并返回一个新的 <code>http.HandlerFunc</code>。</li>
<li><code>Logging() Middleware</code>: 这是一个中间件工厂函数，它返回一个 <code>Middleware</code> 类型的函数。这个中间件会在处理请求前后记录日志。</li>
<li><code>Chain(f http.HandlerFunc,ms... Middleware) http.HandlerFunc</code>: 这个函数将多个中间件按顺序应用到一个 <code>http.HandlerFunc</code> 上，形成一个处理链。请求会依次经过每个中间件，最后到达最终的处理函数 <code>f</code>。</li>
</ul>
<h2 id="ch09-Sessions">ch09 - Sessions</h2>
<ul>
<li><strong>核心概念</strong>: 会话管理，用于在多个 HTTP 请求之间维护用户状态。</li>
<li><strong>实现</strong>: 使用 <code>github.com/gorilla/sessions</code> 库。</li>
<li><strong>操作</strong>:
<ul>
<li><code>sessions.NewCookieStore</code>: 创建基于 Cookie 的 session 存储。</li>
<li><code>store.Get</code>: 获取或创建一个 session。</li>
<li><code>session.Values</code>: 存储 session 数据。</li>
<li><code>session.Save</code>: 保存 session 到客户端 Cookie。</li>
</ul>
</li>
<li><strong>示例</strong>: 模拟用户登录、登出和访问受保护的资源。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/sessions&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	key   = []<span class="type">byte</span>(<span class="string">&quot;super-secret-key&quot;</span>)</span><br><span class="line">	store = sessions.NewCookieStore(key)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">secret</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	session, _ := store.Get(r, <span class="string">&quot;cookie-name&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> auth, ok := session.Values[<span class="string">&quot;authenticated&quot;</span>].(<span class="type">bool</span>); !ok || !auth &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Forbidden&quot;</span>, http.StatusForbidden)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintln(w, <span class="string">&quot;The cake is a lie!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	session, _ := store.Get(r, <span class="string">&quot;cookie-name&quot;</span>)</span><br><span class="line">	session.Values[<span class="string">&quot;authenticated&quot;</span>] = <span class="literal">true</span></span><br><span class="line">	session.Save(r, w)</span><br><span class="line">	fmt.Fprintln(w, <span class="string">&quot;Successfully logged in!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/secret&quot;</span>, secret)</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/login&quot;</span>, login)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>sessions.NewCookieStore(key)</code>: 创建一个新的 Cookie 存储，<code>key</code> 用于加密 session 数据。</li>
<li><code>store.Get(r, &quot;cookie-name&quot;)</code>: 从请求中获取名为 “cookie-name” 的 session。如果不存在，则创建一个新的。</li>
<li><code>session.Values[&quot;authenticated&quot;] = true</code>: 在 session 中设置一个键值对，表示用户已认证。</li>
<li><code>session.Save(r, w)</code>: 将 session 的更改保存到客户端的 Cookie 中。</li>
<li><code>secret</code> 函数通过检查 <code>session.Values[&quot;authenticated&quot;]</code> 来判断用户是否登录，从而保护敏感资源。</li>
</ul>
<h2 id="ch10-JSON">ch10 - JSON</h2>
<ul>
<li><strong>核心概念</strong>: 处理 JSON 数据的编码（Go 对象转 JSON 字符串）和解码（JSON 字符串转 Go 对象）。</li>
<li><strong>实现</strong>: 使用 <code>encoding/json</code> 包。</li>
<li><strong>操作</strong>:
<ul>
<li><code>json.NewDecoder(r.Body).Decode(&amp;user)</code>: 从请求体中解码 JSON 到 Go 结构体。</li>
<li><code>json.NewEncoder(w).Encode(data)</code>: 将 Go 结构体编码为 JSON 并写入响应体。</li>
</ul>
</li>
<li><strong>结构体标签</strong>: 使用 <code>json:&quot;field_name&quot;</code> 标签来控制 JSON 字段名。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">	FirstName <span class="type">string</span> <span class="string">`json:&quot;firstname&quot;`</span></span><br><span class="line">	LastName <span class="type">string</span> <span class="string">`json:&quot;lastname&quot;`</span></span><br><span class="line">	Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/decode&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> user User</span><br><span class="line">		json.NewDecoder(r.Body).Decode(&amp;user)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;%s %s is %d years old!&quot;</span>, user.FirstName, user.LastName, user.Age)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/encode&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		peter := User&#123;</span><br><span class="line">			FirstName: <span class="string">&quot;Jo&quot;</span>,</span><br><span class="line">			LastName: <span class="string">&quot;Dio&quot;</span>,</span><br><span class="line">			Age: <span class="number">100</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		json.NewEncoder(w).Encode(peter)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>type User struct&#123;...&#125;</code>: 定义一个结构体，用于映射 JSON 数据。<code>json:&quot;...&quot;</code> 标签指定了结构体字段对应的 JSON 键名。</li>
<li><code>json.NewDecoder(r.Body).Decode(&amp;user)</code>: 创建一个 JSON 解码器，从请求体 <code>r.Body</code> 中读取 JSON 数据并解码到 <code>user</code> 结构体中。</li>
<li><code>json.NewEncoder(w).Encode(peter)</code>: 创建一个 JSON 编码器，将 <code>peter</code> 结构体编码为 JSON 格式，并写入响应体 <code>w</code>。</li>
</ul>
<h2 id="ch11-Websocket">ch11 - Websocket</h2>
<ul>
<li><strong>核心概念</strong>: 实现全双工通信协议 WebSocket，用于实时应用。</li>
<li><strong>实现</strong>: 使用 <code>github.com/gorilla/websocket</code> 库。</li>
<li><strong>操作</strong>:
<ul>
<li><code>websocket.Upgrader</code>: 配置 WebSocket 升级器，例如 <code>CheckOrigin</code> 用于跨域检查。</li>
<li><code>upgrader.Upgrade</code>: 将 HTTP 连接升级为 WebSocket 连接。</li>
<li><code>conn.ReadMessage</code>: 读取 WebSocket 消息。</li>
<li><code>conn.WriteMessage</code>: 发送 WebSocket 消息。</li>
</ul>
</li>
<li><strong>示例</strong>: 实现一个简单的 WebSocket 回显服务器，并将 <code>websockets.html</code> 作为客户端页面。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/websocket&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upgrader = websocket.Upgrader&#123;</span><br><span class="line">	ReadBufferSize: <span class="number">1024</span>,</span><br><span class="line">	WriteBufferSize: <span class="number">1024</span>,</span><br><span class="line">	CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/echo&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		conn,err := upgrader.Upgrade(w,r,<span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			http.Error(w, <span class="string">&quot;Could not open websocket connection&quot;</span>, http.StatusBadRequest)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>&#123;</span><br><span class="line">			msgType,msg,err := conn.ReadMessage()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Read error:&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s sent: %s\n&quot;</span>, conn.RemoteAddr(), <span class="type">string</span>(msg))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := conn.WriteMessage(msgType, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Write error:&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>websocket.Upgrader</code>: 用于将普通的 HTTP 连接升级为 WebSocket 连接。<code>CheckOrigin</code> 设置为 <code>true</code> 允许跨域连接（生产环境中应谨慎设置）。</li>
<li><code>upgrader.Upgrade(w, r, nil)</code>: 执行连接升级操作，成功后返回一个 <code>*websocket.Conn</code> 对象，代表 WebSocket 连接。</li>
<li><code>conn.ReadMessage()</code>: 从 WebSocket 连接中读取消息。它返回消息类型、消息数据和可能的错误。</li>
<li><code>conn.WriteMessage(msgType, msg)</code>: 向 WebSocket 连接写入消息，将接收到的消息原样发送回客户端，实现了“回显”功能。</li>
</ul>
<h2 id="ch12-Password-Hashing">ch12 - Password Hashing</h2>
<ul>
<li><strong>核心概念</strong>: 使用安全的哈希算法存储用户密码，而不是明文存储，以提高安全性。</li>
<li><strong>实现</strong>: 使用 <code>golang.org/x/crypto/bcrypt</code> 包。</li>
<li><strong>操作</strong>:
<ul>
<li><code>bcrypt.GenerateFromPassword</code>: 生成密码哈希。</li>
<li><code>bcrypt.CompareHashAndPassword</code>: 比较明文密码和哈希值是否匹配。</li>
</ul>
</li>
<li><strong>安全性</strong>: <code>bcrypt</code> 是一种自适应的哈希函数，可以抵御彩虹表攻击和暴力破解。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/crypto/bcrypt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashPassword</span><span class="params">(pwd <span class="type">string</span>)</span></span>(<span class="type">string</span>,<span class="type">error</span>)&#123;</span><br><span class="line">	bytes,err := bcrypt.GenerateFromPassword([]<span class="type">byte</span>(pwd),<span class="number">14</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(bytes),err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckPasswordHash</span><span class="params">(password, hash <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	err := bcrypt.CompareHashAndPassword([]<span class="type">byte</span>(hash),[]<span class="type">byte</span>(password))</span><br><span class="line">	<span class="keyword">return</span> err == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    password := <span class="string">&quot;secret&quot;</span></span><br><span class="line">    hash, _ := HashPassword(password)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Password:&quot;</span>, password)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hash:    &quot;</span>, hash)</span><br><span class="line"></span><br><span class="line">    match := CheckPasswordHash(password, hash)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Match:   &quot;</span>, match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解</strong>:</p>
<ul>
<li><code>bcrypt.GenerateFromPassword([]byte(pwd), 14)</code>: 使用 bcrypt 算法对密码进行哈希。第二个参数 <code>14</code> 是成本因子（cost factor），值越大，哈希计算越慢，安全性越高，但也会消耗更多计算资源。</li>
<li><code>bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))</code>: 比较明文密码和哈希值是否匹配。这个函数会处理哈希和盐值的提取，并进行安全的比较，防止时序攻击。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之CLI框架：cobra</title>
    <url>/2025/05/25/go%E8%AF%AD%E8%A8%80%E4%B9%8BCLI%E6%A1%86%E6%9E%B6cobra/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="📦-第一步：安装-Cobra-CLI-工具">📦 第一步：安装 Cobra CLI 工具</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/spf13/cobra-cli@latest</span><br></pre></td></tr></table></figure>
<p>确保 <code>$GOPATH/bin</code> 在你的 <code>PATH</code> 中，然后你可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cobra-cli --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧱-第二步：初始化项目">🧱 第二步：初始化项目</h2>
<p>创建你的 Go 项目目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tasker &amp;&amp; <span class="built_in">cd</span> tasker</span><br><span class="line">go mod init github.com/yourname/tasker</span><br></pre></td></tr></table></figure>
<p>使用 <code>cobra-cli</code> 初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cobra-cli init --pkg-name github.com/yourname/tasker</span><br></pre></td></tr></table></figure>
<p>这会生成如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasker/</span><br><span class="line">├── cmd/</span><br><span class="line">│   └── root.go</span><br><span class="line">├── main.go</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🚀-第三步：运行项目">🚀 第三步：运行项目</h2>
<p>在当前目录运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure>
<p>输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasker is a CLI application</span><br></pre></td></tr></table></figure>
<p>你可以查看帮助：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="➕-第四步：添加子命令">➕ 第四步：添加子命令</h2>
<h3 id="示例：添加-add-命令">示例：添加 <code>add</code> 命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cobra-cli add add</span><br></pre></td></tr></table></figure>
<p>编辑 <code>cmd/add.go</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addCmd = &amp;cobra.Command&#123;</span><br><span class="line">	Use:   <span class="string">&quot;add [task]&quot;</span>,</span><br><span class="line">	Short: <span class="string">&quot;添加一个新任务&quot;</span>,</span><br><span class="line">	Args:  cobra.ExactArgs(<span class="number">1</span>),</span><br><span class="line">	Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		task := args[<span class="number">0</span>]</span><br><span class="line">		fmt.Printf(<span class="string">&quot;添加任务: %s\n&quot;</span>, task)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rootCmd.AddCommand(addCmd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go add <span class="string">&quot;写 Cobra 教程&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="📋-第五步：添加-list-命令">📋 第五步：添加 <code>list</code> 命令</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cobra-cli add list</span><br></pre></td></tr></table></figure>
<p>编辑 <code>cmd/list.go</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tasks = []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listCmd = &amp;cobra.Command&#123;</span><br><span class="line">	Use:   <span class="string">&quot;list&quot;</span>,</span><br><span class="line">	Short: <span class="string">&quot;列出所有任务&quot;</span>,</span><br><span class="line">	Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(tasks) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;没有任务&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d. %s\n&quot;</span>, i+<span class="number">1</span>, task)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rootCmd.AddCommand(listCmd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="📝-注意：数据结构在内存中，不持久化。可用-map-string-string-或写入文件模拟更复杂逻辑。">📝 注意：数据结构在内存中，不持久化。可用 <code>map[string]string</code> 或写入文件模拟更复杂逻辑。</h3>
<hr>
<h2 id="🎛-第六步：添加标志（flags）">🎛 第六步：添加标志（flags）</h2>
<p>比如我们想让 <code>add</code> 命令带一个 <code>--priority</code> 选项：</p>
<p>在 <code>add.go</code> 的 <code>init()</code> 函数中添加：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">addCmd.Flags().StringP(<span class="string">&quot;priority&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;normal&quot;</span>, <span class="string">&quot;任务优先级&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>并在 <code>Run</code> 中读取：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">priority, _ := cmd.Flags().GetString(<span class="string">&quot;priority&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;添加任务: %s（优先级: %s）\n&quot;</span>, task, priority)</span><br></pre></td></tr></table></figure>
<p>示例运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go add <span class="string">&quot;学习 Go&quot;</span> --priority high</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧼-第七步：美化和构建项目">🧼 第七步：美化和构建项目</h2>
<p>构建可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -o tasker</span><br><span class="line">./tasker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>可以将 <code>tasker</code> 添加到系统 PATH 中，变成全局命令行工具。</p>
<hr>
<h2 id="📦-最终项目结构">📦 最终项目结构</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasker/</span><br><span class="line">├── cmd/</span><br><span class="line">│   ├── add.go</span><br><span class="line">│   ├── list.go</span><br><span class="line">│   └── root.go</span><br><span class="line">├── go.mod</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之Stateful Goroutine</title>
    <url>/2025/05/27/go%E8%AF%AD%E8%A8%80%E4%B9%8BStatefulGoroutine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Go-并发编程的“管家”：Stateful-Goroutine">Go 并发编程的“管家”：Stateful Goroutine</h2>
<p>在 Go 语言的世界里，Goroutine 让并发变得轻而易举。我们可以轻松地启动成千上万个并发执行的任务。但是，当多个 Goroutine 需要共享和修改同一个数据时，问题就来了：如果没有妥善的管理，就会发生“数据竞争”，导致程序行为变得不可预测。</p>
<p>想象一下，你和你的朋友们都在编辑同一份在线文档。如果没有协作机制，你们可能会同时修改同一个段落，最终导致文档内容混乱。</p>
<p>在 Go 语言中，一种优雅地解决这个问题的方法就是使用 <strong>Stateful Goroutine</strong>。你可以把 Stateful Goroutine 想象成一个负责管理特定数据的“管家”。其他的 Goroutine 如果想读取或修改这些数据，不能直接操作，而是需要通过“管家”来协调。</p>
<h3 id="为什么需要“管家”？">为什么需要“管家”？</h3>
<p>让我们看一个简单的例子。假设我们有一个计数器，多个 Goroutine 想要增加这个计数器的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	numGoroutines := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	wg.Add(numGoroutines)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">				counter++ <span class="comment">// 潜在的数据竞争！</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会期望最终的 <code>counter</code> 值是 100 * 1000 = 100000，但实际运行多次，你可能会得到不同的结果，而且很可能不是 100000。这就是因为多个 Goroutine 同时修改 <code>counter</code> 变量，导致了数据竞争。</p>
<h3 id="“管家”登场：Stateful-Goroutine">“管家”登场：Stateful Goroutine</h3>
<p>现在，让我们用 Stateful Goroutine 的方式来管理这个计数器。我们将创建一个专门的 Goroutine 来持有和操作计数器的状态。其他的 Goroutine 如果想增加计数器的值，就需要给这个“管家”发送一个“增加”的请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// incrementOp 代表一个增加计数器的操作</span></span><br><span class="line"><span class="keyword">type</span> incrementOp <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">// 用于通知操作完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	increments := <span class="built_in">make</span>(<span class="keyword">chan</span> incrementOp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态管理的 Goroutine（我们的“管家”）</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> inc := <span class="keyword">range</span> increments &#123;</span><br><span class="line">			counter++</span><br><span class="line">			inc.done &lt;- <span class="literal">true</span> <span class="comment">// 通知增加操作已完成</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	numGoroutines := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	wg.Add(numGoroutines)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">				inc := incrementOp&#123;done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)&#125;</span><br><span class="line">				increments &lt;- inc <span class="comment">// 发送增加请求给“管家”</span></span><br><span class="line">				&lt;-inc.done       <span class="comment">// 等待“管家”完成操作的通知</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了获取最终的计数器值，我们需要再发送一个请求给“管家”</span></span><br><span class="line">	<span class="comment">// 这里为了简化，我们直接在管理 Goroutine 内部维护状态，</span></span><br><span class="line">	<span class="comment">// 如果需要从外部读取，还需要定义一个读取操作的类型和通道。</span></span><br><span class="line">	<span class="comment">// 在这个例子中，最终的 counter 值在管理 Goroutine 内部。</span></span><br><span class="line">	<span class="comment">// 我们让管理 Goroutine 退出后，counter 的值就固定了。</span></span><br><span class="line">	<span class="built_in">close</span>(increments) <span class="comment">// 通知管理 Goroutine 没有更多的增加操作了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意：要获取最终的计数器值，通常需要再设计一个读取操作。</span></span><br><span class="line">	<span class="comment">// 这里我们只是展示如何安全地增加计数器。</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Counter (managed by Goroutine): 100000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ol>
<li>我们定义了一个 <code>incrementOp</code> 结构体，代表一个增加操作，并包含一个 <code>done</code> 通道用于接收完成通知。</li>
<li>我们创建了一个 <code>increments</code> 通道，用于将增加操作的请求发送给我们的“管家” Goroutine。</li>
<li>启动了一个 Goroutine 作为“管家”，它维护着 <code>counter</code> 变量。它在一个循环中监听 <code>increments</code> 通道，每当收到一个 <code>incrementOp</code>，就增加 <code>counter</code> 的值，并通过 <code>inc.done</code> 通道通知请求者操作已完成。</li>
<li>其他的 Goroutine 如果想增加计数器，就创建一个 <code>incrementOp</code>，将其发送到 <code>increments</code> 通道，并等待 <code>inc.done</code> 通道接收到通知。</li>
</ol>
<p>通过这种方式，对 <code>counter</code> 变量的修改完全由“管家” Goroutine 控制，避免了数据竞争。</p>
<h3 id="回到教程的例子">回到教程的例子</h3>
<p>现在，让我们再看看你提供的教程中的例子，它更完整地展示了如何处理读取和写入操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOp <span class="keyword">struct</span> &#123;</span><br><span class="line">	key  <span class="type">int</span></span><br><span class="line">	resp <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writeOp <span class="keyword">struct</span> &#123;</span><br><span class="line">	key  <span class="type">int</span></span><br><span class="line">	val  <span class="type">int</span></span><br><span class="line">	resp <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> readOps <span class="type">uint64</span></span><br><span class="line">	<span class="keyword">var</span> writeOps <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	reads := <span class="built_in">make</span>(<span class="keyword">chan</span> readOp)</span><br><span class="line">	writes := <span class="built_in">make</span>(<span class="keyword">chan</span> writeOp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态管理的 Goroutine（“白板管理员”）</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>) <span class="comment">// 白板</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> read := &lt;-reads:</span><br><span class="line">				read.resp &lt;- state[read.key] <span class="comment">// 查看白板，将结果通过通道回复</span></span><br><span class="line">			<span class="keyword">case</span> write := &lt;-writes:</span><br><span class="line">				state[write.key] = write.val <span class="comment">// 在白板上写入</span></span><br><span class="line">				write.resp &lt;- <span class="literal">true</span>           <span class="comment">// 通知写入完成</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 多个 Goroutine 发送读取请求</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				read := readOp&#123;</span><br><span class="line">					key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">					resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">				&#125;</span><br><span class="line">				reads &lt;- read</span><br><span class="line">				&lt;-read.resp</span><br><span class="line">				atomic.AddUint64(&amp;readOps, <span class="number">1</span>)</span><br><span class="line">				time.Sleep(time.Millisecond)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 多个 Goroutine 发送写入请求</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				write := writeOp&#123;</span><br><span class="line">					key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">					val:  rand.Intn(<span class="number">100</span>),</span><br><span class="line">					resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">				&#125;</span><br><span class="line">				writes &lt;- write</span><br><span class="line">				atomic.AddUint64(&amp;writeOps, <span class="number">1</span>)</span><br><span class="line">				time.Sleep(time.Millisecond)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">	readOpsFinal := atomic.LoadUint64(&amp;readOps)</span><br><span class="line">	fmt.Println(<span class="string">&quot;readOps:&quot;</span>, readOpsFinal)</span><br><span class="line">	writeOpsFinal := atomic.LoadUint64(&amp;writeOps)</span><br><span class="line">	fmt.Println(<span class="string">&quot;writeOps:&quot;</span>, writeOpsFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个更完整的例子中：</p>
<ul>
<li><code>state</code> ( <code>map[int]int</code> ) 是我们想要安全共享的状态，就像那个公共的白板。</li>
<li>管理状态的 Goroutine 就像“白板管理员”，它在一个无限循环中等待读取 (<code>readOp</code>) 和写入 (<code>writeOp</code>) 的请求。</li>
<li>当收到读取请求时，它查看 <code>state</code>，并通过 <code>resp</code> 通道将结果发送回请求者。</li>
<li>当收到写入请求时，它更新 <code>state</code>，并通过 <code>resp</code> 通道通知请求者写入完成。</li>
<li>其他的 Goroutine (100 个读取 Goroutine 和 10 个写入 Goroutine) 通过创建 <code>readOp</code> 或 <code>writeOp</code> 结构体，并将其发送到 <code>reads</code> 或 <code>writes</code> 通道来与“管理员”交互。它们通过各自的 <code>resp</code> 通道来接收结果或完成通知。</li>
</ul>
<h3 id="总结">总结</h3>
<p>Stateful Goroutine 是一种通过将状态的管理权交给一个单独的 Goroutine，并使用通道进行通信，从而安全地在多个并发 Goroutine 之间共享和修改状态的模式。这个“管家” Goroutine 串行化了对共享状态的访问，避免了数据竞争，使得并发程序更加可靠和易于理解。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之URL解析</title>
    <url>/2025/05/28/go%E8%AF%AD%E8%A8%80%E4%B9%8BURL%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Go-语言-URL-解析详解：从入门到实战">Go 语言 URL 解析详解：从入门到实战</h2>
<p>在互联网世界中，URL（Uniform Resource Locator）是定位网络资源的关键。Go 语言的标准库 <code>net/url</code> 提供了强大且灵活的工具，用于解析、构建和操作 URL。本文将带你从基础概念入手，逐步深入到在实际开发中的常见用法和最佳实践。</p>
<h3 id="什么是-URL？">什么是 URL？</h3>
<p>URL 是一种用于定位互联网上资源的文本字符串，其通用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://[userinfo@]host[:port][path][?query][#fragment]</span><br></pre></td></tr></table></figure>
<p>例如：<code>https://www.example.com:8080/api/data?id=123&amp;format=json#details</code></p>
<ul>
<li><strong>scheme</strong>: 协议类型（如 <code>http</code>, <code>https</code>, <code>ftp</code>）。</li>
<li><strong>userinfo</strong>: 可选的用户名和密码。</li>
<li><strong>host</strong>: 主机名或 IP 地址。</li>
<li><strong>port</strong>: 可选的端口号。</li>
<li><strong>path</strong>: 资源在服务器上的路径。</li>
<li><strong>query</strong>: 可选的查询参数。</li>
<li><strong>fragment</strong>: 可选的片段标识符。</li>
</ul>
<h3 id="初探-net-url：URL-解析">初探 <code>net/url</code>：URL 解析</h3>
<p>Go 语言的 <code>net/url</code> 包的核心功能之一就是解析 URL 字符串。通过 <code>url.Parse()</code> 函数，我们可以将一个 URL 字符串转换为 <code>url.URL</code> 类型的结构体，从而方便地访问其各个组成部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	urlString := <span class="string">&quot;https://user:pass@www.example.com:8080/path/to/resource?param1=value1&amp;param2=value2#section&quot;</span></span><br><span class="line"></span><br><span class="line">	u, err := url.Parse(urlString)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解析 URL 失败:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Scheme:&quot;</span>, u.Scheme)</span><br><span class="line">	fmt.Println(<span class="string">&quot;User:&quot;</span>, u.User)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Host:&quot;</span>, u.Host)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Path:&quot;</span>, u.Path)</span><br><span class="line">	fmt.Println(<span class="string">&quot;RawQuery:&quot;</span>, u.RawQuery)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Fragment:&quot;</span>, u.Fragment)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进一步解析 Userinfo</span></span><br><span class="line">	<span class="keyword">if</span> u.User != <span class="literal">nil</span> &#123;</span><br><span class="line">		username := u.User.Username()</span><br><span class="line">		password, _ := u.User.Password()</span><br><span class="line">		fmt.Println(<span class="string">&quot;Username:&quot;</span>, username)</span><br><span class="line">		fmt.Println(<span class="string">&quot;Password:&quot;</span>, password)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 Query 参数</span></span><br><span class="line">	queryParams, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Query Parameters:&quot;</span>, queryParams)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Value of param1:&quot;</span>, queryParams.Get(<span class="string">&quot;param1&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进阶应用：开发中的常见用法">进阶应用：开发中的常见用法</h3>
<h4 id="1-构建-API-请求-URL">1. 构建 API 请求 URL</h4>
<p>动态构建带有查询参数的 API 请求 URL 是常见的开发任务。结合 <code>url.URL</code> 和 <code>url.Values</code> 可以优雅地实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	baseURL := <span class="string">&quot;https://api.example.com/products&quot;</span></span><br><span class="line">	params := url.Values&#123;&#125;</span><br><span class="line">	params.Set(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;books&quot;</span>)</span><br><span class="line">	params.Add(<span class="string">&quot;sort&quot;</span>, <span class="string">&quot;price&quot;</span>)</span><br><span class="line">	params.Add(<span class="string">&quot;order&quot;</span>, <span class="string">&quot;desc&quot;</span>)</span><br><span class="line"></span><br><span class="line">	u, err := url.Parse(baseURL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解析基础 URL 失败:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u.RawQuery = params.Encode()</span><br><span class="line">	fmt.Println(<span class="string">&quot;API URL:&quot;</span>, u.String())</span><br><span class="line">	<span class="comment">// Output: API URL: https://api.example.com/products?category=books&amp;sort=price&amp;order=desc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-处理-HTTP-重定向">2. 处理 HTTP 重定向</h4>
<p>处理 HTTP 3xx 重定向响应中的 <code>Location</code> 头部需要解析 URL，特别是当 <code>Location</code> 是相对路径时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	baseURL := <span class="string">&quot;https://www.example.com&quot;</span></span><br><span class="line">	location := <span class="string">&quot;/new-page?ref=old&quot;</span></span><br><span class="line"></span><br><span class="line">	redirectURL, err := url.Parse(location)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解析重定向 URL 失败:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	finalURL := baseURL</span><br><span class="line">	<span class="keyword">if</span> !redirectURL.IsAbs() &#123;</span><br><span class="line">		base, _ := url.Parse(baseURL)</span><br><span class="line">		finalURL = base.ResolveReference(redirectURL).String()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		finalURL = redirectURL.String()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Final URL:&quot;</span>, finalURL)</span><br><span class="line">	<span class="comment">// Output: Final URL: https://www.example.com/new-page?ref=old</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-安全处理用户输入-URL">3. 安全处理用户输入 URL</h4>
<p>验证和清理用户输入的 URL 对于防止安全漏洞至关重要。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidUserURL</span><span class="params">(rawURL <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	u, err := url.ParseRequestURI(rawURL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || u.Scheme == <span class="string">&quot;&quot;</span> || (!strings.HasPrefix(u.Scheme, <span class="string">&quot;http&quot;</span>) &amp;&amp; u.Scheme != <span class="string">&quot;ftp&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 可以添加更多自定义校验</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userInput1 := <span class="string">&quot;https://trusted.com/page&quot;</span></span><br><span class="line">	userInput2 := <span class="string">&quot;javascript:alert(&#x27;XSS&#x27;)&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;&#x27;%s&#x27; is valid: %t\n&quot;</span>, userInput1, isValidUserURL(userInput1))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;&#x27;%s&#x27; is valid: %t\n&quot;</span>, userInput2, isValidUserURL(userInput2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-修改已解析的-URL">4. 修改已解析的 URL</h4>
<p>有时需要在已解析的 URL 基础上修改其部分内容，例如添加或删除查询参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	urlString := <span class="string">&quot;https://api.example.com/data?id=123&amp;format=xml&quot;</span></span><br><span class="line">	u, _ := url.Parse(urlString)</span><br><span class="line"></span><br><span class="line">	queryParams := u.Query()</span><br><span class="line">	queryParams.Set(<span class="string">&quot;format&quot;</span>, <span class="string">&quot;json&quot;</span>)</span><br><span class="line">	queryParams.Add(<span class="string">&quot;fields&quot;</span>, <span class="string">&quot;name,value&quot;</span>)</span><br><span class="line">	u.RawQuery = queryParams.Encode()</span><br><span class="line"></span><br><span class="line">	u.Path = <span class="string">&quot;/items&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Modified URL:&quot;</span>, u.String())</span><br><span class="line">	<span class="comment">// Output: Modified URL: https://api.example.com/items?format=json&amp;fields=name%2Cvalue&amp;id=123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最佳实践总结">最佳实践总结</h3>
<ul>
<li>使用 <code>url.Parse()</code> 解析 URL 字符串。</li>
<li>利用 <code>url.Values</code> 类型管理和操作查询参数。</li>
<li>对于用户输入的 URL，考虑使用 <code>url.ParseRequestURI()</code> 进行更严格的解析和验证。</li>
<li>处理重定向 URL 时，使用 <code>URL.ResolveReference()</code> 来正确解析相对路径。</li>
<li>在构建 API 请求 URL 时，先解析基础 URL，然后设置其 <code>RawQuery</code>。</li>
<li>修改 URL 时，操作 <code>url.URL</code> 结构体的相应字段，最后使用 <code>URL.String()</code> 获取最终的 URL。</li>
</ul>
<h3 id="结语">结语</h3>
<p>Go 语言的 <code>net/url</code> 包为我们提供了强大且易用的 URL 处理能力。无论是简单的解析还是复杂的构建和修改，掌握这些工具都能帮助我们更高效、更安全地进行网络相关的开发。希望本文能够帮助你更好地理解和应用 Go 语言中的 URL 解析。<br>
鼠鼠还没学到web开发，有点不懂，以后再啃。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之select指南</title>
    <url>/2025/05/26/go%E8%AF%AD%E8%A8%80%E4%B9%8Bselect%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>想象一下场景：</strong></p>
<p>你现在是一位咖啡师，你的面前有多个顾客在不同的窗口等待点单（每个窗口可以看作一个 channel）。你不可能同时处理所有窗口的请求，但你希望尽快处理到来的请求。<code>select</code> 语句就像你的耳朵和眼睛，让你能够同时监听所有窗口，一旦有顾客按下呼叫铃（channel 有数据可接收），你就可以优先处理那个窗口的请求。</p>
<p><strong><code>select</code> 语句的基本结构：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">    <span class="comment">// 如果 chan1 可读，执行这里的代码</span></span><br><span class="line"><span class="keyword">case</span> val := &lt;-chan2:</span><br><span class="line">    <span class="comment">// 如果 chan2 可读，执行这里的代码，并将接收到的值赋给 val</span></span><br><span class="line"><span class="keyword">case</span> chan3 &lt;- expr:</span><br><span class="line">    <span class="comment">// 如果 chan3 可写（非满），执行这里的代码，并将 expr 发送到 chan3</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果没有任何 case 准备好，执行这里的代码（可选）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心要点：</strong></p>
<ol>
<li><strong>多路复用：</strong> <code>select</code> 允许你同时等待多个 channel 的操作（发送或接收）。</li>
<li><strong>非阻塞：</strong> <code>select</code> 本身不会阻塞。它会检查所有的 <code>case</code>，如果其中一个 <code>case</code> 满足条件（可以进行收发操作），就执行该 <code>case</code> 对应的代码。</li>
<li><strong>随机选择：</strong> 如果有多个 <code>case</code> 同时满足条件，Go 语言会<strong>随机</strong>选择一个 <code>case</code> 执行。</li>
<li><strong><code>default</code> 子句（可选）：</strong> 如果没有 <code>case</code> 准备好，并且存在 <code>default</code> 子句，那么会执行 <code>default</code> 中的代码。如果不存在 <code>default</code>，<code>select</code> 语句会阻塞，直到至少有一个 <code>case</code> 可以执行。</li>
</ol>
<p><strong>生动解释每个 <code>case</code>：</strong></p>
<ul>
<li><code>case &lt;-chan1:</code>：这表示尝试从通道 <code>chan1</code> 接收数据。如果 <code>chan1</code> 中有数据，这个 <code>case</code> 就会被选中，并且接收到的数据会被丢弃（因为你没有用变量接收）。你可以把它想象成你听到一个窗口的铃响了，你知道有人要点单了。</li>
<li><code>case val := &lt;-chan2:</code>：这同样是尝试从通道 <code>chan2</code> 接收数据。如果 <code>chan2</code> 中有数据，这个 <code>case</code> 会被选中，并且接收到的数据会存储在变量 <code>val</code> 中。这就像你听到另一个窗口的铃响了，并且你知道了顾客想要点什么。</li>
<li><code>case chan3 &lt;- expr:</code>：这表示尝试向通道 <code>chan3</code> 发送数据 <code>expr</code>。如果 <code>chan3</code> 有足够的空间（非满），这个 <code>case</code> 就会被选中，并且 <code>expr</code> 会被发送到 <code>chan3</code>。这就像你准备好了一杯咖啡，准备送到一个等待的窗口。</li>
<li><code>default:</code>：如果没有任何顾客按下铃（没有任何 channel 可读或可写），并且你不想一直等待，你可以使用 <code>default</code> 子句来做一些其他的事情，比如擦桌子或者看看还有哪些咖啡豆。</li>
</ul>
<p><strong>实际应用示例代码：</strong></p>
<p>让我们模拟一个场景，有两个不同的服务在向我们的主程序发送消息。我们希望能够同时监听这两个服务，并处理先到达的消息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟服务 1 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">service1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; ; i++ &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond) <span class="comment">// 模拟处理时间</span></span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;来自服务 1 的消息 #%d&quot;</span>, i)</span><br><span class="line">		fmt.Println(<span class="string">&quot;服务 1 发送:&quot;</span>, message)</span><br><span class="line">		ch &lt;- message</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟服务 2 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">service2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; ; i++ &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">1500</span>)) * time.Millisecond) <span class="comment">// 模拟处理时间</span></span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;来自服务 2 的消息 #%d&quot;</span>, i)</span><br><span class="line">		fmt.Println(<span class="string">&quot;服务 2 发送:&quot;</span>, message)</span><br><span class="line">		ch &lt;- message</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> service1(ch1)</span><br><span class="line">	<span class="keyword">go</span> service2(ch2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 我们只接收前 5 条消息</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">			fmt.Println(<span class="string">&quot;主程序接收到:&quot;</span>, msg1)</span><br><span class="line">		<span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">			fmt.Println(<span class="string">&quot;主程序接收到:&quot;</span>, msg2)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;--- 处理了一条消息 ---&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;处理完毕！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释：</strong></p>
<ol>
<li>我们创建了两个通道 <code>ch1</code> 和 <code>ch2</code>，分别用于接收来自 <code>service1</code> 和 <code>service2</code> 的消息。</li>
<li><code>service1</code> 和 <code>service2</code>  Goroutine 会不断地生成消息并通过各自的通道发送。它们发送消息的时间间隔是随机的，模拟了不同的服务可能在不同的时间发送数据。</li>
<li>在 <code>main</code> 函数的 <code>for</code> 循环中，我们使用 <code>select</code> 语句同时监听 <code>ch1</code> 和 <code>ch2</code>。</li>
<li>哪个通道先有数据到达，对应的 <code>case</code> 就会被执行，主程序会接收并打印该消息。</li>
<li>由于 <code>select</code> 的随机性，你每次运行程序，接收到的消息顺序可能会不同。</li>
</ol>
<p><strong>更进一步的应用场景：</strong></p>
<ul>
<li><strong>超时控制：</strong> 你可以在 <code>select</code> 中加入一个 <code>time.After</code> 的 <code>case</code>，如果在指定时间内没有从其他通道接收到数据，就可以执行超时处理逻辑。</li>
<li><strong>取消操作：</strong> 可以使用一个 done channel，在需要取消某个 Goroutine 的时候关闭这个 channel，然后在 <code>select</code> 中监听这个 done channel，一旦关闭就退出 Goroutine。</li>
<li><strong>多路网络请求：</strong> 同时等待多个网络请求的响应，哪个先返回就先处理哪个。</li>
</ul>
<h3 id="1-超时控制">1. 超时控制</h3>
<p><strong>场景：</strong> 假设我们正在尝试从一个外部服务获取数据，但这个服务有时响应很慢或者没有响应。我们不希望程序一直等待下去，而是希望在一定时间后放弃并进行其他处理。</p>
<p><strong>实现方式：</strong> 在 <code>select</code> 语句中加入一个 <code>time.After(timeout)</code> 的 <code>case</code>。<code>time.After(timeout)</code> 会返回一个在 <code>timeout</code> 时间后会收到一个 <code>time.Time</code> 值的 channel。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 模拟耗时操作</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	ch &lt;- <span class="string">&quot;来自外部服务的数据&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>) <span class="comment">// 使用带缓冲的 channel，防止 Goroutine 阻塞</span></span><br><span class="line">	<span class="keyword">go</span> fetchData(result)</span><br><span class="line"></span><br><span class="line">	timeout := <span class="number">1</span> * time.Second</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> data := &lt;-result:</span><br><span class="line">		fmt.Println(<span class="string">&quot;成功获取到数据:&quot;</span>, data)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求超时，放弃等待。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;程序继续执行...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释：</strong></p>
<ol>
<li><code>fetchData</code> 函数模拟了一个需要 2 秒才能完成的操作，并将结果发送到 <code>result</code> channel。</li>
<li>在 <code>main</code> 函数中，我们启动了一个 Goroutine 来执行 <code>fetchData</code>。</li>
<li>我们设置了一个 <code>timeout</code> 为 1 秒。</li>
<li><code>select</code> 语句同时监听 <code>result</code> channel 和 <code>time.After(timeout)</code> 返回的 channel。</li>
<li>如果 <code>fetchData</code> 在 1 秒内完成，我们会从 <code>result</code> 接收到数据并打印。</li>
<li>如果超过 1 秒后，<code>time.After(timeout)</code> 返回的 channel 会收到一个值，<code>case &lt;-time.After(timeout):</code> 就会被选中，我们打印 “请求超时，放弃等待。”。</li>
</ol>
<p><strong>运行结果（可能）：</strong></p>
<p>由于 <code>fetchData</code> 需要 2 秒，而超时时间是 1 秒，所以很可能会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求超时，放弃等待。</span><br><span class="line">程序继续执行...</span><br></pre></td></tr></table></figure>
<p>如果你将 <code>time.Sleep(2 * time.Second)</code> 改为一个小于 1 秒的值，你就会看到成功获取数据的输出。</p>
<h3 id="2-取消操作">2. 取消操作</h3>
<p><strong>场景：</strong> 有时我们需要在某个操作进行到一半的时候取消它，例如用户关闭了一个页面，我们不再需要等待后台任务完成。</p>
<p><strong>实现方式：</strong> 使用一个 “done” channel。当需要取消操作时，关闭这个 done channel。在执行任务的 Goroutine 中，使用 <code>select</code> 监听这个 done channel。一旦 done channel 被关闭，Goroutine 就可以清理资源并退出。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-done:</span><br><span class="line">			fmt.Println(<span class="string">&quot;工作者收到取消信号，退出。&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;工作者正在努力工作... (%d)\n&quot;</span>, i)</span><br><span class="line">			time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;启动工作者...&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟一段时间后需要取消工作者</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;发送取消信号...&quot;</span>)</span><br><span class="line">	<span class="built_in">close</span>(done) <span class="comment">// 关闭 done channel 通知 worker 停止</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待一段时间，确保 worker 有机会退出</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;主程序结束。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释：</strong></p>
<ol>
<li><code>worker</code> 函数在一个无限循环中模拟工作。</li>
<li>它使用 <code>select</code> 同时监听 <code>done</code> channel 和默认情况。</li>
<li>如果 <code>done</code> channel 接收到值（当它被关闭时，会一直可以接收到零值），则 <code>case &lt;-done:</code> 会被选中，worker 打印退出信息并返回。</li>
<li><code>default</code> case 表示如果没有收到取消信号，worker 就继续工作一段时间。</li>
<li>在 <code>main</code> 函数中，我们创建了一个 <code>done</code> channel 并启动了 <code>worker</code> Goroutine，并将 <code>done</code> channel 传递给它。</li>
<li>主程序等待 2 秒后，通过 <code>close(done)</code> 关闭了 <code>done</code> channel，向 <code>worker</code> 发送取消信号。</li>
<li><code>worker</code> 接收到信号后会退出。</li>
</ol>
<p><strong>运行结果（大致）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动工作者...</span><br><span class="line">工作者正在努力工作... (0)</span><br><span class="line">工作者正在努力工作... (1)</span><br><span class="line">工作者正在努力工作... (2)</span><br><span class="line">工作者正在努力工作... (3)</span><br><span class="line">发送取消信号...</span><br><span class="line">工作者收到取消信号，退出。</span><br><span class="line">主程序结束。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之依赖注入</title>
    <url>/2025/06/06/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="📦-理解依赖注入：原理与-Go-项目实战">📦 理解依赖注入：原理与 Go 项目实战</h1>
<h2 id="在现代软件开发中，“解耦”-是实现高质量、可维护代码的核心原则之一，而“依赖注入”（Dependency-Injection-简称-DI）正是实现这一目标的重要手段。">在现代软件开发中，<strong>“解耦”</strong> 是实现高质量、可维护代码的核心原则之一，而“依赖注入”（Dependency Injection, 简称 DI）正是实现这一目标的重要手段。</h2>
<h2 id="🔍-什么是依赖注入？">🔍 什么是依赖注入？</h2>
<p><strong>依赖注入是一种设计模式，它将组件所依赖的资源（例如数据库连接、日志工具、配置项等）“注入”到组件中，而不是让组件自己创建这些资源。</strong></p>
<p>简单来说：</p>
<ul>
<li>传统写法：组件自己负责依赖的创建和管理。</li>
<li>依赖注入：依赖由外部提供，组件只负责使用。</li>
</ul>
<h3 id="✏️-举个小例子：">✏️ 举个小例子：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用依赖注入</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">    db *sql.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">()</span></span> *Service &#123;</span><br><span class="line">    db, _ := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;dsn&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;Service&#123;db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Service 被“绑定”到 MySQL 数据库，难以测试或替换。</p>
<p>使用依赖注入后：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用依赖注入</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">    db *sql.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(db *sql.DB)</span></span> *Service &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Service&#123;db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，Service 不再关心 db 是什么来源，外部可以灵活传入真实的数据库或 mock 实现，方便测试。</p>
<hr>
<h2 id="🧠-为什么要使用依赖注入？">🧠 为什么要使用依赖注入？</h2>
<ul>
<li>✅ <strong>解耦模块之间的依赖关系</strong></li>
<li>✅ <strong>提升代码的测试性和可维护性</strong></li>
<li>✅ <strong>更方便进行单元测试（mock 替代）</strong></li>
<li>✅ <strong>逻辑更清晰，依赖一目了然</strong></li>
</ul>
<hr>
<h2 id="🛠-Go-项目中如何实现依赖注入">🛠 Go 项目中如何实现依赖注入</h2>
<p>Go 语言没有内建 DI 容器（不像 Java 的 Spring 或 C# 的 .NET Core），但通过其简洁的语法结构，我们可以轻松地<strong>手动实现依赖注入</strong>。</p>
<hr>
<h3 id="✅-方法一：构造函数注入（最推荐）">✅ 方法一：构造函数注入（最推荐）</h3>
<p>这是 Go 项目中最常见和推荐的做法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">    logger *Logger</span><br><span class="line">    db     *DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(logger *Logger, db *DB)</span></span> *Service &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Service&#123;logger: logger, db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好处</strong>：</p>
<ul>
<li>依赖通过构造函数显式传入</li>
<li>可替换、可 mock</li>
<li>编译时强类型校验，安全可靠</li>
</ul>
<hr>
<h3 id="✅-方法二：接口注入（实现解耦）">✅ 方法二：接口注入（实现解耦）</h3>
<p>通过依赖接口而非具体类型，进一步提升灵活性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(msg <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmailNotifier <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EmailNotifier)</span></span> Send(msg <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Email sent:&quot;</span>, msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑只依赖接口</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    notifier Notifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">(n Notifier)</span></span> *UserService &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserService&#123;notifier: n&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以轻松替换为 <code>MockNotifier</code> 做测试，而无需改动核心业务代码。</p>
<hr>
<h3 id="✅-方法三：应用结构体统一管理依赖">✅ 方法三：应用结构体统一管理依赖</h3>
<p>适用于中型项目，可以封装一个 <code>App</code> 或 <code>Container</code> 结构体，集中管理各依赖组件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">    DB     *sql.DB</span><br><span class="line">    Logger *log.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">(db *sql.DB, logger *log.Logger)</span></span> *App &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;App&#123;DB: db, Logger: logger&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> HandleHome(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    a.Logger.Println(<span class="string">&quot;Serving Home&quot;</span>)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">&quot;Welcome to Go App&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger := log.New(os.Stdout, <span class="string">&quot;[APP] &quot;</span>, log.LstdFlags)</span><br><span class="line">    db, _ := sql.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;:memory:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    app := NewApp(db, logger)</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, app.HandleHome)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="⚡️-自动化依赖注入？看一下-Wire">⚡️ 自动化依赖注入？看一下 Wire</h2>
<p>Go 社区也有自动化的依赖注入工具，例如：</p>
<h3 id="🔧-Google-Wire">🔧 <a href="https://github.com/google/wire">Google Wire</a></h3>
<p><code>wire</code> 是一种<strong>静态代码生成</strong>的依赖注入工具，在编译阶段生成注入代码，不增加运行时成本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build wireinject</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitApp</span><span class="params">()</span></span> *App &#123;</span><br><span class="line">    wire.Build(NewLogger, NewDB, NewApp)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>wire</code> 命令会生成等效的构造代码。</p>
<p>适用于大型项目，能自动解决依赖图。</p>
<hr>
<h2 id="🧪-单元测试中的好帮手">🧪 单元测试中的好帮手</h2>
<p>依赖注入最大的优势之一：<strong>便于测试</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MockNotifier <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockNotifier)</span></span> Send(msg <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Mock:&quot;</span>, msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNotify</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    userService := NewUserService(&amp;MockNotifier&#123;&#125;)</span><br><span class="line">    userService.notifier.Send(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试中，你不需要真正的数据库、HTTP 请求或 Email 服务——只需要替代实现。</p>
<hr>
<h2 id="💡-开发中的最佳实践">💡 开发中的最佳实践</h2>
<ol>
<li>✅ <strong>用构造函数注入依赖</strong>，而不是在内部硬编码。</li>
<li>✅ <strong>依赖接口而非具体实现</strong>（面向抽象编程）。</li>
<li>✅ <strong>封装 App 结构统一注入服务</strong>。</li>
<li>✅ <strong>避免全局变量，除非确实是常量或全局唯一实例（如配置）</strong>。</li>
<li>✅ <strong>中大型项目可以考虑 Wire 等工具自动生成依赖注入代码</strong>。</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之各种空切片的应用</title>
    <url>/2025/06/09/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%90%84%E7%A7%8D%E7%A9%BA%E5%88%87%E7%89%87%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="📌-一、Go-中的切片回顾">📌 一、Go 中的切片回顾</h2>
<p>切片是 Go 的核心数据结构，本质上是一个三元结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span> <span class="comment">// 底层数组的指针</span></span><br><span class="line">    Len  <span class="type">int</span>     <span class="comment">// 长度</span></span><br><span class="line">    Cap  <span class="type">int</span>     <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片可以是：</p>
<ul>
<li><code>nil</code>（切片为 nil，表示它未被初始化）</li>
<li>空切片（长度为 0，但不一定是 nil）</li>
<li>非空切片</li>
</ul>
<hr>
<h2 id="📚-二、几种空切片的写法对比">📚 二、几种空切片的写法对比</h2>
<table>
<thead>
<tr>
<th>写法</th>
<th>类型值</th>
<th>是否为 nil</th>
<th>长度（len）</th>
<th>容量（cap）</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>var s []string</code></td>
<td><code>nil</code> 切片</td>
<td>✅ 是 nil</td>
<td>0</td>
<td>0</td>
<td>声明但尚未分配</td>
</tr>
<tr>
<td><code>[]string(nil)</code></td>
<td>显式 nil</td>
<td>✅ 是 nil</td>
<td>0</td>
<td>0</td>
<td>显式赋为 nil</td>
</tr>
<tr>
<td><code>[]string&#123;&#125;</code></td>
<td>非 nil 空切片</td>
<td>❌ 否</td>
<td>0</td>
<td>0</td>
<td>空但初始化</td>
</tr>
<tr>
<td><code>make([]string, 0)</code></td>
<td>非 nil 空切片</td>
<td>❌ 否</td>
<td>0</td>
<td>≥0（通常是0）</td>
<td>空但初始化，可扩容</td>
</tr>
</tbody>
</table>
<h3 id="✅-示例验证">✅ 示例验证</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a []<span class="type">string</span>                 <span class="comment">// nil</span></span><br><span class="line">	b := []<span class="type">string</span>(<span class="literal">nil</span>)            <span class="comment">// nil</span></span><br><span class="line">	c := []<span class="type">string</span>&#123;&#125;               <span class="comment">// 空，但非 nil</span></span><br><span class="line">	d := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)        <span class="comment">// 空，但非 nil</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;a == nil:&quot;</span>, a == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;b == nil:&quot;</span>, b == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;c == nil:&quot;</span>, c == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;d == nil:&quot;</span>, d == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧠-三、这些差异的意义是什么？">🧠 三、这些差异的意义是什么？</h2>
<h3 id="1-JSON-序列化行为（重点！）">1. JSON 序列化行为（重点！）</h3>
<p>这是最常遇到空切片的应用场景之一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span>   <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Friends []<span class="type">string</span> <span class="string">`json:&quot;friends&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>若 <code>Friends == nil</code>（如 <code>var s []string</code>），序列化为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Alice&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若 <code>Friends == []string&#123;&#125;</code> 或 <code>make([]string, 0)</code>，序列化为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;friends&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>📌 若你希望始终输出字段（哪怕为空数组），就不能用 nil！</p>
<hr>
<h3 id="2-数据库序列化（如-SQL、BSON）">2. 数据库序列化（如 SQL、BSON）</h3>
<ul>
<li><code>nil</code> 可能表示 NULL</li>
<li><code>[]&#123;&#125;</code> 通常表示空数组（不为 NULL）</li>
</ul>
<hr>
<h3 id="3-避免-nil-崩溃（安全性）">3. 避免 nil 崩溃（安全性）</h3>
<p>虽然 <code>nil</code> 切片是合法的切片，但在某些操作中如果不谨慎，容易 panic，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;hi&quot;</span> <span class="comment">// panic: index out of range</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-性能（微差异）">4. 性能（微差异）</h3>
<p>创建一个 <code>[]string&#123;&#125;</code> 会立即分配一个指针指向空数组，<code>make([]string, 0)</code> 同理。而 <code>nil</code> 切片没有底层数组，节省极小内存，在高性能场景或频繁创建时可能更优。</p>
<hr>
<h2 id="💡-四、最佳实践建议">💡 四、最佳实践建议</h2>
<h3 id="✅-如果你希望切片表示“尚未初始化”或“不存在数据”：">✅ 如果你希望切片表示“尚未初始化”或“不存在数据”：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []T    <span class="comment">// 或 s = nil</span></span><br></pre></td></tr></table></figure>
<p>用于延迟初始化或懒加载。</p>
<hr>
<h3 id="✅-如果你需要生成空数组表示“确实没有数据”，建议：">✅ 如果你需要生成空数组表示“确实没有数据”，建议：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []T&#123;&#125;            <span class="comment">// 推荐</span></span><br><span class="line">s := <span class="built_in">make</span>([]T, <span class="number">0</span>)     <span class="comment">// 也可以</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>尤其用于：<strong>JSON 响应、接口返回、明确代表空列表</strong></p>
</blockquote>
<hr>
<h3 id="✅-当你遍历切片时，不用担心-nil：">✅ 当你遍历切片时，不用担心 nil：</h3>
<p>Go 对 nil 切片的 <code>len()</code>、<code>range</code> 都是安全的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))   <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; <span class="comment">// 不会 panic</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧪-五、总结对比表">🧪 五、总结对比表</h2>
<table>
<thead>
<tr>
<th>表达式</th>
<th>是否为 nil</th>
<th>推荐用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>var s []T</code></td>
<td>✅ 是</td>
<td>延迟初始化、可能无值</td>
</tr>
<tr>
<td><code>[]T(nil)</code></td>
<td>✅ 是</td>
<td>显式设为 nil</td>
</tr>
<tr>
<td><code>[]T&#123;&#125;</code></td>
<td>❌ 否</td>
<td>空切片（用于空数组语义）✅</td>
</tr>
<tr>
<td><code>make([]T, 0)</code></td>
<td>❌ 否</td>
<td>空切片 + 预留扩容空间</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="✅-实战建议">✅ 实战建议</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>REST API 返回空数组</td>
<td><code>[]T&#123;&#125;</code></td>
</tr>
<tr>
<td>数据加载前的初始状态</td>
<td><code>var s []T</code></td>
</tr>
<tr>
<td>动态构建切片</td>
<td><code>make([]T, 0, cap)</code></td>
</tr>
<tr>
<td>性能敏感初始化</td>
<td><code>make([]T, 0)</code> 或 <code>[]T&#123;&#125;</code></td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之http</title>
    <url>/2025/05/30/go%E8%AF%AD%E8%A8%80%E4%B9%8Bhttp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言内置了功能强大的 <code>net/http</code> 包，用于构建 <strong>高性能 HTTP 服务</strong> 和 <strong>客户端请求</strong>。这是 Go 成为服务端开发热门语言的核心原因之一。</p>
<p>本文从背景、服务端开发、客户端请求、处理常见需求等多个方面 <strong>系统讲解 Go HTTP 的相关知识与实际用法</strong></p>
<hr>
<h2 id="📌-一、背景介绍：Go-HTTP-是什么？">📌 一、背景介绍：Go HTTP 是什么？</h2>
<p>Go 的 <code>net/http</code> 是标准库的一部分，包含：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>http.Server</code></td>
<td>用于创建 Web 服务器</td>
</tr>
<tr>
<td><code>http.Handler</code></td>
<td>接口，处理 HTTP 请求</td>
</tr>
<tr>
<td><code>http.Client</code></td>
<td>发起 HTTP 请求</td>
</tr>
<tr>
<td><code>http.Request</code></td>
<td>客户端请求的信息封装</td>
</tr>
<tr>
<td><code>http.ResponseWriter</code></td>
<td>服务端写入响应的接口</td>
</tr>
</tbody>
</table>
<p><strong>特性：</strong></p>
<ul>
<li>开箱即用，不依赖第三方框架</li>
<li>支持中间件、自定义路由</li>
<li>支持并发请求（默认支持）</li>
<li>可配合 <code>context</code> 实现超时控制、取消等高级功能</li>
</ul>
<hr>
<h2 id="🚀-二、服务端开发：快速搭建一个-HTTP-服务器">🚀 二、服务端开发：快速搭建一个 HTTP 服务器</h2>
<h3 id="✅-示例：创建一个基本-HTTP-服务">✅ 示例：创建一个基本 HTTP 服务</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">&quot;Hello, Go HTTP!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, helloHandler) <span class="comment">// 注册路由</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Listening on :8080&quot;</span>)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 启动服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="📘-说明：">📘 说明：</h3>
<ul>
<li><code>HandleFunc</code> 将 URL 路径 <code>/</code> 绑定到处理函数</li>
<li><code>http.ListenAndServe</code> 启动服务器并监听端口</li>
<li>每一个请求都会在 goroutine 中处理（自动并发）</li>
</ul>
<hr>
<h2 id="🔄-三、自定义路由与多路径处理">🔄 三、自定义路由与多路径处理</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aboutHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">&quot;This is the about page.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, helloHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/about&quot;</span>, aboutHandler)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧱-四、自定义-http-Handler-实现更复杂逻辑">🧱 四、自定义 <code>http.Handler</code> 实现更复杂逻辑</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h myHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="comment">// 任何 URL 都由这个 Handler 处理</span></span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Handled by custom handler: %s\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := myHandler&#123;&#125;                     <span class="comment">// 实例化自定义 handler</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, handler)      <span class="comment">// 使用自定义 handler 启动服务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧰-五、中间件机制（Logging、Auth-等）">🧰 五、中间件机制（Logging、Auth 等）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个中间件函数，打印每次访问的路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Received request: %s\n&quot;</span>, r.URL.Path)</span><br><span class="line">        next.ServeHTTP(w, r) <span class="comment">// 调用下一个 handler</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">&quot;Hello with middleware!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()          <span class="comment">// 创建多路复用器</span></span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/&quot;</span>, hello)         <span class="comment">// 注册路由处理函数</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, logger(mux)) <span class="comment">// 启用中间件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🌐-六、HTTP-客户端请求（GET-POST）">🌐 六、HTTP 客户端请求（GET/POST）</h2>
<h3 id="✅-GET-请求">✅ GET 请求</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://httpbin.org/get&quot;</span>) <span class="comment">// 发起 GET 请求</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err) <span class="comment">// 请求失败则打印错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close() <span class="comment">// 确保释放资源</span></span><br><span class="line"></span><br><span class="line">    body, _ := io.ReadAll(resp.Body) <span class="comment">// 读取响应体内容</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))        <span class="comment">// 打印响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="✅-POST-请求">✅ POST 请求</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Post(<span class="string">&quot;https://httpbin.org/post&quot;</span>, <span class="string">&quot;application/json&quot;</span>, bytes.NewBuffer([]<span class="type">byte</span>(<span class="string">`&#123;&quot;name&quot;:&quot;go&quot;&#125;`</span>)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="⏱-七、结合-context-处理超时与取消">⏱ 七、结合 context 处理超时与取消</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ctx := r.Context() <span class="comment">// 获取请求上下文</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Handler started&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Handler ended&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">        fmt.Fprintln(w, <span class="string">&quot;Finished work&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 客户端取消请求</span></span><br><span class="line">        http.Error(w, <span class="string">&quot;Request canceled&quot;</span>, http.StatusRequestTimeout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🔒-八、生产场景推荐配置（含超时）">🔒 八、生产场景推荐配置（含超时）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:         <span class="string">&quot;:8080&quot;</span>,      <span class="comment">// 服务监听端口</span></span><br><span class="line">        Handler:      http.DefaultServeMux,</span><br><span class="line">        ReadTimeout:  <span class="number">5</span> * time.Second, <span class="comment">// 读请求最大时间</span></span><br><span class="line">        WriteTimeout: <span class="number">10</span> * time.Second, <span class="comment">// 写响应最大时间</span></span><br><span class="line">        IdleTimeout:  <span class="number">15</span> * time.Second, <span class="comment">// Keep-alive 空闲连接最大时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintln(w, <span class="string">&quot;Hello with timeout!&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    log.Fatal(srv.ListenAndServe()) <span class="comment">// 启动服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="✅-九、实际开发中-HTTP-最佳实践">✅ 九、实际开发中 HTTP 最佳实践</h2>
<table>
<thead>
<tr>
<th>实践</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 路由封装</td>
<td>使用 <code>ServeMux</code> 或第三方框架如 <code>chi</code>、<code>gorilla/mux</code></td>
</tr>
<tr>
<td>✅ 中间件设计</td>
<td>封装日志、认证、限流等</td>
</tr>
<tr>
<td>✅ context 控制</td>
<td>控制取消、超时（防止内存泄露）</td>
</tr>
<tr>
<td>✅ 合理使用缓存</td>
<td>设置 <code>Cache-Control</code> 头、ETag</td>
</tr>
<tr>
<td>✅ 日志记录</td>
<td>打印响应耗时、状态码等</td>
</tr>
<tr>
<td>✅ 优雅关闭</td>
<td>使用 <code>context</code> 和 <code>os/signal</code> 优雅退出</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之嵌入</title>
    <url>/2025/05/14/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%B5%8C%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言中嵌入（embedding）<strong>是一种设计哲学和工程思维的体现，它摒弃了传统面向对象语言（如 Java/C++）中“类继承”的复杂性，取而代之的是一种</strong>显式组合（composition over inheritance）的设计风格。</p>
<hr>
<h2 id="🧠-一、Go-的设计哲学：组合优于继承">🧠 一、Go 的设计哲学：组合优于继承</h2>
<p>传统 OOP 语言采用类的继承来复用行为，但容易带来以下问题：</p>
<ul>
<li><strong>继承层级过深</strong>：容易造成维护困难；</li>
<li><strong>强耦合</strong>：子类与父类紧密绑定；</li>
<li><strong>隐藏依赖</strong>：不利于解耦和测试；</li>
<li><strong>继承冲突</strong>：多重继承带来的歧义。</li>
</ul>
<blockquote>
<p>Go 的核心哲学是：<strong>清晰的组合 + 显式的接口 + 零隐藏魔法</strong>。</p>
</blockquote>
<hr>
<h2 id="🧩-二、嵌入的本质：字段和方法的提升">🧩 二、嵌入的本质：字段和方法的提升</h2>
<p>嵌入只是将一个类型的字段或方法<strong>提升到另一个结构体中</strong>，不做任何隐式继承。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Logger)</span></span> Log(msg <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Log:&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">	Logger  <span class="comment">// 嵌入</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>Service</code> 就拥有了 <code>Log()</code> 方法，但你一眼能看出它来自 <code>Logger</code> ——这就是 Go 所强调的<strong>显式组合但隐式使用</strong>。</p>
<hr>
<h2 id="🔍-三、底层原理：语法糖-方法查找">🔍 三、底层原理：语法糖 + 方法查找</h2>
<p>Go 的嵌入实际上是<strong>语法糖</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := Service&#123;&#125;</span><br><span class="line">s.Log(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>编译器会自动解释为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.Logger.Log(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>方法和字段都遵循<strong>字段查找机制</strong>，嵌套结构最多支持一层字段提升。</p>
<hr>
<h2 id="🔧-四、实际应用场景">🔧 四、实际应用场景</h2>
<h3 id="1-复用通用字段结构">1. <strong>复用通用字段结构</strong></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BaseModel <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID        <span class="type">int</span></span><br><span class="line">	CreatedAt time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	BaseModel</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有实体都可以通过嵌入 BaseModel 拥有通用字段，无需重复定义。</p>
</blockquote>
<hr>
<h3 id="2-共享行为（方法）">2. <strong>共享行为（方法）</strong></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Logger)</span></span> Log(msg <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[LOG]:&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Logger</span><br><span class="line">	Addr <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>嵌入一个 Logger，可以让多个结构体共享日志功能。</p>
</blockquote>
<hr>
<h3 id="3-模拟继承-方法重写">3. <strong>模拟继承 + 方法重写</strong></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Animal)</span></span> Speak() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Animal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Speak() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>Dog</code> 定义了自己的 <code>Speak()</code> 方法，就会覆盖 <code>Animal</code> 的方法。</p>
</blockquote>
<hr>
<h3 id="4-接口嵌入：组合接口">4. <strong>接口嵌入：组合接口</strong></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多个小接口嵌入成大接口，符合 Go 的接口拆分哲学：<strong>“尽量小的接口”</strong>。</p>
</blockquote>
<hr>
<h2 id="💡-五、设计优势总结">💡 五、设计优势总结</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>简洁</td>
<td>无需冗长的继承结构</td>
</tr>
<tr>
<td>解耦</td>
<td>结构体之间组合而非依赖</td>
</tr>
<tr>
<td>清晰</td>
<td>嵌入行为是显式可见的</td>
</tr>
<tr>
<td>灵活</td>
<td>可以随意组合不同的功能块</td>
</tr>
<tr>
<td>类型安全</td>
<td>编译器检查嵌入字段和方法</td>
</tr>
<tr>
<td>避免菱形继承</td>
<td>多重嵌入不会有 C++ 那种冲突问题</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🤔-常见的工程实践场景">🤔 常见的工程实践场景</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库模型基类</td>
<td><code>BaseModel</code> 提供 ID、时间戳等字段</td>
</tr>
<tr>
<td>服务组件封装</td>
<td>嵌入日志、配置、HTTP 客户端等模块</td>
</tr>
<tr>
<td>中间件链封装</td>
<td>使用嵌入构造链式 handler</td>
</tr>
<tr>
<td>接口适配器</td>
<td>通过接口嵌入组合多个职责</td>
</tr>
<tr>
<td>控制反转（IoC）</td>
<td>提供默认行为，再由上层结构体重写方法</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🥵-组合（嵌入）结和接口代替继承的最佳实践">🥵 组合（嵌入）结和接口代替继承的最佳实践</h2>
<p>案例：打印机</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------- Shared Component ----------------</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Logger)</span></span> Log(msg <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[LOG]:&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------- Interface ----------------</span></span><br><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------- PDF Printer ----------------</span></span><br><span class="line"><span class="keyword">type</span> PDFPrinter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Logger</span><br><span class="line">	File <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PDFPrinter)</span></span> Print() &#123;</span><br><span class="line">	p.Log(<span class="string">&quot;Printing PDF: &quot;</span> + p.File)</span><br><span class="line">	fmt.Println(<span class="string">&quot;PDF content: &lt;pdf data&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------- HTML Printer ----------------</span></span><br><span class="line"><span class="keyword">type</span> HTMLPrinter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Logger</span><br><span class="line">	HTML <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HTMLPrinter)</span></span> Print() &#123;</span><br><span class="line">	h.Log(<span class="string">&quot;Printing HTML: &quot;</span> + h.HTML)</span><br><span class="line">	fmt.Println(<span class="string">&quot;HTML content: &lt;html data&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------- Polymorphic Function ----------------</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(p Printer)</span></span> &#123;</span><br><span class="line">	p.Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------- Main ----------------</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pdf := PDFPrinter&#123;File: <span class="string">&quot;invoice.pdf&quot;</span>&#125;</span><br><span class="line">	html := HTMLPrinter&#123;HTML: <span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	Process(pdf)</span><br><span class="line">	Process(html)</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之嵌入实战案例</title>
    <url>/2025/05/30/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%B5%8C%E5%85%A5%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="✅-案例-1：嵌入静态网页文件到-Web-服务器">✅ 案例 1：嵌入静态网页文件到 Web 服务器</h2>
<p><strong>应用场景</strong>：构建前端静态页面并打包进 Go 的后端程序中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;embed&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/fs&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed static/*</span></span><br><span class="line"><span class="keyword">var</span> content embed.FS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 子文件系统，从 static 开始</span></span><br><span class="line">	staticFiles, err := fs.Sub(content, <span class="string">&quot;static&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Serving static files on http://localhost:8080&quot;</span>)</span><br><span class="line">	http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.FS(staticFiles)))</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📂 <code>项目结构</code> 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.go</span><br><span class="line">static/</span><br><span class="line">  index.html</span><br><span class="line">  style.css</span><br><span class="line">  app.js</span><br></pre></td></tr></table></figure>
<p>启动后访问 <a href="http://localhost:8080">http://localhost:8080</a> 可以直接看到网页内容。</p>
<hr>
<h2 id="✅-案例-2：嵌入默认配置文件">✅ 案例 2：嵌入默认配置文件</h2>
<p><strong>应用场景</strong>：命令行工具或服务程序中嵌入默认配置（如 YAML、JSON、TOML）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;embed&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed config.default.json</span></span><br><span class="line"><span class="keyword">var</span> defaultConfig []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Port <span class="type">int</span>    <span class="string">`json:&quot;port&quot;`</span></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cfg Config</span><br><span class="line">	err := json.Unmarshal(defaultConfig, &amp;cfg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Loaded config: %+v\n&quot;</span>, cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📄 <code>config.default.json</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8080</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-app&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>开发者可以选择使用默认配置或在运行时覆盖配置。</p>
<hr>
<h2 id="✅-案例-3：嵌入模板文件">✅ 案例 3：嵌入模板文件</h2>
<p><strong>应用场景</strong>：Go Web 应用中需要渲染 HTML 模板（如邮件模板、用户界面等）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;embed&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed templates/email.html</span></span><br><span class="line"><span class="keyword">var</span> tmplFS embed.FS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tmpl, err := template.ParseFS(tmplFS, <span class="string">&quot;templates/email.html&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;Username&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Content&quot;</span>:  <span class="string">&quot;Welcome to our service!&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = tmpl.Execute(os.Stdout, data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📄 <code>templates/email.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;&#123;.Username&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;.Content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="✅-案例-4：嵌入版本信息和帮助文档">✅ 案例 4：嵌入版本信息和帮助文档</h2>
<p><strong>应用场景</strong>：CLI 工具显示版本信息或帮助文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;embed&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed VERSION</span></span><br><span class="line"><span class="keyword">var</span> version <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed HELP.md</span></span><br><span class="line"><span class="keyword">var</span> helpDoc <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Version:&quot;</span>, version)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Help:&quot;</span>)</span><br><span class="line">	fmt.Println(helpDoc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📄 <code>VERSION</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v1.0.3</span><br></pre></td></tr></table></figure>
<p>📄 <code>HELP.md</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  myapp [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  help        Show help info</span><br><span class="line">  version     Show version</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧠-总结：实际场景汇总">🧠 总结：实际场景汇总</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>使用资源</th>
<th>类型</th>
<th>推荐变量类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>嵌入静态文件</td>
<td>HTML/CSS/JS</td>
<td>多个文件</td>
<td><code>embed.FS</code></td>
</tr>
<tr>
<td>默认配置</td>
<td>JSON/YAML</td>
<td>单个文件</td>
<td><code>[]byte</code></td>
</tr>
<tr>
<td>模板引擎</td>
<td>HTML 模板</td>
<td>单/多文件</td>
<td><code>embed.FS</code></td>
</tr>
<tr>
<td>帮助文档</td>
<td>文本/Markdown</td>
<td>单个文件</td>
<td><code>string</code></td>
</tr>
<tr>
<td>字体/图片</td>
<td>二进制文件</td>
<td>单个文件</td>
<td><code>[]byte</code></td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之最常用标准库</title>
    <url>/2025/05/23/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1. <code>fmt</code> 包:</strong></p>
<ul>
<li><strong>功能:</strong> 提供格式化输入输出的功能，类似于 C 语言的 <code>printf</code> 和 <code>scanf</code>。</li>
<li><strong>为什么必备:</strong> 几乎所有的程序都需要进行输入输出，无论是打印日志、用户交互还是格式化数据。</li>
<li><strong>学习建议:</strong> 重点学习 <code>Printf</code>、<code>Sprintf</code>、<code>Fprintf</code> 等格式化输出函数，以及 <code>Scanf</code>、<code>Sscanf</code>、<code>Fscanf</code> 等格式化输入函数。了解各种格式化动词（如 <code>%d</code>, <code>%s</code>, <code>%v</code> 等）的用法。</li>
</ul>
<p><strong>2. <code>os</code> 包:</strong></p>
<ul>
<li><strong>功能:</strong> 提供与操作系统交互的功能，如文件操作、进程管理、环境变量等。</li>
<li><strong>为什么必备:</strong> 任何需要与底层操作系统交互的程序都会用到这个包。</li>
<li><strong>学习建议:</strong> 学习文件和目录的操作（<code>os.Create</code>, <code>os.Open</code>, <code>os.Mkdir</code>, <code>os.Remove</code> 等），环境变量的获取和设置（<code>os.Getenv</code>, <code>os.Setenv</code> 等），以及进程相关的操作（<code>os.Exit</code> 等）。</li>
</ul>
<p><strong>3. <code>net/http</code> 包:</strong></p>
<ul>
<li><strong>功能:</strong> 提供 HTTP 客户端和服务器的实现。</li>
<li><strong>为什么必备:</strong> 在当今互联网时代，Web 开发非常普遍，无论是构建 API 还是简单的 HTTP 客户端，这个包都是必不可少的。</li>
<li><strong>学习建议:</strong> 学习如何创建一个简单的 HTTP 服务器（<code>http.HandleFunc</code>, <code>http.ListenAndServe</code>），以及如何发起 HTTP 请求（<code>http.Get</code>, <code>http.Post</code> 等）。了解 <code>http.Request</code> 和 <code>http.ResponseWriter</code> 的结构和用法。</li>
</ul>
<p><strong>4. <code>io</code> 包:</strong></p>
<ul>
<li><strong>功能:</strong> 提供基本的 I/O 接口。很多其他的 I/O 相关的包都基于 <code>io</code> 包的接口。</li>
<li><strong>为什么必备:</strong> 处理输入和输出流是编程中常见的任务。</li>
<li><strong>学习建议:</strong> 理解 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，以及一些常用的实现，如 <code>bytes.Buffer</code> 和 <code>os.File</code>。</li>
</ul>
<p><strong>5. <code>bufio</code> 包:</strong></p>
<ul>
<li><strong>功能:</strong> 提供带缓冲的 I/O 操作，可以提高 I/O 的效率。</li>
<li><strong>为什么必备:</strong> 在处理大量数据或需要更精细控制 I/O 的场景下很有用。</li>
<li><strong>学习建议:</strong> 学习 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 的用法，以及它们提供的缓冲读取和写入方法。</li>
</ul>
<p><strong>6. <code>strings</code> 包:</strong></p>
<ul>
<li><strong>功能:</strong> 提供字符串操作的常用函数，如查找、替换、分割等。</li>
<li><strong>为什么必备:</strong> 字符串处理在各种应用中都很常见。</li>
<li><strong>学习建议:</strong> 学习 <code>strings.Contains</code>, <code>strings.Index</code>, <code>strings.ReplaceAll</code>, <code>strings.Split</code>, <code>strings.Join</code> 等常用函数。</li>
</ul>
<p><strong>7. <code>strconv</code> 包:</strong></p>
<ul>
<li><strong>功能:</strong> 提供字符串和基本数据类型之间的转换功能。</li>
<li><strong>为什么必备:</strong> 在处理用户输入、配置文件等场景下，经常需要在字符串和数值之间进行转换。</li>
<li><strong>学习建议:</strong> 学习 <code>strconv.Atoi</code> (字符串转整数), <code>strconv.Itoa</code> (整数转字符串), 以及其他类型转换函数，如 <code>ParseBool</code>, <code>ParseFloat</code> 等。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之chan struct{}</title>
    <url>/2025/05/29/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%B9%B6%E5%8F%91%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Go-语言并发利器：chan-struct-与-close-的妙用">Go 语言并发利器：<code>chan struct&#123;&#125;</code> 与 <code>close()</code> 的妙用</h2>
<p>在 Go 语言的并发世界里，goroutine 和 channel 是构建强大并发程序的基石。今天，我们来深入探讨一种特殊但非常实用的 channel 类型：<code>chan struct&#123;&#125;</code>，以及与之配合使用的 <code>close()</code> 函数。理解它们的机制和应用场景，能帮助我们写出更优雅、更高效的并发代码。</p>
<h3 id="chan-struct-：轻量级的信号通道"><code>chan struct&#123;&#125;</code>：轻量级的信号通道</h3>
<p>通常，channel 用于在 goroutine 之间传递数据。但有时，我们仅仅需要一个<strong>信号</strong>，通知某个或某些 goroutine 某个事件已经发生，而不需要传递任何具体的数据。这时，<code>chan struct&#123;&#125;</code> 就派上了用场。</p>
<p><code>struct&#123;&#125;</code> 是一个零大小的类型，这意味着通过 <code>chan struct&#123;&#125;</code> 传递数据不会产生额外的内存开销。我们仅仅关心 channel 是否被发送或接收，以此作为事件发生的标志。</p>
<p><strong>声明和使用 <code>chan struct&#123;&#125;</code>:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Worker is starting...&quot;</span>)</span><br><span class="line">	<span class="comment">// 模拟工作</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Worker is done!&quot;</span>)</span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 发送信号表示完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> worker(done)</span><br><span class="line">	&lt;-done <span class="comment">// 阻塞直到收到 worker 完成的信号</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;All done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>done</code> channel 的类型是 <code>chan struct&#123;&#125;</code>。<code>worker</code> goroutine 完成工作后，向 <code>done</code> channel 发送一个空结构体 <code>struct&#123;&#125;</code>。<code>main</code> goroutine 通过接收这个信号得知 <code>worker</code> 已经完成。</p>
<h3 id="close-：优雅地广播“结束”信号"><code>close()</code>：优雅地广播“结束”信号</h3>
<p><code>close()</code> 函数用于关闭一个 channel。<strong>关闭一个 channel 会向所有正在等待从该 channel 接收数据的 goroutine 发送一个零值（对于 <code>chan struct&#123;&#125;</code> 来说就是零值，即可以接收到信号），并且后续不能再向已关闭的 channel 发送数据，否则会引发 panic。</strong></p>
<p>接收方可以通过接收操作的第二个返回值来判断 channel 是否已经关闭：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := &lt;-ch</span><br></pre></td></tr></table></figure>
<p>如果 <code>ok</code> 是 <code>true</code>，表示接收到了 channel 中发送的值；如果 <code>ok</code> 是 <code>false</code>，表示 channel 已经关闭，并且 channel 中没有更多的数据可以接收。</p>
<p><strong>使用 <code>close()</code> 通知多个 goroutine 停止工作:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Worker %d starting...\n&quot;</span>, id)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Worker %d received quit signal. Exiting.\n&quot;</span>, id)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 模拟工作</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Worker %d is working...\n&quot;</span>, id)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numWorkers := <span class="number">3</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numWorkers; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(i+<span class="number">1</span>, quit, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟一段时间后发出停止信号</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sending quit signal to all workers...&quot;</span>)</span><br><span class="line">	<span class="built_in">close</span>(quit) <span class="comment">// 关闭 quit channel，广播停止信号</span></span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;All workers have exited.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了多个 <code>worker</code> goroutine，它们都监听同一个 <code>quit</code> channel。当 <code>main</code> goroutine 调用 <code>close(quit)</code> 时，所有正在阻塞等待从 <code>quit</code> 接收数据的 <code>worker</code> 都会收到一个零值，并通过 <code>select</code> 语句中的 <code>case &lt;-quit:</code> 分支退出。<code>sync.WaitGroup</code> 用于等待所有 worker goroutine 优雅地退出。</p>
<h2 id="实际应用场景">实际应用场景</h2>
<h3 id="1-事件通知：更细致的场景">1. 事件通知：更细致的场景</h3>
<p>在微服务架构中，一个服务完成某个关键操作后，可能需要通知其他依赖它的服务。使用 <code>chan struct&#123;&#125;</code> 可以实现这种轻量级的通知机制。</p>
<p><strong>场景：订单服务完成支付，通知库存服务扣减库存。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库存服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inventoryService</span><span class="params">(orderPaid &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> orderPaid &#123; <span class="comment">// 接收到信号</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;库存服务：收到订单支付通知，正在扣减库存...&quot;</span>)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 模拟扣减库存</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;库存服务：库存扣减完成。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;库存服务已停止。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderService</span><span class="params">(orderID <span class="type">string</span>, paid <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;订单服务：订单 %s 开始处理支付...\n&quot;</span>, orderID)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟支付处理</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;订单服务：订单 %s 支付完成。\n&quot;</span>, orderID)</span><br><span class="line">	paid &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 发送支付完成的信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	orderPaid := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> inventoryService(orderPaid, &amp;wg)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> orderService(<span class="string">&quot;order-123&quot;</span>, orderPaid)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 模拟主流程运行一段时间</span></span><br><span class="line">	<span class="built_in">close</span>(orderPaid)           <span class="comment">// 关闭通知通道，库存服务会优雅退出</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;主服务已停止。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>orderPaid</code> 是一个 <code>chan struct&#123;&#125;</code>。当订单服务完成支付后，会向 <code>orderPaid</code> 发送一个信号。库存服务监听这个信号，一旦收到，就开始扣减库存。使用 <code>chan struct&#123;&#125;</code> 的好处是，我们只关心“支付完成”这个事件的发生，不需要传递订单的具体信息给库存服务（订单信息应该通过其他更适合的方式传递）。最后通过 <code>close(orderPaid)</code> 通知库存服务可以停止监听了。</p>
<h3 id="2-服务优雅关闭：更全面的考量">2. 服务优雅关闭：更全面的考量</h3>
<p>在构建长时间运行的服务（如 Web 服务器、后台任务处理程序）时，优雅关闭至关重要。这涉及到通知所有正在运行的 goroutine 停止工作，并等待它们清理资源后退出。</p>
<p><strong>场景：一个简单的 Web 服务器，需要能够优雅地停止所有请求处理 goroutine。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestHandler</span><span class="params">(w http.ResponseWriter, r *http.Request, quit &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求处理 goroutine 收到停止信号，正在退出...&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second): <span class="comment">// 模拟请求处理</span></span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;请求处理完成 at %s\n&quot;</span>, time.Now().Format(time.RFC3339))</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求处理完成。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/process&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> requestHandler(w, r, quit, &amp;wg)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	server := &amp;http.Server&#123;Addr: <span class="string">&quot;:8080&quot;</span>, Handler: <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Web 服务器正在监听 :8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err := server.ListenAndServe(); err != http.ErrServerClosed &#123;</span><br><span class="line">			fmt.Fatalf(<span class="string">&quot;HTTP server ListenAndServe: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Web 服务器已停止监听。&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听操作系统的中断信号 (Ctrl+C) 或终止信号</span></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">	&lt;-sig <span class="comment">// 阻塞直到收到信号</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n收到停止信号，开始关闭服务器...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知所有请求处理 goroutine 停止</span></span><br><span class="line">	<span class="built_in">close</span>(quit)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给正在处理的请求一些时间完成</span></span><br><span class="line">	shutdownCtx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">if</span> err := server.Shutdown(shutdownCtx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;HTTP server shutdown error: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有请求处理 goroutine 退出</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;所有 goroutine 已退出，服务器已优雅关闭。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个更复杂的例子中：</p>
<ul>
<li>我们创建了一个 <code>quit</code> channel (<code>chan struct&#123;&#125;</code>) 用于通知请求处理的 goroutine 停止。</li>
<li>当收到操作系统的停止信号时，我们首先 <code>close(quit)</code>，向所有正在处理请求的 <code>requestHandler</code> goroutine 发送停止信号。</li>
<li>然后，我们使用 <code>http.Server.Shutdown</code> 来优雅地关闭 HTTP 服务器，这会阻止新的连接，并等待正在处理的连接完成（在超时时间内）。</li>
<li>最后，我们使用 <code>wg.Wait()</code> 等待所有正在处理的 <code>requestHandler</code> goroutine 退出。</li>
</ul>
<p><code>close(quit)</code> 在这里起到了广播停止信号的关键作用，使得多个并发的请求处理 goroutine 能够收到通知并开始清理退出。</p>
<h3 id="3-限流：令牌桶的简单实现">3. 限流：令牌桶的简单实现</h3>
<p>虽然 Go 语言有更专业的限流库，但使用带缓冲的 <code>chan struct&#123;&#125;</code> 可以实现一个简单的令牌桶限流器。</p>
<p><strong>场景：限制某个操作的并发执行数量。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, rateLimiter &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	&lt;-rateLimiter <span class="comment">// 从限流器获取一个“令牌”</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Worker %d started at %s\n&quot;</span>, id, time.Now().Format(time.RFC3339))</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟工作</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Worker %d finished at %s\n&quot;</span>, id, time.Now().Format(time.RFC3339))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numWorkers := <span class="number">5</span></span><br><span class="line">	concurrencyLimit := <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	rateLimiter := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, concurrencyLimit)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化令牌桶</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; concurrencyLimit; i++ &#123;</span><br><span class="line">		rateLimiter &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numWorkers; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(i+<span class="number">1</span>, rateLimiter, &amp;wg)</span><br><span class="line">		time.Sleep(<span class="number">500</span> * time.Millisecond) <span class="comment">// 稍微延迟启动 worker</span></span><br><span class="line">		<span class="comment">// 模拟令牌的补充 (实际场景可能更复杂)</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rateLimiter &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 如果令牌桶已满，则不补充</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;All workers finished.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>rateLimiter</code> 是一个容量为 <code>concurrencyLimit</code> 的 <code>chan struct&#123;&#125;</code>。每个 <code>worker</code> 在开始工作前需要从 <code>rateLimiter</code> 接收一个值（相当于获取一个“令牌”）。只有当 <code>rateLimiter</code> 中有可用的“令牌”时，<code>worker</code> 才能继续执行。虽然这个例子中的令牌补充比较简单，但它展示了如何使用带缓冲的 <code>chan struct&#123;&#125;</code> 来控制并发数量。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之RESTful Routing</title>
    <url>/2025/06/06/go%E8%AF%AD%E8%A8%80%E4%B9%8BRESTful/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="📌-什么是-RESTful-Routing？一文理解-Web-架构的“黄金准则”">📌 什么是 RESTful Routing？一文理解 Web 架构的“黄金准则”</h1>
<p>在 Web 开发中，如果你想写出清晰、易维护、符合标准的 API，那么你一定绕不开一个重要的概念——<strong>RESTful 路由（RESTful Routing）</strong>。它是一种约定俗成的资源路径设计方式，能够让你的接口直观、统一、专业。</p>
<hr>
<h2 id="🧠-一、什么是-REST？">🧠 一、什么是 REST？</h2>
<p>REST，全称 <strong>Representational State Transfer</strong>（表述性状态转移），是一种软件架构风格，强调：</p>
<ul>
<li>资源（Resource）导向；</li>
<li>无状态通信；</li>
<li>使用标准的 HTTP 方法（GET、POST、PUT、DELETE）进行操作；</li>
<li>统一接口设计。</li>
</ul>
<p>简单理解：<strong>一切皆资源</strong>，你对资源的操作应该用标准的方法来表达。</p>
<hr>
<h2 id="🧭-二、RESTful-Routing-是什么？">🧭 二、RESTful Routing 是什么？</h2>
<p><strong>RESTful Routing</strong> 就是指按照 REST 原则设计 Web 应用的 URL 路由结构，它把 URL 当作“资源名词”，而不是“动作动词”。</p>
<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><code>/users</code></td>
<td>获取用户列表</td>
</tr>
<tr>
<td>GET</td>
<td><code>/users/42</code></td>
<td>获取 id 为 42 的用户</td>
</tr>
<tr>
<td>POST</td>
<td><code>/users</code></td>
<td>创建一个新用户</td>
</tr>
<tr>
<td>PUT</td>
<td><code>/users/42</code></td>
<td>更新指定用户</td>
</tr>
<tr>
<td>DELETE</td>
<td><code>/users/42</code></td>
<td>删除指定用户</td>
</tr>
</tbody>
</table>
<p>✅ URL 描述资源位置<br>
✅ HTTP 方法描述操作行为</p>
<hr>
<h2 id="🏗️-三、为什么使用-RESTful-Routing？">🏗️ 三、为什么使用 RESTful Routing？</h2>
<ol>
<li><strong>清晰</strong>：URL 设计统一、语义明确。</li>
<li><strong>标准</strong>：便于协同开发、前后端约定一致。</li>
<li><strong>可扩展</strong>：适用于大型 API 系统。</li>
<li><strong>易测试</strong>：与工具如 Postman、curl、Swagger 协作更自然。</li>
</ol>
<hr>
<h2 id="🧪-四、在-Go-中实现-RESTful-Routing">🧪 四、在 Go 中实现 RESTful Routing</h2>
<p>Go 标准库 <code>net/http</code> 只支持基础路由，但我们可以借助路由库如 <code>gorilla/mux</code> 或 <code>chi</code> 来实现更复杂的 RESTful API。</p>
<h3 id="示例：使用-gorilla-mux-构建-RESTful-用户接口">示例：使用 gorilla/mux 构建 RESTful 用户接口</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/gorilla/mux</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">string</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;</span><br><span class="line">    &#123;ID: <span class="string">&quot;1&quot;</span>, Name: <span class="string">&quot;Alice&quot;</span>&#125;,</span><br><span class="line">    &#123;ID: <span class="string">&quot;2&quot;</span>, Name: <span class="string">&quot;Bob&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUsers</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    json.NewEncoder(w).Encode(users)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    params := mux.Vars(r)</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.ID == params[<span class="string">&quot;id&quot;</span>] &#123;</span><br><span class="line">            json.NewEncoder(w).Encode(u)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createUser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user User</span><br><span class="line">    json.NewDecoder(r.Body).Decode(&amp;user)</span><br><span class="line">    users = <span class="built_in">append</span>(users, user)</span><br><span class="line">    json.NewEncoder(w).Encode(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    params := mux.Vars(r)</span><br><span class="line">    <span class="keyword">for</span> i, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.ID == params[<span class="string">&quot;id&quot;</span>] &#123;</span><br><span class="line">            json.NewDecoder(r.Body).Decode(&amp;users[i])</span><br><span class="line">            json.NewEncoder(w).Encode(users[i])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteUser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    params := mux.Vars(r)</span><br><span class="line">    <span class="keyword">for</span> i, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.ID == params[<span class="string">&quot;id&quot;</span>] &#123;</span><br><span class="line">            users = <span class="built_in">append</span>(users[:i], users[i+<span class="number">1</span>:]...)</span><br><span class="line">            w.WriteHeader(http.StatusNoContent)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line"></span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/users&quot;</span>, getUsers).Methods(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, getUser).Methods(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/users&quot;</span>, createUser).Methods(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, updateUser).Methods(<span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, deleteUser).Methods(<span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="✅-五、最佳实践总结">✅ 五、最佳实践总结</h2>
<ol>
<li><strong>URL 是名词，动作用方法表达</strong>：避免 <code>/getUser</code>, <code>/createUser</code>，而应使用 <code>/users</code> + <code>GET/POST</code>。</li>
<li><strong>路径层级表达资源关系</strong>：例如 <code>/users/42/posts</code> 表示获取用户的所有帖子。</li>
<li><strong>使用状态码反馈操作结果</strong>：200、201、204、400、404、500 等。</li>
<li><strong>保持一致性与统一性</strong>：所有路由命名、风格、方法统一。</li>
</ol>
<hr>
<h2 id="🔚-总结">🔚 总结</h2>
<p>RESTful Routing 是现代 Web 开发的核心约定，Go 语言虽简洁，但配合路由库也能优雅实现 REST 风格接口。在团队协作、API 设计、文档生成等方面，它带来的价值是长期可见的。</p>
<blockquote>
<p>下一步：你可以尝试为一个博客系统设计 RESTful 接口 —— <code>/posts</code>、<code>/comments</code>、<code>/tags</code>……然后用 <code>mux</code> 或 <code>chi</code> 实现它们！</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之嵌入指令</title>
    <url>/2025/05/30/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%B5%8C%E5%85%A5%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Go 语言中，<code>//go:embed</code>指令是 Go 1.16 引入的一项新特性，它允许你在编译时<strong>将文件或目录的内容嵌入到 Go 程序中</strong>，不需要额外的文件打包工具。这项功能主要通过标准库中的 <a href="https://pkg.go.dev/embed"><code>embed</code></a> 包实现。</p>
<hr>
<h2 id="✅-用途简介">✅ 用途简介</h2>
<ul>
<li>内嵌 HTML、CSS、JS 等静态资源</li>
<li>嵌入配置文件（如 JSON、YAML）</li>
<li>将模板文件或小型二进制资源嵌入可执行文件中</li>
<li>创建无需外部文件的“单文件分发”程序</li>
</ul>
<hr>
<h2 id="📦-如何使用-go-embed">📦 如何使用 <code>//go:embed</code></h2>
<h3 id="1-引入-embed-包">1. 引入 <code>embed</code> 包</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;embed&quot;</span></span><br></pre></td></tr></table></figure>
<p>即使不直接使用包中的函数，也<strong>必须显式导入 <code>embed</code> 包</strong>，否则编译会报错。</p>
<hr>
<h3 id="2-基础示例：嵌入单个文件">2. 基础示例：嵌入单个文件</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    _ <span class="string">&quot;embed&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="keyword">var</span> content <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设目录下有 <code>hello.txt</code> 文件，内容为 <code>&quot;Hello, Go Embed!&quot;</code>，运行时会将文件内容直接嵌入 <code>content</code> 变量中。</p>
<hr>
<h3 id="3-嵌入为-byte">3. 嵌入为 <code>[]byte</code></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed data.bin</span></span><br><span class="line"><span class="keyword">var</span> binaryData []<span class="type">byte</span></span><br></pre></td></tr></table></figure>
<p>适用于图片、字体、二进制文件等。</p>
<hr>
<h3 id="4-嵌入多个文件">4. 嵌入多个文件</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed file1.txt file2.txt</span></span><br><span class="line"><span class="keyword">var</span> file1 <span class="type">string</span></span><br></pre></td></tr></table></figure>
<p>⚠️ 多个文件使用时只能赋值给 <code>embed.FS</code> 类型（虚拟文件系统）：</p>
<hr>
<h3 id="5-嵌入目录（推荐方式）">5. 嵌入目录（推荐方式）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;embed&quot;</span></span><br><span class="line">    <span class="string">&quot;io/fs&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed static/*</span></span><br><span class="line"><span class="keyword">var</span> staticFiles embed.FS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data, err := staticFiles.ReadFile(<span class="string">&quot;static/index.html&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>💡 <code>embed.FS</code> 实现了 <code>fs.FS</code> 接口，可以直接用于标准库的 <code>http.FS()</code>、<code>io/fs</code> 等。</p>
<hr>
<h2 id="🧑‍💻-实际开发中的最佳实践">🧑‍💻 实际开发中的最佳实践</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>使用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Web 应用</td>
<td>嵌入静态资源（HTML/CSS/JS）并通过 <code>http.FileServer(http.FS(embed.FS))</code> 提供服务</td>
</tr>
<tr>
<td>CLI 工具</td>
<td>嵌入帮助文档、版本信息、License</td>
</tr>
<tr>
<td>配置系统</td>
<td>内嵌默认配置（可被用户覆盖）</td>
</tr>
<tr>
<td>嵌入模板</td>
<td>渲染时读取模板文件，避免部署麻烦</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="⛔-注意事项">⛔ 注意事项</h2>
<ul>
<li>文件路径是<strong>相对当前 <code>.go</code> 文件的路径</strong></li>
<li>不能用变量动态指定路径（路径必须是编译时常量）</li>
<li>文件内容是编译时嵌入，运行时不会重新读取磁盘文件</li>
<li>不支持通配子目录：<code>//go:embed static/**</code> 不合法，需手动指定每一级目录</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之并发编程入门指南</title>
    <url>/2025/05/18/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-并发编程指南">Go 并发编程指南</h1>
<h2 id="一、并发与并行的基本概念">一、并发与并行的基本概念</h2>
<ul>
<li><strong>并发（Concurrency）</strong>：多个任务在同一时间段内交替执行（单核或多核皆可）。</li>
<li><strong>并行（Parallelism）</strong>：多个任务在同一时刻同时执行（仅在多核 CPU 中实现）。</li>
</ul>
<h2 id="二、Goroutine：轻量级线程">二、Goroutine：轻量级线程</h2>
<h3 id="1-基本使用">1. 基本使用</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello from goroutine&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<ul>
<li>每个 <code>goroutine</code> 约 2KB 栈空间，由 Go 调度器调度（非操作系统线程）。</li>
<li>创建开销小，可大规模使用（成千上万）。</li>
</ul>
<h3 id="2-注意事项">2. 注意事项</h3>
<ul>
<li>goroutine 是异步执行的，主协程退出会导致所有子 goroutine 被杀死。</li>
<li>需使用 <code>sync.WaitGroup</code> 或其他手段控制生命周期。</li>
</ul>
<h2 id="三、通道-Channel：Goroutine-间通信">三、通道 Channel：Goroutine 间通信</h2>
<h3 id="1-基本语法">1. 基本语法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)     <span class="comment">// 创建无缓冲通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 创建带缓冲通道</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span>      <span class="comment">// 发送数据</span></span><br><span class="line">x := &lt;-ch    <span class="comment">// 接收数据</span></span><br></pre></td></tr></table></figure>
<h3 id="2-特点">2. 特点</h3>
<ul>
<li>通道通信是<strong>阻塞的</strong>（无缓冲时发送/接收都阻塞）。</li>
<li>可用于 goroutine 之间安全地共享数据。</li>
</ul>
<h3 id="3-关闭通道">3. 关闭通道</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 通知接收方不再发送</span></span><br></pre></td></tr></table></figure>
<h3 id="4-使用-range-读取所有数据">4. 使用 <code>range</code> 读取所有数据</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、select：监听多个通道">四、select：监听多个通道</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-ch1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;From ch1:&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- <span class="number">42</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Send to ch2&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;No channel ready&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>select</code> 会阻塞直到某个分支可执行。</li>
<li>可用于实现超时、广播、负载均衡等逻辑。</li>
</ul>
<h2 id="五、WaitGroup：等待一组-goroutine-完成">五、WaitGroup：等待一组 goroutine 完成</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 阻塞直到计数器归零</span></span><br></pre></td></tr></table></figure>
<h2 id="六、Mutex：互斥锁">六、Mutex：互斥锁</h2>
<p>用于保护共享资源，避免数据竞争。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
<h2 id="七、Once：只执行一次（如单例）">七、Once：只执行一次（如单例）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="八、Cond：条件变量">八、Cond：条件变量</h2>
<p>适用于需要等待某条件成立再继续执行的情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    cond.Wait() <span class="comment">// 等待条件</span></span><br><span class="line">    <span class="comment">// 条件满足后执行</span></span><br><span class="line">    cond.L.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Signal() <span class="comment">// 或 cond.Broadcast()</span></span><br><span class="line">cond.L.Unlock()</span><br></pre></td></tr></table></figure>
<h2 id="九、Context：控制-goroutine-的生命周期">九、Context：控制 goroutine 的生命周期</h2>
<h3 id="1-取消-goroutine">1. 取消 goroutine</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 正常执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line"></span><br><span class="line">cancel() <span class="comment">// 通知 goroutine 退出</span></span><br></pre></td></tr></table></figure>
<h3 id="2-超时-截止时间">2. 超时 / 截止时间</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br></pre></td></tr></table></figure>
<h2 id="十、定时器和-Ticker">十、定时器和 Ticker</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">time.After(<span class="number">1</span> * time.Second)     <span class="comment">// 一次性定时器</span></span><br><span class="line">time.NewTicker(<span class="number">1</span> * time.Second) <span class="comment">// 周期性定时器</span></span><br></pre></td></tr></table></figure>
<h2 id="十一、数据竞争与工具">十一、数据竞争与工具</h2>
<ul>
<li>使用 <code>go run -race</code> 启用数据竞争检测。</li>
<li>Go 的 <code>race detector</code> 是诊断并发程序的强大工具。</li>
</ul>
<h2 id="十二、高级模式和最佳实践">十二、高级模式和最佳实践</h2>
<ul>
<li>使用工作池（Worker Pool）限制 goroutine 并发数。</li>
<li>避免共享内存，推荐通过 Channel 传递数据。</li>
<li>对共享状态使用原子操作或互斥锁。</li>
<li>理解 CSP 模型：“不要通过共享内存来通信，而应该通过通信来共享内存”。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之恐慌与恢复</title>
    <url>/2025/05/28/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%81%90%E6%85%8C%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-语言中-panic-和-recover-的使用准则">Go 语言中 panic 和 recover 的使用准则</h1>
<p>在 Go 语言中，panic 和 recover 机制提供了异常处理能力，但 Go 社区普遍认为应谨慎使用。以下是关于何时使用 panic 和 error 的原则：</p>
<h2 id="主要原则：优先使用-error">主要原则：优先使用 error</h2>
<p>在大多数情况下，应使用返回 error 的方式而非 panic，原因如下：</p>
<ul>
<li><strong>显式错误处理</strong>：调用者可明确知道哪些操作可能失败，并决定如何处理。</li>
<li><strong>代码可读性</strong>：错误处理流程清晰可见。</li>
<li><strong>控制流明确</strong>：避免意外的程序终止。</li>
<li><strong>符合 Go 语言哲学</strong>：Go 鼓励显式错误处理而非异常机制。</li>
</ul>
<h2 id="适合使用-panic-的场景">适合使用 panic 的场景</h2>
<p>以下情况可考虑使用 panic：</p>
<h3 id="1-不可恢复的错误">1. 不可恢复的错误</h3>
<p>程序遇到无法继续执行的严重问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !criticalCondition &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;系统处于不可恢复状态&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-程序初始化阶段的错误">2. 程序初始化阶段的错误</h3>
<p>如配置文件缺失、数据库连接失败等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> configFile == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;配置文件路径不能为空&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-编程错误（bug）">3. 编程错误（bug）</h3>
<p>如违反接口约定、不可达的代码路径等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> value := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    <span class="comment">// 处理int</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    <span class="comment">// 处理string</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;未处理的类型: %T&quot;</span>, v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-在测试中标记测试失败">4. 在测试中标记测试失败</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSomething</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> result != expected &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;测试失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-recover-的场景">使用 recover 的场景</h2>
<p>recover 主要用于：</p>
<h3 id="1-防止-goroutine-崩溃影响整个程序">1. 防止 goroutine 崩溃影响整个程序</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeDo</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;捕获到panic:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-顶级-HTTP-处理器中捕获-panic">2. 顶级 HTTP 处理器中捕获 panic</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            http.Error(w, <span class="string">&quot;内部服务器错误&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">            log.Printf(<span class="string">&quot;处理器panic: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 处理器逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-在库的边界处恢复-panic（若库内部使用了-panic）">3. 在库的边界处恢复 panic（若库内部使用了 panic）</h3>
<h2 id="最佳实践建议">最佳实践建议</h2>
<ul>
<li><strong>在应用程序代码中</strong>：几乎总是使用 error 而非 panic。</li>
<li><strong>在库代码中</strong>：更加谨慎，通常应返回 error 而非 panic。</li>
<li><strong>保持一致性</strong>：若一个包使用了 panic，整个包需采用相同策略。</li>
<li><strong>文档记录</strong>：若函数可能 panic，必须在文档中明确说明。</li>
</ul>
<h2 id="示例对比">示例对比</h2>
<h3 id="使用-error（推荐）">使用 error（推荐）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处</span></span><br><span class="line">result, err := Divide(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-panic（不推荐，除非特殊情况）">使用 panic（不推荐，除非特殊情况）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustDivide</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;错误:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    result := MustDivide(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>在 Go 中，error 是处理错误的默认和推荐方式，panic 应保留给真正异常的情况（如不可恢复的错误或编程错误）。recover 则用于捕获 panic，防止程序或 goroutine 崩溃。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之接口设计原则</title>
    <url>/2025/05/15/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>假设接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Foo()</span><br><span class="line">    Bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你有一个结构体只实现了 <code>Foo()</code>，没有实现 <code>Bar()</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStruct)</span></span> Foo() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Foo called&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="❌-此时的行为">❌ 此时的行为</h3>
<p>如果你尝试这样赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x MyInterface = MyStruct&#123;&#125;  <span class="comment">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure>
<p><strong>会报编译错误：</strong></p>
<blockquote>
<p><code>MyStruct</code> does not implement <code>MyInterface</code> (missing method <code>Bar</code>)</p>
</blockquote>
<hr>
<h3 id="✅-Go-的接口是结构性的">✅ Go 的接口是结构性的</h3>
<p>Go 使用结构性类型系统，<strong>只要类型实现了接口所需的所有方法，就隐式满足该接口。</strong><br>
所以如果缺失任意一个方法，即便名字完全匹配，<strong>也不能赋值给该接口变量。</strong></p>
<hr>
<h3 id="✅-正确实现方式">✅ 正确实现方式</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStruct)</span></span> Foo() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Foo called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStruct)</span></span> Bar() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bar called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x MyInterface = MyStruct&#123;&#125;  <span class="comment">// ✅ OK</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="实际开发建议">实际开发建议</h3>
<ul>
<li><strong>接口设计要聚焦最小功能集</strong>（遵循接口隔离原则），以便结构体可以按需实现。</li>
<li><strong>使用组合接口</strong>：将多个小接口组合成更大接口，例如：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fooer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Barer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooBar <span class="keyword">interface</span> &#123;</span><br><span class="line">    Fooer</span><br><span class="line">    Barer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之文件读取</title>
    <url>/2025/05/29/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Go-语言文件读取详解与最佳实践">Go 语言文件读取详解与最佳实践</h2>
<p>在 Go 语言中，文件操作是常见的任务之一。Go 的 os 包和 io 包提供了丰富的功能来读取和写入文件。本文将通过一个具体的代码示例，深入探讨 Go 语言中文件读取的几种常用方法，并总结一些工程中的最佳实践。</p>
<h3 id="代码示例">代码示例</h3>
<p>首先，让我们来看一下你提供的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;err : &quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := fmt.Println</span><br><span class="line">	pf := fmt.Printf</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 os.ReadFile 一次性读取整个文件内容</span></span><br><span class="line">	data, err := os.ReadFile(<span class="string">&quot;./tmp/dat&quot;</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	p(<span class="type">string</span>(data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 os.Open 打开文件并进行更细粒度的读取</span></span><br><span class="line">	f, err := os.Open(<span class="string">&quot;./tmp/dat&quot;</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="keyword">defer</span> f.Close() <span class="comment">// 确保文件在使用完毕后关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从文件中读取指定数量的字节</span></span><br><span class="line">	b1 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">	n1, err := f.Read(b1)</span><br><span class="line">	check(err)</span><br><span class="line">	pf(<span class="string">&quot;%d bytes: %s\n&quot;</span>, n1, <span class="type">string</span>(b1[:n1]))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Seek 方法移动文件指针，并从新的位置读取</span></span><br><span class="line">	o2, err := f.Seek(<span class="number">6</span>, io.SeekStart)</span><br><span class="line">	check(err)</span><br><span class="line">	b2 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">6</span>)</span><br><span class="line">	n2, err := f.Read(b2)</span><br><span class="line">	pf(<span class="string">&quot;%d bytes @ %d: &quot;</span>, n2, o2)</span><br><span class="line">	pf(<span class="string">&quot;%v\n&quot;</span>, <span class="type">string</span>(b2[:n2]))</span><br><span class="line"></span><br><span class="line">	_, err = f.Seek(<span class="number">2</span>, io.SeekCurrent) <span class="comment">// 相对于当前位置移动</span></span><br><span class="line">	check(err)</span><br><span class="line"></span><br><span class="line">	_, err = f.Seek(<span class="number">-4</span>, io.SeekEnd) <span class="comment">// 相对于文件末尾移动</span></span><br><span class="line">	check(err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 io.ReadAtLeast 确保读取到指定的最少字节数</span></span><br><span class="line">	o3, err := f.Seek(<span class="number">6</span>, io.SeekStart)</span><br><span class="line">	check(err)</span><br><span class="line">	b3 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">6</span>)</span><br><span class="line">	n3, err := io.ReadAtLeast(f, b3, <span class="number">6</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	pf(<span class="string">&quot;%d bytes @ %d: %s\n&quot;</span>, n3, o3, <span class="type">string</span>(b3))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 bufio.NewReader 提高读取效率</span></span><br><span class="line">	_, err = f.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">	check(err)</span><br><span class="line">	r4 := bufio.NewReader(f)</span><br><span class="line">	b4, err := r4.Peek(<span class="number">5</span>) <span class="comment">// 预览 Reader 缓冲区的前 N 个字节</span></span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;5 bytes: %s\n&quot;</span>, <span class="type">string</span>(b4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码详解">代码详解</h3>
<ol>
<li>
<p><strong>导入包</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os</code>: 提供了操作系统相关的功能，包括文件操作。</li>
<li><code>fmt</code>: 用于格式化输入输出。</li>
<li><code>io</code>: 提供了基本的 I/O 接口。</li>
<li><code>bufio</code>: 提供了带缓冲的 I/O 操作，可以提高读写效率。</li>
</ul>
</li>
<li>
<p><strong>错误检查函数 <code>check</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Errorf(<span class="string">&quot;err : &quot;</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的错误处理函数。在实际项目中，你可能需要更完善的错误处理机制，例如记录日志、返回错误等。</p>
</li>
<li>
<p><strong><code>os.ReadFile</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data, err := os.ReadFile(<span class="string">&quot;./tmp/dat&quot;</span>)</span><br><span class="line">check(err)</span><br><span class="line">p(<span class="type">string</span>(data))</span><br></pre></td></tr></table></figure>
<p><code>os.ReadFile</code> 函数会一次性读取整个文件的内容并返回一个 <code>[]byte</code>。这适用于读取小文件，对于大文件可能会消耗大量内存。</p>
</li>
<li>
<p><strong><code>os.Open</code> 和 <code>f.Read</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;./tmp/dat&quot;</span>)</span><br><span class="line">check(err)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">b1 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">n1, err := f.Read(b1)</span><br><span class="line">check(err)</span><br><span class="line">pf(<span class="string">&quot;%d bytes: %s\n&quot;</span>, n1, <span class="type">string</span>(b1[:n1]))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.Open</code> 用于以只读模式打开一个文件，返回一个 <code>*os.File</code> 类型的文件对象 <code>f</code>。</li>
<li><code>defer f.Close()</code>: 这是一个非常重要的最佳实践。<code>defer</code> 关键字确保在函数执行完毕后（无论是正常返回还是发生 panic），<code>f.Close()</code> 都会被调用，从而释放文件资源。</li>
<li><code>f.Read(b1)</code>: 从文件中读取最多 <code>len(b1)</code> 个字节到 <code>b1</code> 这个 byte slice 中。它返回实际读取的字节数 <code>n1</code> 和一个 <code>error</code>。</li>
</ul>
</li>
<li>
<p><strong><code>f.Seek</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o2, err := f.Seek(<span class="number">6</span>, io.SeekStart)</span><br><span class="line">check(err)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">_, err = f.Seek(<span class="number">2</span>, io.SeekCurrent)</span><br><span class="line">check(err)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">_, err = f.Seek(<span class="number">-4</span>, io.SeekEnd)</span><br><span class="line">check(err)</span><br></pre></td></tr></table></figure>
<p><code>f.Seek</code> 用于设置文件指针的位置。</p>
<ul>
<li>第一个参数 <code>offset</code> 是偏移量。</li>
<li>第二个参数 <code>whence</code> 定义了起始位置：
<ul>
<li><code>io.SeekStart</code> (0): 相对于文件起始位置。</li>
<li><code>io.SeekCurrent</code> (1): 相对于当前文件指针位置。</li>
<li><code>io.SeekEnd</code> (2): 相对于文件末尾位置。<br>
它返回新的文件指针位置和一个 <code>error</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>io.ReadAtLeast</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o3, err := f.Seek(<span class="number">6</span>, io.SeekStart)</span><br><span class="line">check(err)</span><br><span class="line">b3 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">6</span>)</span><br><span class="line">n3, err := io.ReadAtLeast(f, b3, <span class="number">6</span>)</span><br><span class="line">check(err)</span><br><span class="line">pf(<span class="string">&quot;%d bytes @ %d: %s\n&quot;</span>, n3, o3, <span class="type">string</span>(b3))</span><br></pre></td></tr></table></figure>
<p><code>io.ReadAtLeast</code> 函数尝试从 <code>io.Reader</code> 中读取至少 <code>min</code> 个字节到给定的 buffer 中。如果读取的字节数少于 <code>min</code> 但没有遇到 EOF，它会返回一个错误。</p>
</li>
<li>
<p><strong><code>bufio.NewReader</code> 和 <code>r4.Peek</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err = f.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">check(err)</span><br><span class="line">r4 := bufio.NewReader(f)</span><br><span class="line">b4, err := r4.Peek(<span class="number">5</span>)</span><br><span class="line">check(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;5 bytes: %s\n&quot;</span>, <span class="type">string</span>(b4))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bufio.NewReader(f)</code> 创建一个新的带缓冲的读取器。缓冲可以减少系统调用的次数，提高读取性能，特别是对于频繁的小块读取。</li>
<li><code>r4.Peek(5)</code> 返回 Reader 缓冲区中前 5 个字节的切片，但不会移动读取指针。如果缓冲区中的数据少于 5 个字节，它会返回可用的字节。</li>
</ul>
</li>
</ol>
<h3 id="工程中的最佳实践">工程中的最佳实践</h3>
<ol>
<li>
<p><strong>及时关闭文件</strong>: 始终使用 <code>defer f.Close()</code> 来确保在不再需要文件时关闭它，释放系统资源。</p>
</li>
<li>
<p><strong>错误处理</strong>: 示例代码中的 <code>check</code> 函数非常简单。在实际项目中，应该根据错误类型进行更细致的处理，例如记录日志、返回特定的错误信息等。</p>
</li>
<li>
<p><strong>选择合适的读取方法</strong>:</p>
<ul>
<li>对于小文件，可以使用 <code>os.ReadFile</code> 一次性读取。</li>
<li>对于大文件或需要分块处理的文件，应该使用 <code>os.Open</code> 并结合 <code>f.Read</code> 来逐步读取。</li>
<li>如果需要提高读取性能，特别是当进行大量的小块读取时，可以使用 <code>bufio.Reader</code>。</li>
</ul>
</li>
<li>
<p><strong>处理读取的字节数</strong>: <code>f.Read</code> 返回实际读取的字节数。在处理读取到的数据时，应该使用实际读取的长度，例如 <code>string(b1[:n1])</code>，而不是假设总是读取了预期的字节数。</p>
</li>
<li>
<p><strong>文件指针操作</strong>: 谨慎使用 <code>f.Seek</code>，理解其相对于起始位置、当前位置和末尾位置的含义。不当的文件指针操作可能导致数据读取错误。</p>
</li>
<li>
<p><strong>使用 <code>bufio</code> 进行高效 I/O</strong>: <code>bufio</code> 提供的缓冲功能可以显著提高 I/O 操作的效率，尤其是在处理大量数据时。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之文件写入</title>
    <url>/2025/05/29/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Go-语言文件写入详解与最佳实践">Go 语言文件写入详解与最佳实践</h2>
<p>在 Go 语言中，文件写入是另一个重要的文件操作任务。Go 的 <code>os</code> 包和 <code>bufio</code> 包提供了多种方式来向文件写入数据。本文将通过你提供的代码示例，深入探讨 Go 语言中文件写入的常用方法，并总结一些工程中的最佳实践。</p>
<h3 id="代码示例">代码示例</h3>
<p>首先，我们来看一下你提供的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 os.WriteFile 一次性写入数据到文件</span></span><br><span class="line">	d1 := []<span class="type">byte</span>(<span class="string">&quot;hello\ngo\n&quot;</span>)</span><br><span class="line">	err := os.WriteFile(<span class="string">&quot;./tmp/dat1&quot;</span>, d1, <span class="number">0644</span>)</span><br><span class="line">	check(err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 os.Create 创建文件并获取 *os.File 对象，然后使用 Write 方法写入</span></span><br><span class="line">	f, err := os.Create(<span class="string">&quot;./tmp/dat2&quot;</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="keyword">defer</span> f.Close() <span class="comment">// 确保文件在使用完毕后关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Write 方法写入 byte slice</span></span><br><span class="line">	d2 := []<span class="type">byte</span>&#123;<span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">10</span>&#125;</span><br><span class="line">	n2, err := f.Write(d2)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 WriteString 方法写入字符串</span></span><br><span class="line">	n3, err := f.WriteString(<span class="string">&quot;writes\n&quot;</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用 Sync 将缓冲区的数据写入磁盘</span></span><br><span class="line">	f.Sync()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 bufio.NewWriter 创建带缓冲的写入器，提高写入效率</span></span><br><span class="line">	w := bufio.NewWriter(f)</span><br><span class="line">	n4, err := w.WriteString(<span class="string">&quot;buffered\n&quot;</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n4)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用 Flush 将缓冲区中的数据写入底层写入器（在这里是文件）</span></span><br><span class="line">	w.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码详解">代码详解</h3>
<ol>
<li>
<p><strong>导入包</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os</code>: 提供了操作系统相关的功能，包括文件操作。</li>
<li><code>fmt</code>: 用于格式化输入输出。</li>
<li><code>bufio</code>: 提供了带缓冲的 I/O 操作，可以提高读写效率。</li>
</ul>
</li>
<li>
<p><strong>错误检查函数 <code>check</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个错误处理函数在遇到错误时会触发 <code>panic</code>。在实际项目中，你可能需要更优雅的错误处理方式。</p>
</li>
<li>
<p><strong><code>os.WriteFile</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d1 := []<span class="type">byte</span>(<span class="string">&quot;hello\ngo\n&quot;</span>)</span><br><span class="line">err := os.WriteFile(<span class="string">&quot;./tmp/dat1&quot;</span>, d1, <span class="number">0644</span>)</span><br><span class="line">check(err)</span><br></pre></td></tr></table></figure>
<p><code>os.WriteFile</code> 函数会将给定的 <code>[]byte</code> 数据一次性写入到指定的文件中。第三个参数 <code>0644</code> 是文件的权限模式。这适用于简单地写入少量数据到文件的场景。</p>
</li>
<li>
<p><strong><code>os.Create</code> 和 <code>f.Write</code> / <code>f.WriteString</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">&quot;./tmp/dat2&quot;</span>)</span><br><span class="line">check(err)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">d2 := []<span class="type">byte</span>&#123;<span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">10</span>&#125;</span><br><span class="line">n2, err := f.Write(d2)</span><br><span class="line">check(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n2)</span><br><span class="line"></span><br><span class="line">n3, err := f.WriteString(<span class="string">&quot;writes\n&quot;</span>)</span><br><span class="line">check(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n3)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.Create</code> 函数会创建一个新的文件用于写入。如果文件已存在，它会截断（清空）该文件。它返回一个 <code>*os.File</code> 类型的文件对象 <code>f</code>。</li>
<li><code>defer f.Close()</code>: 同样，这是一个重要的最佳实践，确保文件在使用完毕后被关闭。</li>
<li><code>f.Write(d2)</code>: 将一个 <code>[]byte</code> 写入到文件中，返回实际写入的字节数 <code>n2</code> 和一个 <code>error</code>。</li>
<li><code>f.WriteString(&quot;writes\n&quot;)</code>: 将一个字符串写入到文件中，返回实际写入的字节数 <code>n3</code> 和一个 <code>error</code>。</li>
</ul>
</li>
<li>
<p><strong><code>f.Sync()</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f.Sync()</span><br></pre></td></tr></table></figure>
<p><code>Sync</code> 方法会将文件底层驱动的任何缓存中的数据写入到磁盘。这可以确保数据的持久性，但在频繁写入的场景下可能会影响性能。</p>
</li>
<li>
<p><strong><code>bufio.NewWriter</code> 和 <code>w.WriteString</code> / <code>w.Flush</code></strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w := bufio.NewWriter(f)</span><br><span class="line">n4, err := w.WriteString(<span class="string">&quot;buffered\n&quot;</span>)</span><br><span class="line">check(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n4)</span><br><span class="line"></span><br><span class="line">w.Flush()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bufio.NewWriter(f)</code> 创建一个新的带缓冲的写入器。写入到这个 writer 的数据会先被缓存在内存中，当缓冲区满或者显式调用 <code>Flush</code> 方法时，才会批量写入到底层的文件中，这样可以减少系统调用次数，提高写入性能。</li>
<li><code>w.WriteString(&quot;buffered\n&quot;)</code>: 将字符串写入到 writer 的缓冲区中。</li>
<li><code>w.Flush()</code>: 将 writer 缓冲区中的所有数据写入到底层的 <code>io.Writer</code>（在这里是文件）。<strong>务必在完成写入后调用 <code>Flush</code>，以确保所有数据都被写入磁盘。</strong></li>
</ul>
</li>
</ol>
<h3 id="工程中的最佳实践">工程中的最佳实践</h3>
<ol>
<li>
<p><strong>及时关闭文件</strong>: 始终使用 <code>defer f.Close()</code> 来确保文件在使用完毕后关闭，释放系统资源。</p>
</li>
<li>
<p><strong>错误处理</strong>: 示例代码中使用了 <code>panic</code> 进行错误处理，这在生产环境中通常是不合适的。应该使用更健壮的错误处理机制，例如返回 <code>error</code> 值并进行处理。</p>
</li>
<li>
<p><strong>选择合适的写入方法</strong>:</p>
<ul>
<li>对于简单的、一次性的少量数据写入，可以使用 <code>os.WriteFile</code>。</li>
<li>对于更复杂的写入操作或需要追加写入等，可以使用 <code>os.Create</code> (或 <code>os.OpenFile</code> with appropriate flags) 获取 <code>*os.File</code> 并使用 <code>Write</code> 或 <code>WriteString</code> 方法。</li>
<li>对于需要提高写入性能的场景，尤其是当进行多次小块写入时，应该使用 <code>bufio.Writer</code>，并在完成写入后调用 <code>Flush</code>。</li>
</ul>
</li>
<li>
<p><strong>考虑数据持久性</strong>: 如果对数据的持久性有较高的要求，可以在适当的时候调用 <code>f.Sync()</code>，但这可能会牺牲一定的性能。</p>
</li>
<li>
<p><strong>文件权限</strong>: 使用 <code>os.WriteFile</code> 或 <code>os.Create</code> 时需要注意设置正确的文件权限模式。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之无缓冲通道</title>
    <url>/2025/05/18/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%A0%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言中的通道（<code>channel</code>）是用于<strong>协程间通信</strong>的核心工具。它有两种形式：<strong>无缓冲通道</strong> 和 <strong>有缓冲通道</strong>。</p>
<hr>
<h2 id="🌱-什么是通道（channel）？">🌱 什么是通道（channel）？</h2>
<p>在 Go 中，通道用于在 goroutine 之间传递数据。它就像一个<strong>传送带</strong>，一个 goroutine 把数据“放上去”，另一个 goroutine 把它“取下来”。</p>
<hr>
<h2 id="⚙️-无缓冲通道（unbuffered-channel）">⚙️ 无缓冲通道（unbuffered channel）</h2>
<h3 id="✅-特点：">✅ 特点：</h3>
<ul>
<li><strong>发送和接收必须同步进行。</strong></li>
<li>如果发送时没有接收方在等着，发送就会<strong>阻塞（卡住）</strong>，直到接收方出现。</li>
<li>更适合用于<strong>协程同步</strong>。</li>
</ul>
<h3 id="🎯-比喻：">🎯 比喻：</h3>
<p>像两个人面对面递纸条，递的人不能走，直到接的人把纸条接过去。</p>
<h3 id="🔧-示例代码：">🔧 示例代码：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// 无缓冲通道</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="string">&quot;hello from goroutine&quot;</span> <span class="comment">// 会阻塞直到 main() 接收</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	msg := &lt;-ch <span class="comment">// 接收到消息后，上面的发送才完成</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="⚙️-有缓冲通道（buffered-channel）">⚙️ 有缓冲通道（buffered channel）</h2>
<h3 id="✅-特点：-2">✅ 特点：</h3>
<ul>
<li>允许<strong>指定缓冲大小</strong>。</li>
<li>发送操作在缓冲未满时不会阻塞。</li>
<li>接收操作在缓冲非空时不会阻塞。</li>
<li>适用于<strong>解耦发送者和接收者速度</strong>不同的场景。</li>
</ul>
<h3 id="🎯-比喻：-2">🎯 比喻：</h3>
<p>像一个邮箱，有多个格子可以放纸条。你可以先投进去，只要格子没满。</p>
<h3 id="🔧-示例代码：-2">🔧 示例代码：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>) <span class="comment">// 有缓冲通道，容量为2</span></span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="string">&quot;message 1&quot;</span> <span class="comment">// ✅ 不阻塞</span></span><br><span class="line">	ch &lt;- <span class="string">&quot;message 2&quot;</span> <span class="comment">// ✅ 不阻塞</span></span><br><span class="line">	<span class="comment">// ch &lt;- &quot;message 3&quot; // ❌ 超出缓冲，会阻塞，除非有接收</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-ch) <span class="comment">// 输出 message 1</span></span><br><span class="line">	fmt.Println(&lt;-ch) <span class="comment">// 输出 message 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧠-总结对比">🧠 总结对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>无缓冲通道</th>
<th>有缓冲通道</th>
</tr>
</thead>
<tbody>
<tr>
<td>阻塞行为</td>
<td>发送和接收必须同步</td>
<td>缓冲满才阻塞发送，空才阻塞接收</td>
</tr>
<tr>
<td>是否适合同步</td>
<td>✅ 是</td>
<td>❌ 不直接适合</td>
</tr>
<tr>
<td>是否适合解耦速度</td>
<td>❌ 否</td>
<td>✅ 是</td>
</tr>
<tr>
<td>使用难度</td>
<td>稍高，容易死锁</td>
<td>相对灵活，但容易忘记接收</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之日志</title>
    <url>/2025/05/30/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言内置了基本的日志库 <code>log</code>，自 Go 1.21 起又引入了更现代、结构化的日志库 <code>log/slog</code></p>
<span id="more"></span>
<h2 id="🧱-一、标准库-log-简介">🧱 一、标准库 <code>log</code> 简介</h2>
<p>Go 标准库中的 <code>log</code> 提供了基本的同步日志功能。适合简单项目或单机程序，特点是：</p>
<ul>
<li>支持日志前缀（Prefix）</li>
<li>支持设置时间戳、文件路径等输出信息（通过 <code>SetFlags</code>）</li>
<li>支持自定义输出目的地（Writer）</li>
</ul>
<h3 id="常用方法">常用方法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.Print(<span class="string">&quot;普通日志&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;自动换行&quot;</span>)</span><br><span class="line">log.Printf(<span class="string">&quot;格式化日志: %d&quot;</span>, <span class="number">100</span>)</span><br><span class="line">log.Fatal(<span class="string">&quot;打印后调用 os.Exit(1)&quot;</span>)</span><br><span class="line">log.Panic(<span class="string">&quot;打印后 panic()&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="设置日志属性">设置日志属性</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.SetPrefix(<span class="string">&quot;DEBUG: &quot;</span>)                     <span class="comment">// 设置日志前缀</span></span><br><span class="line">log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile) <span class="comment">// 显示日期、时间、文件名:行号</span></span><br><span class="line">log.SetOutput(os.Stdout)                     <span class="comment">// 改变输出目标（默认是 stderr）</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="💡-二、自定义日志记录器-log-New">💡 二、自定义日志记录器 (<code>log.New</code>)</h2>
<p>用于模块化日志输出、写入文件或缓存等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, _ := os.Create(<span class="string">&quot;app.log&quot;</span>)</span><br><span class="line">logger := log.New(file, <span class="string">&quot;APP: &quot;</span>, log.LstdFlags|log.Lshortfile)</span><br><span class="line"></span><br><span class="line">logger.Println(<span class="string">&quot;hello from logger&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🌟-三、结构化日志库-log-slog（Go-1-21-）">🌟 三、结构化日志库 <code>log/slog</code>（Go 1.21+）</h2>
<h3 id="特点">特点</h3>
<ul>
<li>支持 <strong>JSON 格式</strong> 输出</li>
<li>支持 <strong>键值对结构化日志</strong></li>
<li>可插拔的日志后端（可用于发送到远程、文件、服务等）</li>
</ul>
<h3 id="示例：基本用法">示例：基本用法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line">    logger := slog.New(handler)</span><br><span class="line"></span><br><span class="line">    logger.Info(<span class="string">&quot;user logged in&quot;</span>, <span class="string">&quot;userID&quot;</span>, <span class="number">1234</span>, <span class="string">&quot;ip&quot;</span>, <span class="string">&quot;192.168.1.1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下（JSON 格式）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2025-05-30T12:00:00Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;INFO&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;user logged in&quot;</span><span class="punctuation">,</span><span class="attr">&quot;userID&quot;</span><span class="punctuation">:</span><span class="number">1234</span><span class="punctuation">,</span><span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span><span class="string">&quot;192.168.1.1&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="📁-四、最佳实践：构建通用日志模块（推荐用于实际项目）">📁 四、最佳实践：构建通用日志模块（推荐用于实际项目）</h2>
<h3 id="logger-logger-go"><code>logger/logger.go</code></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Log *slog.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(env <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> handler slog.Handler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> env == <span class="string">&quot;dev&quot;</span> &#123;</span><br><span class="line">        handler = slog.NewTextHandler(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler = slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log = slog.New(handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用日志模块">使用日志模块</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;yourapp/logger&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger.Init(<span class="string">&quot;dev&quot;</span>)</span><br><span class="line">    logger.Log.Info(<span class="string">&quot;server started&quot;</span>, <span class="string">&quot;port&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    logger.Log.Error(<span class="string">&quot;failed to connect DB&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🛠️-五、进阶用法与建议">🛠️ 五、进阶用法与建议</h2>
<h3 id="写入文件（使用-io-MultiWriter）">写入文件（使用 <code>io.MultiWriter</code>）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, _ := os.OpenFile(<span class="string">&quot;app.log&quot;</span>, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line">multi := io.MultiWriter(os.Stdout, file)</span><br><span class="line">log.SetOutput(multi)</span><br></pre></td></tr></table></figure>
<h3 id="加入日志级别（标准库不支持，需要自己实现或用-slog）">加入日志级别（标准库不支持，需要自己实现或用 slog）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.Println(<span class="string">&quot;[INFO] service started&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;[ERROR] database unavailable&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用第三方库（如-zerolog、zap）">使用第三方库（如 zerolog、zap）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 zap</span></span><br><span class="line">logger, _ := zap.NewProduction()</span><br><span class="line"><span class="keyword">defer</span> logger.Sync()</span><br><span class="line">logger.Info(<span class="string">&quot;hello zap&quot;</span>, zap.String(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;Alice&quot;</span>), zap.Int(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="📌-六、推荐日志策略（开发建议）">📌 六、推荐日志策略（开发建议）</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>建议做法</th>
</tr>
</thead>
<tbody>
<tr>
<td>本地开发</td>
<td>使用 <code>slog.TextHandler</code>，方便阅读</td>
</tr>
<tr>
<td>生产环境</td>
<td>使用 <code>slog.JSONHandler</code>，适合日志采集与分析工具（ELK、Loki）</td>
</tr>
<tr>
<td>多模块项目</td>
<td>自定义日志模块，统一日志格式与等级</td>
</tr>
<tr>
<td>需要性能或日志量极大</td>
<td>使用 <code>zap</code>（Uber）或 <code>zerolog</code>（高性能）</td>
</tr>
<tr>
<td>日志等级控制</td>
<td><code>slog.Level</code> 支持 DEBUG、INFO、WARN、ERROR 可设置过滤</td>
</tr>
<tr>
<td>测试中使用</td>
<td>写入 <code>bytes.Buffer</code>，便于断言日志输出</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="✅-总结">✅ 总结</h2>
<table>
<thead>
<tr>
<th>日志方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>log</code></td>
<td>简单快速，内置</td>
<td>无结构化、不支持等级</td>
</tr>
<tr>
<td><code>log.New</code></td>
<td>可自定义输出</td>
<td>管理复杂、功能有限</td>
</tr>
<tr>
<td><code>log/slog</code></td>
<td>结构化日志、JSON/文本输出</td>
<td>Go 1.21+ 限制</td>
</tr>
<tr>
<td><code>zap/zerolog</code></td>
<td>高性能、等级控制、生产级</td>
<td>引入外部依赖，API 学习成本</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之时间与并发</title>
    <url>/2025/05/26/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%B6%E9%97%B4%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="理论部分">理论部分</h1>
<p><strong>核心概念：时间与并发</strong></p>
<p>在 Go 语言中，处理时间相关的任务通常会涉及到并发，因为我们不希望等待某个时间点的到来或者周期性地执行任务阻塞了主程序的运行。<code>Timer</code> 和 <code>Ticker</code> 正好是 Go 并发模型中处理时间事件的利器。它们都基于 Go 的 Goroutine 和 Channel 实现。</p>
<p><strong>1. <code>time.Timer</code>：一次性定时器</strong></p>
<p><strong>原理：</strong></p>
<p><code>time.Timer</code> 代表一个<strong>在未来某个时刻</strong>触发的事件。当你创建一个 <code>Timer</code> 时，你需要指定一个延迟时间。当这个延迟时间到达后，<code>Timer</code> 会向其内部的 Channel 发送一个 <code>time.Time</code> 类型的值。之后，这个 <code>Timer</code> 通常就完成了它的使命（除非你显式地重置它，但这不常用）。</p>
<p>你可以将 <code>Timer</code> 想象成一个闹钟，你设置好闹钟在某个时间响起一次。</p>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>一次性触发：</strong> <code>Timer</code> 主要用于在指定的延迟后执行一次操作。</li>
<li><strong>Channel 通信：</strong> 它通过自身的 Channel (<code>C</code>) 来通知事件的发生。你需要从这个 Channel 中接收值。</li>
<li><strong>需要显式停止：</strong> 如果你创建了一个 <code>Timer</code> 但在它触发之前就不再需要了，你应该调用它的 <code>Stop()</code> 方法来释放相关资源。如果不停止，这个 Goroutine 可能会一直存在。</li>
</ul>
<p><strong>实际应用示例：延迟执行任务</strong></p>
<p>假设你想在 2 秒后打印一条消息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;程序启动...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 2 秒后触发的 Timer</span></span><br><span class="line">	timer := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待 Timer 触发</span></span><br><span class="line">	&lt;-timer.C</span><br><span class="line">	fmt.Println(<span class="string">&quot;2 秒过去了，Timer 触发了！&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意：timer 在触发后，其内部的 Goroutine 可能会继续尝试发送，</span></span><br><span class="line">	<span class="comment">// 所以即使已经触发，如果不再使用，最好也 Stop() 一下（虽然在这个简单例子中不一定必要）。</span></span><br><span class="line">	timer.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更细致的解释：</strong></p>
<ol>
<li><code>time.NewTimer(2 * time.Second)</code> 创建了一个新的 <code>Timer</code>。内部会启动一个 Goroutine，这个 Goroutine 会等待 2 秒。</li>
<li><code>&lt;-timer.C</code> 阻塞了当前的 Goroutine（主 Goroutine），直到 <code>timer.C</code> 这个 Channel 接收到值。当 2 秒过去后，<code>Timer</code> 内部的 Goroutine 会向 <code>timer.C</code> 发送当前的时间。</li>
<li>一旦 <code>timer.C</code> 接收到值，阻塞解除，<code>fmt.Println(&quot;2 秒过去了，Timer 触发了！&quot;)</code> 这行代码就会被执行。</li>
<li><code>timer.Stop()</code> 用于停止 Timer。如果 Timer 尚未触发，<code>Stop()</code> 会阻止它发送事件到 Channel，并返回 <code>true</code>。如果 Timer 已经触发或者已经被停止，<code>Stop()</code> 返回 <code>false</code>。</li>
</ol>
<p><strong>2. <code>time.Ticker</code>：周期性定时器</strong></p>
<p><strong>原理：</strong></p>
<p><code>time.Ticker</code> 代表一个<strong>以固定时间间隔</strong>重复触发的事件。当你创建一个 <code>Ticker</code> 时，你需要指定一个时间间隔。之后，<code>Ticker</code> 会每隔这个时间间隔就向其内部的 Channel 发送一个 <code>time.Time</code> 类型的值。</p>
<p>你可以将 <code>Ticker</code> 想象成一个节拍器，它会按照固定的节奏发出信号。</p>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>周期性触发：</strong> <code>Ticker</code> 用于以固定的时间间隔重复执行操作。</li>
<li><strong>Channel 通信：</strong> 它也通过自身的 Channel (<code>C</code>) 来通知每次事件的发生。你需要在一个循环中从这个 Channel 中接收值。</li>
<li><strong>需要显式停止：</strong> 当你不再需要 <code>Ticker</code> 时，<strong>必须</strong>调用它的 <code>Stop()</code> 方法来停止底层的 Goroutine，否则这个 Goroutine 会一直运行下去，导致资源泄漏。</li>
</ul>
<p><strong>实际应用示例：每隔一段时间执行任务</strong></p>
<p>假设你想每隔 1 秒打印一次当前时间，持续一段时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;程序启动，开始周期性打印时间...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个每隔 1 秒触发一次的 Ticker</span></span><br><span class="line">	ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop() <span class="comment">// 确保在函数退出时停止 Ticker</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 持续 5 秒打印时间</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		currentTime := &lt;-ticker.C</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前时间:&quot;</span>, currentTime)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;5 秒结束，停止打印。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更细致的解释：</strong></p>
<ol>
<li><code>time.NewTicker(1 * time.Second)</code> 创建了一个新的 <code>Ticker</code>。内部会启动一个 Goroutine，这个 Goroutine 会每隔 1 秒向 <code>ticker.C</code> 发送当前时间。</li>
<li><code>defer ticker.Stop()</code> 是一个良好的习惯，它确保在 <code>main</code> 函数退出时 <code>ticker.Stop()</code> 会被调用，从而释放 <code>Ticker</code> 占用的资源。</li>
<li><code>for i := 0; i &lt; 5; i++ &#123; currentTime := &lt;-ticker.C ... &#125;</code> 这个循环会执行 5 次。每次循环都会阻塞在 <code>&lt;-ticker.C</code>，直到 <code>Ticker</code> 发送一个新的时间值。接收到值后，打印当前时间。</li>
</ol>
<p><strong>总结对比：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>time.Timer</code></th>
<th><code>time.Ticker</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>触发次数</td>
<td>一次性</td>
<td>周期性 (重复)</td>
</tr>
<tr>
<td>主要用途</td>
<td>延迟执行任务</td>
<td>定期执行任务</td>
</tr>
<tr>
<td>停止</td>
<td>建议在不再需要时调用 <code>Stop()</code></td>
<td><strong>必须</strong>在不再需要时调用 <code>Stop()</code></td>
</tr>
</tbody>
</table>
<p><strong>实际应用场景举例：</strong></p>
<ul>
<li><strong><code>time.Timer</code>:</strong>
<ul>
<li>实现请求超时机制。</li>
<li>延迟重试某个操作。</li>
<li>在用户空闲一段时间后执行某些清理工作。</li>
</ul>
</li>
<li><strong><code>time.Ticker</code>:</strong>
<ul>
<li>定期上报系统状态或监控数据。</li>
<li>实现心跳机制。</li>
<li>周期性地刷新缓存。</li>
</ul>
</li>
</ul>
<h1 id="实例部分">实例部分</h1>
<p>好的，我们来针对你提到的实际场景给出 <code>time.Timer</code> 和 <code>time.Ticker</code> 的代码讲解和示例。</p>
<p><strong>1. <code>time.Timer</code>: 实现请求超时机制</strong></p>
<p><strong>场景描述:</strong> 当向外部服务发起请求时，为了避免长时间等待无响应，我们需要设置一个超时时间。如果在指定时间内没有收到响应，就认为请求失败。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchDataFromExternalService</span><span class="params">(url <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;正在请求: %s\n&quot;</span>, url)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个结果 Channel 和一个错误 Channel</span></span><br><span class="line">	result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">	errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动一个 Goroutine 来执行实际的 HTTP 请求</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		resp, err := http.Get(url)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errChan &lt;- err</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟读取响应</span></span><br><span class="line">		<span class="comment">// 这里为了简化，直接发送一个成功的消息</span></span><br><span class="line">		result &lt;- <span class="string">&quot;成功获取数据&quot;</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个超时 Timer</span></span><br><span class="line">	timeout := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> timeout.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 select 监听不同的事件</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> data := &lt;-result:</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求成功:&quot;</span>, data)</span><br><span class="line">		<span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> err := &lt;-errChan:</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求失败:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	<span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求超时！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := fetchDataFromExternalService(<span class="string">&quot;https://example.com/api/data&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;处理请求失败:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟超时的情况</span></span><br><span class="line">	_, err = fetchDataFromExternalService(<span class="string">&quot;https://slow.example.com/api/data&quot;</span>) <span class="comment">// 假设这个地址响应很慢</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;处理慢请求:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了让慢请求的 Goroutine 有机会执行（虽然会超时），我们等待一小段时间</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解:</strong></p>
<ol>
<li><code>fetchDataFromExternalService</code> 函数模拟向外部服务发起请求。</li>
<li>我们创建了两个 Channel：<code>result</code> 用于接收成功的数据，<code>errChan</code> 用于接收错误信息。</li>
<li>在一个新的 Goroutine 中执行实际的 HTTP 请求。</li>
<li><code>timeout := time.NewTimer(3 * time.Second)</code> 创建了一个 3 秒后触发的 <code>Timer</code>。</li>
<li><code>select</code> 语句用于同时监听 <code>result</code> Channel、<code>errChan</code> Channel 和 <code>timeout.C</code> Channel。
<ul>
<li>如果从 <code>result</code> 接收到数据，说明请求成功。</li>
<li>如果从 <code>errChan</code> 接收到错误，说明请求失败。</li>
<li>如果 <code>timeout.C</code> 接收到值，说明 3 秒超时时间已到，请求超时。</li>
</ul>
</li>
</ol>
<p><strong>2. <code>time.Timer</code>: 延迟重试某个操作</strong></p>
<p><strong>场景描述:</strong> 当某个操作失败时，我们不立即放弃，而是等待一段时间后进行重试。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">attemptOperation</span><span class="params">(attempt <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 模拟一个可能失败的操作</span></span><br><span class="line">	<span class="keyword">if</span> rand.Intn(<span class="number">3</span>) != <span class="number">0</span> &#123; <span class="comment">// 大约 2/3 的概率失败</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;尝试 %d 失败\n&quot;</span>, attempt)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;操作失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;尝试 %d 成功\n&quot;</span>, attempt)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retryOperationWithDelay</span><span class="params">(maxRetries <span class="type">int</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= maxRetries; i++ &#123;</span><br><span class="line">		err := attemptOperation(i)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i &lt; maxRetries &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;等待 %s 后重试...\n&quot;</span>, delay)</span><br><span class="line">			timer := time.NewTimer(delay)</span><br><span class="line">			&lt;-timer.C</span><br><span class="line">			timer.Stop() <span class="comment">// 记得停止 Timer</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;达到最大重试次数，操作失败。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	retryOperationWithDelay(<span class="number">3</span>, <span class="number">2</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解:</strong></p>
<ol>
<li><code>attemptOperation</code> 函数模拟一个可能失败的操作。</li>
<li><code>retryOperationWithDelay</code> 函数接收最大重试次数和延迟时间。</li>
<li>在一个循环中尝试执行操作。如果操作失败且未达到最大重试次数，则创建一个 <code>time.NewTimer(delay)</code>，等待 <code>delay</code> 时间后继续下一次尝试。</li>
</ol>
<p><strong>3. <code>time.Timer</code>: 在用户空闲一段时间后执行某些清理工作</strong></p>
<p><strong>场景描述:</strong> 例如，在一个交互式应用中，如果用户长时间没有操作，我们可能需要清理一些资源或执行登出操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simulateUserActivity</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;用户正在操作...&quot;</span>)</span><br><span class="line">		<span class="comment">// 模拟用户操作的间隔</span></span><br><span class="line">		sleepTime := time.Duration(rand.Intn(<span class="number">3</span>)) * time.Second</span><br><span class="line">		time.Sleep(sleepTime)</span><br><span class="line">		resetIdleTimer() <span class="comment">// 用户活动后重置空闲计时器</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;用户停止活动。&quot;</span>)</span><br><span class="line">	<span class="comment">// 即使用户停止活动，空闲清理的 Goroutine 仍然可能在运行，需要考虑如何优雅地关闭</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	stopIdleCheck()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> idleTimer *time.Timer</span><br><span class="line"><span class="keyword">var</span> idleDuration = <span class="number">5</span> * time.Second</span><br><span class="line"><span class="keyword">var</span> idleStop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">idleCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;启动空闲状态检测...&quot;</span>)</span><br><span class="line">	idleTimer = time.NewTimer(idleDuration)</span><br><span class="line">	<span class="keyword">defer</span> idleTimer.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-idleTimer.C:</span><br><span class="line">			fmt.Println(<span class="string">&quot;用户长时间未活动，执行清理操作...&quot;</span>)</span><br><span class="line">			<span class="comment">// 在这里执行清理逻辑</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-idleStop:</span><br><span class="line">			fmt.Println(<span class="string">&quot;停止空闲状态检测。&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetIdleTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !idleTimer.Stop() &amp;&amp; <span class="built_in">len</span>(idleTimer.C) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		&lt;-idleTimer.C</span><br><span class="line">	&#125;</span><br><span class="line">	idleTimer.Reset(idleDuration)</span><br><span class="line">	fmt.Println(<span class="string">&quot;空闲计时器已重置。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopIdleCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">close</span>(idleStop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">go</span> idleCleanup()</span><br><span class="line">	simulateUserActivity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解:</strong></p>
<ol>
<li><code>idleCleanup</code> 函数启动一个 Goroutine，使用 <code>time.NewTimer</code> 检测用户是否空闲超过 <code>idleDuration</code>。</li>
<li><code>resetIdleTimer</code> 函数在用户活动时被调用，它会停止之前的 Timer 并重新启动一个新的 Timer。</li>
<li><code>simulateUserActivity</code> 模拟用户的操作，并在每次操作后调用 <code>resetIdleTimer</code>。</li>
<li><code>stopIdleCheck</code> 用于停止空闲检测的 Goroutine。</li>
</ol>
<p><strong>4. <code>time.Ticker</code>: 定期上报系统状态或监控数据</strong></p>
<p><strong>场景描述:</strong> 系统需要定期向监控中心发送自身的运行状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reportSystemStats</span><span class="params">(interval time.Duration)</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(interval)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">		<span class="keyword">var</span> mem runtime.MemStats</span><br><span class="line">		runtime.ReadMemStats(&amp;mem)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;[%s] Goroutines: %d, HeapAlloc: %d bytes\n&quot;</span>,</span><br><span class="line">			time.Now().Format(time.RFC3339), runtime.NumGoroutine(), mem.HeapAlloc)</span><br><span class="line">		<span class="comment">// 在这里可以将这些数据发送到监控系统</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;开始定期上报系统状态...&quot;</span>)</span><br><span class="line">	reportSystemStats(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了让程序运行一段时间，我们 Sleep 一下</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;停止上报。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解:</strong></p>
<ol>
<li><code>reportSystemStats</code> 函数接收一个时间间隔。</li>
<li><code>ticker := time.NewTicker(interval)</code> 创建一个每隔 <code>interval</code> 时间触发一次的 <code>Ticker</code>。</li>
<li><code>for range ticker.C</code> 循环会持续从 <code>ticker.C</code> 接收时间，并在每次接收到时获取并打印当前的 Goroutine 数量和堆内存分配情况。</li>
</ol>
<p><strong>5. <code>time.Ticker</code>: 实现心跳机制</strong></p>
<p><strong>场景描述:</strong> 在分布式系统中，服务之间需要定期发送心跳包，以告知对方自己仍然存活。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendHeartbeat</span><span class="params">(serviceName <span class="type">string</span>, interval time.Duration, quit &lt;-<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(interval)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[%s] 发送心跳: %s\n&quot;</span>, time.Now().Format(time.RFC3339), serviceName)</span><br><span class="line">			<span class="comment">// 在这里可以将心跳发送给其他服务</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[%s] 停止发送心跳: %s\n&quot;</span>, time.Now().Format(time.RFC3339), serviceName)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> sendHeartbeat(<span class="string">&quot;ServiceA&quot;</span>, <span class="number">1</span>*time.Second, quit)</span><br><span class="line">	<span class="keyword">go</span> sendHeartbeat(<span class="string">&quot;ServiceB&quot;</span>, <span class="number">2</span>*time.Second, quit)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟运行一段时间</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;停止发送心跳。&quot;</span>)</span><br><span class="line">	<span class="built_in">close</span>(quit) <span class="comment">// 通知心跳 Goroutine 停止</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待心跳 Goroutine 退出</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解:</strong></p>
<ol>
<li><code>sendHeartbeat</code> 函数接收服务名称、心跳间隔和一个退出 Channel。</li>
<li><code>ticker := time.NewTicker(interval)</code> 创建一个定期触发的 <code>Ticker</code>。</li>
<li><code>select</code> 语句用于监听 <code>ticker.C</code>（发送心跳）和 <code>quit</code> Channel（停止心跳）。</li>
</ol>
<p><strong>6. <code>time.Ticker</code>: 周期性地刷新缓存</strong></p>
<p><strong>场景描述:</strong> 为了保证数据的时效性，我们需要定期地从数据源加载最新的数据到缓存中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟缓存</span></span><br><span class="line"><span class="keyword">var</span> cache <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadDataFromSource</span><span class="params">()</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;从数据源加载最新数据...&quot;</span>)</span><br><span class="line">	<span class="comment">// 实际场景中会连接数据库或 API</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;user:1&quot;</span>: fmt.Sprintf(<span class="string">&quot;User 1 - Updated at %s&quot;</span>, time.Now().Format(time.RFC3339)),</span><br><span class="line">		<span class="string">&quot;item:1&quot;</span>: fmt.Sprintf(<span class="string">&quot;Item 1 - Updated at %s&quot;</span>, time.Now().Format(time.RFC3339)),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refreshCache</span><span class="params">(interval time.Duration, quit &lt;-<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(interval)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			fmt.Println(<span class="string">&quot;开始刷新缓存...&quot;</span>)</span><br><span class="line">			cache = loadDataFromSource()</span><br><span class="line">			fmt.Println(<span class="string">&quot;缓存刷新完成:&quot;</span>, cache)</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;停止缓存刷新。&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> refreshCache(<span class="number">5</span>*time.Second, quit)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟一段时间的应用运行</span></span><br><span class="line">	time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;停止缓存刷新。&quot;</span>)</span><br><span class="line">	<span class="built_in">close</span>(quit)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码讲解:</strong></p>
<ol>
<li><code>loadDataFromSource</code> 函数模拟从数据源加载最新数据。</li>
<li><code>refreshCache</code> 函数使用 <code>time.NewTicker</code> 定期触发缓存刷新操作，调用 <code>loadDataFromSource</code> 更新全局的 <code>cache</code> 变量。</li>
</ol>
<p>在 Go 语言的 <code>time</code> 包中，<code>time.Tick()</code> 和 <code>time.NewTicker()</code> 都用于以固定的时间间隔产生事件，但它们之间存在一些关键的区别。</p>
<p><strong><code>time.Tick()</code></strong></p>
<ul>
<li><strong>功能:</strong> <code>time.Tick(d Duration)</code> 是一个<strong>便利的封装函数</strong>，它返回一个只读的 <code>&lt;-chan Time</code>。这个 channel 会以 <code>d</code> 指定的时间间隔发送当时的时间。</li>
<li><strong>用法:</strong> 它通常在 <code>for range</code> 循环中使用，以便在每个时间间隔执行某些操作。</li>
<li><strong>资源管理:</strong> <strong>在 Go 1.23 之前</strong>，由 <code>time.Tick()</code> 创建的底层的 <code>Ticker</code> 不会被垃圾回收，除非程序结束。因此，如果不再需要这个 ticker，<strong>在 Go 1.23 之前</strong>推荐使用 <code>time.NewTicker()</code> 并调用其 <code>Stop()</code> 方法来释放资源。<strong>从 Go 1.23 开始</strong>，垃圾回收器可以回收不再被引用的 tickers，即使它们没有被停止。因此，现在 <code>time.Tick()</code> 在不需要显式停止 ticker 的场景下也更方便。</li>
<li><strong>无法停止:</strong> 你无法显式地停止由 <code>time.Tick()</code> 创建的 ticker。它会一直发送 tick，直到包含它的 goroutine 结束。</li>
<li><strong>返回值:</strong> 返回一个 <code>&lt;-chan Time</code>。如果 <code>d &lt;= 0</code>，<code>time.Tick()</code> 会返回 <code>nil</code>。</li>
</ul>
<p><strong><code>time.NewTicker()</code></strong></p>
<ul>
<li><strong>功能:</strong> <code>time.NewTicker(d Duration)</code> 创建并返回一个新的 <code>*Ticker</code>。<code>Ticker</code> 类型包含一个 channel <code>C</code> (也是 <code>&lt;-chan Time</code>)，它会以 <code>d</code> 指定的时间间隔发送时间。<code>Ticker</code> 类型还包含一个 <code>Stop()</code> 方法，用于显式停止 ticker 并释放相关资源.</li>
<li><strong>用法:</strong> 你需要创建一个 <code>Ticker</code> 实例，然后通过访问其 <code>C</code> 字段来接收 tick。当不再需要时，应该调用 <code>Stop()</code> 方法。</li>
<li><strong>资源管理:</strong> 使用 <code>time.NewTicker()</code> 可以让你显式地控制 ticker 的生命周期，通过调用 <code>Stop()</code> 来释放资源，这在长时间运行的程序中很重要，<strong>尤其是在 Go 1.23 之前</strong>。</li>
<li><strong>可以停止:</strong> 你可以通过调用 <code>ticker.Stop()</code> 来停止 <code>NewTicker()</code> 创建的 ticker。</li>
<li><strong>返回值:</strong> 返回一个指向 <code>Ticker</code> 类型的指针 <code>*Ticker</code>。如果 <code>d &lt;= 0</code>，<code>time.NewTicker()</code> 会 panic。</li>
</ul>
<p><strong>总结:</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>time.Tick()</code></th>
<th><code>time.NewTicker()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值</td>
<td><code>&lt;-chan Time</code></td>
<td><code>*Ticker</code> (包含 <code>C</code> 字段和 <code>Stop()</code> 方法)</td>
</tr>
<tr>
<td>停止</td>
<td>无法显式停止</td>
<td>可以通过 <code>ticker.Stop()</code> 停止</td>
</tr>
<tr>
<td>资源管理</td>
<td><strong>Go 1.23 之前:</strong> 可能导致资源泄漏，不适合长时间运行且需要停止的场景。<strong>Go 1.23 之后:</strong> GC 可以回收。</td>
<td>需要显式调用 <code>Stop()</code> 来释放资源 (在 Go 1.23 之前更重要)</td>
</tr>
<tr>
<td>用途</td>
<td>简单的周期性任务，不需要停止 ticker 的场景</td>
<td>需要更精细控制 ticker 生命周期和资源管理的场景</td>
</tr>
<tr>
<td><code>d &lt;= 0</code></td>
<td>返回 <code>nil</code></td>
<td>panic</td>
</tr>
</tbody>
</table>
<p><strong>用法示例:</strong></p>
<p><strong><code>time.Tick()</code> 示例:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 每秒 tick 一次</span></span><br><span class="line">	ticker := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">	done := time.After(<span class="number">5</span> * time.Second) <span class="comment">// 5 秒后结束</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> t := &lt;-ticker:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Tick at&quot;</span>, t)</span><br><span class="line">		<span class="keyword">case</span> &lt;-done:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>time.NewTicker()</code> 示例:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 每 500 毫秒 tick 一次</span></span><br><span class="line">	ticker := time.NewTicker(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop() <span class="comment">// 确保在函数退出时停止 ticker</span></span><br><span class="line"></span><br><span class="line">	done := time.After(<span class="number">3</span> * time.Second) <span class="comment">// 3 秒后结束</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Ticker at&quot;</span>, t)</span><br><span class="line">		<span class="keyword">case</span> &lt;-done:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的 <code>time.NewTicker()</code> 示例中，我们使用了 <code>defer ticker.Stop()</code> 来确保在 <code>main</code> 函数结束时调用 <code>Stop()</code> 方法，释放 ticker 占用的资源。这在长时间运行的程序中是一个良好的实践。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之枚举</title>
    <url>/2025/05/13/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h1 id="📘-Go-语言中的枚举">📘 Go 语言中的枚举</h1>
<hr>
<h2 id="🔸-1-为什么-Go-没有-enum？">🔸 1. 为什么 Go 没有 enum？</h2>
<p>Go 的设计哲学之一是 <strong>“少即是多（Less is more）”</strong>。它刻意避免加入 C/C++ 或 Java 风格的 <code>enum</code> 语法，而鼓励开发者通过现有机制构建自己的“枚举”，使语言更简洁。</p>
<hr>
<h2 id="🔸-2-使用-const-iota-自定义类型模拟枚举">🔸 2. 使用 <code>const + iota</code> 自定义类型模拟枚举</h2>
<h3 id="✅-示例：订单状态（OrderStatus）">✅ 示例：订单状态（OrderStatus）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个新类型</span></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明常量并用 iota 自动编号</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Pending OrderStatus = <span class="literal">iota</span></span><br><span class="line">	Processing</span><br><span class="line">	Shipped</span><br><span class="line">	Delivered</span><br><span class="line">	Cancelled</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此时你定义了一个类型 <code>OrderStatus</code>，并赋值了几个状态枚举。使用时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s OrderStatus = Shipped</span><br><span class="line">fmt.Println(<span class="string">&quot;Order status:&quot;</span>, s) <span class="comment">// 输出：Order status: 2（不直观）</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🔸-3-让枚举可读：添加-String-方法">🔸 3. 让枚举可读：添加 <code>String()</code> 方法</h2>
<p>要让输出更清晰（而不是数字），实现 <code>fmt.Stringer</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s OrderStatus)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> s &#123;</span><br><span class="line">	<span class="keyword">case</span> Pending:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Processing:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Processing&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Shipped:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Shipped&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Delivered:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Delivered&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Cancelled:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Cancelled&quot;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在输出变成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;Order status:&quot;</span>, s) <span class="comment">// 输出：Order status: Shipped</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🔸-4-提高开发效率：使用-stringer-工具自动生成">🔸 4. 提高开发效率：使用 <code>stringer</code> 工具自动生成</h2>
<p>Go 提供了官方工具 <a href="https://pkg.go.dev/golang.org/x/tools/cmd/stringer"><code>stringer</code></a> 来自动生成 <code>String()</code> 方法。</p>
<h3 id="✅-步骤：">✅ 步骤：</h3>
<ol>
<li>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go install golang.org/x/tools/cmd/stringer@latest</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在代码顶部加注释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:generate stringer -type=OrderStatus</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go generate</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>它会生成一个 <code>orderstatus_string.go</code> 文件，自动添加 <code>String()</code> 方法！</p>
</li>
</ol>
<hr>
<h2 id="🔸-5-在实际开发中的典型应用场景">🔸 5. 在实际开发中的典型应用场景</h2>
<table>
<thead>
<tr>
<th>枚举类型</th>
<th>场景举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户角色</td>
<td>Admin, Moderator, User</td>
</tr>
<tr>
<td>支付方式</td>
<td>WeChat, Alipay, CreditCard</td>
</tr>
<tr>
<td>网络协议类型</td>
<td>HTTP, HTTPS, FTP</td>
</tr>
<tr>
<td>日志级别</td>
<td>Debug, Info, Warn, Error</td>
</tr>
<tr>
<td>服务状态</td>
<td>Starting, Running, Stopped, Failed</td>
</tr>
</tbody>
</table>
<p>示例代码（支付方式）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PaymentMethod <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Alipay PaymentMethod = <span class="literal">iota</span></span><br><span class="line">	WeChat</span><br><span class="line">	CreditCard</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PaymentMethod)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> p &#123;</span><br><span class="line">	<span class="keyword">case</span> Alipay:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Alipay&quot;</span></span><br><span class="line">	<span class="keyword">case</span> WeChat:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;WeChat&quot;</span></span><br><span class="line">	<span class="keyword">case</span> CreditCard:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;CreditCard&quot;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pay := WeChat</span><br><span class="line">fmt.Println(<span class="string">&quot;Chosen method:&quot;</span>, pay) <span class="comment">// 输出：Chosen method: WeChat</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🔸-6-枚举类型优势总结">🔸 6. 枚举类型优势总结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>使用枚举自定义类型的好处</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型安全</td>
<td>不会误传其他类型，编译时检查</td>
</tr>
<tr>
<td>可读性高</td>
<td>使用名称而非数字，便于维护和调试</td>
</tr>
<tr>
<td>易于扩展</td>
<td>可以集中管理、统一处理</td>
</tr>
<tr>
<td>支持 <code>switch</code></td>
<td>可用于 <code>switch case</code> 表达逻辑分支处理</td>
</tr>
<tr>
<td>与接口搭配灵活使用</td>
<td>可以与接口模式组合形成更复杂的业务逻辑</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🔸-7-一个完整小案例：订单状态切换器">🔸 7. 一个完整小案例：订单状态切换器</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Pending OrderStatus = <span class="literal">iota</span></span><br><span class="line">	Confirmed</span><br><span class="line">	Shipped</span><br><span class="line">	Delivered</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s OrderStatus)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> s &#123;</span><br><span class="line">	<span class="keyword">case</span> Pending:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Confirmed:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Confirmed&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Shipped:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Shipped&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Delivered:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Delivered&quot;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextStatus</span><span class="params">(s OrderStatus)</span></span> OrderStatus &#123;</span><br><span class="line">	<span class="keyword">switch</span> s &#123;</span><br><span class="line">	<span class="keyword">case</span> Pending:</span><br><span class="line">		<span class="keyword">return</span> Confirmed</span><br><span class="line">	<span class="keyword">case</span> Confirmed:</span><br><span class="line">		<span class="keyword">return</span> Shipped</span><br><span class="line">	<span class="keyword">case</span> Shipped:</span><br><span class="line">		<span class="keyword">return</span> Delivered</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	status := Pending</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Current status:&quot;</span>, status)</span><br><span class="line">		status = nextStatus(status)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Current status: Pending</span><br><span class="line">Current status: Confirmed</span><br><span class="line">Current status: Shipped</span><br><span class="line">Current status: Delivered</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="✅-总结">✅ 总结</h2>
<ul>
<li>
<p>Go 没有内置枚举语法，但我们可以用 <code>const + type + iota</code> 灵活模拟。</p>
</li>
<li>
<p>枚举用得非常广泛，尤其是在：</p>
<ul>
<li>状态管理</li>
<li>类型控制</li>
<li>协议识别</li>
<li>日志处理 等场景</li>
</ul>
</li>
<li>
<p>可以手写 <code>String()</code> 方法提高可读性，或用 <code>stringer</code> 工具自动生成。</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之未知结构体反序列化</title>
    <url>/2025/05/24/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%9C%AA%E7%9F%A5%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="📝-技巧：解码-JSON-到-map-string-interface">📝 技巧：解码 JSON 到 <code>map[string]interface&#123;&#125;</code></h3>
<p><strong>讲解：</strong></p>
<p>当处理来自外部 API 或其他来源的 JSON 数据时，你可能并不总是事先知道其确切的结构。或者，你可能只对 JSON 数据中的一部分字段感兴趣，而不想为了完整地映射整个 JSON 结构而定义复杂的 Go 结构体。</p>
<p>在这种情况下，你可以将 JSON 数据解码到一个通用的 Go 类型：<code>map[string]interface&#123;&#125;</code>。</p>
<ul>
<li><code>map[string]interface&#123;&#125;</code> 是一个键值对的集合，其中键是字符串（对应 JSON 对象的键），值可以是任何类型 (<code>interface&#123;&#125;</code>)。这使得你可以灵活地访问 JSON 数据中的各种类型的值（字符串、数字、布尔值、嵌套的对象或数组）。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>处理结构不固定的 JSON 响应。</li>
<li>只需要访问 JSON 数据中的特定字段。</li>
<li>在完全了解 JSON 结构之前探索数据。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 假设我们收到了以下 JSON 数据，但我们不确定其完整结构</span></span><br><span class="line">	jsonData := []<span class="type">byte</span>(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">		&quot;name&quot;: &quot;Dynamic Object&quot;,</span></span><br><span class="line"><span class="string">		&quot;version&quot;: 1.0,</span></span><br><span class="line"><span class="string">		&quot;details&quot;: &#123;</span></span><br><span class="line"><span class="string">			&quot;author&quot;: &quot;AI Assistant&quot;,</span></span><br><span class="line"><span class="string">			&quot;created_at&quot;: &quot;2025-05-24T10:00:00Z&quot;</span></span><br><span class="line"><span class="string">		&#125;,</span></span><br><span class="line"><span class="string">		&quot;tags&quot;: [&quot;dynamic&quot;, &quot;json&quot;, &quot;go&quot;]</span></span><br><span class="line"><span class="string">	&#125;`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 JSON 解码到 map[string]interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> genericData <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal(jsonData, &amp;genericData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;JSON decoding error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Decoded generic data:&quot;</span>, genericData)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在我们可以通过键来访问数据，并进行类型断言</span></span><br><span class="line">	<span class="keyword">if</span> name, ok := genericData[<span class="string">&quot;name&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Name:&quot;</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> version, ok := genericData[<span class="string">&quot;version&quot;</span>].(<span class="type">float64</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Version:&quot;</span>, version)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> details, ok := genericData[<span class="string">&quot;details&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> author, ok := details[<span class="string">&quot;author&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Author:&quot;</span>, author)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> createdAt, ok := details[<span class="string">&quot;created_at&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Created At:&quot;</span>, createdAt)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tags, ok := genericData[<span class="string">&quot;tags&quot;</span>].([]<span class="keyword">interface</span>&#123;&#125;); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Tags:&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, tag := <span class="keyword">range</span> tags &#123;</span><br><span class="line">			<span class="keyword">if</span> t, ok := tag.(<span class="type">string</span>); ok &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;- %s\n&quot;</span>, t)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Decoded generic data: map[details:map[author:AI Assistant created_at:2025-05-24T10:00:00Z] name:Dynamic Object tags:[dynamic json go] version:1]</span><br><span class="line">Name: Dynamic Object</span><br><span class="line">Version: 1</span><br><span class="line">Author: AI Assistant</span><br><span class="line">Created At: 2025-05-24T10:00:00Z</span><br><span class="line">Tags:</span><br><span class="line">- dynamic</span><br><span class="line">- json</span><br><span class="line">- go</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>使用 <code>json.Unmarshal</code> 将 JSON 数据解码到 <code>map[string]interface&#123;&#125;</code> 提供了一种灵活的方式来处理结构未知的 JSON 数据。你需要通过类型断言来使用 map 中的值。</p>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之测试与基准测试入门</title>
    <url>/2025/05/30/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="📌-一、Go-的测试框架介绍">📌 一、Go 的测试框架介绍</h2>
<p>Go 内置了强大的测试框架，不需要第三方库，只需引入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br></pre></td></tr></table></figure>
<p>所有测试文件必须以 <code>_test.go</code> 结尾，所有测试函数以 <code>Test</code> 开头，并接受 <code>*testing.T</code> 参数。</p>
<hr>
<h2 id="📘-二、单元测试（Unit-Test）">📘 二、单元测试（Unit Test）</h2>
<h3 id="✅-基本格式">✅ 基本格式</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    result := Add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> result != <span class="number">5</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Expected 5, got %d&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="📁-文件结构示例">📁 文件结构示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calc/</span><br><span class="line"> ├── calc.go</span><br><span class="line"> └── calc_test.go</span><br></pre></td></tr></table></figure>
<h3 id="📌-示例代码">📌 示例代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calc.go</span></span><br><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calc_test.go</span></span><br><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    want := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Add(1, 2) = %d; want %d&quot;</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🚀-运行测试">🚀 运行测试</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧪-三、表驱动测试（推荐）">🧪 三、表驱动测试（推荐）</h2>
<p>适合多个输入输出的函数测试，易扩展、代码更清晰。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddTableDriven</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    cases := []<span class="keyword">struct</span>&#123;</span><br><span class="line">        a, b, expected <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">5</span>, <span class="number">15</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        got := Add(c.a, c.b)</span><br><span class="line">        <span class="keyword">if</span> got != c.expected &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Add(%d, %d) = %d; want %d&quot;</span>, c.a, c.b, got, c.expected)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🕓-四、基准测试（Benchmark）">🕓 四、基准测试（Benchmark）</h2>
<p>用于性能评估。函数名以 <code>Benchmark</code> 开头，接收 <code>*testing.B</code> 参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench=.</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧪-五、测试覆盖率">🧪 五、测试覆盖率</h2>
<p>查看测试覆盖率：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -cover</span><br></pre></td></tr></table></figure>
<p>生成详细报告：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -coverprofile=cover.out</span><br><span class="line">go tool cover -html=cover.out</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧰-六、实际开发中的测试最佳实践">🧰 六、实际开发中的测试最佳实践</h2>
<table>
<thead>
<tr>
<th>做法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 使用表驱动测试</td>
<td>可读性强、维护方便</td>
</tr>
<tr>
<td>✅ 测试覆盖边界条件</td>
<td>不仅测常规输入，还要测试错误输入、零值等</td>
</tr>
<tr>
<td>✅ 使用子测试</td>
<td><code>t.Run(&quot;case name&quot;, func(t *testing.T) &#123;...&#125;)</code> 有助于分组管理测试</td>
</tr>
<tr>
<td>✅ 保持测试快速</td>
<td>测试应能快速运行，不阻塞开发</td>
</tr>
<tr>
<td>✅ 对接口进行测试</td>
<td>方便 mock 和替换</td>
</tr>
<tr>
<td>✅ 使用 <code>go test -race</code></td>
<td>检查并发代码中的数据竞争问题</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🧪-七、测试中的-Mock-与-Stub（进阶）">🧪 七、测试中的 Mock 与 Stub（进阶）</h2>
<p>Go 没有内置 mock 框架，但可以手动定义接口并注入假实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetUser(id <span class="type">int</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MockDB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockDB)</span></span> GetUser(id <span class="type">int</span>) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;mock-user&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试中使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestService</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    service := NewService(&amp;MockDB&#123;&#125;)</span><br><span class="line">    user := service.GetUserName(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> user != <span class="string">&quot;mock-user&quot;</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="✅-总结">✅ 总结</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>单元测试</td>
<td>测试函数是否输出正确结果</td>
</tr>
<tr>
<td>表驱动测试</td>
<td>测试多个输入组合</td>
</tr>
<tr>
<td>基准测试</td>
<td>测试性能</td>
</tr>
<tr>
<td>子测试</td>
<td>多维度组织测试</td>
</tr>
<tr>
<td>覆盖率</td>
<td>检查测试是否全面</td>
</tr>
<tr>
<td>Mock 接口</td>
<td>模拟依赖</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之Embedding vs. OOP subclassing</title>
    <url>/2025/06/03/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%B5%8C%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言中的 <strong>Embedding（嵌入）</strong> 和传统面向对象编程（OOP）中的 <strong>Subclassing（子类继承）</strong> 是两种不同的代码复用与扩展机制。虽然它们在语法或语义上有相似之处，但设计哲学完全不同。</p>
<hr>
<h2 id="一、核心理念对比">一、核心理念对比</h2>
<table>
<thead>
<tr>
<th>特性/维度</th>
<th>Go Embedding</th>
<th>OOP Subclassing</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计理念</td>
<td>组合优于继承（Composition over Inheritance）</td>
<td>继承层次结构（Inheritance Hierarchy）</td>
</tr>
<tr>
<td>关系含义</td>
<td>“has-a” 或 “can-do”</td>
<td>“is-a”</td>
</tr>
<tr>
<td>方法提升</td>
<td>被嵌入类型的方法自动提升到外层</td>
<td>子类重用并可重写父类方法</td>
</tr>
<tr>
<td>多重复用</td>
<td>支持多类型嵌入</td>
<td>单继承（如 Java），多继承有钻石问题（如 C++）</td>
</tr>
<tr>
<td>动态绑定</td>
<td>通过接口实现多态</td>
<td>支持运行时多态</td>
</tr>
<tr>
<td>可替换性（LSP）</td>
<td>倾向于接口的鸭子类型</td>
<td>子类应能替换父类对象</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="二、Go-的-Embedding-示例与分析">二、Go 的 Embedding 示例与分析</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Logger)</span></span> Log(msg <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Log:&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Logger <span class="comment">// 嵌入 Logger</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;Name: <span class="string">&quot;Alice&quot;</span>&#125;</span><br><span class="line">    u.Log(<span class="string">&quot;created user&quot;</span>) <span class="comment">// 自动提升，像是继承来的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-特点分析：">✅ 特点分析：</h3>
<ul>
<li><code>Logger</code> 是被嵌入的类型，<code>User</code> 拥有其方法。</li>
<li>编译器将 <code>u.Log(...)</code> 转化为 <code>u.Logger.Log(...)</code>。</li>
<li>没有继承树，但实现了“方法复用”。</li>
<li><code>User</code> 可以嵌入多个类型，没有冲突时全部方法都可以用。</li>
</ul>
<hr>
<h2 id="三、OOP-中的-Subclassing-示例（Java）">三、OOP 中的 Subclassing 示例（Java）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Log: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        u.log(<span class="string">&quot;created user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-特点分析：-2">✅ 特点分析：</h3>
<ul>
<li><code>User</code> 是 <code>Logger</code> 的子类。</li>
<li>强烈的 is-a 关系：<code>User</code> is-a <code>Logger</code>。</li>
<li>支持方法重写（override），支持多态。</li>
</ul>
<hr>
<h2 id="四、设计哲学对比：组合-vs-继承">四、设计哲学对比：组合 vs 继承</h2>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Go Embedding（组合）</th>
<th>OOP Subclassing（继承）</th>
</tr>
</thead>
<tbody>
<tr>
<td>解耦性</td>
<td>强：改动嵌入类型不影响宿主</td>
<td>弱：父类改动可能破坏子类行为</td>
</tr>
<tr>
<td>灵活性</td>
<td>高：可随意组合多个类型</td>
<td>低：被绑定在继承结构中</td>
</tr>
<tr>
<td>多态实现方式</td>
<td>倾向接口实现鸭子类型</td>
<td>通过继承和虚函数表</td>
</tr>
<tr>
<td>方法冲突处理</td>
<td>手动指定调用哪个嵌入字段的方法</td>
<td>支持方法重写，父类方法被屏蔽</td>
</tr>
<tr>
<td>复用机制</td>
<td>显式组合，支持多个被嵌入类型</td>
<td>只能继承一个父类（多数语言）</td>
</tr>
<tr>
<td>易读性/层级复杂度</td>
<td>简洁，结构扁平</td>
<td>继承链长可能难以追踪行为</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五、接口-Embedding-实现多态">五、接口 + Embedding 实现多态</h2>
<p>Go 中不鼓励“继承树”，但你可以结合接口与嵌入模拟多态行为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmailNotifier <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(EmailNotifier)</span></span> Notify() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sending email...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Notifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;Notifier: EmailNotifier&#123;&#125;&#125;</span><br><span class="line">    u.Notify() <span class="comment">// 调用嵌入的接口实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、总结对比">六、总结对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Go Embedding</th>
<th>OOP Subclassing</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否是继承机制</td>
<td>❌ 否</td>
<td>✅ 是</td>
</tr>
<tr>
<td>是否支持方法复用</td>
<td>✅ 是</td>
<td>✅ 是</td>
</tr>
<tr>
<td>是否强调接口</td>
<td>✅ 是（鸭子类型）</td>
<td>❶ 接口可选（如 Java 中）</td>
</tr>
<tr>
<td>是否支持重写</td>
<td>❌ 否，除非手动遮蔽方法</td>
<td>✅ 是</td>
</tr>
<tr>
<td>是否有继承树</td>
<td>❌ 无</td>
<td>✅ 有</td>
</tr>
<tr>
<td>多继承支持</td>
<td>✅ 支持多个嵌入</td>
<td>❌ 一般不支持或有复杂性（如 C++）</td>
</tr>
<tr>
<td>推荐使用场景</td>
<td>简洁、组合、依赖注入、组件化</td>
<td>行为扩展、框架设计、多态重写</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="七、使用建议">七、使用建议</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐机制</th>
<th>原因说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码复用、减少重复逻辑</td>
<td>Go Embedding</td>
<td>组合简单明了，逻辑分离好</td>
</tr>
<tr>
<td>表达 is-a 关系</td>
<td>Subclassing</td>
<td>自然符合类的语义</td>
</tr>
<tr>
<td>需要运行时多态</td>
<td>接口 + 组合</td>
<td>更灵活、适应性强</td>
</tr>
<tr>
<td>多种行为组合（Mixin）</td>
<td>Go Embedding</td>
<td>多嵌入类型即实现 Mixin 效果</td>
</tr>
<tr>
<td>构建基础框架/库</td>
<td>OOP 继承</td>
<td>适合设计层级分明的抽象层</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之空返回值的选择</title>
    <url>/2025/06/09/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%A9%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>紧接着上一篇文章关于“空”的问题，在 Go 开发中经常碰到：<strong>函数/方法返回结构体、切片、map、指针等时，应该返回 <code>nil</code>，还是返回空值（如 <code>T&#123;&#125;</code>、<code>[]T&#123;&#125;</code>、<code>map[T]U&#123;&#125;</code>）？</strong></p>
<span id="more"></span>
<h1 id="Go-开发中函数返回-nil-vs-空值的选择与实践">Go 开发中函数返回 nil vs 空值的选择与实践</h1>
<p>这个选择看似简单，实际上对代码的 <strong>健壮性、易读性、兼容性（如 JSON 序列化</strong> 影响非常大。</p>
<hr>
<h2 id="一、返回空值-vs-nil：含义对比">一、返回空值 vs nil：含义对比</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>nil 的语义</th>
<th>空值的语义</th>
</tr>
</thead>
<tbody>
<tr>
<td>指针 <code>*T</code></td>
<td>表示“无对象”或“不存在”</td>
<td>无意义（结构体指针不能用 <code>T&#123;&#125;</code> 表示）</td>
</tr>
<tr>
<td>值类型 <code>T</code>（结构体）</td>
<td>不可为 nil，除非用指针</td>
<td>有效的零值（字段默认）</td>
</tr>
<tr>
<td>切片 <code>[]T</code></td>
<td>通常表示“无结果”或“无数据”</td>
<td>表示“结果为空”</td>
</tr>
<tr>
<td>映射 <code>map[K]V</code></td>
<td>表示“未初始化”</td>
<td>初始化但为空</td>
</tr>
</tbody>
</table>
<blockquote>
<p>✅ 建议：在大多数场景下，<strong>返回空值而非 nil</strong> 更稳健安全，尤其是集合类型。</p>
</blockquote>
<hr>
<h2 id="二、不同类型的返回设计建议及调用示例">二、不同类型的返回设计建议及调用示例</h2>
<h3 id="✅-1-结构体（值类型）返回-T">✅ 1. 结构体（值类型）返回 <code>T&#123;&#125;</code></h3>
<p><strong>推荐使用空结构体而非指针或 nil</strong></p>
<h4 id="函数设计：">函数设计：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Port  <span class="type">int</span></span><br><span class="line">	Debug <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadDefaultConfig</span><span class="params">()</span></span> Config &#123;</span><br><span class="line">	<span class="keyword">return</span> Config&#123;Port: <span class="number">8080</span>, Debug: <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用判断：">调用判断：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg := LoadDefaultConfig()</span><br><span class="line"><span class="keyword">if</span> cfg.Port == <span class="number">0</span> &amp;&amp; !cfg.Debug &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;使用默认配置&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>空结构体返回可避免 nil 指针错误，并保持良好封装。</p>
</blockquote>
<hr>
<h3 id="✅-2-指针类型返回-nil-表示“无结果”">✅ 2. 指针类型返回 nil 表示“无结果”</h3>
<h4 id="函数设计：-2">函数设计：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindUserByName</span><span class="params">(name <span class="type">string</span>)</span></span> *User &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 明确表示“无用户”</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;User&#123;Name: name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用判断：-2">调用判断：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">u := FindUserByName(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;用户不存在&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;找到用户:&quot;</span>, u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="✅-3-切片：返回-T-更安全，避免-JSON-中变成-null">✅ 3. 切片：返回 <code>[]T&#123;&#125;</code> 更安全，避免 JSON 中变成 <code>null</code></h3>
<h4 id="函数设计：-3">函数设计：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserTasks</span><span class="params">(uid <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 查询数据库...未找到任何任务</span></span><br><span class="line">	<span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用判断：-3">调用判断：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tasks := GetUserTasks(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tasks) == <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;当前没有任何任务&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;任务列表：&quot;</span>, tasks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JSON-序列化对比：">JSON 序列化对比：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 nil： &quot;tasks&quot;: null</span></span><br><span class="line"><span class="comment">// 返回 []：  &quot;tasks&quot;: []</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>🚫 如果返回 <code>nil</code>，前端或调用方可能误解为“值未初始化”。</p>
</blockquote>
<hr>
<h3 id="✅-4-map：返回空-map-比-nil-更安全">✅ 4. map：返回空 map 比 nil 更安全</h3>
<h4 id="函数设计：-4">函数设计：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserSettings</span><span class="params">(uid <span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125; <span class="comment">// 安全返回空 map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用判断：-4">调用判断：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">settings := GetUserSettings(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(settings) == <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;使用系统默认设置&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;用户设置:&quot;</span>, settings)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-小心：nil-map-写入会-panic">⚠️ 小心：nil map 写入会 panic</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">// nil</span></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span> <span class="comment">// ❌ panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、完整对比总结表">三、完整对比总结表</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>返回 nil 表示</th>
<th>返回空值含义</th>
<th>推荐返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*T</code>（指针）</td>
<td>“无对象”</td>
<td>不适用</td>
<td><code>nil</code> ✅</td>
</tr>
<tr>
<td><code>T</code>（结构体）</td>
<td>不可为 nil</td>
<td>有效默认值</td>
<td><code>T&#123;&#125;</code> ✅</td>
</tr>
<tr>
<td><code>[]T</code>（切片）</td>
<td>“无数据”或“查询失败”</td>
<td>查询成功但为空结果</td>
<td><code>[]T&#123;&#125;</code> ✅</td>
</tr>
<tr>
<td><code>map[K]V</code>（映射）</td>
<td>“未初始化”</td>
<td>初始化但为空</td>
<td><code>map[K]V&#123;&#125;</code> ✅</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四、补充：判断是否为-“空值”-的最佳写法">四、补充：判断是否为 “空值” 的最佳写法</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>判断方式</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]T</code></td>
<td><code>len(slice) == 0</code></td>
<td><code>if len(s) == 0 &#123;&#125;</code></td>
</tr>
<tr>
<td><code>map</code></td>
<td><code>len(map) == 0</code></td>
<td><code>if len(m) == 0 &#123;&#125;</code></td>
</tr>
<tr>
<td><code>*T</code></td>
<td><code>pointer == nil</code></td>
<td><code>if u == nil &#123;&#125;</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td>判断字段是否为默认值</td>
<td><code>if cfg.Port == 0 &#123;&#125;</code></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五、实际开发中案例选型参考">五、实际开发中案例选型参考</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>建议返回</th>
<th>原因说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询单个用户</td>
<td><code>*User</code> 或 <code>nil</code></td>
<td>可表示“用户不存在”</td>
</tr>
<tr>
<td>查询订单列表</td>
<td><code>[]Order&#123;&#125;</code></td>
<td>空切片清晰表达“查询成功但无结果”</td>
</tr>
<tr>
<td>返回配置项</td>
<td><code>Config&#123;&#125;</code></td>
<td>结构体零值可使用默认设置</td>
</tr>
<tr>
<td>获取用户自定义设置</td>
<td><code>map[string]string&#123;&#125;</code></td>
<td>空 map 表示“无设置项”，避免写入 panic</td>
</tr>
<tr>
<td>API JSON 返回结果字段</td>
<td><code>[]T&#123;&#125;</code>、<code>map&#123;&#125;</code></td>
<td>避免前端出现 <code>null</code></td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之结构体哈希方法</title>
    <url>/2025/06/08/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%93%88%E5%B8%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🌐-Go语言结构体哈希策略实战：手动拼接-vs-自动序列化">🌐 Go语言结构体哈希策略实战：手动拼接 vs. 自动序列化</h1>
<p>在区块链或其他依赖数据不可篡改性的系统中，常常需要将某个结构体（如交易、区块、事件等）转换成唯一的哈希值。这个哈希不仅是系统唯一标识的关键，还用于验证数据完整性。</p>
<p>那么问题来了：</p>
<blockquote>
<p><strong>你会选择手动拼接所有字段后哈希，还是直接用 <code>gob</code> 或 <code>json</code> 自动序列化后哈希？</strong></p>
</blockquote>
<p>本文将深入比较两种方式，并结合区块链实际开发中的案例，帮助你选择最适合你场景的策略。</p>
<hr>
<h2 id="🧪-背景：以交易结构体为例">🧪 背景：以交易结构体为例</h2>
<p>我们以一个 <code>Transaction</code> 为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID      []<span class="type">byte</span></span><br><span class="line">	Inputs  []TxInput</span><br><span class="line">	Outputs []TxOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要为 <code>Transaction</code> 计算一个唯一哈希，作为它的 ID。</p>
<hr>
<h2 id="📌-方法一：结构体序列化-哈希（推荐）">📌 方法一：结构体序列化 + 哈希（推荐）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> TxHash() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line">	err := encoder.Encode(tx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	hash := sha256.Sum256(buffer.Bytes())</span><br><span class="line">	<span class="keyword">return</span> hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-优点">✅ 优点</h3>
<ul>
<li>✅ <strong>快速开发</strong>：不用手动处理每个字段。</li>
<li>✅ <strong>字段一致性</strong>：自动序列化结构体所有内容。</li>
<li>✅ <strong>适配变化</strong>：结构体字段变化不会破坏哈希逻辑。</li>
<li>✅ <strong>通用工具</strong>：<code>gob</code>/<code>json</code> 可以同时用于网络传输、磁盘存储。</li>
</ul>
<h3 id="⚠️-注意">⚠️ 注意</h3>
<ul>
<li>性能略逊于手动拼接。</li>
<li><code>gob</code> 不能跨语言，若考虑多语言兼容需使用 JSON 或 protobuf。</li>
</ul>
<hr>
<h2 id="📌-方法二：手动拼接字段-哈希（更底层）">📌 方法二：手动拼接字段 + 哈希（更底层）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> ManualHash() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.Inputs &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, input.ID...)</span><br><span class="line">		result = <span class="built_in">append</span>(result, input.Signature...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, output := <span class="keyword">range</span> tx.Outputs &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, output.PubKeyHash...)</span><br><span class="line">	&#125;</span><br><span class="line">	hash := sha256.Sum256(result)</span><br><span class="line">	<span class="keyword">return</span> hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-优点-2">✅ 优点</h3>
<ul>
<li>✅ <strong>性能最佳</strong>：没有中间结构序列化，极致控制。</li>
<li>✅ <strong>跨平台无差异</strong>：不依赖任何特定编码格式。</li>
<li>✅ <strong>更可控</strong>：你可以精细定义哪些字段参与哈希，如何拼接。</li>
</ul>
<h3 id="⚠️-缺点">⚠️ 缺点</h3>
<ul>
<li>❌ <strong>开发麻烦</strong>：字段多时极易出错。</li>
<li>❌ <strong>字段顺序敏感</strong>：稍有更改可能就导致哈希值改变。</li>
<li>❌ <strong>结构不可扩展</strong>：字段变动后必须改代码。</li>
</ul>
<hr>
<h2 id="📘-案例：区块链系统中的哈希策略">📘 案例：区块链系统中的哈希策略</h2>
<h3 id="✅-区块结构体">✅ 区块结构体</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Timestamp     <span class="type">int64</span></span><br><span class="line">	Data          []<span class="type">byte</span></span><br><span class="line">	PrevBlockHash []<span class="type">byte</span></span><br><span class="line">	Hash          []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-常见写法（结构拼接）">✅ 常见写法（结构拼接）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> SetHash() &#123;</span><br><span class="line">	headers := bytes.Join([][]<span class="type">byte</span>&#123;</span><br><span class="line">		IntToHex(b.Timestamp),</span><br><span class="line">		b.PrevBlockHash,</span><br><span class="line">		b.Data,</span><br><span class="line">	&#125;, []<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">	hash := sha256.Sum256(headers)</span><br><span class="line">	b.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于区块结构较简单，<strong>直接拼接字段更直接、更高效</strong>。</p>
</blockquote>
<h3 id="✅-对比：交易结构体更复杂，建议序列化">✅ 对比：交易结构体更复杂，建议序列化</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID      []<span class="type">byte</span></span><br><span class="line">	Inputs  []TxInput</span><br><span class="line">	Outputs []TxOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 <code>Inputs</code> 和 <code>Outputs</code> 是结构体数组，用 <code>gob</code>/<code>json</code> 处理起来更稳定、更自动。</p>
</blockquote>
<hr>
<h2 id="💡-如何选择？">💡 如何选择？</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构体字段较多/嵌套复杂</td>
<td>自动序列化（gob/json）</td>
</tr>
<tr>
<td>性能要求极高</td>
<td>手动拼接</td>
</tr>
<tr>
<td>跨语言交互</td>
<td>使用 <code>json</code> 或 <code>protobuf</code></td>
</tr>
<tr>
<td>结构不常变化</td>
<td>手动拼接可接受</td>
</tr>
<tr>
<td>想省心省力</td>
<td>自动序列化</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🚀-高级建议：结合使用">🚀 高级建议：结合使用</h2>
<p>你也可以结合两种方法：重要字段手动拼接，不重要字段使用序列化。甚至可以将手动拼接逻辑封装成工具函数，供不同结构体调用。</p>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之错误处理</title>
    <url>/2025/05/15/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go语言中的错误处理详解">Go语言中的错误处理详解</h1>
<p>Go 语言的错误处理机制与许多其他语言有所不同。Go 不使用异常机制（<code>try-catch</code>），而是通过返回错误值来显式地处理错误。虽然这种方式比异常机制更加简洁和明确，但它也带来了更多的冗长和细节。</p>
<h2 id="📌-一、Go-错误处理的基本方式">📌 一、Go 错误处理的基本方式</h2>
<p>Go 语言的错误通常是通过 <code>error</code> 接口来表示的。<code>error</code> 接口本身非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现了 <code>Error()</code> 方法的类型，都可以作为 <code>error</code> 类型使用。</p>
<h3 id="返回错误">返回错误</h3>
<p>Go 中大多数函数会返回一个 <code>error</code> 类型的值来表示执行过程中可能出现的错误。典型的错误处理模式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回数据和错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时，可以通过检查返回的 <code>error</code> 值来判断是否发生错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err := someFunction()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Success:&quot;</span>, result)</span><br></pre></td></tr></table></figure>
<h2 id="📌-二、创建和包装错误">📌 二、创建和包装错误</h2>
<p>Go 提供了标准库中的 <code>errors</code> 包来创建简单的错误，也提供了 <code>fmt.Errorf</code> 来包装错误并增加上下文信息。</p>
<h3 id="1-使用-errors-New-创建简单错误">1. 使用 <code>errors.New</code> 创建简单错误</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;resource not found&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-fmt-Errorf-包装错误">2. 使用 <code>fmt.Errorf</code> 包装错误</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to load config file: %w&quot;</span>, err)</span><br></pre></td></tr></table></figure>
<h3 id="3-错误包装与错误链">3. 错误包装与错误链</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Resource not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="📌-三、自定义错误类型">📌 三、自定义错误类型</h2>
<h3 id="定义自定义错误类型">定义自定义错误类型</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AppError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Err     <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *AppError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[code %d] %s: %v&quot;</span>, e.Code, e.Message, e.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *AppError)</span></span> Unwrap() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAppError</span><span class="params">(code <span class="type">int</span>, msg <span class="type">string</span>, err <span class="type">error</span>)</span></span> *AppError &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;AppError&#123;</span><br><span class="line">        Code:    code,</span><br><span class="line">        Message: msg,</span><br><span class="line">        Err:     err,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用自定义错误类型">使用自定义错误类型</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    data, err := os.ReadFile(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NewAppError(<span class="number">1001</span>, <span class="string">&quot;failed to load config&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Config data:&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := loadConfig(<span class="string">&quot;config.json&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> appErr *AppError</span><br><span class="line">        <span class="keyword">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Custom error caught: %s\n&quot;</span>, appErr.Error())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Unknown error:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="📌-四、错误判断与处理">📌 四、错误判断与处理</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Resource not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appErr *AppError</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;AppError with code: %d\n&quot;</span>, appErr.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="📌-五、最佳实践">📌 五、最佳实践</h2>
<ol>
<li>错误返回而非 panic。</li>
<li>错误信息应简洁并富有上下文。</li>
<li>使用自定义错误类型增强错误可处理性。</li>
<li>使用统一的错误处理策略与工具函数。</li>
</ol>
<h2 id="📌-六、使用-panic-和-recover（仅限不可恢复场景）">📌 六、使用 panic 和 recover（仅限不可恢复场景）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeRun</span><span class="params">(fn <span class="keyword">func</span>()</span></span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;panic recovered: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fn()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="📌-七、Starter-封装实战：构建统一错误处理框架">📌 七、Starter 封装实战：构建统一错误处理框架</h2>
<p>在项目中，可以封装一个 starter 模板，集中管理错误定义与处理。以下是一个 starter 错误模块的例子：</p>
<h3 id="定义错误类型">定义错误类型</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> errs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrorCode <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ErrInternal ErrorCode = <span class="number">1000</span></span><br><span class="line">    ErrDatabase ErrorCode = <span class="number">1001</span></span><br><span class="line">    ErrValidation ErrorCode = <span class="number">1002</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code ErrorCode</span><br><span class="line">    Msg  <span class="type">string</span></span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *AppError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[%d] %s: %v&quot;</span>, e.Code, e.Msg, e.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *AppError)</span></span> Unwrap() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(code ErrorCode, msg <span class="type">string</span>, err <span class="type">error</span>)</span></span> *AppError &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;AppError&#123;Code: code, Msg: msg, Err: err&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用封装的错误模块">使用封装的错误模块</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;project/errs&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUser</span><span class="params">(id <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> id == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errs.New(errs.ErrValidation, <span class="string">&quot;user id is invalid&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟数据库错误</span></span><br><span class="line">    dbErr := errors.New(<span class="string">&quot;db connection failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errs.New(errs.ErrDatabase, <span class="string">&quot;failed to load user&quot;</span>, dbErr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name, err := LoadUser(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> appErr *errs.AppError</span><br><span class="line">        <span class="keyword">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Handled error:&quot;</span>, appErr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Loaded user:&quot;</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过构建统一错误处理模块，我们可以提升项目结构清晰度，使错误处理更加系统化和可维护。</p>
<hr>
<h2 id="📌-八、总结">📌 八、总结</h2>
<p>Go 的错误处理机制强调<strong>显式、清晰和简单</strong>。通过定义错误类型、错误链和自定义错误，我们能够创建更加清晰和易于管理的错误处理流程。</p>
<p>✅ 错误应返回而不是 panic。</p>
<p>✅ 通过 <code>fmt.Errorf</code> 增加上下文信息。</p>
<p>✅ 自定义错误类型 + 错误链判断提升可读性与可维护性。</p>
<p>✅ 封装 starter 错误模块，提高开发效率。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之跨平台</title>
    <url>/2025/06/04/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%B7%A8%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么-Go-可以跨平台？一文讲透底层原理">为什么 Go 可以跨平台？一文讲透底层原理</h1>
<blockquote>
<p>Go（Golang）是一门被称为“现代 C 语言”的编程语言，不仅语法简洁，还具备强大的跨平台能力。那么，Go 是如何实现跨平台的？本文将从实用层到底层机制，一步步为你揭开答案。</p>
</blockquote>
<hr>
<h2 id="一、什么是跨平台？">一、什么是跨平台？</h2>
<p>跨平台的意思是：<strong>同一套代码可以在多个操作系统上运行</strong>，比如 Linux、Windows、macOS，甚至是 Android 和 iOS。</p>
<p>Go 的跨平台支持非常优秀：</p>
<ul>
<li>你可以在 mac 上开发，打包一个 Linux 可执行文件；</li>
<li>也可以编译出适用于 Windows 的 <code>.exe</code> 文件；</li>
<li>甚至可以为嵌入式系统或 WebAssembly 生成程序。</li>
</ul>
<p>这到底是怎么做到的呢？</p>
<hr>
<h2 id="二、Go-是编译型语言，生成原生程序">二、Go 是编译型语言，生成原生程序</h2>
<p>首先要明确一点：<strong>Go 是编译型语言，不依赖虚拟机</strong>。</p>
<p>不像 Java 或 Python 那样运行在 JVM 或解释器中，Go 的程序在编译后就是一个操作系统可以直接运行的“原生二进制文件”。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -o app main.go</span><br></pre></td></tr></table></figure>
<p>上面这条命令会生成一个 <code>app</code> 可执行文件，直接运行即可。</p>
<blockquote>
<p>✅ 不需要额外环境、不依赖虚拟机 —— 这是 Go 能高效跨平台的第一步。</p>
</blockquote>
<hr>
<h2 id="三、Go-的跨平台神器：GOOS-和-GOARCH">三、Go 的跨平台神器：<code>GOOS</code> 和 <code>GOARCH</code></h2>
<p>Go 提供了两个非常重要的环境变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GOOS</code></td>
<td>目标操作系统</td>
<td>linux、windows</td>
</tr>
<tr>
<td><code>GOARCH</code></td>
<td>目标系统架构</td>
<td>amd64、arm64 等</td>
</tr>
</tbody>
</table>
<p>只需设置这两个变量，Go 就可以为对应平台交叉编译程序！</p>
<h3 id="举个例子：">举个例子：</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOOS=windows GOARCH=amd64 go build -o hello.exe main.go</span><br></pre></td></tr></table></figure>
<p>这条命令在 macOS 或 Linux 上执行时，会生成一个 <strong>适用于 Windows 64 位系统</strong> 的 <code>.exe</code> 文件！</p>
<p>Go 编译器会：</p>
<ul>
<li>根据 <code>GOOS</code> 和 <code>GOARCH</code> 查找对应平台的标准库和系统调用实现；</li>
<li>选择合适的汇编代码生成器；</li>
<li>编译出目标平台可直接运行的二进制文件。</li>
</ul>
<h3 id="支持平台一览（部分）：">支持平台一览（部分）：</h3>
<ul>
<li>操作系统（<code>GOOS</code>）：<code>linux</code>、<code>windows</code>、<code>darwin</code>（mac）、<code>android</code>、<code>ios</code></li>
<li>架构（<code>GOARCH</code>）：<code>amd64</code>、<code>arm64</code>、<code>386</code>、<code>wasm</code> 等</li>
</ul>
<hr>
<h2 id="四、Go-内置标准库已适配多平台">四、Go 内置标准库已适配多平台</h2>
<p>Go 的标准库，比如 <code>net</code>, <code>os</code>, <code>syscall</code>, <code>runtime</code>，内部使用了大量的“<strong>条件编译</strong>”和“<strong>平台特定文件</strong>”。</p>
<p>比如 <code>os</code> 包中，文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os/</span><br><span class="line">├── file_unix.go</span><br><span class="line">├── file_windows.go</span><br><span class="line">├── file_darwin.go</span><br></pre></td></tr></table></figure>
<ul>
<li>文件名后缀（如 <code>_windows.go</code>）决定了该文件只在特定平台编译；</li>
<li>源码中也使用了 <code>// +build windows</code> 这样的条件编译标志；</li>
<li>Go 编译器会自动选择匹配的文件进行编译。</li>
</ul>
<p>因此，无需手动处理各种系统差异，Go 已经帮我们做好了平台适配。</p>
<hr>
<h2 id="五、Go-工具链内置交叉编译支持">五、Go 工具链内置交叉编译支持</h2>
<p>不同于 C/C++ 需要复杂的交叉工具链，<strong>Go 从诞生之初就内置了交叉编译功能</strong>。你不需要为不同平台安装专门的编译器，只要设置环境变量即可。</p>
<p>这一点大大降低了多平台开发的门槛。</p>
<h3 id="小贴士：">小贴士：</h3>
<p>你还可以使用 <code>go env</code> 查看所有支持的目标平台：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool dist list</span><br></pre></td></tr></table></figure>
<p>会列出所有支持的 <code>GOOS/GOARCH</code> 组合。</p>
<hr>
<h2 id="六、Go-为什么能跨平台总结一下：">六、Go 为什么能跨平台总结一下：</h2>
<table>
<thead>
<tr>
<th>原因</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 编译型语言</td>
<td>编译后生成目标平台的本地二进制</td>
</tr>
<tr>
<td>✅ 内置交叉编译</td>
<td><code>GOOS</code> 和 <code>GOARCH</code> 控制输出平台</td>
</tr>
<tr>
<td>✅ 平台适配完善</td>
<td>标准库用条件编译实现跨平台代码</td>
</tr>
<tr>
<td>✅ 无外部依赖</td>
<td>不依赖 JVM 或解释器，运行环境简单</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="七、一句话总结：">七、一句话总结：</h2>
<blockquote>
<p><strong>Go 跨平台的本质，就是通过编译器直接为目标系统生成原生程序，而不是依赖额外的运行时。</strong></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之转字符串</title>
    <url>/2025/05/29/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Go 语言中，<code>string(value)</code> 和 <code>value.(string)</code> 是两种完全不同的操作，它们用于不同的目的：</p>
<p><strong>1. <code>string(value)</code>: 类型转换 (Type Conversion)</strong></p>
<ul>
<li>
<p>这个语法用于将其他类型的值<strong>转换</strong>为 <code>string</code> 类型。</p>
</li>
<li>
<p>Go 语言会尝试将 <code>value</code> 的内容解释为一个字符串。</p>
</li>
<li>
<p>常见的用法是将整数类型的 Rune（Unicode 码点）或字节切片 (<code>[]byte</code>) 转换为字符串。</p>
<ul>
<li>
<p><strong>Rune 转字符串:</strong> 如果 <code>value</code> 是一个 <code>rune</code> 类型的值（代表一个 Unicode 码点），<code>string(value)</code> 会创建一个包含该 Unicode 字符的字符串。</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := <span class="string">&#x27;你&#x27;</span></span><br><span class="line">s := <span class="type">string</span>(r)</span><br><span class="line">fmt.Println(s) <span class="comment">// 输出: 你</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>[]byte</code> 转字符串:</strong> 如果 <code>value</code> 是一个 <code>[]byte</code> 类型的值，<code>string(value)</code> 会将该字节切片解释为一个 UTF-8 编码的字符串。</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := []<span class="type">byte</span>&#123;<span class="number">0xE4</span>, <span class="number">0xBD</span>, <span class="number">0xA0</span>&#125; <span class="comment">// &quot;你&quot; 的 UTF-8 编码</span></span><br><span class="line">s := <span class="type">string</span>(b)</span><br><span class="line">fmt.Println(s) <span class="comment">// 输出: 你</span></span><br><span class="line"></span><br><span class="line">b2 := []<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">s2 := <span class="type">string</span>(b2)</span><br><span class="line">fmt.Println(s2) <span class="comment">// 输出: hello</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>2. <code>value.(string)</code>: 类型断言 (Type Assertion)</strong></p>
<ul>
<li>
<p>这个语法用于判断一个<strong>接口类型</strong>的变量 <code>value</code> 的底层值是否是 <code>string</code> 类型，并尝试将其转换为 <code>string</code> 类型。</p>
</li>
<li>
<p><code>value</code> 必须是一个接口类型（例如 <code>interface&#123;&#125;</code>）。</p>
</li>
<li>
<p>类型断言有两种形式：</p>
<ul>
<li>
<p><strong>单返回值形式:</strong> <code>s := value.(string)</code></p>
<ul>
<li>如果 <code>value</code> 的底层值是 <code>string</code> 类型，<code>s</code> 将会是该字符串值。</li>
<li>如果 <code>value</code> 的底层值不是 <code>string</code> 类型，程序会触发 <code>panic</code> (运行时错误)。</li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// 输出: hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">interface</span>&#123;&#125; = <span class="number">123</span></span><br><span class="line"><span class="comment">// s2 := j.(string) // 这行代码会触发 panic</span></span><br><span class="line"><span class="comment">// fmt.Println(s2)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>双返回值形式 (更安全):</strong> <code>s, ok := value.(string)</code></p>
<ul>
<li>如果 <code>value</code> 的底层值是 <code>string</code> 类型，<code>s</code> 将会是该字符串值，并且 <code>ok</code> 的值为 <code>true</code>。</li>
<li>如果 <code>value</code> 的底层值不是 <code>string</code> 类型，<code>s</code> 将会是该类型的零值（对于 <code>string</code> 是空字符串 <code>&quot;&quot;</code>），并且 <code>ok</code> 的值为 <code>false</code>。这种形式更安全，因为它允许你检查类型是否匹配，而不会导致 <code>panic</code>。</li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Value is a string:&quot;</span>, s) <span class="comment">// 输出: Value is a string: hello</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Value is not a string&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">interface</span>&#123;&#125; = <span class="number">123</span></span><br><span class="line">s2, ok2 := j.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Value is a string:&quot;</span>, s2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Value is not a string&quot;</span>) <span class="comment">// 输出: Value is not a string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>总结:</strong></p>
<ul>
<li><code>string(value)</code> 是<strong>类型转换</strong>，用于将其他类型（特别是 <code>rune</code> 和 <code>[]byte</code>) 转换为 <code>string</code>。</li>
<li><code>value.(string)</code> 是<strong>类型断言</strong>，用于检查一个接口类型变量的底层值是否为 <code>string</code> 类型，并尝试获取该字符串值。它通常用于处理接口类型的变量。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之结构体中的函数类型字段</title>
    <url>/2025/06/02/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Go-语言奇技淫巧：结构体中的函数类型字段">Go 语言奇技淫巧：结构体中的函数类型字段</h2>
<p>在 Go 语言中，我们通常会将方法 (method) 绑定到结构体上，以实现与该类型相关的行为。但你有没有见过一种特殊的写法：将一个函数本身作为结构体的一个字段？这种做法初看可能有些不寻常，但它在某些场景下却能展现出强大的灵活性。</p>
<p>先看一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operation <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Execute <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addOp := Operation&#123;</span><br><span class="line">		Name: <span class="string">&quot;Addition&quot;</span>,</span><br><span class="line">		Execute: <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a + b</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	multiplyOp := Operation&#123;</span><br><span class="line">		Name: <span class="string">&quot;Multiplication&quot;</span>,</span><br><span class="line">		Execute: <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a * b</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s: %d\n&quot;</span>, addOp.Name, addOp.Execute(<span class="number">5</span>, <span class="number">3</span>))       <span class="comment">// Output: Addition: 8</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s: %d\n&quot;</span>, multiplyOp.Name, multiplyOp.Execute(<span class="number">5</span>, <span class="number">3</span>)) <span class="comment">// Output: Multiplication: 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个 <code>Operation</code> 结构体，它包含一个 <code>Execute</code> 字段，而 <code>Execute</code> 的类型是 <code>func(int, int) int</code>。这意味着我们可以将任何符合这个函数签名的函数赋值给 <code>Execute</code> 字段。在 <code>main</code> 函数中，我们创建了两个 <code>Operation</code> 实例，分别将加法和乘法的匿名函数赋值给了它们的 <code>Execute</code> 字段。</p>
<p><strong>这种写法的意义何在？它的应用场景是什么呢？</strong></p>
<ol>
<li>
<p><strong>策略模式 (Strategy Pattern)</strong>：<br>
这种方式非常适合实现策略模式。策略模式允许你在运行时选择算法或行为。将不同的算法封装成函数，并将这些函数存储在结构体的字段中，使得我们可以在创建结构体实例时动态地选择要使用的算法。</p>
<p>回到我们 <code>SliceFn</code> 的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceFn[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    S       []T</span><br><span class="line">    Compare <span class="function"><span class="keyword">func</span><span class="params">(T, T)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := SliceFn[<span class="type">int</span>]&#123;</span><br><span class="line">        S: []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        Compare: <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b <span class="comment">// 升序比较</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Numbers with ascending compare:&quot;</span>, numbers.S)</span><br><span class="line"></span><br><span class="line">    strings := SliceFn[<span class="type">string</span>]&#123;</span><br><span class="line">        S: []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;,</span><br><span class="line">        Compare: <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(a) &lt; <span class="built_in">len</span>(b) <span class="comment">// 按长度比较</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Strings with length compare:&quot;</span>, strings.S)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上面的例子并没有真正使用 <code>Compare</code> 函数进行排序，但你可以想象，你可以为 <code>SliceFn</code> 添加一个 <code>Sort</code> 方法，该方法会使用 <code>Compare</code> 字段中存储的比较函数来对 <code>S</code> 进行排序。这样，同一个 <code>SliceFn</code> 结构体可以根据不同的比较策略进行排序。</p>
</li>
<li>
<p><strong>回调机制 (Callback Mechanism)</strong>：<br>
将函数作为字段存储在结构体中，可以方便地实现回调。结构体的某个方法在执行过程中，可以调用这个函数类型的字段，从而允许用户自定义某些步骤的行为。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    Process <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">    OnComplete <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    task1 := Task&#123;</span><br><span class="line">        Name: <span class="string">&quot;Data Processing&quot;</span>,</span><br><span class="line">        Process: <span class="function"><span class="keyword">func</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Processed: %s&quot;</span>, data)</span><br><span class="line">        &#125;,</span><br><span class="line">        OnComplete: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Task 1 completed.&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result := task1.Process(<span class="string">&quot;example data&quot;</span>)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">    task1.OnComplete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 <code>Task</code> 结构体中，<code>Process</code> 和 <code>OnComplete</code> 都是函数类型的字段，允许我们在创建 <code>Task</code> 实例时注入自定义的处理逻辑和完成时的回调行为。</p>
</li>
</ol>
<p><strong>与传统方法绑定的对比</strong></p>
<p>你可能会问，为什么不直接将这些行为定义为结构体的方法呢？在很多情况下，将方法绑定到结构体是更自然和更符合面向对象思维的方式。然而，使用函数类型字段的主要优势在于<strong>灵活性</strong>和<strong>配置性</strong>。</p>
<ul>
<li><strong>灵活性</strong>：你可以在创建结构体实例时动态地指定不同的行为，而无需创建不同的结构体类型或实现接口。</li>
<li><strong>配置性</strong>：这种方式使得结构体的行为可以通过数据（即函数本身）进行配置。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言之项目布局</title>
    <url>/2025/06/05/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自GitHub：(<a href="https://github.com/golang-standards/project-layout/tree/master">https://github.com/golang-standards/project-layout/tree/master</a>)</p>
<span id="more"></span>
<h1 id="Standard-Go-Project-Layout">Standard Go Project Layout</h1>
<p>这是 Go 应用程序项目的基本布局。它不是核心 Go 开发团队定义的官方标准；然而，它是 Go 生态系统中一组常见的老项目和新项目的布局模式。其中一些模式比其他模式更受欢迎。它还具有许多小的增强，以及对任何足够大的实际应用程序通用的几个支持目录。</p>
<p>如果你尝试学习 Go，或者你正在为自己建立一个 PoC 或一个玩具项目，这个项目布局是没啥必要的。从一些非常简单的事情开始(一个 <code>main.go</code> 文件绰绰有余)。随着项目的增长，请记住保持代码结构良好非常重要，否则你最终会得到一个凌乱的代码，这其中就包含大量隐藏的依赖项和全局状态。当有更多的人参与这个项目时，你将需要更多的结构。这时候，介绍一种管理包/库的通用方法是很重要的。当你有一个开源项目时，或者当你知道其他项目从你的项目存储库中导入代码时，这时候拥有私有(又名 <code>internal</code>)包和代码就很重要。克隆存储库，保留你需要的内容，删除其他所有的内容！仅仅因为它在那里并不意味着你必须全部使用它。这些模式都没有在每个项目中使用。甚至 <code>vendor</code> 模式也不是通用的。</p>
<p>Go 1.14 <a href="https://go.dev/wiki/Modules"><code>Go Modules</code></a> 终于可以投入生产了。除非你有特定的理由不使用它们，否则使用 <a href="https://blog.golang.org/using-go-modules"><code>Go Modules</code></a> 。如果你使用，就无需担心 $GOPATH 以及项目放置的位置。存储库中的 <code>go.mod</code> 文件基本假定你的项目托管在 Github 上，但这不是要求。模块路径可以是任何地方，尽管第一个模块路径组件的名称中应该有一个点（当前版本的 Go 不再强制使用该模块，但如果使用稍旧的版本，如果没有 <code>mod</code> 文件构建失败的话 ，不要惊讶）。如果你想知道更多信息，请参阅 Issues <a href="https://github.com/golang/go/issues/37554"><code>37554</code></a> 和 <a href="https://github.com/golang/go/issues/32819"><code>32819</code></a> 。</p>
<p>此项目布局是通用的，并且不会尝试强加一个特定的 Go 包结构。</p>
<p>这是社区的努力。 如果看到新的模式，或者认为一个现有的模式需要更新，请提一个 issue。</p>
<p>如果需要命名、格式和样式方面的帮助，请运行 <a href="https://golang.org/cmd/gofmt/"><code>gofmt</code></a> 和 <a href="https://github.com/golang/lint"><code>golint</code></a> 。还要确保阅读这些 Go 代码风格的指导方针和建议:</p>
<ul>
<li><a href="https://talks.golang.org/2014/names.slide">https://talks.golang.org/2014/names.slide</a></li>
<li><a href="https://golang.org/doc/effective_go.html#names">https://golang.org/doc/effective_go.html#names</a></li>
<li><a href="https://blog.golang.org/package-names">https://blog.golang.org/package-names</a></li>
<li><a href="https://go.dev/wiki/CodeReviewComments">https://go.dev/wiki/CodeReviewComments</a></li>
<li><a href="https://rakyll.org/style-packages">Style guideline for Go packages</a> (rakyll/JBD)</li>
</ul>
<p>参见 <a href="https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2"><code>Go Project Layout</code></a> 了解更多的背景信息。</p>
<p>更多关于包的命名和组织以及其他代码结构的建议:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=PTE4VJIdHPg">GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming</a></li>
<li><a href="https://www.youtube.com/watch?v=MzTcsI6tn-0">GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.</a></li>
<li><a href="https://www.youtube.com/watch?v=ltqV6pDKZD8">GopherCon 2017: Edward Muller - Go Anti-Patterns</a></li>
<li><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a></li>
</ul>
<h2 id="Go-目录">Go 目录</h2>
<h3 id="cmd"><code>/cmd</code></h3>
<p>本项目的主干。</p>
<p>每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，<code>/cmd/myapp</code>)。</p>
<p>不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 <code>/pkg</code> 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 <code>/internal</code> 目录中。你会惊讶于别人会怎么做，所以要明确你的意图!</p>
<p>通常有一个小的 <code>main</code> 函数，从 <code>/internal</code> 和 <code>/pkg</code> 目录导入和调用代码，除此之外没有别的东西。</p>
<p>有关示例，请参阅 <a href="cmd/README.md"><code>/cmd</code></a> 目录。</p>
<h3 id="internal"><code>/internal</code></h3>
<p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 <a href="https://golang.org/doc/go1.4#internalpackages"><code>release notes</code></a> 。注意，你并不局限于顶级 <code>internal</code> 目录。在项目树的任何级别上都可以有多个内部目录。</p>
<p>你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 <code>/internal/app</code> 目录下(例如 <code>/internal/app/myapp</code>)，这些应用程序共享的代码可以放在 <code>/internal/pkg</code> 目录下(例如 <code>/internal/pkg/myprivlib</code>)。</p>
<h3 id="pkg"><code>/pkg</code></h3>
<p>外部应用程序可以使用的库代码(例如 <code>/pkg/mypubliclib</code>)。其他项目会导入这些库，希望它们能正常工作，所以在这里放东西之前要三思:-)注意，<code>internal</code> 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。<code>/pkg</code> 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。由 Travis Jeffery  撰写的 <a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/"><code>I'll take pkg over internal</code></a> 博客文章提供了 <code>pkg</code> 和 <code>internal</code> 目录的一个很好的概述，以及什么时候使用它们是有意义的。</p>
<p>当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易（正如在这些演讲中提到的那样: 来自 GopherCon EU 2018 的 <a href="https://www.youtube.com/watch?v=PTE4VJIdHPg"><code>Best Practices for Industrial Programming</code></a> , <a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a> 和 <a href="https://www.youtube.com/watch?v=3gQa1LWwuzk">GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go</a> ）。</p>
<p>如果你想查看哪个流行的 Go 存储库使用此项目布局模式，请查看 <a href="pkg/README.md"><code>/pkg</code></a> 目录。这是一种常见的布局模式，但并不是所有人都接受它，一些 Go 社区的人也不推荐它。</p>
<p>如果你的应用程序项目真的很小，并且额外的嵌套并不能增加多少价值(除非你真的想要:-)，那就不要使用它。当它变得足够大时，你的根目录会变得非常繁琐时(尤其是当你有很多非 Go 应用组件时)，请考虑一下。</p>
<h3 id="vendor"><code>/vendor</code></h3>
<p>应用程序依赖项(手动管理或使用你喜欢的依赖项管理工具，如新的内置 <a href="https://go.dev/wiki/Modules"><code>Go Modules</code></a> 功能)。<code>go mod vendor</code> 命令将为你创建 <code>/vendor</code> 目录。请注意，如果未使用默认情况下处于启用状态的 Go 1.14，则可能需要在 <code>go build</code> 命令中添加 <code>-mod=vendor</code> 标志。</p>
<p>如果你正在构建一个库，那么不要提交你的应用程序依赖项。</p>
<p>注意，自从 <a href="https://golang.org/doc/go1.13#modules"><code>1.13</code></a> 以后，Go 还启用了模块代理功能(默认使用 <a href="https://proxy.golang.org"><code>https://proxy.golang.org</code></a> 作为他们的模块代理服务器)。在<a href="https://blog.golang.org/module-mirror-launch"><code>here</code></a> 阅读更多关于它的信息，看看它是否符合你的所有需求和约束。如果需要，那么你根本不需要 <code>vendor</code> 目录。</p>
<p>国内模块代理功能默认是被墙的，七牛云有维护专门的的<a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md"><code>模块代理</code></a> 。</p>
<h2 id="服务应用程序目录">服务应用程序目录</h2>
<h3 id="api"><code>/api</code></h3>
<p>OpenAPI/Swagger 规范，JSON 模式文件，协议定义文件。</p>
<p>有关示例，请参见 <a href="api/README.md"><code>/api</code></a> 目录。</p>
<h2 id="Web-应用程序目录">Web 应用程序目录</h2>
<h3 id="web"><code>/web</code></h3>
<p>特定于 Web 应用程序的组件:静态 Web 资源、服务器端模板和 SPAs。</p>
<h2 id="通用应用目录">通用应用目录</h2>
<h3 id="configs"><code>/configs</code></h3>
<p>配置文件模板或默认配置。</p>
<p>将你的 <code>confd</code> 或 <code>consul-template</code> 模板文件放在这里。</p>
<h3 id="init"><code>/init</code></h3>
<p>System init（systemd，upstart，sysv）和 process manager/supervisor（runit，supervisor）配置。</p>
<h3 id="scripts"><code>/scripts</code></h3>
<p>执行各种构建、安装、分析等操作的脚本。</p>
<p>这些脚本保持了根级别的 Makefile 变得小而简单(例如， <a href="https://github.com/hashicorp/terraform/blob/main/Makefile"><code>https://github.com/hashicorp/terraform/blob/main/Makefile</code></a> )。</p>
<p>有关示例，请参见  <a href="scripts/README.md"><code>/scripts</code></a> 目录。</p>
<h3 id="build"><code>/build</code></h3>
<p>打包和持续集成。</p>
<p>将你的云( AMI )、容器( Docker )、操作系统( deb、rpm、pkg )包配置和脚本放在 <code>/build/package</code> 目录下。</p>
<p>将你的 CI (travis、circle、drone)配置和脚本放在 <code>/build/ci</code> 目录中。请注意，有些 CI 工具(例如 Travis CI)对配置文件的位置非常挑剔。尝试将配置文件放在 <code>/build/ci</code> 目录中，将它们链接到 CI 工具期望它们的位置(如果可能的话)。</p>
<h3 id="deployments"><code>/deployments</code></h3>
<p>IaaS、PaaS、系统和容器编排部署配置和模板(docker-compose、kubernetes/helm、mesos、terraform、bosh)。注意，在一些存储库中(特别是使用 kubernetes 部署的应用程序)，这个目录被称为 <code>/deploy</code>。</p>
<h3 id="test"><code>/test</code></h3>
<p>额外的外部测试应用程序和测试数据。你可以随时根据需求构造 <code>/test</code> 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 <code>/test/data</code> 或 <code>/test/testdata</code> (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。</p>
<p>有关示例，请参见  <a href="test/README.md"><code>/test</code></a> 目录。</p>
<h2 id="其他目录">其他目录</h2>
<h3 id="docs"><code>/docs</code></h3>
<p>设计和用户文档(除了 godoc 生成的文档之外)。</p>
<p>有关示例，请参阅 <a href="docs/README.md"><code>/docs</code></a> 目录。</p>
<h3 id="tools"><code>/tools</code></h3>
<p>这个项目的支持工具。注意，这些工具可以从 <code>/pkg</code> 和 <code>/internal</code> 目录导入代码。</p>
<p>有关示例，请参见 <a href="tools/README.md"><code>/tools</code></a> 目录。</p>
<h3 id="examples"><code>/examples</code></h3>
<p>你的应用程序和/或公共库的示例。</p>
<p>有关示例，请参见 <a href="examples/README.md"><code>/examples</code></a> 目录。</p>
<h3 id="third-party"><code>/third_party</code></h3>
<p>外部辅助工具，分叉代码和其他第三方工具(例如 Swagger UI)。</p>
<h3 id="githooks"><code>/githooks</code></h3>
<p>Git hooks。</p>
<h3 id="assets"><code>/assets</code></h3>
<p>与存储库一起使用的其他资源(图像、徽标等)。</p>
<h3 id="website"><code>/website</code></h3>
<p>如果你不使用 Github 页面，则在这里放置项目的网站数据。</p>
<p>有关示例，请参见 <a href="website/README.md"><code>/website</code></a> 目录。</p>
<h2 id="你不应该拥有的目录">你不应该拥有的目录</h2>
<h3 id="src"><code>/src</code></h3>
<p>有些 Go 项目确实有一个 <code>src</code> 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。如果可以的话，尽量不要采用这种 Java 模式。你真的不希望你的 Go 代码或 Go 项目看起来像 Java:-)</p>
<p>不要将项目级别 <code>src</code> 目录与 Go 用于其工作空间的 <code>src</code> 目录(如 <a href="https://golang.org/doc/code.html"><code>How to Write Go Code</code></a> 中所述)混淆。<code>$GOPATH</code> 环境变量指向你的(当前)工作空间(默认情况下，它指向非 windows 系统上的 <code>$HOME/go</code>)。这个工作空间包括顶层 <code>/pkg</code>, <code>/bin</code> 和 <code>/src</code> 目录。你的实际项目最终是 <code>/src</code> 下的一个子目录，因此，如果你的项目中有 <code>/src</code> 目录，那么项目路径将是这样的: <code>/some/path/to/workspace/src/your_project/src/your_code.go</code>。注意，在 Go 1.11 中，可以将项目放在 <code>GOPATH</code> 之外，但这并不意味着使用这种布局模式是一个好主意。</p>
<h2 id="Badges">Badges</h2>
<ul>
<li>
<p><a href="https://goreportcard.com/">Go Report Card</a> - It will scan your code with <code>gofmt</code>, <code>go vet</code>, <code>gocyclo</code>, <code>golint</code>, <code>ineffassign</code>, <code>license</code> and <code>misspell</code>. Replace <code>github.com/golang-standards/project-layout</code> with your project reference.</p>
</li>
<li>
<p><a href="http://godoc.org">GoDoc</a> - It will provide online version of your GoDoc generated documentation. Change the link to point to your project.</p>
</li>
<li>
<p>Release - It will show the latest release number for your project. Change the github link to point to your project.</p>
</li>
</ul>
<p><a href="https://goreportcard.com/report/github.com/golang-standards/project-layout"><img data-src="https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square" alt="Go Report Card"></a><br>
<a href="http://godoc.org/github.com/golang-standards/project-layout"><img data-src="https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square" alt="Go Doc"></a><br>
<a href="https://github.com/golang-standards/project-layout/releases/latest"><img data-src="https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square" alt="Release"></a></p>
<h2 id="Notes">Notes</h2>
<p>A more opinionated project template with sample/reusable configs, scripts and code is a WIP.</p>
]]></content>
      <categories>
        <category>go</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>主流语言依赖注入对比</title>
    <url>/2025/06/06/%E4%B8%BB%E6%B5%81%E8%AF%AD%E8%A8%80%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🚀-Java、Go、C-实践分析（以-log-和-db-为例）">🚀 Java、Go、C++ 实践分析（以 log 和 db 为例）</h1>
<p>在不同语言中，依赖注入的实现方式大相径庭：Java 倾向于使用框架，Go 倾向于显示传递，而 C++ 倾向于泛型或函数指针形式的注入。</p>
<hr>
<h2 id="🧱-场景设定">🧱 场景设定</h2>
<p>我们假设有一个 <code>UserService</code> 服务，它依赖一个日志组件（Logger）和一个数据库组件（DB）。我们希望通过依赖注入将这两个依赖提供给它，而不在 <code>UserService</code> 内部直接创建它们。</p>
<hr>
<h2 id="☕-Java：使用-Spring-框架的构造函数注入">☕ Java：使用 Spring 框架的构造函数注入</h2>
<p>Java 的依赖注入几乎都是通过框架（如 Spring）实现的，主流方式是构造器注入或注解注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Database db;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(Logger logger, Database db)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger = logger;</span><br><span class="line">        <span class="built_in">this</span>.db = db;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        logger.log(<span class="string">&quot;Creating user: &quot;</span> + name);</span><br><span class="line">        db.saveUser(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置方式（XML 或注解）交由 Spring 容器管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Database <span class="title function_">database</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySQLDatabase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>优点</strong>：</p>
<ul>
<li>框架自动管理依赖，易用且强大</li>
<li>支持生命周期管理、作用域、AOP 等</li>
</ul>
<p>⚠️ <strong>缺点</strong>：</p>
<ul>
<li>学习曲线较陡</li>
<li>项目初始化成本高</li>
</ul>
<hr>
<h2 id="🦫-Go：显示构造函数注入（无框架，清晰可控）">🦫 Go：显示构造函数注入（无框架，清晰可控）</h2>
<p>Go 倾向于使用显示注入（manual injection），遵循组合优于继承的思想。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">    Log(msg <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">interface</span> &#123;</span><br><span class="line">    SaveUser(name <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    logger Logger</span><br><span class="line">    db     DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">(logger Logger, db DB)</span></span> *UserService &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserService&#123;logger: logger, db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserService)</span></span> CreateUser(name <span class="type">string</span>) &#123;</span><br><span class="line">    u.logger.Log(<span class="string">&quot;Creating user: &quot;</span> + name)</span><br><span class="line">    u.db.SaveUser(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建时注入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger := &amp;ConsoleLogger&#123;&#125;</span><br><span class="line">    db := &amp;MySQL&#123;&#125;</span><br><span class="line">    userService := NewUserService(logger, db)</span><br><span class="line"></span><br><span class="line">    userService.CreateUser(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>优点</strong>：</p>
<ul>
<li>无魔法，依赖清晰可见</li>
<li>更易于测试和维护</li>
</ul>
<p>⚠️ <strong>缺点</strong>：</p>
<ul>
<li>项目规模变大后需要手动组织构造器</li>
<li>DI 逻辑容易散乱</li>
</ul>
<p>🛠️ Go 项目中常用 wire、fx、dig 等工具实现自动依赖注入，但本质还是构造函数注入。</p>
<hr>
<h2 id="🧠-C-：泛型-函数注入（模板-std-function）">🧠 C++：泛型 &amp; 函数注入（模板 + std::function）</h2>
<p>C++ 中没有内建 DI 框架，常用两种方式：</p>
<ol>
<li>构造函数注入（经典方式）</li>
<li>函数式注入（适合注入策略或行为）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> : <span class="keyword">public</span> Logger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[LOG] &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">saveUser</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQL</span> : <span class="keyword">public</span> DB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveUser</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Saving user: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UserService</span>(Logger* logger, DB* db)</span><br><span class="line">        : <span class="built_in">logger_</span>(logger), <span class="built_in">db_</span>(db) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createUser</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">        logger_-&gt;<span class="built_in">log</span>(<span class="string">&quot;Creating user: &quot;</span> + name);</span><br><span class="line">        db_-&gt;<span class="built_in">saveUser</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Logger* logger_;</span><br><span class="line">    DB* db_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConsoleLogger logger;</span><br><span class="line">    MySQL db;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserService <span class="title">service</span><span class="params">(&amp;logger, &amp;db)</span></span>;</span><br><span class="line">    service.<span class="built_in">createUser</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>优点</strong>：</p>
<ul>
<li>灵活、无外部依赖</li>
<li>可轻松注入不同实现用于测试或扩展</li>
</ul>
<p>⚠️ <strong>缺点</strong>：</p>
<ul>
<li>缺少统一管理机制</li>
<li>生命周期管理需自行处理（裸指针 vs 智能指针）</li>
</ul>
<hr>
<h2 id="🧾-总结对比表">🧾 总结对比表</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Java (Spring)</th>
<th>Go</th>
<th>C++</th>
</tr>
</thead>
<tbody>
<tr>
<td>框架支持</td>
<td>强，自动注入</td>
<td>无/弱（dig、wire）</td>
<td>基本无</td>
</tr>
<tr>
<td>DI 类型</td>
<td>注解、XML、构造器注入</td>
<td>构造器注入</td>
<td>构造器注入 / 函数注入</td>
</tr>
<tr>
<td>生命周期管理</td>
<td>自动</td>
<td>手动</td>
<td>手动（注意指针）</td>
</tr>
<tr>
<td>学习成本</td>
<td>中高</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>测试友好性</td>
<td>强</td>
<td>强</td>
<td>中</td>
</tr>
<tr>
<td>推荐项目规模</td>
<td>中大型企业应用</td>
<td>中小型/微服务</td>
<td>嵌入式/性能敏感/底层系统</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🏁-结语">🏁 结语</h2>
<p>依赖注入是一种提升代码灵活性、解耦性和测试能力的重要手段。不同语言有不同实现风格：</p>
<ul>
<li>Java 倾向于<strong>框架驱动</strong>，自动注入、企业级开发常用；</li>
<li>Go 倾向于<strong>显示注入</strong>，符合其简洁哲学；</li>
<li>C++ 倾向于<strong>灵活注入</strong>，适合性能敏感场景；</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>双线映射和计算迪菲-赫尔曼假设</title>
    <url>/2025/06/29/%E5%8F%8C%E7%BA%BF%E6%98%A0%E5%B0%84%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%81%87%E8%AE%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现代密码学中非常重要的两个概念：<strong>Bilinear Pairings/Mappings</strong> 和 <strong>CDH Assumption</strong></p>
<span id="more"></span>
<p><strong>核心思想：</strong></p>
<ul>
<li><strong>群（Group）：</strong> 你可以把“群”想象成一个集合（比如一些数字），上面定义了一种运算（比如乘法）。这个运算有一些特殊的性质，比如你总能把两个元素“乘”起来得到集合里的另一个元素，每个元素都有一个“倒数”，还有一个特殊的“1”（单位元），等等。</li>
<li><strong>循环群（Cyclic Group）：</strong> 在循环群里，有一个特殊的元素叫做“生成元”（generator），用它自己反复进行群运算，就可以得到群里的所有其他元素。就像时钟上的指针，从12点开始，一步一步走，可以走到所有的时间点。</li>
<li><strong>乘法循环群（Multiplicative Cyclic Group）：</strong> 这里的群运算是乘法。一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 次方 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">g^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span>) 就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 乘以自己 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 次。</li>
<li><strong>阶（Order）：</strong> 群的阶就是群里面元素的个数。素数阶（prime order）是指群里元素的个数是一个素数。</li>
<li><strong>离散对数问题（Discrete Logarithm Problem - DLP）：</strong> 在循环群里，给你生成元 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 和群里的一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>，如果知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><msup><mi>g</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">h = g^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span>，找出这个指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 是很难的（在密码学用的那种大群里）。这就像你知道时针从12点出发走了多少圈到达某个位置，但如果只告诉你现在是3点，很难一下子知道它走了多少圈（考虑很多圈的情况）。很多密码学的安全性都建立在这个困难性上。</li>
</ul>
<hr>
<h3 id="2-1-双线性配对-Bilinear-Pairings">2.1 双线性配对 (Bilinear Pairings)</h3>
<p>想象一下，你有两个“世界”（群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span>），里面住了各种“元素”。还有一个“目标世界”（群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）。双线性配对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 就像一个特殊的“桥梁”或者“翻译器”，它能把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 里的两个元素“组合”起来，然后把你带到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 里的一个元素。</p>
<p>正式地说：</p>
<ul>
<li>
<p>你有两个乘法循环群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 和一个目标乘法循环群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，它们的阶都是同一个素数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>。</p>
</li>
<li>
<p>有一个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>，输入是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 里的两个元素（比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">g_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">g_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），输出是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 里的一个元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(g_1, g_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
</li>
<li>
<p>这个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 之所以特殊，是因为它满足两个关键性质：</p>
<ol>
<li>
<p><strong>(Bilinear / 双线性):</strong> 这是最神奇的性质。它说：如果你在输入端对元素进行指数运算，这个指数可以“移出来”变成整个输出结果的指数。</p>
<ul>
<li>公式是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>g</mi><mn>1</mn><mi>x</mi></msubsup><mo separator="true">,</mo><msubsup><mi>g</mi><mn>2</mn><mi>y</mi></msubsup><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e(g_1^x, g_2^y) = e(g_1, g_2)^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0486em;vertical-align:-0.2663em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>通俗理解：在群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 里，把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">g_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 乘以自己 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 次得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>g</mi><mn>1</mn><mi>x</mi></msubsup></mrow><annotation encoding="application/x-tex">g_1^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9125em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span>，把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">g_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 乘以自己 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 次得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>g</mi><mn>2</mn><mi>y</mi></msubsup></mrow><annotation encoding="application/x-tex">g_2^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0486em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span>。然后计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>g</mi><mn>1</mn><mi>x</mi></msubsup><mo separator="true">,</mo><msubsup><mi>g</mi><mn>2</mn><mi>y</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(g_1^x, g_2^y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0486em;vertical-align:-0.2663em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li>这个性质告诉我们，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>g</mi><mn>1</mn><mi>x</mi></msubsup><mo separator="true">,</mo><msubsup><mi>g</mi><mn>2</mn><mi>y</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(g_1^x, g_2^y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0486em;vertical-align:-0.2663em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的结果，<strong>等同于</strong>先计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(g_1, g_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，然后在目标群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 里把结果乘以自己 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 次。</li>
<li>注意看，输入的指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 变成了输出的指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>！这个能力非常强大，因为它在不知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 具体数值的情况下，把指数的乘法（在指数位置上）变成了一种可以通过配对计算得到的结果（在群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 里作为指数）。</li>
<li>可以分解理解：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>g</mi><mn>1</mn><mi>x</mi></msubsup><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">e(g_1^x, g_2) = e(g_1, g_2)^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msubsup><mi>g</mi><mn>2</mn><mi>y</mi></msubsup><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">e(g_1, g_2^y) = e(g_1, g_2)^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0486em;vertical-align:-0.2663em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span>。配对对每个输入都是“线性”的（指数可以提出来）。</li>
</ul>
</li>
<li>
<p><strong>(Non-degenerate / 非退化):</strong> 这个性质保证配对不是无聊的、没用的。</p>
<ul>
<li>公式是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><msub><mi>h</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>h</mi><mn>2</mn></msub><mo>∈</mo><mi mathvariant="double-struck">G</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exists h_1, h_2 \in \mathbb{G}, e(h_1, h_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∃</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is a generator of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. (注：这里图片上写的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，根据上下文应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span>，假设是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span>)</li>
<li>通俗理解：存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 里的两个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_1, h_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，它们的配对结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(h_1, h_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 在目标群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 里是一个“生成元”。</li>
<li>意思是，通过适当选择输入，配对的结果可以生成目标群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 里的所有元素，而不仅仅是目标群里的“1”（单位元）。如果配对总是得到“1”，那就没啥用了。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>(Computable / 可计算):</strong> 实际应用中，群里的运算和配对函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 本身必须是能用计算机有效计算出来的。</p>
</li>
</ul>
<p><strong>总结双线性配对：</strong> 它是一种特殊的函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 连接两个群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，最关键的性质是能把输入的指数“移动”到输出，并变成输出结果的指数（且指数相乘）。这种能力在密码学中非常有用，可以用来构建身份加密、签名、零知识证明等更复杂的加密方案。</p>
<hr>
<h3 id="2-2-计算迪菲-赫尔曼（CDH）假设-Computational-Diffie-Hellman-CDH-assumption">2.2 计算迪菲-赫尔曼（CDH）假设 (Computational Diffie-Hellman (CDH) assumption)</h3>
<p>这是一个关于计算困难性的“假设”。迪菲-赫尔曼是第一个公开密钥交换协议的发明者，这个假设就是基于他们在协议中用到的一个计算问题。</p>
<ul>
<li>
<p><strong>设定：</strong> 你有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 阶的乘法循环群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span>，以及它的一个生成元 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>。</p>
</li>
<li>
<p><strong>问题：</strong> 假设你得到了三个群里的元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">g^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span>, 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">g^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span>。这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是你在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, \dots, q-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> 范围内的两个秘密数字，<strong>你并不知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 具体是多少</strong>。</p>
</li>
<li>
<p><strong>任务：</strong> 你的目标是计算出群里的另一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
</li>
<li>
<p><strong>CDH 假设是什么？</strong> 计算迪菲-赫尔曼假设就是说：对于精心选择的群 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span>，<strong>从已知信息 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><msup><mi>g</mi><mi>x</mi></msup><mo separator="true">,</mo><msup><mi>g</mi><mi>y</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g, g^x, g^y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 计算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span> 是计算上不可行的（非常困难）</strong>。</p>
</li>
<li>
<p><strong>为什么重要？</strong></p>
<ul>
<li>如果你知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>（通过解离散对数问题从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">g^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span> 得到），你就可以轻松计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>y</mi></msup><msup><mo stretchy="false">)</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">g^{xy} = (g^y)^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span>。同样，如果你知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，你可以计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>x</mi></msup><msup><mo stretchy="false">)</mo><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">g^{xy} = (g^x)^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span>。CDH 假设比离散对数问题（DLP）通常被认为更难或至少一样难。如果有人能高效解决 CDH 问题，那他很可能也能解决 DLP 问题。</li>
<li>很多密码学协议（包括原始的迪菲-赫尔曼密钥交换协议）的安全性直接依赖于这个假设。如果有人能“攻破”CDH 假设（找到一个快速计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span> 的方法），那么这些协议就不安全了。</li>
</ul>
</li>
<li>
<p><strong>为什么是“假设”？</strong> 因为数学上没有被证明这是不可能的。它是一个基于我们目前最佳算法的认识而提出的。如果未来有人找到了一个快速算法来解决 CDH 问题，这个假设就不成立了。</p>
</li>
</ul>
<p><strong>总结 CDH 假设：</strong> 它是一个在特定数学群上的困难性假设，指出了在不知道指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的情况下，单单从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo separator="true">,</mo><msup><mi>g</mi><mi>x</mi></msup><mo separator="true">,</mo><msup><mi>g</mi><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">g, g^x, g^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span> 这几个群元素，计算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span> 这个群元素是非常困难的。这是许多基于离散对数密码学安全性的基石之一。</p>
<hr>
<p><strong>这两个概念的关系（补充）：</strong></p>
<p>双线性配对提供了一种独特的计算能力：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msup><mi>g</mi><mi>x</mi></msup><mo separator="true">,</mo><msup><mi>g</mi><mi>y</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>g</mi><msup><mo stretchy="false">)</mo><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e(g^x, g^y) = e(g, g)^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span>。<br>
在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 中直接从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>x</mi></msup><mo separator="true">,</mo><msup><mi>g</mi><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">g^x, g^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span> 计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span> 被 CDH 假设认为是困难的。<br>
但是，通过双线性配对，如果你在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中能够计算离散对数（或者说 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中的计算更容易），那么你可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>g</mi><msup><mo stretchy="false">)</mo><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e(g, g)^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span>。这个值与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span> 有关联，但并不是直接得到了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">G</mi></mrow><annotation encoding="application/x-tex">\mathbb{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">G</span></span></span></span> 中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>x</mi><mi>y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g^{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span>。双线性配对的存在有时可以“打破”一些只依赖于 CDH 假设的密码学问题，但同时它也带来了新的构建复杂密码学协议的可能性。</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ERC-1155</title>
    <url>/2025/05/04/%E5%AD%A6%E4%B9%A0ERC-1155/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ERC-1155：可多功能代币标准">ERC-1155：可多功能代币标准</h2>
<h3 id="什么是ERC-1155？">什么是ERC-1155？</h3>
<p>ERC-1155 是一种以太坊智能合约标准，专为实现多功能代币（Multi-Token Standard）而设计。与 ERC-20（同质化代币）和 ERC-721（非同质化代币）不同，ERC-1155 支持 <strong>同质化代币（Fungible Tokens）</strong> 和 <strong>非同质化代币（Non-Fungible Tokens）</strong> 的混合管理。该标准极大地提高了区块链代币管理的灵活性与效率，尤其适用于游戏、收藏品等对多种资产类型有需求的场景。</p>
<p>ERC-1155 的主要特点包括：</p>
<ul>
<li>
<p><strong>批量操作</strong>：可以同时转移或创建多个代币，降低了链上操作成本。</p>
</li>
<li>
<p><strong>单一合约管理多种代币</strong>：一个合约中可以包含多种代币类型，而不需要单独部署多个合约。</p>
</li>
<li>
<p><strong>灵活性</strong>：支持同质化代币（如游戏金币）、非同质化代币（如NFT角色）和半同质化代币（如门票）。</p>
</li>
<li>
<p><strong>节约Gas费用</strong>：通过批量操作和共享逻辑减少链上交易成本。</p>
</li>
</ul>
<hr>
<h3 id="ERC-1155-的工作原理">ERC-1155 的工作原理</h3>
<p>ERC-1155 定义了一种标准接口，支持以下功能：</p>
<ol>
<li>
<p><strong>代币创建</strong>：可以通过 <code>mint</code> 方法创建新的代币类型。</p>
</li>
<li>
<p><strong>代币转移</strong>：支持单个或批量的代币转移。</p>
</li>
<li>
<p><strong>事件通知</strong>：通过事件（如 <code>TransferSingle</code> 和 <code>TransferBatch</code>）提供透明且高效的状态更新。</p>
</li>
<li>
<p><strong>安全检测</strong>：增加了对智能合约接收代币的安全检测（如 <code>onERC1155Received</code> 和 <code>onERC1155BatchReceived</code>）。</p>
</li>
</ol>
<p>ERC-1155 的核心方法：</p>
<ul>
<li>
<p><code>safeTransferFrom</code>：单个代币的安全转移。</p>
</li>
<li>
<p><code>safeBatchTransferFrom</code>：批量代币的安全转移。</p>
</li>
<li>
<p><code>balanceOf</code>：查询某个账户上的指定代币余额。</p>
</li>
<li>
<p><code>balanceOfBatch</code>：批量查询多个账户的多个代币余额。</p>
</li>
<li>
<p><code>setApprovalForAll</code>：授权某个地址管理所有代币。</p>
</li>
<li>
<p><code>isApprovedForAll</code>：检查授权状态。</p>
</li>
</ul>
<hr>
<h3 id="ERC-1155-的用法：代码示例">ERC-1155 的用法：代码示例</h3>
<p>以下是一个简单的 ERC-1155 智能合约，基于 OpenZeppelin 提供的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// 引入 OpenZeppelin 的 ERC1155 实现</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyERC1155Token is ERC1155, Ownable &#123;</span><br><span class="line"></span><br><span class="line">    // 定义代币的 ID</span><br><span class="line">    uint256 public constant GOLD = 1;</span><br><span class="line">    uint256 public constant SILVER = 2;</span><br><span class="line">    uint256 public constant DIAMOND = 3;</span><br><span class="line"></span><br><span class="line">    // 构造函数：设置代币URI</span><br><span class="line">    constructor() ERC1155(&quot;https://game.example/api/token/&#123;id&#125;.json&quot;) &#123;</span><br><span class="line">        // 铸造初始代币</span><br><span class="line">        _mint(msg.sender, GOLD, 1000, &quot;&quot;); // 1000枚 GOLD 代币</span><br><span class="line">        _mint(msg.sender, SILVER, 5000, &quot;&quot;); // 5000枚 SILVER 代币</span><br><span class="line">        _mint(msg.sender, DIAMOND, 100, &quot;&quot;); // 100枚 DIAMOND 代币</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自定义铸造函数</span><br><span class="line">    function mint(uint256 id, uint256 amount) public onlyOwner &#123;</span><br><span class="line">        _mint(msg.sender, id, amount, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自定义批量铸造函数</span><br><span class="line">    function mintBatch(uint256[] memory ids, uint256[] memory amounts) public onlyOwner &#123;</span><br><span class="line">        _mintBatch(msg.sender, ids, amounts, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自定义销毁函数</span><br><span class="line">    function burn(address account, uint256 id, uint256 amount) public &#123;</span><br><span class="line">        require(msg.sender == account, &quot;Only the token owner can burn tokens&quot;);</span><br><span class="line">        _burn(account, id, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自定义批量销毁函数</span><br><span class="line">    function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public &#123;</span><br><span class="line">        require(msg.sender == account, &quot;Only the token owner can burn tokens&quot;);</span><br><span class="line">        _burnBatch(account, ids, amounts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="合约说明">合约说明</h3>
<ol start="5">
<li><strong>ERC1155 基础实现</strong>：</li>
</ol>
<ul>
<li>
<p>我们继承了 OpenZeppelin 的 <code>ERC1155</code> 实现，能够快速实现 ERC-1155 标准的功能。</p>
</li>
<li>
<p><code>ERC1155</code> 构造函数中需要指定一个代币元数据的 URI，可以通过 <code>id</code> 动态替换。</p>
</li>
</ul>
<ol start="6">
<li><strong>代币 ID 和初始铸造</strong>：</li>
</ol>
<ul>
<li>
<p>定义了 3 种代币类型：<code>GOLD</code>（ID 为 1），<code>SILVER</code>（ID 为 2），<code>DIAMOND</code>（ID 为 3）。</p>
</li>
<li>
<p>在合约部署时，分别铸造了 1000、5000 和 100 枚代币。</p>
</li>
</ul>
<ol start="7">
<li><strong>铸造与销毁</strong>：</li>
</ol>
<ul>
<li>
<p>提供了 <code>mint</code> 和 <code>mintBatch</code> 方法供合约所有者调用，用于铸造新的代币。</p>
</li>
<li>
<p>提供了 <code>burn</code> 和 <code>burnBatch</code> 方法允许代币持有者销毁自己的代币。</p>
</li>
</ul>
<ol start="8">
<li><strong>批量操作</strong>：</li>
</ol>
<ul>
<li>我们可以通过 <code>_mintBatch</code> 和 <code>_burnBatch</code> 一次性操作多个代币，极大减少了交易复杂度和成本。</li>
</ul>
<hr>
<h3 id="部署与使用">部署与使用</h3>
<ol start="9">
<li><strong>部署</strong>：</li>
</ol>
<ul>
<li>
<p>使用 Remix 或 Hardhat 部署上面的合约。</p>
</li>
<li>
<p>部署后，合约创建者会自动成为初始代币的持有者。</p>
</li>
</ul>
<ol start="10">
<li><strong>查询余额</strong>：</li>
</ol>
<ul>
<li>
<p>使用 <code>balanceOf</code> 方法查询某个账户的指定代币余额。</p>
</li>
<li>
<p>示例：<code>balanceOf(address, GOLD)</code>。</p>
</li>
</ul>
<ol start="11">
<li><strong>转移代币</strong>：</li>
</ol>
<ul>
<li>
<p>使用 <code>safeTransferFrom</code> 方法将代币发送给其他地址。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 从 msg.sender 转移 10 枚 GOLD 给另一个地址</span><br><span class="line">safeTransferFrom(msg.sender, recipient, GOLD, 10, &quot;&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="12">
<li><strong>批量转移代币</strong>：</li>
</ol>
<ul>
<li>
<p>使用 <code>safeBatchTransferFrom</code> 方法批量转移多个代币。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 从 msg.sender 转移 GOLD 和 SILVER 给另一个地址</span><br><span class="line">uint256[] memory ids = new uint256[](2);</span><br><span class="line">ids[0] = GOLD;</span><br><span class="line">ids[1] = SILVER;</span><br><span class="line"></span><br><span class="line">uint256[] memory amounts = new uint256[](2);</span><br><span class="line">amounts[0] = 10;</span><br><span class="line">amounts[1] = 20;</span><br><span class="line"></span><br><span class="line">safeBatchTransferFrom(msg.sender, recipient, ids, amounts, &quot;&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="ERC-1155-的应用场景">ERC-1155 的应用场景</h3>
<ul>
<li>
<p><strong>游戏资产</strong>：</p>
<ul>
<li>游戏道具、金币、装备等可以用 ERC-1155 统一管理，并支持批量交易。</li>
</ul>
</li>
<li>
<p><strong>数字收藏品</strong>：</p>
<ul>
<li>一个合约中可以包含多种类型的收藏品（如卡牌游戏中的不同稀有度卡片）。</li>
</ul>
</li>
<li>
<p><strong>门票系统</strong>：</p>
<ul>
<li>支持活动门票的发行、转移和销毁，既可以是同质化的（如普通票），也可以是非同质化的（如 VIP 定制票）。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Solidity学习</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>mac新推出的原生容器技术-container</title>
    <url>/2025/06/18/mac%E6%96%B0%E6%8E%A8%E5%87%BA%E7%9A%84%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>地址：<a href="https://github.com/apple/container">container</a><br>
文档：<a href="https://github.com/apple/container/blob/main/docs/tutorial.md">tutorial document</a></p>
<span id="more"></span>
<p>以下是官方教程</p>
<h1 id="Tutorial">Tutorial</h1>
<p>Take a guided tour of <code>container</code> by building, running, and publishing a simple web server image.</p>
<h2 id="Try-out-the-container-CLI">Try out the <code>container</code> CLI</h2>
<p>Start the application, and try out some basic commands to familiarize yourself with the command line interface (CLI) tool.</p>
<h3 id="Start-the-container-service">Start the container service</h3>
<p>Start the services that <code>container</code> uses:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container system start</span><br></pre></td></tr></table></figure>
<p>If you have not installed a Linux kernel yet, the command will prompt you to install one:</p>
<pre>
% container system start

Verifying apiserver is running...
Installing base container filesystem...
No default kernel configured.
Install the recommended default kernel from [https://github.com/kata-containers/kata-containers/releases/download/3.17.0/kata-static-3.17.0-arm64.tar.xz]? [Y/n]: y
Installing kernel...
%
</pre>
<p>Then, verify that the application is working by running a command to list all containers:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container list --all</span><br></pre></td></tr></table></figure>
<p>If you haven’t created any containers yet, the command outputs an empty list:</p>
<pre>
% container list --all
ID  IMAGE  OS  ARCH  STATE  ADDR
%
</pre>
<h3 id="Get-CLI-help">Get CLI help</h3>
<p>You can get help for any <code>container</code> CLI command by appending the <code>--help</code> option:</p>
<pre>
% container --help
OVERVIEW: A container platform for macOS

USAGE: container [--debug] <subcommand>

OPTIONS:
  --debug                 Enable debug output [environment: CONTAINER_DEBUG]
  --version               Show the version.
  -h, --help              Show help information.

CONTAINER SUBCOMMANDS:
  create                  Create a new container
  delete, rm              Delete one or more containers
  exec                    Run a new command in a running container
  inspect                 Display information about one or more containers
  kill                    Kill one or more running containers
  list, ls                List containers
  logs                    Fetch container stdio or boot logs
  run                     Run a container
  start                   Start a container
  stop                    Stop one or more running containers

IMAGE SUBCOMMANDS:
  build                   Build an image from a Dockerfile
  images, image, i        Manage images
  registry, r             Manage registry configurations

SYSTEM SUBCOMMANDS:
  builder                 Manage an image builder instance
  system, s               Manage system components

%
</pre>
<h3 id="Abbreviations">Abbreviations</h3>
<p>You can save keystrokes by abbreviating commands and options. For example, abbreviate the <code>container list</code> command to <code>container ls</code>, and the <code>--all</code> option to <code>-a</code>:</p>
<pre>
% container ls -a
ID  IMAGE  OS  ARCH  STATE  ADDR
%
</pre>
<p>Use the <code>--help</code> flag to see which abbreviations exist.</p>
<h3 id="Set-up-a-local-DNS-domain-optional">Set up a local DNS domain (optional)</h3>
<p><code>container</code> includes an embedded DNS service that simplifies access to your containerized applications. If you want to configure a local DNS domain named <code>test</code> for this tutorial, run:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> container system dns create <span class="built_in">test</span></span><br><span class="line">container system dns default <span class="built_in">set</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>Enter your administrator password when prompted. The first command requires administrator privileges to create a file containing the domain configuration under the <code>/etc/resolver</code> directory, and to tell the macOS DNS resolver to reload its configuration files.</p>
<p>The second command makes <code>test</code> the default domain to use when running a container with an unqualified name. For example, if the default domain is <code>test</code> and you use <code>--name my-web-server</code> to start a container, queries to <code>my-web-server.test</code> will respond with that container’s IP address.</p>
<h2 id="Build-an-image">Build an image</h2>
<p>Set up a <code>Dockerfile</code> for a basic Python web server, and use it to build a container image named <code>web-test</code>.</p>
<h3 id="Set-up-a-simple-project">Set up a simple project</h3>
<p>Start a terminal, create a directory named <code>web-test</code> for the files needed to create the container image:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> web-test</span><br><span class="line"><span class="built_in">cd</span> web-test</span><br></pre></td></tr></table></figure>
<p>In the <code>web-test</code> directory, create a file named <code>Dockerfile</code> with this content:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.io/python:alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /content</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add curl</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span> &gt; index.html</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;http.server&quot;</span>, <span class="string">&quot;80&quot;</span>, <span class="string">&quot;--bind&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>The <code>FROM</code> line instructs the <code>container</code> builder to start with a base image containing the latest production version of Python 3.</p>
<p>The <code>WORKDIR</code> line creates a directory <code>/content</code> in the image, and makes it the current directory.</p>
<p>The first <code>RUN</code> line adds the <code>curl</code> command to your image, and the second <code>RUN</code> line creates a simple HTML landing page named <code>/content/index.html</code>.</p>
<p>The <code>CMD</code> line configures the container to run a simple web server in Python on port 80. Since the working directory is <code>/content</code>, the web server runs in that directory and delivers the content of the file <code>/content/index.html</code> when a user requests the index page URL.</p>
<p>The server listens on the wildcard address <code>0.0.0.0</code> to allow connections from the host and other containers. You can safely use the listen address <code>0.0.0.0</code> inside the container, because external systems have no access to the virtual network to which the container attaches.</p>
<h3 id="Build-the-web-server-image">Build the web server image</h3>
<p>Run the <code>container build</code> command to create an image with the name <code>web-test</code> from your <code>Dockerfile</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container build --tag web-test --file Dockerfile .</span><br></pre></td></tr></table></figure>
<p>The last argument <code>.</code> tells the builder to use the current directory (<code>web-test</code>) as the root of the build context. You can copy files within the build context into your image using the <code>COPY</code> command in your Dockerfile.</p>
<p>After the build completes, list the images. You should see both the base image and the image that you built in the results:</p>
<pre>
% container images list
NAME      TAG     DIGEST
python    alpine  b4d299311845147e7e47c970...
web-test  latest  25b99501f174803e21c58f9c...
%
</pre>
<h2 id="Run-containers">Run containers</h2>
<p>Using your container image, run a web server and try out different ways of interacting with it.</p>
<h3 id="Start-the-webserver">Start the webserver</h3>
<p>Use <code>container run</code> to start a container named <code>my-web-server</code> that runs your webserver:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container run --name my-web-server --detach --<span class="built_in">rm</span> web-test</span><br></pre></td></tr></table></figure>
<p>The <code>--detach</code> flag runs the container in the background, so that you can continue running commands in the same terminal. The <code>--rm</code> flag causes the container to be removed automatically after it stops.</p>
<p>When you list containers now, <code>my-web-server</code> is present, along with the container that <code>container</code> started to build your image. Note that its IP address, shown in the <code>ADDR</code> column, is <code>192.168.64.3</code>:</p>
<pre>
% container ls
ID             IMAGE                                               OS     ARCH   STATE    ADDR
buildkit       ghcr.io/apple/container-builder-shim/builder:0.0.3  linux  arm64  running  192.168.64.2
my-web-server  web-test:latest                                     linux  arm64  running  192.168.64.3
%
</pre>
<p>Open the website, using the container’s IP address in the URL:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open http://192.168.64.3</span><br></pre></td></tr></table></figure>
<p>If you configured the local domain <code>test</code> earlier in the tutorial, you can also open the page with the full hostname for the container:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open http://my-web-server.test</span><br></pre></td></tr></table></figure>
<h3 id="Run-other-commands-in-the-container">Run other commands in the container</h3>
<p>You can run other commands in <code>my-web-server</code> by using the <code>container exec</code> command. To list the files under the content directory, run an <code>ls</code> command:</p>
<pre>
% container exec my-web-server ls /content
index.html
%
</pre>
<p>If you want to poke around in the container, run a shell and issue one or more commands:</p>
<pre>
% container exec --tty --interactive my-web-server sh
/content # ls
index.html
/content # uname -a
Linux my-web-server 6.12.28 #1 SMP Tue May 20 15:19:05 UTC 2025 aarch64 Linux
/content # exit
%
</pre>
<p>The <code>--tty</code> and <code>--interactive</code> flag allow you to interact with the shell from your host terminal. The <code>--tty</code> flag tells the shell in the container that its input is a terminal device, and the <code>--interactive</code> flag connects what you input in your host terminal to the input of the shell in the container.</p>
<p>You will often see these two options abbreviated and specified together as <code>-ti</code> or <code>-it</code>.</p>
<h3 id="Access-the-web-server-from-another-container">Access the web server from another container</h3>
<p>Your web server is accessible from other containers as well as from your host. Launch a second container using your <code>web-test</code> image, and this time, specify a <code>curl</code> command to retrieve the <code>index.html</code> content from the first container.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container run -it --<span class="built_in">rm</span> web-test curl http://192.168.64.3</span><br></pre></td></tr></table></figure>
<p>The output should appear as:</p>
<pre>
% container run -it --rm web-test curl http://192.168.64.3
&lt;!DOCTYPE html>&lt;html>&lt;head>&lt;title>Hello&lt;/title>&lt;/head>&lt;body>&lt;h1>Hello, world!&lt;/h1>&lt;/body>&lt;/html>
%
</pre>
<p>If you set up the <code>test</code> domain earlier, you can achieve the same result with:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container run -it --<span class="built_in">rm</span> web-test curl http://my-web-server.test</span><br></pre></td></tr></table></figure>
<h2 id="Run-a-published-image">Run a published image</h2>
<p>Push your image to a container registry, publishing it so that you and others can use it.</p>
<h3 id="Publish-the-web-server-image">Publish the web server image</h3>
<p>To publish your image, you need push images to a registry service that stores the image for future use. Typically, you need to authenticate with a registry to push an image. This example assumes that you have an account at a hypothetical registry named <code>registry.example.com</code> with username <code>fido</code> and a password or token <code>my-secret</code>, and that your personal repository name is the same as your username.</p>
<blockquote>
<p>[!NOTE]<br>
By default <code>container</code> is configured to use Docker Hub.<br>
You can change the default registry used by running <code>container registry default set &lt;registry url&gt;</code>.<br>
See the other sub commands under <code>container registry</code> for more options.</p>
</blockquote>
<p>To sign into a secure registry with your login credentials, enter your username and password at the prompts after running:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container registry login &#123;registry.example.com&#125;</span><br></pre></td></tr></table></figure>
<p>Create another name for your image that includes the registry name, your repository name, and the image name, with the tag <code>latest</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container images tag web-test &#123;registry.example.com/fido&#125;/web-test:latest</span><br></pre></td></tr></table></figure>
<p>Then, push the image:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container images push &#123;registry.example.com/fido&#125;/web-test:latest</span><br></pre></td></tr></table></figure>
<h3 id="Pull-and-run-your-image">Pull and run your image</h3>
<p>To validate your published image, stop your current web server container, remove the image that you built, and then run using the remote image:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container stop my-web-server</span><br><span class="line">container images delete web-test &#123;registry.example.com/fido&#125;/web-test:latest</span><br><span class="line">container run --name my-web-server --detach --<span class="built_in">rm</span> &#123;registry.example.com/fido&#125;/web-test:latest</span><br></pre></td></tr></table></figure>
<h2 id="Clean-up">Clean up</h2>
<p>Stop your container and shut down the application.</p>
<h3 id="Shut-down-the-web-server">Shut down the web server</h3>
<p>Stop your web server container with:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container stop my-web-server</span><br></pre></td></tr></table></figure>
<p>If you list all running and stopped containers, you will see that the <code>--rm</code> flag you supplied with the <code>container run</code> command caused the container to be removed:</p>
<pre>
% container list --all
ID        IMAGE                                               OS     ARCH   STATE    ADDR
buildkit  ghcr.io/apple/container-builder-shim/builder:0.0.3  linux  arm64  running  192.168.64.2
%
</pre>
<h3 id="Stop-the-container-service">Stop the container service</h3>
<p>When you want to stop <code>container</code> completely, run:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">container system stop</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>工具分享</tag>
      </tags>
  </entry>
  <entry>
    <title>指针vs引用</title>
    <url>/2025/05/11/%E6%8C%87%E9%92%88vs%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h2 id="🧩-总体对比表：Go-vs-Java（指针-vs-引用）">🧩 总体对比表：Go vs Java（指针 vs 引用）</h2>
<table>
<thead>
<tr>
<th>场景编号</th>
<th>场景描述</th>
<th>Go（是否用指针）</th>
<th>Java（是否需要显式指针）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>修改结构体字段</td>
<td>✅ 是，结构体传 <code>*Struct</code></td>
<td>✅ 是，所有对象都是引用</td>
</tr>
<tr>
<td>2</td>
<td>缓存中存对象引用</td>
<td>✅ 是，map[string]*Obj</td>
<td>✅ 是，Map 存对象引用</td>
</tr>
<tr>
<td>3</td>
<td>可选字段（判断是否有传参）</td>
<td>✅ 是，字段类型设为指针</td>
<td>✅ 是，用 boxed 类型判断 null</td>
</tr>
<tr>
<td>4</td>
<td>大结构体传参/返回值</td>
<td>✅ 是，传 <code>*Config</code> 节省复制</td>
<td>✅ 是，对象就是引用</td>
</tr>
<tr>
<td>5</td>
<td>链表/树结构</td>
<td>✅ 是，结构体内嵌指针字段</td>
<td>✅ 是，类字段是引用类型</td>
</tr>
<tr>
<td>6</td>
<td>组合结构体</td>
<td>✅ 是，字段类型为指针</td>
<td>✅ 是，成员变量就是引用</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🔍-分场景详解对比">🔍 分场景详解对比</h2>
<hr>
<h3 id="✅-场景-1：修改结构体字段">✅ 场景 1：修改结构体字段</h3>
<h4 id="Go：">Go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateName</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">	u.Name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java：">Java：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateName</span><span class="params">(User u)</span> &#123;</span><br><span class="line">	u.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 <strong>区别：</strong></p>
<ul>
<li>Go 需要用 <code>*User</code> 明确是指针，否则值传递会拷贝。</li>
<li>Java 所有对象传参天然是引用，直接修改。</li>
</ul>
<hr>
<h3 id="✅-场景-2：缓存中引用对象">✅ 场景 2：缓存中引用对象</h3>
<h4 id="Go：-2">Go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cache := <span class="keyword">map</span>[<span class="type">string</span>]*Product&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java：-2">Java：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Product&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>📌 <strong>区别：</strong></p>
<ul>
<li>Go 明确用 <code>*Product</code>，节省内存。</li>
<li>Java 中 <code>Product</code> 是引用，不需要额外操作。</li>
</ul>
<hr>
<h3 id="✅-场景-3：可选字段（如-API-请求中可能未传）">✅ 场景 3：可选字段（如 API 请求中可能未传）</h3>
<h4 id="Go：-3">Go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UpdateUserRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name *<span class="type">string</span> <span class="comment">// 可判断是否传</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java：-3">Java：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateUserRequest</span> &#123;</span><br><span class="line">	String name; <span class="comment">// 默认 null 就是“没传”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 <strong>区别：</strong></p>
<ul>
<li>Go 需要用指针来区分“没传” vs “传了默认值”。</li>
<li>Java 所有对象默认可能是 <code>null</code>，可以直接用 <code>if (req.name != null)</code> 判断。</li>
</ul>
<hr>
<h3 id="✅-场景-4：返回或传入大型配置对象">✅ 场景 4：返回或传入大型配置对象</h3>
<h4 id="Go：-4">Go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConfig</span><span class="params">()</span></span> *Config &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Config&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java：-4">Java：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config <span class="title function_">loadConfig</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 <strong>区别：</strong></p>
<ul>
<li>Go：返回指针防止复制整个结构体。</li>
<li>Java：默认就是返回引用，天然高效。</li>
</ul>
<hr>
<h3 id="✅-场景-5：链表、树等结构体">✅ 场景 5：链表、树等结构体</h3>
<h4 id="Go：-5">Go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="type">int</span></span><br><span class="line">	Next *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java：-5">Java：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 <strong>区别：</strong></p>
<ul>
<li>Go 要用 <code>*Node</code> 明确引用关系。</li>
<li>Java 中 <code>Node</code> 字段天然就是引用类型。</li>
</ul>
<hr>
<h3 id="✅-场景-6：组合结构体">✅ 场景 6：组合结构体</h3>
<h4 id="Go：-6">Go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	User *User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java：-6">Java：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">	User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 <strong>区别：</strong></p>
<ul>
<li>Go 中组合用指针字段可避免复制。</li>
<li>Java 所有类字段本身就是引用，默认行为就是组合。</li>
</ul>
<hr>
<h2 id="🧠-总结：Go-vs-Java-指针-引用哲学">🧠 总结：Go vs Java 指针/引用哲学</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>Go</th>
<th>Java</th>
</tr>
</thead>
<tbody>
<tr>
<td>值 vs 引用</td>
<td>区分明确（值类型 vs 指针）</td>
<td>所有对象默认是引用</td>
</tr>
<tr>
<td>是否需要手动加 <code>*</code></td>
<td>✅ 是，需要指明引用</td>
<td>❌ 不需要</td>
</tr>
<tr>
<td>内存管理</td>
<td>自动垃圾回收（有指针但无手动 free）</td>
<td>自动垃圾回收</td>
</tr>
<tr>
<td>安全性</td>
<td>不支持指针运算，较安全</td>
<td>更安全，无裸指针</td>
</tr>
<tr>
<td>可选字段建模</td>
<td>通过 <code>*T</code> 判断是否设置</td>
<td>判断 <code>null</code></td>
</tr>
<tr>
<td>性能优化（避免复制）</td>
<td>手动使用指针传参</td>
<td>默认就是引用传递</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="📌-总结一句话：">📌 总结一句话：</h2>
<blockquote>
<p>Java 和 Go 在实际开发中都大量使用“引用”，区别在于：<strong>Go 需要你手动声明使用指针，而 Java 默认一切对象就是引用。</strong></p>
</blockquote>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Concurrent multi-threaded tasks in real life?</title>
    <url>/2026/01/20/%E6%80%8E%E6%A0%B7%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>研究生的第一个学期结束了，总觉得没太多的收获，学习上没有什么进步，不论是科研还是技术上，甚至是认知上，似乎浑浑噩噩地度过了半年。回顾这一学期，中间有开辟很多很多小的分支，有很多想学的东西，但是最终却没有一个完整做完的。有时候是突然的科研工作、有时候又是课程任务、还有心境和生活变故，似乎生活总是有数不尽变化，不论是外因还是内因总有事情打断前一个阶段学习计划。但是每个人其实应是如此，每个人每天的想法也会不断的改变，每天都可能发生特殊的事情或更高优先级的工作要去做。所以得好好想想该怎么并发地处理多线程的任务？</p>
</blockquote>
<hr>
<h2 id="问题">问题</h2>
<p>核心是未适配研究生阶段多任务、高突发的学习生活节奏，导致各类学习计划频繁被打断，最终事事搁置、半途而废。</p>
<p>问题拆解：</p>
<ul>
<li><strong>任务管理逻辑错位</strong>：用本科生 “线性固定计划” 应对研究生 “非线性高变动” 场景，无明确优先级划分，想做的事分支多、无主次，突发任务无缓冲时间，直接挤占原有计划，导致计划全盘被打破。</li>
<li><strong>任务推进模式不合理</strong>：以 “完成完整任务” 为唯一目标，一旦被打断就觉得 “无价值、白忙活”，缺乏碎片化的有效积累，也让半途而废的可惜感被放大。</li>
<li><strong>断点衔接能力缺失</strong>：任务被搁置后无任何记录，再次拾起时需花费时间回忆进度和内容，形成明显心理负担，因做事的惯性问题，最终导致搁置的事彻底荒废。</li>
<li><strong>心态与评价标准偏差</strong>：仍以本科生 “事事做完、标准化进步” 为自我期待，无法接受研究生阶段 “不完美的完成”，忽略了碎片化成长的常态；只关注技术、科研等显性收获，无视应对突发、多任务处理、压力下做事等隐性能力的积累，学期末复盘时过度放大 “未完成” 的遗憾，陷入自我否定。</li>
</ul>
<hr>
<h2 id="思考">思考</h2>
<p>我觉得应该从多个方面来化解这种困境</p>
<p>[] 既然现实注定孤独无聊，那就应该无视多数不必要的交互，保持注意力在个人提升上这一件事上；<br>
[] 需要一套更好地执行体系，不能任由小的分析被搁置抛弃，追求碎片化成长；<br>
[] 调整到正确的心态：大道就在脚下，只管走就行，胜利之风会从背后吹来；</p>
<hr>
<h2 id="解决">解决</h2>
<blockquote>
<p>研究生阶段的核心矛盾，从 “按计划完成单一任务” 变成了 “在多线程、高突发、高优先级波动的环境里，守住自己的核心成长主线”。研究生的成长从来不是 “把一件事从头到尾完美做完”，而是 “在混乱的多任务里，抓准「可积累的有效片段」，并建立「断点续传」的能力”</p>
</blockquote>
<h3 id="第一步：重构任务管理逻辑">第一步：重构任务管理逻辑</h3>
<pre><code>研究生阶段的计划，核心不是 “定时间、定内容”，而是定优先级、定 “最小推进单元”、留足缓冲
</code></pre>
<h4 id="1-做「三层任务清单」，只抓-“核心层”-的积累，其余都是-“适配层”">1. 做「三层任务清单」，只抓 “核心层” 的积累，其余都是 “适配层”</h4>
<ul>
<li>
<p>核心层（1-2 件）：决定本学期/阶段核心成长的事，是哪怕被突发打断，也要挤碎片时间守住「最小推进」的事。<br>
✅ <em>关键：核心层永远只留 1-2 件，多了等于没有，对抗混乱的 “定海神针”，哪怕所有事都被打断，只要核心层的事有持续的小推进，就不会有 “毫无收获” 的感觉。</em></p>
</li>
<li>
<p>适配层（2-3 件）：必须做、但优先级随外部变化的事，比如课程作业、期末复习、科研加急任务、日常杂事。这类事的原则是 <strong>“随叫随到、见缝插针、完成即止”</strong>，不追求完美，只追求达标（比如期末复习不追求考 90，只求过线 / 拿到基础分，把时间省回核心层）。</p>
</li>
<li>
<p>拓展层（不限）：想学、但暂时没优先级的事，比如额外的技术博客、新的编程语言、兴趣类学习。这类事的原则是 <strong>“有时间就做，没时间就放，完全无心理负担”</strong>，把它当成 “加餐”，而不是 “必完成的正餐”，避免因为这类事搁置而产生可惜感。</p>
</li>
</ul>
<h4 id="2-设定「最小推进单元」，制造推进感">2. 设定「最小推进单元」，制造推进感</h4>
<p>核心是：哪怕被突发打断，也能说 “我今天完成了这个任务的 1 个最小单元，它是有成果的”，而不是 “我又没学完，白忙活了”。这些最小单元的成果，会像积木一样，慢慢堆成完整的任务，哪怕中途搁置，也有 “看得见的积累”。</p>
<p>例如：看一个章节博客、算法每日一题、看半篇论文等等，每个最小单元时间不能长，重点在不能停的<strong>不断积累</strong>。</p>
<h4 id="3-每天留「30-的空白时间」，专门应对突发，不挤占核心层">3. 每天留「30% 的空白时间」，专门应对突发，不挤占核心层</h4>
<p>以往所有的搁置，都是因为 “突发任务没有预留时间，只能挤掉原有计划”，比如科研加急、期末复习、家人就医，这些事无法预测，但可以用 “留白” 来应对。</p>
<p>每天的时间规划，不排满，而是只排 70% 的时间给核心层和适配层的固定推进，剩下 30% 的时间完全空白，作为 “突发缓冲区”：</p>
<ul>
<li>如果当天没突发，这 30% 就用来推进核心层，或者补拓展层的内容；</li>
<li>如果当天有突发（比如科研要加急），就用这 30% 来处理，实在不够再少量挤占适配层的时间，<strong>绝对不碰核心层的最小推进时间</strong>。</li>
</ul>
<h3 id="第二步：建立断点恢复机制">第二步：建立断点恢复机制</h3>
<pre><code>“人做事有惯性，想再次拾起之前的进度有心理负担，学了一半没完成可惜”，
问题的本质不是 “进度没跟上”，而是 “忘记了自己之前学到哪、学到了什么，重新拾起需要花时间回忆，
这个回忆的过程就是最大的心理负担”。
</code></pre>
<p><strong>解决方法：在每次被打断、不得不搁置任务时，花 5 分钟做「断点记录」，这 5 分钟，能帮你消除后续 90% 的拾起重担。</strong></p>
<p>「断点记录」：</p>
<ul>
<li><strong>当前进度</strong>：精准到具体位置；</li>
<li><strong>已掌握核心</strong>：提炼已经学会的关键知识点；</li>
<li><strong>待推进内容</strong>：下一步要做的具体事；</li>
<li><strong>未解决疑问</strong>：记录暂时没懂的点；</li>
</ul>
<h3 id="第三步：心态重构">第三步：心态重构</h3>
<p>研究生第一学期看清一点事实：</p>
<ul>
<li>本科生的成长是 <strong>「线性的、标准化的」</strong> ：按课程表上课，按考试要求复习，完成作业、通过考试，就是收获，有明确的评价标准；</li>
<li>研究生的成长是 <strong>「非线性的、碎片化的」</strong>：科研可能做了 3 个月没结果，技术学了一半被搁置，课程只是辅助，收获没有明确的评价标准，甚至很多收获是 “隐性的”—— 比如应对突发的能力、多任务处理的能力、在压力下挤时间做事的能力，这些都是你这一学期的收获，很多时候只是没把它们当成 “收获” 而已。</li>
</ul>
<p>所以，首先要和自己和解，接受 “这学期就是在试错、在适应”，并在后面的学期里采纳以下的心态：</p>
<ul>
<li>
<p><strong>放弃 “事事做完” 的执念，追求 “事事有积累”</strong><br>
研究生的收获，从来不是 “完整的作品”，而是 “散落在各个任务里的、能被你提取和复用的能力 / 知识”。</p>
</li>
<li>
<p><strong>把 “突发和变动” 当成研究生的「必修课」，而不是「干扰项」</strong><br>
科研的突发需求、课程的临时任务、生活的意外变故，这些不是 “倒霉”，而是研究生阶段必须面对的「现实」—— 未来职场，只会有更多的突发和多任务，而研究生阶段，就是在相对宽容的环境里，练习 “在混乱中保持成长” 的能力。<br>
<em>学会了 “如何判断任务优先级”“如何在压力下挤时间做事”“如何处理生活和学习的平衡”，这些能力，比学会一个技术博客更重要。</em></p>
</li>
<li>
<p><strong>用「月度小复盘」代替「学期大复盘」，及时捕捉自己的收获</strong></p>
<ul>
<li>这一个月，核心层的任务完成了哪些「最小推进单元」？</li>
<li>这一个月，遇到了哪些突发？我是怎么应对的？</li>
<li>下一个月，核心层要不要调整？断点记录有没有补全？</li>
</ul>
</li>
</ul>
<p>这种短周期的复盘，能清晰地看到自己的积累，不会等到学期末才陷入 “毫无收获” 的自我否定，也能及时调整自己的任务和方法，避免问题越攒越多。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>芜杂心绪</tag>
      </tags>
  </entry>
  <entry>
    <title>敌手-挑战者博弈模型</title>
    <url>/2025/07/08/%E6%95%8C%E6%89%8B-%E6%8C%91%E6%88%98%E8%80%85%E5%8D%9A%E5%BC%88%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在密码学与网络空间安全中，<strong>“敌手-挑战者博弈（Adversary-Challenger Game）”</strong> 是一种常用的<strong>安全模型分析方法论</strong>。它用于<strong>形式化地定义和分析安全目标</strong>，评估加密算法或协议的抗攻击能力。该模型基于博弈论思想，将协议的交互过程抽象为一个<strong>敌手与挑战者之间的博弈过程</strong>，强调从攻击者视角出发进行建模和分析。</p>
<span id="more"></span>
<h1 id="密码学与网络空间安全中的“敌手-挑战者”博弈模型理论分析方法">密码学与网络空间安全中的“敌手 - 挑战者”博弈模型理论分析方法</h1>
<h2 id="一、背景与基本概念">一、背景与基本概念</h2>
<p>在密码学和网络安全领域，为了<strong>形式化地定义“安全”</strong>，我们通常采用一种标准方法：<strong>敌手-挑战者博弈模型（Adversary-Challenger Game Model）</strong>。</p>
<p>该模型源于博弈论思想，将加密系统或协议的交互抽象为一场博弈：</p>
<ul>
<li><strong>挑战者（Challenger）</strong>：代表系统环境，负责生成密钥、处理查询等；</li>
<li><strong>敌手（Adversary）</strong>：模拟攻击者，利用可获得的信息尝试破坏系统安全性；</li>
<li><strong>安全游戏（Game）</strong>：定义交互规则，用来判断系统是否能抵抗某种攻击。</li>
</ul>
<hr>
<h2 id="二、模型结构与分析流程">二、模型结构与分析流程</h2>
<h3 id="1-博弈模型结构">1. 博弈模型结构</h3>
<p>安全博弈通常包含以下步骤：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>安全参数设定</td>
<td>挑战者接收安全参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span>，如密钥长度</td>
</tr>
<tr>
<td>初始化</td>
<td>生成系统参数，如密钥对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><mi>s</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(pk, sk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>查询阶段</td>
<td>敌手可以调用系统接口，如加密/解密、签名等</td>
</tr>
<tr>
<td>挑战阶段</td>
<td>敌手发起挑战，挑战者返回“挑战密文”等响应</td>
</tr>
<tr>
<td>再查询阶段</td>
<td>敌手继续查询（有限制）</td>
</tr>
<tr>
<td>输出阶段</td>
<td>敌手输出猜测，判断是否攻击成功</td>
</tr>
</tbody>
</table>
<h3 id="2-敌手能力模型">2. 敌手能力模型</h3>
<p>不同攻击假设下，敌手拥有的能力不同：</p>
<ul>
<li><strong>被动攻击（Passive Adversary）</strong>：仅观察通信过程；</li>
<li><strong>主动攻击（Active Adversary）</strong>：可注入、篡改消息；</li>
<li><strong>选择明文攻击（CPA）</strong>：敌手可选择明文并查看其密文；</li>
<li><strong>选择密文攻击（CCA）</strong>：敌手可提交密文并得到解密结果。</li>
</ul>
<hr>
<h2 id="三、典型安全定义与游戏示例">三、典型安全定义与游戏示例</h2>
<h3 id="1-IND-CPA：选择明文攻击下的不可区分性">1. IND-CPA：选择明文攻击下的不可区分性</h3>
<p>目标：敌手无法区分加密后的两个明文。</p>
<p><strong>游戏定义：</strong></p>
<ol>
<li>挑战者生成密钥对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><mi>s</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(pk, sk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">pk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>；</li>
<li>敌手可查询任意明文 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，获得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>n</mi><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Enc(pk, m_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</li>
<li>敌手提交 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>m</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m_0, m_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，要求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>m</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>m</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|m_0| = |m_1|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>；</li>
<li>挑战者随机选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">b \in \{0,1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>，返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>E</mi><mi>n</mi><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><msub><mi>m</mi><mi>b</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c = Enc(pk, m_b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</li>
<li>敌手输出猜测 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">b&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>；</li>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">b&#x27; = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，攻击成功。</li>
</ol>
<p><strong>安全性定义：</strong> 若对任意 PPT（多项式时间）敌手 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，其成功概率满足：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Pr</mi><mo>⁡</mo><mo stretchy="false">[</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>b</mi><mo stretchy="false">]</mo><mo>≤</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mtext>negl</mtext><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pr[b&#x27; = b] \leq \frac{1}{2} + \text{negl}(\lambda)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mop">Pr</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">negl</span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span></span></p>
<p>则该加密方案是 IND-CPA 安全的。</p>
<hr>
<h3 id="2-EUF-CMA：抗选择消息攻击的签名不可伪造性">2. EUF-CMA：抗选择消息攻击的签名不可伪造性</h3>
<p>目标：敌手不能伪造合法签名。</p>
<p><strong>游戏流程：</strong></p>
<ol>
<li>挑战者生成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><mi>s</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(pk, sk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">pk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>；</li>
<li>敌手提交消息 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，获得签名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><mo>=</mo><mi>S</mi><mi>i</mi><mi>g</mi><mi>n</mi><mo stretchy="false">(</mo><mi>s</mi><mi>k</mi><mo separator="true">,</mo><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_i = Sign(sk, m_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</li>
<li>敌手输出伪造对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mo>∗</mo></msup><mo separator="true">,</mo><msup><mi>σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m^*, \sigma^*)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</li>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">m^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 未被查询，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>f</mi><mi>y</mi><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><msup><mi>m</mi><mo>∗</mo></msup><mo separator="true">,</mo><msup><mi>σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mtext>true</mtext></mrow><annotation encoding="application/x-tex">Verify(pk, m^*, \sigma^*) = \text{true}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord text"><span class="mord">true</span></span></span></span></span>，则攻击成功。</li>
</ol>
<p><strong>安全定义：</strong> 若敌手成功伪造的概率为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Pr</mi><mo>⁡</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>m</mi><mo>∗</mo></msup><mo mathvariant="normal">∉</mo><mo stretchy="false">{</mo><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>and </mtext><mi>V</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>f</mi><mi>y</mi><mo stretchy="false">(</mo><mi>p</mi><mi>k</mi><mo separator="true">,</mo><msup><mi>m</mi><mo>∗</mo></msup><mo separator="true">,</mo><msup><mi>σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mtext>true</mtext></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>≤</mo><mtext>negl</mtext><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pr\left[\begin{array}{l}
m^* \notin \{m_i\} \\
\text{and } Verify(pk, m^*, \sigma^*) = \text{true}
\end{array}\right] \leq \text{negl}(\lambda)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mop">Pr</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">and </span></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">true</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">negl</span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span></span></p>
<p>则该签名方案是 EUF-CMA 安全的。</p>
<hr>
<h2 id="四、安全优势与概率分析">四、安全优势与概率分析</h2>
<p>设敌手 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的成功概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_A(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span>，则其**安全优势（advantage）**定义为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>Adv</mtext><mi>A</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">∣</mo><msub><mi>p</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>p</mi><mn>0</mn></msub><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Adv}_A(\lambda) = \left| p_A(\lambda) - p_0 \right|
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">Adv</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是随机猜测的概率（如 IND-CPA 中为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>）。</p>
<p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Adv</mtext><mi>A</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Adv}_A(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">Adv</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span> 为<strong>可忽略函数（negligible function）</strong>，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mtext>多项式 </mtext><mi>p</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∃</mi><msub><mi>λ</mi><mn>0</mn></msub><mo separator="true">,</mo><mtext>当 </mtext><mi>λ</mi><mo>&gt;</mo><msub><mi>λ</mi><mn>0</mn></msub><mo separator="true">,</mo><mtext>有 </mtext><msub><mtext>Adv</mtext><mi>A</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mfrac><mn>1</mn><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\forall \text{多项式 } p(\lambda), \exists \lambda_0, \text{当 } \lambda &gt; \lambda_0, \text{有 }
\text{Adv}_A(\lambda) &lt; \frac{1}{p(\lambda)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord text"><span class="mord cjk_fallback">多项式</span><span class="mord"> </span></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∃</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord cjk_fallback">当</span><span class="mord"> </span></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord cjk_fallback">有</span><span class="mord"> </span></span><span class="mord"><span class="mord text"><span class="mord">Adv</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2574em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>则系统是安全的。</p>
<hr>
<h2 id="五、典型应用场景">五、典型应用场景</h2>
<ul>
<li><strong>加密系统安全性分析：</strong> RSA、ElGamal、ECC 等</li>
<li><strong>数字签名方案安全性：</strong> DSA、Schnorr、ECDSA</li>
<li><strong>零知识证明协议：</strong> ZK-SNARK、Bulletproofs</li>
<li><strong>安全多方计算协议（MPC）</strong></li>
<li><strong>协议验证工具：</strong> ProVerif、CryptoVerif、Tamarin</li>
</ul>
<hr>
<h2 id="六、总结：实践建议">六、总结：实践建议</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>明确安全目标</td>
<td>是机密性？不可伪造？还是匿名性？</td>
</tr>
<tr>
<td>确定敌手能力</td>
<td>定义敌手可操作的范围（如 CCA 模型）</td>
</tr>
<tr>
<td>选用标准游戏模型</td>
<td>如 IND-CPA、IND-CCA、EUF-CMA 等</td>
</tr>
<tr>
<td>形式化证明安全性</td>
<td>通过 reduction 归约到难题（如 CDH、RSA）</td>
</tr>
<tr>
<td>实际验证和仿真</td>
<td>可使用自动验证工具模拟交互和分析</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>椭圆曲线加密算法(ECC)</title>
    <url>/2025/06/17/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考：<a href="https://www.jianshu.com/p/e41bc1eb1d81">简书-椭圆曲线加密算法</a></p>
<span id="more"></span>
<h1 id="椭圆曲线加密算法（ECC）：从数学原理到工程实践">椭圆曲线加密算法（ECC）：从数学原理到工程实践</h1>
<p>椭圆曲线加密算法（Elliptic Curve Cryptography, ECC）是现代密码学中最具效率的非对称加密技术之一。与 RSA 等传统算法相比，它能以更短的密钥长度实现同等安全强度，这使其在移动设备、区块链等对算力和存储敏感的场景中得到广泛应用。本文将从数学原理出发，逐步解析 ECC 的核心概念与实现逻辑。</p>
<h2 id="一、ECC-的诞生与优势：密码学的效率革命">一、ECC 的诞生与优势：密码学的效率革命</h2>
<p>1985 年，Neal Koblitz 和 Victor Miller 分别独立提出了椭圆曲线在密码学中的应用，开创了非对称加密的新方向。ECC 的核心优势在于<strong>密钥长度与安全强度的高效比</strong>：</p>
<ul>
<li>160 位 ECC 加密的安全性相当于 1024 位 RSA 加密</li>
<li>210 位 ECC 加密的安全性相当于 2048 位 RSA 加密</li>
</ul>
<p>这种优势源于椭圆曲线上的离散对数问题（ECDLP）的数学难度——已知点 G 和 xG 求 x 的计算复杂度极高，而正向计算 xG 则相对容易，这种&quot;单向性&quot;构成了 ECC 的安全基础。</p>
<h2 id="二、椭圆曲线的数学定义与几何直观">二、椭圆曲线的数学定义与几何直观</h2>
<h3 id="2-1-椭圆曲线的代数表达式">2.1 椭圆曲线的代数表达式</h3>
<p>一般情况下，椭圆曲线可用三次方程表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E: y² = ax³ + bx² + cx + d</span><br></pre></td></tr></table></figure>
<p>其中系数 a,b,c,d 需满足特定条件（如判别式非零，确保曲线光滑无奇点）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E: y² = x³ - 2x + 4</span><br></pre></td></tr></table></figure>
<p>该曲线的几何图像并非传统椭圆形，而是呈现出独特的双弧形态，这也是椭圆曲线名称的历史渊源（与椭圆积分相关）。<br>
注：图形可以参考原文</p>
<h3 id="2-2-椭圆曲线上的几何运算规则">2.2 椭圆曲线上的几何运算规则</h3>
<p>椭圆曲线密码学的核心在于定义了一套点集上的代数运算，这些运算基于几何直观设计：</p>
<h4 id="（1）加法运算（A-B-C）">（1）加法运算（A + B = C）</h4>
<ul>
<li>过曲线上两点 A、B 作直线，与曲线交于第三点</li>
<li>该点关于 x 轴的对称点即为 A+B 的结果</li>
</ul>
<h4 id="（2）二倍运算（2A）">（2）二倍运算（2A）</h4>
<ul>
<li>当两点重合（A=B）时，作 A 点的切线</li>
<li>切线与曲线的交点关于 x 轴对称点即为 2A</li>
</ul>
<h4 id="（3）正负取反（-A）">（3）正负取反（-A）</h4>
<ul>
<li>点 A 关于 x 轴的对称点定义为-A，满足 A + (-A) = O（O 为无穷远点）</li>
</ul>
<h4 id="（4）无穷远点（O）">（4）无穷远点（O）</h4>
<ul>
<li>定义为椭圆曲线的加法单位元，满足 A + O = A</li>
<li>当直线垂直于 x 轴时，视为与无穷远点相交</li>
</ul>
<h2 id="三、有限域上的椭圆曲线：从连续到离散的密码学适配">三、有限域上的椭圆曲线：从连续到离散的密码学适配</h2>
<p>实数域上的椭圆曲线是连续光滑的曲线，但密码学需要离散化的数学结构。有限域 GF(p)（p 为质数）的引入解决了这一问题：</p>
<h3 id="3-1-有限域-GF-p-的定义">3.1 有限域 GF(p)的定义</h3>
<ul>
<li>由 0,1,2,…,p-1 共 p 个元素组成</li>
<li>运算规则为模 p 加法、乘法和逆运算</li>
</ul>
<h3 id="3-2-有限域上的椭圆曲线方程">3.2 有限域上的椭圆曲线方程</h3>
<p>以 GF(23)为例，曲线方程表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y² ≡ x³ + x + 1 (mod 23)</span><br></pre></td></tr></table></figure>
<p>此时曲线不再是连续曲线，而是有限个离散点的集合。例如：</p>
<ul>
<li>点(1,7)满足 7²=49≡49-2×23=3 mod23，而 1³+1+1=3，等式成立</li>
<li>点(0,1)的负点为(0,22)，因-1 mod23=22（这体现了有限域中元素的对称性，即若(x, y)在曲线上，则(x, -y mod p)也在曲线上）</li>
</ul>
<h3 id="3-3-有限域上的点运算公式">3.3 有限域上的点运算公式</h3>
<p>设椭圆曲线为 y² = x³ + ax + b，在 GF(p)上两点 P(Xp,Yp)、Q(Xq,Yq)的加法规则为：</p>
<p>当 P≠-Q 时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">λ = (Yq - Yp)/(Xq - Xp) mod p</span><br><span class="line">Xr = (λ² - Xp - Xq) mod p</span><br><span class="line">Yr = (λ(Xp - Xr) - Yp) mod p</span><br></pre></td></tr></table></figure>
<p>当 P=Q 时（二倍运算）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">λ = (3Xp² + a)/(2Yp) mod p</span><br><span class="line">Xr = (λ² - 2Xp) mod p</span><br><span class="line">Yr = (λ(Xp - Xr) - Yp) mod p</span><br></pre></td></tr></table></figure>
<p><strong>计算示例</strong>：在 GF(23)上以 G=(0,1)计算 2G：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">λ = (3×0² + 1)/(2×1) mod23 = 1×12 mod23 = 12（因2×12=24≡1 mod23，故2的逆元为12）</span><br><span class="line">Xr = (12² - 0 - 0) mod23 = 144 mod23 = 144-6×23=6</span><br><span class="line">Yr = (12×(0-6) - 1) mod23 = (-73) mod23 = (-73+4×23)=19</span><br><span class="line">∴2G=(6,19)</span><br></pre></td></tr></table></figure>
<h2 id="四、ECC-加解密原理：基于离散对数问题的安全机制">四、ECC 加解密原理：基于离散对数问题的安全机制</h2>
<h3 id="4-1-密钥生成机制">4.1 密钥生成机制</h3>
<ul>
<li>私钥 k：随机选取的大整数</li>
<li>公钥 K：K = kG，其中 G 为椭圆曲线上的基点</li>
</ul>
<h3 id="4-2-加密过程">4.2 加密过程</h3>
<ul>
<li>发送方选择随机数 r，明文 M 映射为曲线上的点</li>
<li>密文 C 由点对组成：C = {rG, M + rK}</li>
</ul>
<h3 id="4-3-解密过程">4.3 解密过程</h3>
<ul>
<li>接收方用私钥 k 计算：M + rK - k(rG) = M + r(kG) - k(rG) = M</li>
<li>利用代数性质消除随机数 r 的影响，还原明文</li>
</ul>
<p><strong>安全性核心</strong>：从 K=kG 推导 k 的过程等价于椭圆曲线离散对数问题（ECDLP），目前没有多项式时间算法可破解。</p>
<h2 id="五、ECDSA-签名算法：从加密到完整性验证">五、ECDSA 签名算法：从加密到完整性验证</h2>
<p>椭圆曲线数字签名算法（ECDSA）是 ECC 在签名场景的应用，其流程如下：</p>
<h3 id="5-1-签名生成">5.1 签名生成</h3>
<ol>
<li>对消息 M 计算哈希 h = SHA256(M)</li>
<li>选择随机数 r，计算点 rG=(x,y)</li>
<li>计算签名值 s = (h + kx)/r mod p</li>
<li>签名结果为{rG 的 x 坐标, s}</li>
</ol>
<h3 id="5-2-签名验证">5.2 签名验证</h3>
<ol>
<li>接收方计算消息哈希 h’</li>
<li>计算验证值：h’G/s + xK/s</li>
<li>若结果等于 rG，则签名有效</li>
</ol>
<p><strong>数学原理</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h&#x27;G/s + xK/s = (h&#x27; + xk)G/s = r(h&#x27; + xk)G/(h&#x27; + xk) = rG</span><br></pre></td></tr></table></figure>
<p>利用公钥 K=kG 实现了无需私钥的签名验证。</p>
<h2 id="六、Go-语言实现：ECC-签名与验证的工程实践">六、Go 语言实现：ECC 签名与验证的工程实践</h2>
<p>以下是使用 Go 语言实现 ECDSA 签名与验证的完整代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 待签名明文</span></span><br><span class="line">	message := []<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成签名密钥对</span></span><br><span class="line">	key, err := NewSigningKey()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;密钥生成失败:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行签名</span></span><br><span class="line">	signature, err := Sign(message, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;签名失败:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;签名结果: %x\n&quot;</span>, signature)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 验证签名</span></span><br><span class="line">	<span class="keyword">if</span> !Verify(message, signature, &amp;key.PublicKey) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;验证失败！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;验证成功！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成ECDSA签名密钥对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSigningKey</span><span class="params">()</span></span> (*ecdsa.PrivateKey, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 使用P256曲线（NIST推荐的256位椭圆曲线）</span></span><br><span class="line">	<span class="keyword">return</span> ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数据进行ECDSA签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(data []<span class="type">byte</span>, privkey *ecdsa.PrivateKey)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 计算消息哈希</span></span><br><span class="line">	digest := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行签名，得到r和s</span></span><br><span class="line">	r, s, err := ecdsa.Sign(rand.Reader, privkey, digest[:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 格式化签名数据（补全字节长度以保证兼容性）</span></span><br><span class="line">	params := privkey.Curve.Params()</span><br><span class="line">	curveOrderByteSize := params.P.BitLen() / <span class="number">8</span></span><br><span class="line">	rBytes, sBytes := r.Bytes(), s.Bytes()</span><br><span class="line">	signature := <span class="built_in">make</span>([]<span class="type">byte</span>, curveOrderByteSize*<span class="number">2</span>)</span><br><span class="line">	<span class="built_in">copy</span>(signature[curveOrderByteSize-<span class="built_in">len</span>(rBytes):], rBytes)</span><br><span class="line">	<span class="built_in">copy</span>(signature[curveOrderByteSize*<span class="number">2</span>-<span class="built_in">len</span>(sBytes):], sBytes)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> signature, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证ECDSA签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Verify</span><span class="params">(data, signature []<span class="type">byte</span>, pubkey *ecdsa.PublicKey)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 计算消息哈希</span></span><br><span class="line">	digest := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析签名数据</span></span><br><span class="line">	curveOrderByteSize := pubkey.Curve.Params().P.BitLen() / <span class="number">8</span></span><br><span class="line">	r, s := <span class="built_in">new</span>(big.Int), <span class="built_in">new</span>(big.Int)</span><br><span class="line">	r.SetBytes(signature[:curveOrderByteSize])</span><br><span class="line">	s.SetBytes(signature[curveOrderByteSize:])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行签名验证</span></span><br><span class="line">	<span class="keyword">return</span> ecdsa.Verify(pubkey, digest[:], r, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码实现了完整的 ECDSA 流程，包括密钥生成、消息哈希、签名生成与验证，使用了 Go 标准库中的<code>crypto/ecdsa</code>包，底层基于 P256 椭圆曲线（NIST 推荐的 secp256r1 曲线）。</p>
<h2 id="七、ECC-的现实应用与未来趋势">七、ECC 的现实应用与未来趋势</h2>
<h3 id="7-1-典型应用场景">7.1 典型应用场景</h3>
<ul>
<li><strong>区块链</strong>：比特币、以太坊等加密货币使用 ECDSA 作为账户签名算法</li>
<li><strong>TLS/SSL</strong>：ECC 已成为 HTTPS 连接的主流密钥交换方式之一</li>
<li><strong>物联网</strong>：低功耗设备因 ECC 的算力优势优先选择该算法</li>
<li><strong>数字签名</strong>：各国电子政务、金融系统中的合规签名方案</li>
</ul>
<h3 id="7-2-技术挑战与发展">7.2 技术挑战与发展</h3>
<ul>
<li><strong>量子计算威胁</strong>：Shor 算法理论上可破解 ECC，但当前量子计算机尚未达到实用化规模</li>
<li><strong>标准化进程</strong>：不同组织（NIST、SECG、中国 SM2 等）推出了不同的曲线标准</li>
<li><strong>性能优化</strong>：侧信道攻击防护、标量乘法优化仍是研究热点</li>
</ul>
<h2 id="结语：数学之美与密码学的融合">结语：数学之美与密码学的融合</h2>
<p>椭圆曲线加密算法完美诠释了&quot;数学即密码&quot;的理念——看似抽象的三次曲线几何性质，通过有限域的离散化处理，成为保护数字世界的基石。随着计算技术的发展，ECC 在保持安全优势的同时，将在更多场景中替代传统加密算法，持续守护信息时代的安全边界。</p>
<p><strong>参考资源</strong>：</p>
<ul>
<li>Neal Koblitz《Elliptic Curve Cryptography》</li>
<li>SECG 标准《SEC 1: Elliptic Curve Cryptography》</li>
<li>NIST 联邦信息处理标准 FIPS 186-4</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>硕导双选奇遇记</title>
    <url>/2025/06/15/%E7%A1%95%E5%AF%BC%E5%8F%8C%E9%80%89%E5%A5%87%E9%81%87%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（宇宙安全申明：本文纯属虚构，是做梦遇到的一个小故事，挺有趣的记录下来，故事主人公是鼠鼠，我是alan，所以跟我没关系采用第一人称叙述而已，如不幸有读者感到自己是故事中的角色，请勿对号入座，纯属巧合）</p>
<h2 id="硕导双选奇遇记">硕导双选奇遇记</h2>
<p>鼠鼠这两天忙完了导师双选的事，总的来说不是很顺利，但是结果还不错，过程中的一些事实在不吐不快，于是有了这样一篇小故事。</p>
<hr>
<h3 id="第一回-考前筹谋择师事-初阅官牒慕高贤">第一回 考前筹谋择师事 初阅官牒慕高贤</h3>
<p>对于选择导师这件事情，也许是看多了研究生跳楼退学的新闻，鼠鼠还是非常重视这件事的，甚至在考试前就已经在想未来会拜入怎样的师门。<br>
首先是在报考的时候，我就本着不忘初心的想法和一定的录取策略选择了网安区块链专业，那时候我还傻乎乎以为这样我就一定可以继续学习我感兴趣的领域。<br>
后来听一些朋友介绍，说大部分的导师应该都是机器学习为主，我就想着实在没办法也可以接受，虽然我没有AI方面的基础，但是勤能补拙，我觉得也行。<br>
最后到考试结束，我赶紧开始浏览学校官网看老师的信息，发现有几位导师大牛在区块链领域颇有建设，这会儿我就开始幻想加入人家的团队学习新的知识了哈哈。</p>
<hr>
<h3 id="第二回-投笺鸿儒无回音-转寻誉师始相逢">第二回 投笺鸿儒无回音 转寻誉师始相逢</h3>
<p>我开始认真准备自己的简历和邮件，准备给几位大牛教授发送申请，这时候才2月份，成绩刚出来，鼠鼠应该是最早的一批毛遂自荐的考生（排除本校爷的话）。我首先给系里口碑最好，实力最强劲的一位大牛导师G发送邮件。结果等了两天仍然未接收（网易邮箱有查看邮件是否已读的功能），随后我联系到一个学校里的学长，好巧不巧他正是G老师的学生，我就问他这件事，然后他告诉我老师不收专硕。虽然也听说过有这种情况，但是鼠鼠还是比较震惊哈哈，想着也许确实专硕低人一等吧。然后我又投了另一位区块链领域的教授L，这位教授学术成就很厉害但是口碑一般，我想着自己小心一点，乖乖求学不惹他生气就行。结局也是一样的，几天也没有已读。有点小失落。</p>
<p>然后我就感觉得应该把思路打开了，不能局限于区块链，于是我开始上网看一些导师评价网，买一些导师评价信息，联系学校的学长打听导师推荐，贴吧小红书知乎各种论坛搜索等等等等，做了很多的努力来调查。</p>
<p>最后得到了一位老师J，他也是故事的主角，这位导师在各个资料和论坛的评价中都是一致好评，具体来说就是，他专注做横向，并且给学生的每月补助很丰厚，一个月能达到几千元，资料上说可以实习，对于在读的学生来说可以说是很诱人了。我也非常心动，我想着还是向现实妥协吧，有钱拿，毕了业还能有一笔启动资金也不错，暂时放弃自己的梦想吧…此时还是比较伤感的嘤嘤嘤。</p>
<p>但是这才是折磨的开始，老师J的后续骚操作可以说是眼花缭乱，毫无逻辑和底线。此时是2月底，我给J发送了邮件附上自己的详细简历，结果当天夜里就收到了回复，但是ta并未提及任何具体有效信息，都是一些客套话，大致内容是：“感谢信任，双选联系，我的微信xxx”（信任二字记住，后面要考）。按理来说，以鼠鼠的性格此时应该能察觉出不对劲（猜测这人大概是没有认真看我的信息和简历），但是，由于之前的受挫，这回得到J的回复让鼠鼠异常的开心。</p>
<p>我开开心心地加上J的微信，准备和他交流分享一下彼此情况，我想着大事成矣。结果加上之后没有聊什么实质性的内容，ta就发了一些客套话（复试加油之类的），所以我也不知道怎么开口聊下去，想着复试之后拿成绩说话吧。此时按照网上的一些经验分享来说，加上微信基本上就已经稳了，我也问了一些读研的朋友他们也说已经稳了，不用在意，基本已经进组了。</p>
<p>所以一个月后鼠鼠开开心心地去北京考试，由于鼠鼠初试排名还是比较靠前的，所以复试也没有很大压力。临考前，我给J发了一条信息询问第二天复试结束是否需要到ta那里去进行单独的一个面试，我想着来都来了，拜见交流一下也挺好。结果ta说不用，双选前咱们互通有无（这句话记住，后面要考）。</p>
<hr>
<h3 id="第三回-誉师忽疏频劝退-遍访他门路多舛">第三回 誉师忽疏频劝退 遍访他门路多舛</h3>
<p>没过多久复试成绩也出来了（四月），我的总分排名还不错，于是第一时间告知了J，并且询问双选是什么时候开始（此时我傻乎乎并不知道双选是六月的事，我以为成绩出来很快就会进行），被告知的是系统是他们团队做的，很快上线。我此时心想这位老师有点实力，想着进组之后也可以开发各种东西，实在是不错，还有工资。本着真心换真心的想法，就没打算再找其他导师。</p>
<p>过了一段时间，我想着需不需要在开学前学点什么预备知识的，于是询问J老师（此时我是认为我已经基本算进组了）。但是等了十天左右也没有回复我的微信消息，于是我又写了一封邮件发过去较为正式地询问这件事，其中暗暗表达了不确定现在是否接收的疑问。</p>
<p>但是J并未回复邮件，至此我觉的事情不太对劲就直截了当地去微信问：为什么不理我，是不是不要我。J的回复的意思是还没开始双选，正式录取再双选。随后我说我的同学均已联系好导师，有些甚至开始干活了。后面J的回复是系统没上线，建议我再去找别的导师（这里就很诡异，无缘无故劝退学生没有给理由，时至今日我才知道原因），他接着表达自己这里非常多工作继续劝退和系统是他们团队开发的（提前吐槽一下，系统做的也就一般般）。</p>
<p>此时我的想法发生了转变，因为实在想不到一个愿意主动加微信的老师会劝退我，而且完全完全没有深入交流的意思，这一点是非常反常识的，一味地说一些没有营养的话。我的理解是他确实很忙，忙到自己的招生工作也不顾不上。后面得知，J的日常是早上六七点干到晚上十一二点，每天都要开会，等于变相的每日打卡（其实这也是人家课题组的特点，时至今日，鼠鼠作为外人也不会做出倾向性评价，只是阐述实际情况，喜欢这种模式的同学肯定也是有的，鼠鼠只评价关于招生发生的一些小故事）。说实话，J的语言表达上一直很客气，比较有礼貌，只是行为动机实在是难以捉摸，几乎透露任何信息。</p>
<p>在经历J莫名其妙的极力劝退之后，我又尝试联系了几位副教授，有愿意继续交流的但是要等指标的、有傲慢无礼的、有交流费劲突然消失的…总之就是体验不太好，所以我就想着这位等指标的老师也许可以考虑，但是也没和他说太多，此时还是想优先J这边的事，毕竟都加上微信了。</p>
<hr>
<h3 id="第四回-骤临考校勤备试-久候明师意惘然">第四回 骤临考校勤备试 久候明师意惘然</h3>
<p>再到五月份，J突然发了一个考核，里面有一些课题或者工作，需要自行选择方向去完成（主要是实验复现和一个竞赛）。虽然有点难，但是鼠鼠想着提升竞争力就答应了。然后的这一个月，鼠鼠不能说全心全意搞吧（因为迷上了Go语言，看鼠鼠这段时间的其他博客也可以发现），但是绝对说得上是认真弄了，各种材料都有准备，看论文、总结、找复现实验、跑通、做汇报PPT、找朋友练习汇报等等。说实话，了解鼠鼠的帅读者们应该知道，鼠鼠之前有一点职场经验，所以相比其他学生有一定的劳动意识，正常情况下是不会给别人白打工浪费时间的，但是遇到J老师的这种“学生身份也不是，什么承诺都没给”的情况下，我愿意去做这个作业已经是非常给面子了，算得上是真心换真心了。</p>
<p>结果很快就到六月了，我心想着不是互通有无的吗？团长，你tm人呢！？于是在我便询问J什么时候考核他说还要等，然后又来劝退说是组里很忙，都等了你这么久了，你自己什么都不表态，也不跟我沟通，搞什么飞机。我寻思着考验我呢，我就说我加入的意愿比较强烈，其实确实也是此，毕竟为了信任这位全网好评的名师也没有准备退路。</p>
<hr>
<h3 id="第五回-双选系统忽开启-徒众传讯语朦胧">第五回 双选系统忽开启 徒众传讯语朦胧</h3>
<p>等着等着有一天双选系统竟然开放了，我吓了一跳，考核呢？测试选拔学生呢？确实他说要等双选之后，但是说好的双选前的“互通有无”呢，这几个月什么有营养的话都没有，像个客服一样打哈哈，什么也不透露。都到这一步了，努力不想白费，于是鼠鼠又跟个傻子一样等，到了系统开放半天后，我去问他什么时候开始，他又说系统里没我的信息，我才意识到原来还要先占我一个志愿，于是我提交了考核材料并添加到了一志愿，并且仅仅填了他一个志愿。</p>
<p>然后，忙碌的J又不说话了，此时我已经非常着急非常生气了，双选一共就五天时间，已经为了你浪费了一天了，我不明白其他的参选者怎么坐得住的。到了晚上，J派了一个本校提请进组的学生（goutuizi）来接待我（此人疑似高级AI或者做过tb客服，说话跟人机一样，后文简称为客服），他告诉我第二天下午开始考核，我不能理解难道时间很充足吗？双选一共只有五天时间，为什么还等到下午？那么下午被J淘汰的学生该怎么办，靠谱的导师第一天绝对已经没有名额吧？</p>
<p>鼠鼠气得爆炸，然后问客服能不能介绍一下J的课题组，先提前了解一下，看看有什么魅力。结果客服说没法透露，但是鼠鼠知道，是她自己懒得扯皮。后面是又问了考核结果的offer可不可以拒绝，小客服跑去请示了其他“领导”，告诉我不可以。然后便不了了之，鼠鼠感觉跟这种不太聪明的人也问不出什么有价值的东西。</p>
<p>说明一下，到目前为止，鼠鼠的道心已然破碎，因为一直很重视这件事，从二月份以来，拿不定的事情都会问问弓神或者龙哥，结果被狠狠地摆了一道。但是从始至终鼠鼠和他们所有人的沟通都是好好地，有礼貌地进行，鼠鼠是江南地区的人，我觉得礼貌是交往合作的基础，别人和你打招呼一定要有回应，也许个别架子大的蛮夷不讲究这些也没办法，现在终究只是个穷学生，但是内心里决不能低人一等。</p>
<hr>
<h3 id="第六回-试前时辰遭屏退-怒斥倨师泄愤懑">第六回 试前时辰遭屏退 怒斥倨师泄愤懑</h3>
<p>到了第二天，上午鼠鼠找到了之前等待指标确定的老师和另一个学长推荐的导师，但是二位老师遗憾表示名额已满，我又相继给两三位导师和之前玩失踪的两位导师发送了邮件，但是也都已读不回，此时我想着只能寄托于下午的考核认真表现了。中午吃饭的时候鼠鼠收到了客服来的信息，气得直接把饭都扔了。</p>
<p>客服直接说（以下是原文，没有艺术加工）：“您好同学，下午的面试您不用参加了，系统上已经给您拒绝掉了，不好意思同学，老师这边名额有限，不好意思”。跟个客服一样，一口气叽里咕噜发了这些，我直接就懵逼了，啊？什么玩意儿？发生啥了？难道我有不知道犯罪前科吗，直接把我拒了？</p>
<p>此时距离下午的面试仅有一个多小时，我的电脑已经准备好了PPT播放页面，也已经练习试讲了好几次。我首先问为什么，我解释说我在二月就一直给J表达自己的意愿，也认真准备了考核，也把他放在第一志愿并且没有填其他志愿。客服说是我昨天问的关于拒收offer的问题“不太好”，我解释说：系统是你们开发的，我问的是这个双选会的机制里有没有反选的情况，而且我本人的表现到底哪里有问题？客服跟人机一样回复：同学我只负责通知，具体情况我也不清楚，可能我们团队不适合你（确实，你们这种团队确实不适合我，但是是你们配不上我，一群德不配位的家伙），现在你可以选择其他导师了祝你有个更好选择。</p>
<p>鼠鼠气的冒烟，但是很快得出结论：跟这个人机交流不会有任何结果。所以直接找到了J，问他这是怎么回事，给出一个更官方的答复。到此时此刻，鼠鼠的状态是有着前几名的分数排名和应该优于绝大部分人的简历经历，但是却没有没有任何的offer和与其他导师沟通的进展。J很快做出回应称自己很忙很忙，真的很忙，要做运维，马上来查看情况，感谢信任（回收时间线，又来谈信任是吧，你这种人不负责的人究竟值得什么信任，现在对你J老师只有满满怒气值）。我说我只要一个公平，这时候我已经根本不想跟这帮人打交道，更正不用提进组打工了，我只想要属于我的公平的待遇，我答应你做了，你他喵的就得验收。</p>
<p>过了一段时间，J打来电话解释一些东西，基本就是他单方面输出，巴拉巴拉地讲个不停不让我讲话。以下是信息汇总（括号中的是鼠鼠的艺术加工）：</p>
<ul>
<li>我很忙，真的很忙，非常忙</li>
<li>系统是我们团队开发的，所以我不能监守自盗，招生的事情交给手下在处理，账号也给他们了</li>
<li>我真的超级忙，一直在做运维，下午还要监考四六级</li>
<li>我这个系统规则设计很好的（就是一不小心没告诉你们而已）</li>
<li>我的计划是保障大家不会被耽误，尽快的能成功确定关系（开始幻想上了）</li>
<li>我收到了七十多封邮件（一不小心忘记筛选了，一不小心就全部加上微信，一不小心没有告诉你们我啥也没做，一不小心把你们一大帮蒙在鼓里的学生养在池子里）</li>
<li>我已经筛选的不少不“信任”我的人了（确实他们是幸运的，也是聪明的），还有你们二十个愣头青“信任”我的杀进了决赛（但是也没什么了不起，我是不会提前和你们沟通的，因为我很忙，你们这些人并不重要）</li>
<li>我这里名额很有限，保研和非全已经收了一次了，大概还剩三四个名额（一不小心也忘记告诉你们了）</li>
<li>这次的事情我不知道，是手下学生做的（我很忙的）</li>
<li>我们团队非常的忙，从早忙到晚，每天开会，一般人顶不住，但是我给钱，也安排毕业工作</li>
<li>给你两个选择：当做无事发生你自己耗子尾汁 or 让手下把系统恢复回去下午继续面试</li>
</ul>
<p>一部分长得帅的读者应该发现了，J老师并没有觉得整件事有什么问题，没座！！是人机手下的错，是鼠鼠我的错。<br>
一部分不太聪明的读者会说“老师那么忙，那能怎么办？”，那我问你，写一个团队介绍文档讲清楚情况劝退一部分同学行不行？这么厉害个团队做个官网行不行？官网上设计一个初步的学生意向收集整理系统行不行？双选之前那么长时间挤出那么一点来处理招生行不行？一开始就派手下来接待一下有想法的考生行不行？最简单的你J老师抽出十分钟更新一下自己的学校官网主页信息行不行？</p>
<p>鼠鼠不是什么爱因斯坦，就是个普通学生，竟然也能随便想出这么多可行的措施。那么鼠鼠不禁要问，J老师这么在这么优秀的团队的集思广益之下，难道就搞不定这种小事吗？我看是压根就没有往这上面用心，把新生当工具看</p>
<p>事件也分析的差不多了，接下来是鼠鼠的火力输出时间：你个比亚迪自己收研究生自己不管，教出来的学生尽做蠢事，考核面试自己也不参加那还考尼玛呢，你也确实是聪明人之前口口声声说考核选拔优秀学生，参加不了了改口说是开个小会聊一下不是考核，双选之前什么都不做什么信息也不透露（除了团队很忙）当大忙人赚大钱，说好的互通有无的承诺狗屁都没有，一句有价值的话都没有和学生交流过尽说客服套话，满嘴的感谢信任虚伪至极从未把招生这件事放在心上凭什么要学生信任你，毫无底线地延期考核导致部分学生没有退路找不到合适的导师影响后面的学业…(气绝身亡，吾命休矣，骂不动了)</p>
<p>回到故事中，最后鼠鼠选择参加他们的面试，其实并不想进他们的组，只是觉得这是我应得的东西，很奇怪明明我应该赶紧找下家的，这样明显不明智，但是可能实在咽不下这口气，想去证明一下他们课题组根本不值得我参加，大概是这样的想法。</p>
<p>后来客服让我进入了面试，参会的人员是两位学长和这个客服。首先，做了个自我介绍，我就把邮件里的自我介绍又念了一遍，看了邮件的导师又何必整这一波呢，哦，原来是导师压根不在。学长说我还可以继续下一项，汇报一下考核作业，我寻思着开始讲PPT呢，他们说不用，讲讲就行，我愣了一下之后简单介绍了一下我看的论文和复现的实验，然后他们针对这个提了几个简单问题。</p>
<p>面试的后半段就是闲聊，大概是两部分：问问我的情况，我问问他们的情况。首先是我自己说了一下自身情况，主要是表达了我喜欢做开发工作，对于J老师安排的银行之类的文书类的工作不感兴趣。然后就是他们组的逆天强度，忙的跟陀螺一样，每天开会，做不完的工作，压力巨大，实习是想都不要想。值得注意的一点，学长有特意问一个耐人寻味的问题，帅读者们自己品一品：你对于领导不明智的决策怎么看？哈哈哈有点好笑，鼠鼠的回答是联想到了去年在公司上班时候的事，我说我接受不了这种独断不明智的领导，前公司领导就是这样来着。随后我又随便问了一些问题避免尴尬。后来一个学长想说什么东西来着，估计是不能说的内容，被另一个学长直接制止住了：xxx你不要说了，也挺有意思，可惜没听清想说什么。最后就随便聊一聊就结束了，走之前我也明确说了：我推测你们大概率不会要我的。</p>
<p>完事儿，我就去志愿系统上把他们刚刚给我恢复的志愿信息给删了，抱歉没有一点信任了，再也不见了吧浪费我几个月。</p>
<hr>
<h3 id="第七回-转投链学遇知音-一见投契定师徒">第七回 转投链学遇知音 一见投契定师徒</h3>
<p>鼠鼠带着非常沮丧的心情继续寻找合适的导师，我不甘心等学院随机分配没人要的导师，找了两个教授发了邮件，还是已读不回。怎么说呢，不知礼数，非君子之交也，算了算了，我又把他们的志愿给取消了。</p>
<p>后来，我又想到了新的思路，没必要和这些傲慢无礼的教授扯皮，我想年轻教师也是不错的选择。所以我又看起了教师名目的最后一页，大部分是青年教师，我注意到一位做区块链方向的老师Q，老师是Top2毕业的感觉非常有实力，于是开始了解Q老师的相关研究，发现都很有意思也和我的爱好非常契合。所以我就给Q老师发去了申请邮件和简历。</p>
<p>Q老师回信说看了我的信息觉得我的相关经历和积累与ta的研究领域相匹配，欢迎进一步交流，随后我们加了微信交换了想法，一拍即合，老师人很好，愿意给我保留名额等我确定，所以也很快确定了指导关系。总的来说，Q老师确实是最适合鼠鼠的导师，有我喜欢的研究领域，有相差不大的年龄差距，有自由的学术环境，有我向往的职业规划，五颗星给五颗星！！</p>
<p>至此鼠鼠的双选奇遇记也算是完结撒花了。</p>
<p>真是一个很有趣梦</p>
<hr>
<p>版权说明：</p>
<ul>
<li>本小说涉及所有内容的解释权以及其他所有权利均归alan所有</li>
<li>禁止任何形式的篡改</li>
<li>禁止任何形式的书面传播</li>
<li>禁止对故事中相似的人物进行任何形式的人身攻击和开盒攻击</li>
<li>所有读者的个人行为均与alan无关</li>
<li>本小说永不再其他互联网平台传播，如有雷同均与alan无关</li>
<li>如有侵犯上述条款，个人需付法律责任</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
  </entry>
  <entry>
    <title>区块链中的椭圆曲线加密算法概述</title>
    <url>/2025/06/29/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深入解析区块链中的椭圆曲线加密算法（ECC）">深入解析区块链中的椭圆曲线加密算法（ECC）</h2>
<p>本文将讨论 ECC 的核心原理，揭示它如何为区块链构建坚不可摧的安全防线。</p>
<h3 id="1-椭圆曲线的基础">1. 椭圆曲线的基础</h3>
<p>要理解 ECC，我们首先需要了解<strong>椭圆曲线</strong>。在数学上，一条椭圆曲线可以由以下方程表示：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y^2 = x^3 + ax + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 是常数，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mn>27</mn><msup><mi>b</mi><mn>2</mn></msup><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">4a^3 + 27b^2 \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">27</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>（这个条件确保曲线没有奇点，即没有尖点或自交点）。</p>
<p>在加密学中，我们使用的椭圆曲线通常是在<strong>有限域</strong>上定义的。这意味着曲线上的所有点 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>) 都必须是整数，并且所有的运算（加法、乘法等）都在一个模数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 下进行。这个模数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 通常是一个很大的素数。</p>
<h3 id="2-椭圆曲线上的“加法”运算">2. 椭圆曲线上的“加法”运算</h3>
<p>椭圆曲线上定义了一种特殊的“加法”运算。这不是简单的数值相加，而是一种几何操作。</p>
<p>给定椭圆曲线上的两个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>：</p>
<ul>
<li><strong>点加法 (Point Addition):</strong> 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo mathvariant="normal">≠</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P \neq Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>，连接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> 的直线会与椭圆曲线相交于第三个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>。我们将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 关于 x 轴对称的点定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>+</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P+Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>。</li>
<li><strong>点倍增 (Point Doubling):</strong> 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P = Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>，我们作曲线在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 点的切线，这条切线会与椭圆曲线相交于第三个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">R&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>。我们将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">R&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 关于 x 轴对称的点定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>P</mi></mrow><annotation encoding="application/x-tex">2P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>。</li>
</ul>
<p>这些操作都有严格的代数公式来计算，确保了结果依然在曲线上。</p>
<h3 id="3-私钥与公钥的生成">3. 私钥与公钥的生成</h3>
<p>在 ECC 中：</p>
<ol>
<li>
<p><strong>私钥 (Private Key):</strong> 你的私钥是一个随机选取的整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 必须保密，它的长度决定了加密强度。例如，比特币使用的是 256 位的私钥。</p>
</li>
<li>
<p><strong>基点 (Generator Point, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>):</strong> 这是一个预先定义的、所有人都知道的椭圆曲线上的特定点。不同的椭圆曲线标准（如比特币使用的 <code>secp256k1</code>）会指定不同的基点。</p>
</li>
<li>
<p><strong>公钥 (Public Key):</strong> 你的公钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 是通过私钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 对基点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次“点加法”（即点倍增的重复运算）得到的：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>k</mi><mo>×</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">P = k \times G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></p>
<p>这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 表示椭圆曲线上的标量乘法，本质上就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>+</mo><mi>G</mi><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">G + G + \dots + G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次）。</p>
<p>由于椭圆曲线离散对数问题 (ECDLP) 的难度，即使知道公钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和基点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>，也很难反推出私钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。这就是 ECC 安全性的核心所在。</p>
</li>
</ol>
<h3 id="4-数字签名与验证">4. 数字签名与验证</h3>
<p>ECC 在区块链中最重要的应用是<strong>数字签名</strong>，它用于证明交易的发送者身份，并确保交易内容未被篡改。</p>
<h4 id="4-1-签名过程">4.1 签名过程</h4>
<p>假设 Alice 想发送一笔交易，她会执行以下步骤：</p>
<ol>
<li>
<p><strong>计算消息哈希：</strong> 首先，Alice 会对交易数据（称为“消息” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>）计算一个哈希值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>H</mi><mi>A</mi><mi>S</mi><mi>H</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = HASH(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。这个哈希值是一个固定长度的字符串，对消息的任何微小改动都会导致哈希值发生巨大变化。</p>
</li>
<li>
<p><strong>生成随机数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>：</strong> Alice 随机选择一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>（称为“临时密钥”或“随机数”），并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 不能与私钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 相同，且每次签名都必须不同。</p>
</li>
<li>
<p><strong>计算签名分量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">R_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：</strong> 计算椭圆曲线上的点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi>r</mi><mo>×</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">R = r \times G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>。取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 点的 x 坐标，并将其模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>（曲线的阶，一个大的素数）后得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">R_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</li>
<li>
<p><strong>计算签名分量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>：</strong> 根据以下公式计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><msub><mi>R</mi><mi>x</mi></msub><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s = (h + R_x \times k) \times r^{-1} \pmod{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是 Alice 的私钥，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">r^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 在模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 意义下的乘法逆元。</p>
</li>
<li>
<p><strong>生成签名：</strong> 最终的数字签名就是一对数值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_x, s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>。</p>
</li>
</ol>
<h4 id="4-2-验证过程">4.2 验证过程</h4>
<p>当 Bob 收到 Alice 的交易和签名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_x, s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> 时，他需要验证这个签名的有效性：</p>
<ol>
<li>
<p><strong>计算消息哈希：</strong> Bob 也会对接收到的交易数据计算哈希值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>H</mi><mi>A</mi><mi>S</mi><mi>H</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = HASH(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p>
</li>
<li>
<p><strong>计算辅助值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>u</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">u_1, u_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo><mi>h</mi><mo>×</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u_1 = h \times s^{-1} \pmod{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo><msub><mi>R</mi><mi>x</mi></msub><mo>×</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u_2 = R_x \times s^{-1} \pmod{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">s^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 在模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 意义下的乘法逆元。</p>
</li>
<li>
<p><strong>计算验证点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">P&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>：</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msub><mi>u</mi><mn>1</mn></msub><mo>×</mo><mi>G</mi><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><mo>×</mo><msub><mi>P</mi><mrow><mi>p</mi><mi>u</mi><mi>b</mi></mrow></msub><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P&#x27; = u_1 \times G + u_2 \times P_{pub} \pmod{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 是基点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>p</mi><mi>u</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{pub}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 是 Alice 的公钥。</p>
</li>
<li>
<p><strong>比较：</strong> 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">P&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 的 x 坐标等于签名中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">R_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>），则签名有效，表示交易确实由 Alice 发送且未被篡改。</p>
</li>
</ol>
<h3 id="5-ECC-的安全性与优势">5. ECC 的安全性与优势</h3>
<p>ECC 的安全性依赖于<strong>椭圆曲线离散对数问题 (ECDLP)</strong> 的计算难度。在有限域上，已知 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>k</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">P = kG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">G</span></span></span></span>，在计算上从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 中找出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是极其困难的，即使是现代超级计算机也需要极其漫长的时间。</p>
<p>相较于传统的 RSA 算法，ECC 在相同安全强度下，所需的密钥长度更短。这意味着：</p>
<ul>
<li><strong>更小的存储空间：</strong> 区块链中的交易数据量庞大，更短的公钥和签名有助于节省存储空间。</li>
<li><strong>更快的计算速度：</strong> 密钥长度的缩短直接提升了加密、解密和签名、验证的速度，这对于高吞吐量的区块链网络至关重要。</li>
<li><strong>更低的带宽消耗：</strong> 在网络传输中，更短的数据量可以减少带宽占用。</li>
</ul>
<h3 id="6-标准曲线与参数">6. 标准曲线与参数</h3>
<p>在实际应用中，ECC 并非任意选择曲线和参数。为了确保互操作性和安全性，通常会使用一些标准化的椭圆曲线，例如比特币和以太坊都使用的 <strong><code>secp256k1</code></strong>。这个标准定义了曲线的方程 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span></span></span> 的值)、模数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>、基点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 以及阶 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 等所有必要参数。</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>简单DEX合约案例</title>
    <url>/2025/06/02/%E7%AE%80%E5%8D%95DEX%E5%90%88%E7%BA%A6%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单流动性合约-Simple-Liquidity-Pool-学习文档">简单流动性合约 (Simple Liquidity Pool) 学习文档</h1>
<h2 id="1-引言">1. 引言</h2>
<p>本文档旨在介绍一个简化的流动性合约，其设计思想来源于 UniswapV2 的 Pair 合约。通过学习这个简单的合约，你将了解去中心化交易平台中流动性池子的基本运作原理。</p>
<h2 id="2-核心概念">2. 核心概念</h2>
<p>在深入代码之前，我们需要了解几个核心概念：</p>
<ul>
<li><strong>流动性提供者 (Liquidity Provider, LP)</strong>：向流动性池子中存入两种代币的用户。</li>
<li><strong>流动性池子 (Liquidity Pool)</strong>：一个存储了两种或多种代币的智能合约，用于支持交易。</li>
<li><strong>流动性代币 (LP Tokens)</strong>：当流动性提供者存入代币时，合约会铸造代表其在池子中份额的 LP 代币给他们。</li>
<li><strong>储备量 (Reserves)</strong>：池子中每种代币的存量。</li>
<li><strong>恒定乘积公式 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x \times y = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>)</strong>: 这是 UniswapV2 等 AMM (Automated Market Maker) 的核心。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 分别代表池子中两种代币的储备量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是一个（在没有交易费用时）保持不变的常数。这个公式决定了交易的价格。</li>
<li><strong>滑点 (Slippage)</strong>：由于交易会改变池子中的储备量，导致执行价格与预期价格之间的差异。较大的交易通常会有更高的滑点。</li>
</ul>
<h2 id="3-合约结构概览">3. 合约结构概览</h2>
<p>我们实现的 <code>SimpleLiquidityPool</code> 合约主要包含以下几个部分：</p>
<ul>
<li><strong>状态变量</strong>: 存储合约的关键信息，如代币地址、储备量、LP 代币总供应量等。</li>
<li><strong>事件</strong>: 用于记录合约中发生的关键操作，方便在链下追踪。</li>
<li><strong>构造函数</strong>: 在合约部署时初始化。</li>
<li><strong>内部函数</strong>: 执行一些底层操作，例如更新储备量、铸造和销毁 LP 代币、安全地转移代币。</li>
<li><strong>外部函数</strong>: 允许用户与合约交互的主要接口，例如提供流动性 (<code>mint</code>)、移除流动性 (<code>burn</code>)、进行代币交换 (<code>swap</code>)。</li>
<li><strong>修饰器 (Modifier)</strong>: 用于修改函数的行为，例如这里的 <code>lock</code> 用于简单的重入保护。</li>
</ul>
<h2 id="4-代码详解">4. 代码详解</h2>
<h3 id="4-1-导入">4.1. 导入</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>IERC20.sol</code>: 导入 ERC-20 代币的标准接口，使得我们的合约可以与任何符合 ERC-20 标准的代币进行交互。</li>
<li><code>SafeMath.sol</code>: 导入 SafeMath 库，用于执行安全的算术运算，防止溢出。</li>
</ul>
<h3 id="4-2-合约声明和状态变量">4.2. 合约声明和状态变量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SimpleLiquidityPool &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    IERC20 public token0;</span><br><span class="line">    IERC20 public token1;</span><br><span class="line">    uint256 public reserve0;</span><br><span class="line">    uint256 public reserve1;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    uint256 constant MINIMUM_LIQUIDITY = 10**3;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>token0</code> 和 <code>token1</code>: 存储这个流动性池子支持的两种 ERC-20 代币的合约地址。</li>
<li><code>reserve0</code> 和 <code>reserve1</code>: 记录当前池子中 <code>token0</code> 和 <code>token1</code> 的储备数量。</li>
<li><code>totalSupply</code>: 记录流动性代币（LP tokens）的总发行量。</li>
<li><code>balanceOf</code>: 一个映射，记录每个地址拥有的 LP 代币数量。</li>
<li><code>MINIMUM_LIQUIDITY</code>: 在首次提供流动性时，会有一小部分 LP 代币发送到零地址并永久锁定，这是为了防止 <code>totalSupply</code> 在初始状态为零时可能导致的一些除零错误。</li>
</ul>
<h3 id="4-3-事件">4.3. 事件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event Mint(address indexed sender, uint256 amount0, uint256 amount1);</span><br><span class="line">event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);</span><br><span class="line">event Swap(</span><br><span class="line">    address indexed sender,</span><br><span class="line">    uint256 amount0In,</span><br><span class="line">    uint256 amount1In,</span><br><span class="line">    uint256 amount0Out,</span><br><span class="line">    uint256 amount1Out,</span><br><span class="line">    address indexed to</span><br><span class="line">);</span><br><span class="line">event Sync(uint256 reserve0, uint256 reserve1);</span><br></pre></td></tr></table></figure>
<p>这些事件在合约执行关键操作时发出，例如提供流动性 (<code>Mint</code>)、移除流动性 (<code>Burn</code>)、代币交换 (<code>Swap</code>) 和同步储备量 (<code>Sync</code>)。这对于在区块链外部追踪合约的状态非常有用。</p>
<h3 id="4-4-构造函数">4.4. 构造函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(IERC20 _token0, IERC20 _token1) &#123;</span><br><span class="line">    token0 = _token0;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数在合约部署时被调用，用于初始化 <code>token0</code> 和 <code>token1</code> 的地址。</p>
<h3 id="4-5-内部函数">4.5. 内部函数</h3>
<ul>
<li><code>_update(uint256 balance0, uint256 balance1)</code>: 更新 <code>reserve0</code> 和 <code>reserve1</code> 的值，并触发 <code>Sync</code> 事件。</li>
<li><code>_mint(address to, uint256 value)</code>: 增加 <code>totalSupply</code> 并将 <code>value</code> 数量的 LP 代币分配给地址 <code>to</code>。</li>
<li><code>_burn(address from, uint256 value) returns (uint256 amount0, uint256 amount1)</code>: 销毁地址 <code>from</code> 的 <code>value</code> 数量的 LP 代币，并根据其在总供应量中的比例计算出应返还的 <code>token0</code> 和 <code>token1</code> 的数量。</li>
<li><code>_safeTransfer(IERC20 token, address to, uint256 value)</code>: 安全地转移 ERC-20 代币，如果转移失败会触发 <code>require</code> 错误。</li>
</ul>
<h3 id="4-6-外部函数">4.6. 外部函数</h3>
<ul>
<li>
<p><strong><code>mint(address to)</code> (提供流动性)</strong>:</p>
<ul>
<li>计算用户存入的两种代币数量。</li>
<li>如果是首次提供流动性（<code>totalSupply</code> 为 0），则根据几何平均值计算铸造的 LP 代币数量，并永久锁定 <code>MINIMUM_LIQUIDITY</code>。</li>
<li>否则，根据用户提供的代币相对于现有储备的比例来计算铸造的 LP 代币数量。</li>
<li>将计算出的 LP 代币铸造给流动性提供者。</li>
<li>更新储备量。</li>
<li>触发 <code>Mint</code> 事件。</li>
</ul>
</li>
<li>
<p><strong><code>burn(address to) returns (uint256 amount0, uint256 amount1)</code> (移除流动性)</strong>:</p>
<ul>
<li>获取调用者拥有的 LP 代币数量。</li>
<li>根据其持有的 LP 代币占总供应量的比例，计算出应返还的两种代币数量。</li>
<li>销毁调用者的 LP 代币。</li>
<li>将计算出的两种代币返还给调用者。</li>
<li>更新储备量。</li>
<li>触发 <code>Burn</code> 事件。</li>
</ul>
</li>
<li>
<p><strong><code>swap(uint256 amount0Out, uint256 amount1Out, address to)</code> (代币交换)</strong>:</p>
<ul>
<li>要求用户指定想要输出的一种代币的数量 (<code>amount0Out</code> 或 <code>amount1Out</code>)，另一个输出量必须为 0。</li>
<li>根据恒定乘积公式 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x \times y = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>) 计算用户需要输入的另一种代币的数量。例如，如果用户想要输出 <code>amount0Out</code> 的 <code>token0</code>，则需要计算出需要输入的 <code>token1</code> 的数量，以保持（近似）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mn>0</mn><mo>×</mo><mi>r</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">reserve0 \times reserve1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">reser</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">reser</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord">1</span></span></span></span> 的恒定。</li>
<li>将用户输入的代币转移到合约。</li>
<li>更新储备量。</li>
<li>将输出的代币转移给接收者。</li>
<li>触发 <code>Swap</code> 事件。</li>
</ul>
</li>
<li>
<p><strong><code>skim(address to)</code></strong>: 允许在合约实际持有的代币数量与记录的储备量不一致时，将多余的代币发送到指定地址。</p>
</li>
<li>
<p><strong><code>sync()</code></strong>: 允许外部强制更新合约的储备量，使其与合约实际持有的代币数量一致。</p>
</li>
</ul>
<h3 id="4-7-修饰器">4.7. 修饰器</h3>
<ul>
<li><strong><code>lock()</code></strong>: 一个简单的修饰器，用于防止潜在的重入攻击。</li>
</ul>
<h2 id="5-如何使用">5. 如何使用</h2>
<ol>
<li><strong>部署 ERC-20 代币</strong>: 首先需要部署你想要在这个流动性池中交易的两种 ERC-20 代币合约。</li>
<li><strong>部署流动性池合约</strong>: 部署 <code>SimpleLiquidityPool</code> 合约，并将上述两个 ERC-20 代币合约的地址作为构造函数的参数传入。</li>
<li><strong>批准代币转移</strong>: 用户需要调用他们持有的 ERC-20 代币合约的 <code>approve</code> 函数，授权给 <code>SimpleLiquidityPool</code> 合约可以从他们的账户转移一定数量的代币。</li>
<li><strong>提供流动性</strong>: 调用 <code>mint</code> 函数，将一定数量的两种代币存入池子。你会收到相应的 LP 代币作为回报。</li>
<li><strong>移除流动性</strong>: 调用 <code>burn</code> 函数，发送你的 LP 代币到合约，合约会销毁这些 LP 代币，并返还相应的两种代币给你。</li>
<li><strong>进行交易</strong>: 调用 <code>swap</code> 函数，指定你想要输出的代币数量，合约会计算并发送给你相应的另一种代币。</li>
</ol>
<h2 id="6-完整代码">6. 完整代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;; // 导入 ERC-20 接口</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;; // 导入 SafeMath 库以进行安全的算术运算</span><br><span class="line"></span><br><span class="line">contract SimpleLiquidityPool &#123;</span><br><span class="line">    using SafeMath for uint256; // 使用 SafeMath 库处理 uint256 类型的运算</span><br><span class="line"></span><br><span class="line">    IERC20 public token0; // 第一个 ERC-20 代币的接口</span><br><span class="line">    IERC20 public token1; // 第二个 ERC-20 代币的接口</span><br><span class="line">    uint256 public reserve0; // 池子中 token0 的储备量</span><br><span class="line">    uint256 public reserve1; // 池子中 token1 的储备量</span><br><span class="line">    uint256 public totalSupply; // 流动性代币（LP tokens）的总发行量</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf; // 记录每个地址拥有的 LP 代币数量</span><br><span class="line"></span><br><span class="line">    uint256 constant MINIMUM_LIQUIDITY = 10**3; // 首次提供流动性时，发送给零地址的最小流动性数量，用于防止 totalSupply 为零</span><br><span class="line"></span><br><span class="line">    // 定义事件，方便在链下监听合约状态变化</span><br><span class="line">    event Mint(address indexed sender, uint256 amount0, uint256 amount1); // 当提供流动性时触发</span><br><span class="line">    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to); // 当移除流动性时触发</span><br><span class="line">    event Swap(</span><br><span class="line">        address indexed sender,</span><br><span class="line">        uint256 amount0In,</span><br><span class="line">        uint256 amount1In,</span><br><span class="line">        uint256 amount0Out,</span><br><span class="line">        uint256 amount1Out,</span><br><span class="line">        address indexed to</span><br><span class="line">    ); // 当进行代币交换时触发</span><br><span class="line">    event Sync(uint256 reserve0, uint256 reserve1); // 当储备量更新时触发</span><br><span class="line"></span><br><span class="line">    // 构造函数，在合约部署时被调用</span><br><span class="line">    constructor(IERC20 _token0, IERC20 _token1) &#123;</span><br><span class="line">        token0 = _token0; // 设置 token0 的合约地址</span><br><span class="line">        token1 = _token1; // 设置 token1 的合约地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前的储备量</span><br><span class="line">    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1) &#123;</span><br><span class="line">        return (reserve0, reserve1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部函数：更新储备量并触发 Sync 事件</span><br><span class="line">    function _update(uint256 balance0, uint256 balance1) internal &#123;</span><br><span class="line">        reserve0 = balance0;</span><br><span class="line">        reserve1 = balance1;</span><br><span class="line">        emit Sync(reserve0, reserve1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部函数：铸造流动性代币</span><br><span class="line">    function _mint(address to, uint256 value) internal &#123;</span><br><span class="line">        totalSupply = totalSupply.add(value);</span><br><span class="line">        balanceOf[to] = balanceOf[to].add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部函数：销毁流动性代币，并计算应返还的两种代币数量</span><br><span class="line">    function _burn(address from, uint256 value) internal returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">        require(balanceOf[from] &gt;= value, &quot;INSUFFICIENT_LIQUIDITY&quot;);</span><br><span class="line">        balanceOf[from] = balanceOf[from].sub(value);</span><br><span class="line">        totalSupply = totalSupply.sub(value, &quot;INSUFFICIENT_TOTAL_SUPPLY&quot;);</span><br><span class="line">        amount0 = value.mul(reserve0).div(totalSupply); // 根据持有的 LP 比例计算应得的 token0</span><br><span class="line">        amount1 = value.mul(reserve1).div(totalSupply); // 根据持有的 LP 比例计算应得的 token1</span><br><span class="line">        _safeTransfer(token0, from, amount0); // 安全地转移 token0 给用户</span><br><span class="line">        _safeTransfer(token1, from, amount1); // 安全地转移 token1 给用户</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部函数：安全地转移 ERC-20 代币</span><br><span class="line">    function _safeTransfer(IERC20 token, address to, uint256 value) internal &#123;</span><br><span class="line">        bool success = token.transfer(to, value);</span><br><span class="line">        require(success, &quot;TRANSFER_FAILED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 外部函数：提供流动性</span><br><span class="line">    function mint(address to) external lock &#123;</span><br><span class="line">        uint256 balance0 = token0.balanceOf(address(this)); // 获取合约中当前的 token0 余额</span><br><span class="line">        uint256 balance1 = token1.balanceOf(address(this)); // 获取合约中当前的 token1 余额</span><br><span class="line">        uint256 amount0 = balance0.sub(reserve0); // 用户存入的 token0 数量</span><br><span class="line">        uint256 amount1 = balance1.sub(reserve1); // 用户存入的 token1 数量</span><br><span class="line"></span><br><span class="line">        // 在首次提供流动性时，需要特殊处理来初始化 totalSupply</span><br><span class="line">        uint256 liquidity;</span><br><span class="line">        if (totalSupply == 0) &#123;</span><br><span class="line">            liquidity = SafeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);</span><br><span class="line">            _mint(address(0), MINIMUM_LIQUIDITY); // 永久锁定一部分 LP 代币</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 根据已有的储备量和提供的代币比例计算应铸造的 LP 代币数量</span><br><span class="line">            liquidity = SafeMath.min(amount0.mul(totalSupply) / reserve0, amount1.mul(totalSupply) / reserve1);</span><br><span class="line">        &#125;</span><br><span class="line">        require(liquidity &gt; 0, &quot;INSUFFICIENT_LIQUIDITY_MINTED&quot;);</span><br><span class="line">        _mint(to, liquidity); // 将计算出的 LP 代币铸造给提供者</span><br><span class="line">        _update(balance0, balance1); // 更新储备量</span><br><span class="line">        emit Mint(to, amount0, amount1); // 触发 Mint 事件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 外部函数：移除流动性</span><br><span class="line">    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">        uint256 liquidity = balanceOf[msg.sender]; // 获取调用者拥有的 LP 代币数量</span><br><span class="line">        require(liquidity &gt; 0, &quot;BURN_ZERO_LIQUIDITY&quot;);</span><br><span class="line"></span><br><span class="line">        amount0 = liquidity.mul(reserve0).div(totalSupply); // 计算应返还的 token0 数量</span><br><span class="line">        amount1 = liquidity.mul(reserve1).div(totalSupply); // 计算应返还的 token1 数量</span><br><span class="line"></span><br><span class="line">        _burn(msg.sender, liquidity); // 销毁调用者的 LP 代币</span><br><span class="line">        _safeTransfer(token0, to, amount0); // 将 token0 返还给调用者</span><br><span class="line">        _safeTransfer(token1, to, amount1); // 将 token1 返还给调用者</span><br><span class="line">        emit Burn(msg.sender, amount0, amount1, to); // 触发 Burn 事件</span><br><span class="line">        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this))); // 更新储备量</span><br><span class="line">        return (amount0, amount1); // 返回返还的代币数量</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 外部函数：进行代币交换</span><br><span class="line">    function swap(uint256 amount0Out, uint256 amount1Out, address to) external lock &#123;</span><br><span class="line">        require(amount0Out &gt; 0 ^ amount1Out &gt; 0, &quot;INVALID_OUTPUT_AMOUNT&quot;); // 确保只输出一种代币</span><br><span class="line">        (uint112 _reserve0, uint112 _reserve1,) = (uint112(reserve0), uint112(reserve1), uint112(block.timestamp)); // gas 优化，读取储备量</span><br><span class="line"></span><br><span class="line">        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &quot;INSUFFICIENT_LIQUIDITY&quot;); // 确保输出量小于储备量</span><br><span class="line"></span><br><span class="line">        uint256 amount0In;</span><br><span class="line">        uint256 amount1In;</span><br><span class="line"></span><br><span class="line">        // 根据输出量计算输入量（遵循 x * y = k 原则）</span><br><span class="line">        if (amount0Out &gt; 0) &#123; // 用户想要输出 token0</span><br><span class="line">            uint256 numerator = _reserve0.mul(amount1Out);</span><br><span class="line">            uint256 denominator = _reserve1.sub(amount1Out);</span><br><span class="line">            amount0In = (numerator.div(denominator)).add(1); // +1 避免精度损失</span><br><span class="line">            require(amount0In &gt; 0 &amp;&amp; token0.balanceOf(msg.sender) &gt;= amount0In, &quot;INSUFFICIENT_INPUT_AMOUNT&quot;);</span><br><span class="line">            _safeTransfer(token0, address(this), amount0In); // 将输入的 token0 转入合约</span><br><span class="line">        &#125; else &#123; // 用户想要输出 token1</span><br><span class="line">            uint256 numerator = _reserve1.mul(amount0Out);</span><br><span class="line">            uint256 denominator = _reserve0.sub(amount0Out);</span><br><span class="line">            amount1In = (numerator.div(denominator)).add(1); // +1 避免精度损失</span><br><span class="line">            require(amount1In &gt; 0 &amp;&amp; token1.balanceOf(msg.sender) &gt;= amount1In, &quot;INSUFFICIENT_INPUT_AMOUNT&quot;);</span><br><span class="line">            _safeTransfer(token1, address(this), amount1In); // 将输入的 token1 转入合约</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 balance0 = token0.balanceOf(address(this));</span><br><span class="line">        uint256 balance1 = token1.balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        _update(balance0, balance1); // 更新储备量</span><br><span class="line">        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); // 触发 Swap 事件</span><br><span class="line">        if (amount0Out &gt; 0) _safeTransfer(token0, to, amount0Out); // 将输出的 token0 转给接收者</span><br><span class="line">        if (amount1Out &gt; 0) _safeTransfer(token1, to, amount1Out); // 将输出的 token1 转给接收者</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 允许外部合约强制同步余额</span><br><span class="line">    function skim(address to) external lock &#123;</span><br><span class="line">        uint256 balance0 = token0.balanceOf(address(this));</span><br><span class="line">        uint256 balance1 = token1.balanceOf(address(this));</span><br><span class="line">        _safeTransfer(token0, to, balance0.sub(reserve0, &quot;SKIM_FAILED&quot;)); // 将多余的 token0 发送到指定地址</span><br><span class="line">        _safeTransfer(token1, to, balance1.sub(reserve1, &quot;SKIM_FAILED&quot;)); // 将多余的 token1 发送到指定地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 允许外部合约强制更新储备量</span><br><span class="line">    function sync() external lock &#123;</span><br><span class="line">        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 一个简单的修饰器，用于防止重入攻击</span><br><span class="line">    modifier lock() &#123;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>uniswap系列</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>uniswap</tag>
      </tags>
  </entry>
  <entry>
    <title>远程通信协议：RPCvsHTTP</title>
    <url>/2025/05/24/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%9ARPCvsHTTP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RPC与HTTP：理解远程通信的核心概念">RPC与HTTP：理解远程通信的核心概念</h1>
<h2 id="什么是RPC？">什么是RPC？</h2>
<p>RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许一个程序（客户端）像调用本地方法一样调用另一个地址空间（通常是远程服务器）上的程序或服务，而不需要显式处理网络通信的细节。</p>
<p>RPC的核心思想是<strong>透明性</strong>——开发者可以像调用本地函数一样调用远程函数，底层通信细节被隐藏起来。RPC框架通常包括：<br>
• 客户端存根（stub）：负责将调用信息序列化并发送到网络<br>
• 服务器端骨架（skeleton）：负责接收请求并调用实际的方法<br>
• 通信协议：定义数据传输格式和规则<br>
• 序列化机制：将数据结构或对象转换为可传输的格式</p>
<p>常见的RPC框架包括gRPC、Thrift、Dubbo等。</p>
<h2 id="什么是HTTP？">什么是HTTP？</h2>
<p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，用于分布式、协作式的超媒体信息系统。它是万维网（WWW）数据通信的基础。</p>
<p>HTTP基于<strong>请求-响应模型</strong>工作：</p>
<ol>
<li>客户端（通常是浏览器）向服务器发送HTTP请求</li>
<li>服务器处理请求并返回HTTP响应</li>
<li>连接通常会在响应后关闭（除非使用持久连接）</li>
</ol>
<p>HTTP是无状态协议，每个请求都是独立的，服务器不会保留之前请求的信息。现代HTTP/1.1和HTTP/2支持持久连接、管道化和头部压缩等特性。</p>
<h2 id="RPC与HTTP的区别">RPC与HTTP的区别</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>RPC</th>
<th>HTTP</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>设计目的</strong></td>
<td>远程方法调用，强调透明性</td>
<td>超文本传输，强调资源交换</td>
</tr>
<tr>
<td><strong>通信模型</strong></td>
<td>通常面向过程/方法调用</td>
<td>面向资源（RESTful）或动作（SOAP）</td>
</tr>
<tr>
<td><strong>协议层</strong></td>
<td>可以在传输层之上直接构建</td>
<td>应用层协议，通常基于TCP</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>通常更高（二进制协议，更少的开销）</td>
<td>相对较低（文本协议，更多元数据）</td>
</tr>
<tr>
<td><strong>序列化</strong></td>
<td>使用高效的二进制格式（如Protocol Buffers）</td>
<td>通常使用文本格式（JSON/XML）</td>
</tr>
<tr>
<td><strong>服务发现</strong></td>
<td>内置服务发现机制</td>
<td>需要额外组件（如API网关）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>内部服务间通信，高性能需求</td>
<td>公开API，浏览器-服务器交互</td>
</tr>
<tr>
<td><strong>跨语言支持</strong></td>
<td>需要特定客户端实现</td>
<td>通用性强，几乎所有语言都支持</td>
</tr>
</tbody>
</table>
<h2 id="如何选择？">如何选择？</h2>
<p>选择RPC还是HTTP取决于具体场景：</p>
<p><strong>使用RPC当：</strong><br>
• 需要高性能的内部服务通信<br>
• 服务间调用频繁且延迟敏感<br>
• 需要强类型接口和编译时检查<br>
• 系统由同一团队维护，可以统一技术栈</p>
<p><strong>使用HTTP当：</strong><br>
• 需要公开API供第三方使用<br>
• 需要与浏览器直接交互<br>
• 系统组件由不同团队维护，需要松耦合<br>
• 需要利用现有的HTTP基础设施（缓存、负载均衡等）</p>
<h2 id="现代趋势：融合与演进">现代趋势：融合与演进</h2>
<p>值得注意的是，现代技术趋势正在模糊RPC和HTTP的界限：<br>
• gRPC基于HTTP/2，结合了RPC的高效和HTTP的通用性<br>
• RESTful API设计借鉴了RPC的一些思想<br>
• GraphQL提供了类似RPC的精确查询能力，同时运行在HTTP上</p>
<h2 id="结论">结论</h2>
<p>RPC和HTTP都是实现远程通信的重要技术，各有优势和适用场景。理解它们的核心差异有助于我们在系统设计中做出合理的选择。随着技术的发展，两者也在相互借鉴和融合，开发者可以根据具体需求选择最适合的方案，甚至组合使用它们。</p>
]]></content>
  </entry>
  <entry>
    <title>编程中闭包的概念</title>
    <url>/2025/05/10/%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h2 id="🧠-一句话定义（简化版）：">🧠 一句话定义（简化版）：</h2>
<blockquote>
<p><strong>闭包是一个函数，它“记住”了它创建时的环境（变量）。</strong></p>
</blockquote>
<hr>
<h2 id="🍱-生活类比：饭盒里的便当（闭包）">🍱 生活类比：饭盒里的便当（闭包）</h2>
<p>想象你去上班，带了个便当盒（函数）：</p>
<ul>
<li>饭盒里放了饭菜（外部变量）</li>
<li>虽然你已经离开了厨房（函数定义的作用域），</li>
<li>但你打开便当盒，<strong>饭菜还在</strong>！你可以继续吃！</li>
</ul>
<p>➡️ <strong>闭包就是这样的便当盒：带着“当时的变量环境”走了。</strong></p>
<hr>
<h2 id="🧪-编程版：一个-Go-的闭包示例">🧪 编程版：一个 Go 的闭包示例</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := counter()</span><br><span class="line">    fmt.Println(c()) <span class="comment">// 输出 1</span></span><br><span class="line">    fmt.Println(c()) <span class="comment">// 输出 2</span></span><br><span class="line">    fmt.Println(c()) <span class="comment">// 输出 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="💡-发生了什么？">💡 发生了什么？</h3>
<ul>
<li><code>counter</code> 返回一个匿名函数，这个函数访问了变量 <code>x</code></li>
<li><code>x</code> 是 <strong>在 <code>counter()</code> 里定义的局部变量</strong></li>
<li><strong>即使 <code>counter()</code> 执行完了，<code>x</code> 依然活着</strong>！</li>
<li>每次调用 <code>c()</code>，<code>x</code> 都会 +1，因为闭包记住了它的值</li>
</ul>
<hr>
<h2 id="✅-用图感受一下">✅ 用图感受一下</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">counter()</span><br><span class="line">   └── 创建变量 x = 0</span><br><span class="line">   └── 返回 func() &#123;</span><br><span class="line">          x++</span><br><span class="line">          return x</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">c()     ← 调用这个闭包，每次都会用到“记住的 x”</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧩-再举一个真实用途：生成器">🧩 再举一个真实用途：生成器</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAdder</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add5 := makeAdder(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(add5(<span class="number">10</span>)) <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    add10 := makeAdder(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(add10(<span class="number">10</span>)) <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🧠-解释：">🧠 解释：</h3>
<ul>
<li><code>makeAdder(5)</code> 返回的函数里“记住了 n = 5”</li>
<li>即使 <code>makeAdder</code> 函数早就结束了，这个返回的闭包<strong>仍然能使用 <code>n</code> 的值</strong></li>
</ul>
<hr>
<h2 id="🧾-和普通函数的区别">🧾 和普通函数的区别</h2>
<table>
<thead>
<tr>
<th>特点</th>
<th>普通函数</th>
<th>闭包（closure）</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否依赖外部变量</td>
<td>❌ 否</td>
<td>✅ 是，能“记住”上下文</td>
</tr>
<tr>
<td>生命周期限制</td>
<td>当前调用内</td>
<td>可能延续外部函数作用域之后</td>
</tr>
<tr>
<td>实际用途</td>
<td>逻辑分离</td>
<td>保持状态、记忆值、回调函数等</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🏁-总结一波">🏁 总结一波</h2>
<blockquote>
<p><strong>闭包 = 函数 + 它创建时的环境变量的“快照”</strong></p>
</blockquote>
<p>它在很多地方都特别有用，比如：</p>
<ul>
<li>生成器函数</li>
<li>回调函数</li>
<li>保存状态的函数工厂</li>
<li>柯里化（函数定制）</li>
</ul>
<hr>
]]></content>
  </entry>
  <entry>
    <title>考研经验分享</title>
    <url>/2025/07/01/%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>突发奇想写一下考研的经验分享，希望帮到有需要的同学</p>
</blockquote>
<p>鼠鼠一战985自命题遗憾败北，二战京区22408的211稳稳上岸，两年里摸索了很多</p>
<p>原本感觉能写很多，但是时间相距甚远，记忆模糊了，简单写一些重要的内容</p>
<p>以下观点，纯属主观，博君一笑，请自行斟酌，不要和鼠鼠扯皮</p>
<h3 id="1-前言">1.前言</h3>
<p>在现在这个时代，作为在校大学生首先需要对“考研”这件事做一个权衡，思考一些问题，例如：</p>
<ul>
<li>
<p>我是否适合读研？</p>
</li>
<li>
<p>我是否需要读研？</p>
</li>
<li>
<p>读研能否给我想要的“东西”？</p>
</li>
<li>
<p>我毕业能不能找到工作？</p>
</li>
</ul>
<p>等等等等…因为是否读研可以看做是人生小阶段的一个小小的分支，所以要想好自己路</p>
<p>就我个人而言，我的想法是：1.当前就业环境不佳，直接工作不一定能给我想要的生活；2.个人性格和出身原因，非常希望去到一个更高层次的地方（认知、知识和社交等）探索这个世界；</p>
<p>所以我决定考研，并且给自己两年的机会，好在最后达成了目标</p>
<h3 id="2-时间地点安排">2.时间地点安排</h3>
<p>对于时间，首先得先大致了解一下<strong>考试的时间</strong>安排（什么时候考试，什么时候报名之类的），这些信息还是比较好搜集的，简单看一下，心里有个数。</p>
<p>然后是<strong>自己的时间</strong>，二战的话时间自由，一战的话了解一下自己学校的课程安排，学校应该不会用课程和实训来耽误学生考研学习，如果真的遇到学校为难的，咨询上岸学长怎么处理的，这个应该不成问题。</p>
<p>对于<strong>学习地点</strong>的话，以鼠鼠的本科学校为例，对于一战的同学，前期的话可以去图书馆听课学习，但是到了强化和冲刺阶段，最好是选择学校提供的考研自习室，尽量不要去图书馆，因为受到开馆闭馆时间的限制，而自习室24小时开着，没人管，条件也更好（#60顶楼那个就不错）。</p>
<p>对于一战来说，有一个时间节点比较特殊，就是七八月的<strong>暑假</strong>。一般有三个选项：回家、留校、租房。暑假非常非常非常关键，一定选择自己适合的方式，这里仅避雷鼠鼠本科学校的留校，非常不好。另外两种的话，仁者见仁智者见智，鼠鼠是选择了攒钱租房闭关度过两个月，而鼠鼠的好朋友弓大大在家学习最终也取得了那一届最好的成绩（420+）。</p>
<p>最后就是<strong>学习时间</strong>，前期的基础阶段的话，鼠鼠认为无所谓，目标就是系统性的学一遍（学的好不好没差别，反正后面也会忘）。至于最后的冲刺阶段也很简单：“你有多少能量，就有多大作为”，这句话就是说到了快考试的那段时间，大家的精神和身体应该来说都相当疲惫了，尤其是精神，都有可能倦怠迷茫，那就得看自己的精神状态了，能学进去多少全看自己造化了。</p>
<p>所以鼠鼠主要分享一下<strong>强化阶段</strong>的时间安排，这个还是比较重要的：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>7：00-7：30</td>
<td>起床+背单词</td>
<td></td>
</tr>
<tr>
<td>7：30-8：00</td>
<td>随机睡回笼觉</td>
<td>保证精神</td>
</tr>
<tr>
<td>8：00-9：00</td>
<td>英语真题</td>
<td>基础不好的可以继续背单词</td>
</tr>
<tr>
<td>9：30-11：00</td>
<td>408</td>
<td>也有人说跟真实考试一样，上午学数学，鼠鼠认为无所谓，后期模考的时候可以注意一下</td>
</tr>
<tr>
<td>11：30-13：30</td>
<td>吃饭+午休</td>
<td></td>
</tr>
<tr>
<td>13：30-16：00</td>
<td>高数</td>
<td></td>
</tr>
<tr>
<td>16：00-18：30</td>
<td>线代</td>
<td>很多人会踩的坑，线代和高数一定要一起学，都很重要，尤其是线代比较简单，纯送分</td>
</tr>
<tr>
<td>18：30-20：00</td>
<td>吃饭+骑车+洗澡</td>
<td>适量运动，不然身体会垮掉，鼠鼠整个半年都没感冒过</td>
</tr>
<tr>
<td>20：00-22：00</td>
<td>408</td>
<td></td>
</tr>
<tr>
<td>22：00-23：00</td>
<td>王者荣耀，启动！</td>
<td>蘸豆，爽！</td>
</tr>
<tr>
<td>23：00-00：00</td>
<td>休息</td>
<td>鼠鼠定力差，经常玩手机玩过头，不过感觉也无所谓</td>
</tr>
</tbody>
</table>
<blockquote>
<p>1.在整个备考期间一定要保证睡眠，至少要睡满7.5h(8h则更好)。睡眠充足对学习大有益处，虽然鼠鼠在这一点上做得很差。</p>
</blockquote>
<p>2.计划是上面的计划，其实执行过程难免磕磕绊绊，比如睡个大懒觉、玩个一整天游戏或者出去旅游两天，都是小事，不要有负罪感，玩就爽玩，学就狂学。战略上拿下就行了，强化阶段战略是“<strong>闭关修炼</strong>”。</p>
<p>3.另外说明的是，鼠鼠的英语有点小天赋，所以压根就没怎么学，单词都没背，所以同学们需要根据自身情况调整。</p>
<h3 id="3-考研择校">3.考研择校</h3>
<p>最重要的一关，一点比较颠覆性的认知是“选择大于努力”，这不是假大空的道理，也不是事后大家的玩梗，这是考研这件事（甚至是往后的人生）的准则，所以一定要重视择校这件事。</p>
<p>择校的几个关键点：</p>
<ul>
<li>
<p>确定考试科目：自命题 or 统考</p>
</li>
<li>
<p>确定目标院校档次：双一流 or 92</p>
</li>
<li>
<p>确定自身实力：近年真题 and 模拟考试</p>
</li>
<li>
<p>调研目标院校考情：各种分数指标 and 录取原则</p>
</li>
</ul>
<p>鼠鼠的个人观点：</p>
<ul>
<li>
<p>考虑地区时建议不要被家乡束缚，眼光要长远，虽然江苏确实是鼠鼠心目中全国最好的地区没有之一，但也不能总吃细糠</p>
</li>
<li>
<p>推荐报考统考408，因为有些自命题非常不稳定，小心被坑死，鼠鼠已经死过一次了，所以大家不要贪图一两门课简单而失去了更大的优势，408其实不难，只是多</p>
</li>
<li>
<p>有实力的可以考11408，调剂时优势非常非常巨大，身边有朋友甚至调剂到比一志愿好更多更多的院校</p>
</li>
<li>
<p>推荐双一流以上的院校，往下的不值得一上，除非没办法的时候（调剂）</p>
</li>
<li>
<p>学习的时候留一两年的真题不做，留着摸摸自己的底</p>
</li>
<li>
<p>院校调研要多方位，微信公众号+B站+知乎+小红书等等等等，还有研可岸这个网站，里面有很多院校的信息</p>
</li>
</ul>
<p>鼠鼠本人属于是一念神魔型选手，发挥好随便挑，发挥差简直一坨，所以二战综合选择了“一线城市+中上游211”这样的目标。</p>
<p>最后也欢迎学弟学妹也考来北京抱团发展。</p>
<h3 id="4-学科建议">4.学科建议</h3>
<p>下面聊点具体的，但是一定要根据自身调整</p>
<p>总的来说：“是否能够上岸” = “你的数学和专业课炸没炸”</p>
<p>所以，<em><strong>整个备考的重心始终要放在数学和专业课上</strong></em></p>
<p>举个例子，数学最低分值的选择填空为5分，英语完型填空为0.5分一个，而过去的完型均分大约也就5分（除了最近年份），所以孰轻孰重，鼠鼠相信大家自己能判断</p>
<h4 id="政治">政治</h4>
<p>这门学科就是简单考察学生个人素养，热爱国家，心中有理想，脚下有力量就行。</p>
<p>至于学习，12月的时候<strong>肖四肖八</strong>会出版，这将是唯一且最重要的学习资料。肖八写选择，听讲解，记忆知识点；肖四写选择，听讲解，背诵分析题。对于分析题，背下来还是比较难且枯燥的，推荐博主：大牙考研，他总结的带背版逻辑清晰，行为精简，更适合工科宝宝体质。</p>
<p>前期的话，可以吃饭的时候把徐涛强化课当故事听一听，图一乐。其他乱七八糟的什么1000题什么的不要写。</p>
<blockquote>
<p><strong>总结</strong>：前期按兵不动，最后做好冲刺，不要花太多心思（因为花了也没用，性价比极低）</p>
</blockquote>
<p>（2025年肖4大翻车，或者说被反向押题了，但是不能否认这本资料在之后考试中的重要性）</p>
<h4 id="英语">英语</h4>
<p>复习关键：<strong>单词+阅读</strong></p>
<p>单词，推荐使用手机软件背诵，随时随地背（虽然鼠鼠做不到），背上一两遍基本无敌了，基础不好一定要一直背。大部分的单词都只需要留下印象，看到以后知道是什么意思，不用会写。</p>
<p>阅读，通过真题学习，不要看任何其他资料，只会误导方向。鼠鼠在一战的时候是做了一遍所有的真题，包括英一和英二，个人感觉两者差不太多，一开始错的挺多，写着写着就入魔了，基本不会出错，所以要多写，找到感觉。不要听人家说的神乎其神，阅读就是力大砖飞，干就完了。暑假的时候集中强化训练。真是耐听王的话，推荐看看唐迟的阅读课，有微乎其微的作用吧，不如力大砖飞。</p>
<p>作文，两年经验来看，推荐自己总结模板，分数更高，需要的可以直接找鼠鼠要，包牛逼的。时间大概是十月十一月开始学问题不大。底子差的可以听听石雷鹏的课，简单易上手，宝宝巴士型。</p>
<p>其他题型，学一下做题方法就行，基本都是送分题，无需在意也不用专门复习，十一月看一下就行。<em>（语法，学个damn）</em></p>
<p>PS：如果你是像鼠鼠这种的偏科神人，直接不学也没事，可以省出很多时间给数学和408。</p>
<blockquote>
<p><strong>总结</strong>：单词一直背，阅读狠狠练，力大砖飞！</p>
</blockquote>
<h4 id="数学">数学</h4>
<ol>
<li>时间段：</li>
</ol>
<ul>
<li>
<p>基础：4月-6月</p>
</li>
<li>
<p>强化：7月-10月</p>
</li>
<li>
<p>冲刺：11月-12月</p>
</li>
</ul>
<ol start="2">
<li>各阶段课程建议</li>
</ol>
<table>
<thead>
<tr>
<th>阶段</th>
<th>目标</th>
<th>课程</th>
<th>资料</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础</td>
<td>系统地学习一遍</td>
<td>三大名师任选其一：汤家凤、武忠祥、张宇</td>
<td></td>
<td></td>
</tr>
<tr>
<td>线代：李永乐老爷爷 or 没咋了救命课</td>
<td>对应的讲义资料即可</td>
<td>每个人习惯差异很大，每个老师的课听一两节，看看哪个舒服就选哪个。例如汤老师的南京口音鼠鼠感觉很亲切，有种回高中的感觉，有助睡眠（bushi，所以选择基础课听汤老师</td>
<td></td>
<td></td>
</tr>
<tr>
<td>强化</td>
<td>巩固知识点，学会做题</td>
<td>推荐：武忠祥 or 张宇</td>
<td></td>
<td></td>
</tr>
<tr>
<td>线代：李永乐老爷爷 or 没咋了救命课</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>习题讲解：B站一些优质博主，例如没咋了，已经记不清了，自行搜索鉴别</td>
<td>对应的强化讲义</td>
<td>强化重点在于做题而不是听课，当然了可也是必须要听的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>注重习题复盘</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>冲刺</td>
<td>提升应试能力，狠狠地写试卷，针对性地复习</td>
<td>查漏补缺，B站上找需要的视频来看</td>
<td>各种真题模拟卷，建议：不要急着买，每年试卷质量不一样，等一手网上各个博主的测评，值得写再买</td>
<td>看视频缺哪补哪，不要看什么《17堂课》这种长长的课，你没有那个时间了</td>
</tr>
<tr>
<td>做套卷一定一定要计时，不然等于没做</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="3">
<li>学习指南（各种碎碎念）</li>
</ol>
<ul>
<li>
<p>数学一定要大段时间一起学，能进心流是最好</p>
</li>
<li>
<p>听课和练习要结合，学完就去写，不要猛猛听课</p>
</li>
<li>
<p>练习题选择要看网上的评测，是否适合自己</p>
</li>
<li>
<p>重视线代，这门学科有独特魔力，一个星期不碰＝从没学过，一定不能停，千万不要不信邪</p>
</li>
<li>
<p>学习过程：听课→例题→练习题→(全篇复习：错题二刷)</p>
</li>
<li>
<p>做题时间原则，5分的题，5分钟没写出来，直接跳过</p>
</li>
<li>
<p>做试卷的原则，速通然后检查，最后攻坚克难</p>
</li>
<li>
<p>冲刺阶段：2天一套模拟卷，一天做，一天复盘总结（必不可少）</p>
</li>
<li>
<p>做题本很有必要去做，用于回顾知识；笔记本，对于数学而言意义不大，不建议搞</p>
</li>
<li>
<p>不断思考学习方法有没有更好的改进</p>
</li>
<li>
<p>最后阶段集中攻克薄弱，例如反常积分不会，找到专题内容猛猛补就行</p>
</li>
<li>
<p>数学关键是做题能力，不要当耐听王，多动手</p>
</li>
<li>
<p>各个博主的优质内容一定要在有了基础前提下学习，不要上来就跟着某个up主学这学那</p>
</li>
<li>
<p>数学也是力大砖飞，计算能力要过关，尤其是近几年的题目，会写但是未必得分，所以要多练</p>
</li>
<li>
<p>注意一些犄角旮旯的知识点，有时候出卷老头真的很逆天，25年搞了个万有引力直接爆了</p>
</li>
<li>
<p>记住数学的基础分就有120，所以不失误就已经赢了，要打牢基础，注重计算（鼠鼠就经常死在计算上，一定要多练）</p>
</li>
<li>
<p>跳出自己的舒适区，越不会越要搞会。这里我指的是自己的薄弱知识，而不是硬钢那些难题</p>
</li>
</ul>
<ol start="4">
<li>其他问题</li>
</ol>
<ul>
<li>
<p>例如各个资料和试卷质量问题，可以联系鼠鼠询问，就不一一列举</p>
</li>
<li>
<p>资料推荐买盗版或者电子版，省下来的钱上岸之后猛猛玩</p>
</li>
<li>
<p>上面都挺关键的，距离考试时间已经很久远了，想不到更多了，欢迎提问</p>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：基础不牢，地动山摇。多写题多总结 ＞ 耐听王。力大砖飞！</p>
</blockquote>
<h4 id="408">408</h4>
<ol start="5">
<li>认知：</li>
</ol>
<ul>
<li>
<p>408的难度在于知识点的量很大，而不是知识点深度</p>
</li>
<li>
<p>408学习的精髓在于多次反复，因为他有很多文科的特性</p>
</li>
<li>
<p>408需要的时间也没有那么吓人，鼠鼠二战从7月开始学，仍然完完整整过了两遍，后期甚至没事干</p>
</li>
</ul>
<ol start="6">
<li>学习建议：</li>
</ol>
<p>基础阶段就是听王道课，过一遍，很难的内容直接跳，例如计组中的一些东西非常难懂，没关系直接跳。与此同时做王道的课后题中的选择题，推荐使用电子的刷题本，然后打印下来。每题都要弄懂，相关知识点写旁边。习题讲解推荐：Boky、里昂学长或者王道官方。</p>
<p>另外我听过Boky的其他课程，也非常非常推荐，这个女生讲解的很有条理，比起王道的课程更精简高效，全程班不知道质量如何，钱包有实力可以考虑。另外就是她的出版资料非常的棒，比起厚厚的王道书，简直就是神器，推荐入手，鼠鼠后期一直看得她的资料，再也没翻过王道书。</p>
<p>强化的话，王道的强化课是比较推荐的，讲大题的解题方法与知识点的综合，尤其是存储相关的内容和PV相关的内容，跟着做题学习大题，会有茅塞顿开的感觉。</p>
<p>然后就是真题阶段，这个阶段也非常重要，408最好的复习资料就是历年真题，鼠鼠认为至少要刷三遍以上才算吃透，要有一个错题本记录题目和知识点，因为408重复考察的很多。</p>
<p>王道在12月中旬的时候会有一个冲刺课，可以去报个名听一下，咸鱼会把最后几天的重点都勾出来，然后剩下的几天如果没东西复习了，就可以跟着他的重点再复习一次。</p>
<ol start="7">
<li>其他：</li>
</ol>
<ul>
<li>
<p>不要钻牛角尖，例如红黑树之类的，差不多得了，408量比较大，完成度更重要</p>
</li>
<li>
<p>一步步进行，打牢基础，你会发现408并不难，尤其是写真题的时候</p>
</li>
<li>
<p>计网的话咸鱼版本应该已经重置完成了，不够湖科大老师的任然非常推荐</p>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：注重完成度，知识点全覆盖。反复多次，实实在在吃透真题。力大砖飞！</p>
</blockquote>
<h3 id="其他疑问">其他疑问</h3>
<blockquote>
<p>欢迎邮箱留言，鼠鼠知无不言：alan_root@outlook.com</p>
</blockquote>
]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>科研工具分享：Zotero</title>
    <url>/2025/06/28/%E7%A7%91%E7%A0%94%E5%B7%A5%E5%85%B7%E4%B9%8BZotero/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Zotero 是一款功能强大且完全开源的文献管理工具，凭借其高效、灵活、跨平台的特性，成为全球科研工作者的得力助手。它不仅能大幅简化文献收集与整理流程，还通过丰富的功能模块，为学术研究的各个环节提供便利。</p>
<h3 id="核心功能介绍">核心功能介绍</h3>
<ol>
<li><strong>智能文献抓取</strong>：Zotero 支持从网页、数据库、图书馆目录等多种渠道，一键抓取文献的元数据、摘要甚至全文。在浏览器中安装插件后，访问知网、Web of Science 等学术网站时，点击插件即可自动识别页面文献信息，将其快速添加到文献库，无需手动录入。</li>
<li><strong>多样化文献管理</strong>：Zotero 可存储 PDF、Word、Excel、电子书等多种格式的文献资料，并通过文件夹、标签等方式进行分类整理。用户还能创建智能分组，依据文献的作者、关键词、日期等属性，自动筛选归类，让海量文献井井有条。</li>
<li><strong>高效批注与笔记</strong>：它内置的 PDF 阅读器支持高亮、批注、添加书签等操作，方便用户在阅读文献时标记重点内容。同时，用户可添加独立的笔记，记录阅读心得、研究思路等，还能将笔记与文献建立关联，方便后续查阅。</li>
<li><strong>自动引用与参考文献生成</strong>：Zotero 拥有强大的引用功能，集成了数千种学术引用样式，如 APA、MLA、Chicago 等。在撰写论文时，只需在 Word 或 LaTeX 中安装相应插件，就能轻松插入规范的文中引用，并自动生成符合要求的参考文献列表，大幅减少排版时间。</li>
<li><strong>多设备同步与协作</strong>：借助 WebDAV、坚果云等云存储服务，Zotero 可实现文献库在多设备间的实时同步。用户还能创建共享群组，与团队成员共享文献资源、讨论研究进展，提升团队协作效率。</li>
<li><strong>丰富的插件扩展</strong>：Zotero 的插件生态十分丰富，通过安装不同插件，可实现文献去重、自动翻译、数据可视化等功能拓展，满足用户多样化的科研需求。</li>
</ol>
<h3 id="使用教程">使用教程</h3>
<p>略<br>
B站找个视频看看或者摸索一下就知道了，很简单</p>
<h3 id="记一下上手后的配置，主要是一两个好用的插件：">记一下上手后的配置，主要是一两个好用的插件：</h3>
<ul>
<li>登陆自己的账号（如果有的话），同步自己的文献库实现多设备办公</li>
<li>打开Zotero中文社区，找到插件商店（<a href="https://zotero-chinese.com/plugins/%EF%BC%89">https://zotero-chinese.com/plugins/）</a></li>
<li>下载几个好用的插件：Translate for Zotero（阅读翻译工具，支持一键添加笔记）、Better Notes for Zotero（顾名思义，支持模版功能）、Awesome GPT（AI阅读辅助，虽然我用的不多，感觉一般般）、Ethereal Style（更美观的样式显示）</li>
<li>配置插件：
<ul>
<li>Translate for Zotero：主要就是获取密钥，教程<a href="https://zotero.yuque.com/staff-gkhviy/pdf-trans">教程</a></li>
<li>Better Notes for Zotero：去模版社区选择自己中意的模版即可，文末分享自用模版</li>
<li>Awesome GPT：用Github账号白嫖个API key，网址<a href="https://github.com/chatanywhere/GPT_API_free">白嫖</a></li>
</ul>
</li>
</ul>
<p>模版：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2 style=&quot;color: #B72415; text-align: center;&quot;&gt;</span><br><span class="line">    $&#123;topItem.getField(&quot;titleTranslation&quot;) ? `$&#123;topItem.getField(&quot;titleTranslation&quot;)&#125;` : &#x27;&#x27;&#125;</span><br><span class="line">&lt;/h2&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;h2 style=&quot;color: #B72415; text-align: center;&quot;&gt;</span><br><span class="line">    $&#123;topItem.getField(&quot;title&quot;)&#125;</span><br><span class="line">&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;table style=&quot;border-collapse: collapse; width: 100%;&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;b&gt;期刊: &lt;/b&gt;$&#123;topItem.getField(&#x27;publicationTitle&#x27;)&#125;&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 分区 --&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;</span><br><span class="line">        &lt;b&gt;分区: &lt;/b&gt;</span><br><span class="line">        &lt;!-- In Zotero7, the tags of Ethereal Style plugin are referenced. Please install Ethereal Style in advance. --&gt;</span><br><span class="line">        $&#123;&#123;</span><br><span class="line">        let space = &quot; ㅤㅤ ㅤㅤ&quot;</span><br><span class="line">        return Array.prototype.map.call(</span><br><span class="line">          Zotero.ZoteroStyle.api.renderCell(topItem, &quot;publicationTags&quot;).childNodes,</span><br><span class="line">          e =&gt; &#123;</span><br><span class="line">            e.innerText =  space + e.innerText + space;</span><br><span class="line">            return e.outerHTML</span><br><span class="line">          &#125;</span><br><span class="line">          ).join(space)</span><br><span class="line">        &#125;&#125;$</span><br><span class="line">      &lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	  </span><br><span class="line">&lt;td&gt;&lt;b&gt;作者:&lt;/b&gt; $&#123;topItem.getCreators().map((v)=&gt;v.firstName+&quot; &quot;+v.lastName).join(&quot;; &quot;)&#125;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;b&gt;论文发表日期: &lt;/b&gt;$&#123;topItem.getField(&quot;date&quot;).replace(/^(\d+)\/(\d+)$/, &quot;$2/$1&quot;)&#125;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;b&gt;笔记创建日期: &lt;/b&gt;$&#123;new Date().toLocaleString()&#125;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 原文链接 --&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;</span><br><span class="line">        $&#123;(() =&gt; &#123;</span><br><span class="line">          const attachments = Zotero.Items.get(topItem.getAttachments());</span><br><span class="line">          if (attachments &amp;&amp; attachments.length &gt; 0) &#123;</span><br><span class="line">            return `&lt;b&gt;原文链接: &lt;/b&gt;&lt;a href=&quot;zotero://open-pdf/0_$&#123;attachments[0].key&#125;&quot;&gt;$&#123;attachments[0].getFilename()&#125;&lt;/a&gt;`;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return `&lt;b&gt;原文链接: &lt;/b&gt;`;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)()&#125;</span><br><span class="line">      &lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;b&gt;摘要: &lt;/b&gt;$&#123;topItem.getField(&#x27;abstractTranslation&#x27;) || topItem.getField(&#x27;abstractNote&#x27;)&#125;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3 style=&quot;color:  #E65100; background-color:  #FFF8E1;&quot;&gt;💡结论及创新点&lt;/h3&gt;</span><br><span class="line">&lt;blockquote&gt;本文解决了什么&lt;u&gt;新的科学问题&lt;/u&gt;？&lt;br&gt;● &lt;br&gt;提出了什么&lt;u&gt;新的研究思路&lt;/u&gt;？&lt;br&gt;● &lt;br&gt;应用了什么&lt;u&gt;新的研究工具&lt;/u&gt;？&lt;br&gt;● &lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3 style=&quot;color:#2E7D32; background-color:    #F6FAEF;&quot;&gt;📚前言及文献综述&lt;/h3&gt;</span><br><span class="line">&lt;blockquote&gt;本研究的&lt;u&gt;必要性、紧迫性、可行性&lt;/u&gt;是什么？&lt;br&gt;● &lt;br&gt;作者是如何&lt;u&gt;论述&lt;/u&gt;的？&lt;br&gt;● &lt;br&gt;引用了哪些该领域的&lt;u&gt;开创性文献&lt;/u&gt;？&lt;br&gt;● &lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3 style=&quot;color: #006064; background-color:   #E8FBFB;&quot;&gt;🔬可参考点&lt;/h3&gt;</span><br><span class="line">&lt;blockquote&gt;本文针对&lt;u&gt;哪些问题&lt;/u&gt;应用了什么&lt;u&gt;新方法&lt;/u&gt;？&lt;br&gt;● &lt;br&gt;以期获得什么&lt;u&gt;新效果&lt;/u&gt;？&lt;br&gt;● &lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3 style=&quot;color:#4A69D3; background-color:   #EAF1FD;&quot;&gt;📜获得思路&lt;/h3&gt;</span><br><span class="line">&lt;blockquote&gt;本文得出了什么&lt;u&gt;新的方法&lt;/u&gt;？&lt;br&gt;● &lt;br&gt;通过本文在&lt;u&gt;写作上的收获&lt;/u&gt;？&lt;br&gt;● &lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>工具分享</tag>
      </tags>
  </entry>
</search>
