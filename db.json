{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/admin/config.yml","path":"admin/config.yml","modified":0,"renderable":0},{"_id":"source/admin/index.html","path":"admin/index.html","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/av1.jpg","path":"images/av1.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/head.njk","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746290780418},{"_id":"source/_data/sidebar.njk","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746291368552},{"_id":"source/_posts/ENS域名系统.md","hash":"385aefc65e2d241b52937995355cbfa8e9798182","modified":1746360375916},{"_id":"source/_posts/Git合作开发流程.md","hash":"158e69dd271bca8a74fd78c010893d637c6c61fd","modified":1746360116905},{"_id":"source/_posts/Foundry上手指南.md","hash":"e76dc1b08d3e4bdff637885ecf588d7acb6787ad","modified":1746443211706},{"_id":"source/_posts/Hardhat-ignition.md","hash":"f15f164dfa905593abe103155e1d4514f7669e78","modified":1746360685793},{"_id":"source/_posts/Gitcommit术语.md","hash":"5edc1e698d096f683c00a4b74fd23b378a22fa7b","modified":1746360062765},{"_id":"source/_posts/JSXorJS.md","hash":"057adb94b0943659dffbf5a7624c40e1e22cf71c","modified":1746360553331},{"_id":"source/_posts/Hardhat上手指南.md","hash":"0beba7a525aff765b14331b8ab175d1151babc81","modified":1746360860879},{"_id":"source/_posts/gobyexample学习笔记01.md","hash":"cd56262565dacddb81237d0fa1c00f2687c5d223","modified":1747050487804},{"_id":"source/_posts/Solidity中的不可变量和常量.md","hash":"a83fb6acbec9202fcdd85e4d6b0af1a6fb336021","modified":1746359907354},{"_id":"source/_posts/Solidity中的自定义错误.md","hash":"f06a863c1e3033201c3ae5b9475046195053bffc","modified":1746353943724},{"_id":"source/_posts/ethers和viem.md","hash":"d3afd89747ec03c5aaff5878b4a408ad5ccd1dab","modified":1746353638355},{"_id":"source/_posts/RPC框架的概念.md","hash":"2404246cfdb018d8befe294e8c0f3329c839d7fb","modified":1746363656440},{"_id":"source/_posts/指针vs引用.md","hash":"983d12230033f50014449852ac92bbaf612917f3","modified":1746927735990},{"_id":"source/_posts/学习ERC-1155.md","hash":"e29cb2c972e57abf5f14376d07345b997f432514","modified":1746360247461},{"_id":"source/_posts/编程中闭包的概念.md","hash":"7108fd4b20dbb0223dab12d255bb56f80d1c9dcb","modified":1747050674525},{"_id":"source/admin/config.yml","hash":"4a62fd02082417f4f4707e1f8371060b1848337b","modified":1746347036211},{"_id":"source/admin/index.html","hash":"38cd5121d8f73daae271dcfb77e21df1c7695627","modified":1746347641658},{"_id":"source/_posts/Solidity中的转账.md","hash":"ac41e53e92fd0212c5f9ec00dcd5da09e201dc57","modified":1746353967271},{"_id":"source/archives/index.md","hash":"8ad817f2aa22bb0362415ee4695f670e19652b52","modified":1746281205875},{"_id":"source/about/index.md","hash":"f0451703c4fdcfed604dd1c48ab3b1aeb3e00397","modified":1746415528286},{"_id":"source/_posts/考研经验分享.md","hash":"51fe0b9e2d523c042681497bd892cfbe8269b7b6","modified":1747054585032},{"_id":"source/categories/index.md","hash":"b2df8cd9a0ab621dc62f1f8e7be9b4e8c3100c5d","modified":1746279125562},{"_id":"source/tags/index.md","hash":"54a78bade39629b07af38283e74bb841b1fe92c2","modified":1746278738835},{"_id":"themes/next/_vendors.yml","hash":"72a3de9af55fbb7831ab7a3aa6c5e3f89cad53d3","modified":1746276195381},{"_id":"themes/next/package.json","hash":"eaf826c46804a8da9ec6ddf325c4670a3e3ecfa7","modified":1746276195381},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1746276195320},{"_id":"themes/next/README.md","hash":"5dd295594b92dbe07b0376b505f29fb3884e77f9","modified":1746276195380},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1746276195373},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1746276195375},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1746276195374},{"_id":"themes/next/_config.yml","hash":"8fda61ef6ed611fd51d0dda6f3f558cbba3c302b","modified":1746843125077},{"_id":"themes/next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1746276195379},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1746276195378},{"_id":"themes/next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1746276195377},{"_id":"themes/next/languages/bn.yml","hash":"564bed75da6e05b11dce6164508f97a15e2fb6c2","modified":1746276195380},{"_id":"themes/next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1746276195378},{"_id":"themes/next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1746276195378},{"_id":"themes/next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1746276195377},{"_id":"themes/next/languages/eo.yml","hash":"e34bb33ae827bf2f0727088599a73bc64bdad1b0","modified":1746276195378},{"_id":"themes/next/languages/fr.yml","hash":"8ac44e58f71a38b7697a2f7f98a6971ed818cb5b","modified":1746276195379},{"_id":"themes/next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1746276195377},{"_id":"themes/next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1746276195376},{"_id":"themes/next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1746276195380},{"_id":"themes/next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1746276195378},{"_id":"themes/next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1746276195379},{"_id":"themes/next/languages/pt.yml","hash":"b62faaa767a45a613dd042b5f1903675eb5a8cf9","modified":1746276195377},{"_id":"themes/next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1746276195376},{"_id":"themes/next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1746276195377},{"_id":"themes/next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1746276195377},{"_id":"themes/next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1746276195376},{"_id":"themes/next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1746276195376},{"_id":"themes/next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1746276195379},{"_id":"themes/next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1746276195379},{"_id":"themes/next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1746276195376},{"_id":"themes/next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1746276195380},{"_id":"themes/next/languages/zh-HK.yml","hash":"8eb6a9f231ce1bfa54cc54418ccf14f01dcc9a31","modified":1746276195378},{"_id":"themes/next/languages/zh-TW.yml","hash":"5c0f00cdac3f4727b880dd223f622a535736fa8e","modified":1746276195379},{"_id":"themes/next/layout/_layout.njk","hash":"36a27524e84e91850dfacf67afed2cc72721c616","modified":1746351235934},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1746276195322},{"_id":"themes/next/layout/page.njk","hash":"af6d7570621be760536c216a56d74e40a1cceae2","modified":1746276195330},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1746276195323},{"_id":"themes/next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1746276195322},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1746276195322},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1746276195320},{"_id":"themes/next/layout/_macro/post.njk","hash":"952449064fcb6a5cefc281b585f9149809f857f1","modified":1746276195338},{"_id":"themes/next/docs/ru/README.md","hash":"285d5c4dffb97da659851fb6e53379a614619fd9","modified":1746276195374},{"_id":"themes/next/docs/zh-CN/README.md","hash":"21567f1810f861b0a33db6514a4fcf18fb98467d","modified":1746276195375},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1746276195326},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"12a6631617695504d5cf2a94b57d87bd331bef6f","modified":1746276195375},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1746276195375},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1746276195338},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1746276195328},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1746276195327},{"_id":"themes/next/layout/_partials/head.njk","hash":"38f6db68a272ae46dff0381c8b510f3f84d68aeb","modified":1746322505987},{"_id":"themes/next/layout/_partials/footer.njk","hash":"fbf8232cacf0df87e88e74860be66c9f86018302","modified":1746276195330},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1746276195333},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"d83fb59f02c5e6630a7770401a05c02f6f07358b","modified":1746276195327},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1746276195336},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1746276195330},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1746276195385},{"_id":"themes/next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1746276195388},{"_id":"themes/next/layout/_third-party/addtoany.njk","hash":"ef64c6bfb8540cd874701236b9be47db2496e98e","modified":1746276195336},{"_id":"themes/next/scripts/filters/minify.js","hash":"2063aaa1db448ebcf7b0fdbbc54d3991a368bbd3","modified":1746276195384},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1746276195385},{"_id":"themes/next/layout/_third-party/index.njk","hash":"dfd7cdd6ba89f8c3deabc27726c7a350cadafd11","modified":1746276195334},{"_id":"themes/next/scripts/helpers/engine.js","hash":"83235f2879567eb8686431c9554a4b99f14ab665","modified":1746276195390},{"_id":"themes/next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1746276195384},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1746276195390},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1746276195390},{"_id":"themes/next/scripts/helpers/font.js","hash":"4c84d45daac86396edf656d2a8abe6e7583491ea","modified":1746276195390},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"6281d47c1de98eb38f3aa0f6df29bbb19d412173","modified":1746276195391},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"af3946a595f997eb43d9af87428e4898c9acbc82","modified":1746276195390},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"439c37d7177ebc407206a432168536af41dea826","modified":1746276195391},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1746276195387},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"7261e24287984853c8ef08cda8bbc80cacf9bd6f","modified":1746276195321},{"_id":"themes/next/scripts/tags/index.js","hash":"1f6aba7820f1fb58b61969485148db21846e1aa9","modified":1746276195387},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1746276195386},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1746276195388},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1746276195387},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"f57f7e09eb6220f681fa8385082b0960502ce5c4","modified":1746276195388},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"7d7bbc4a9970bd4c5449bc71b94364a8ec61e5d2","modified":1746276195386},{"_id":"themes/next/layout/_scripts/index.njk","hash":"2a7dfffebad19b67dc9e3b2a6b2986d0630ef930","modified":1746276195321},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1746276195387},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1746276195386},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1746276195387},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1746276195386},{"_id":"themes/next/scripts/tags/wavedrom.js","hash":"b44dfeeb58b41945d469141787f3dbce4b117d08","modified":1746276195386},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1746276195386},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1746276195361},{"_id":"themes/next/source/css/_mixins.styl","hash":"e21309d4165ebb6645084eed8dd749846ae981f1","modified":1746276195356},{"_id":"themes/next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1746276195339},{"_id":"themes/next/source/css/_colors.styl","hash":"ebfe0954e3931431f46f913abe08d0212e06e7c2","modified":1746276195355},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1746276195361},{"_id":"themes/next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1746276195356},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1746276195361},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1746276195361},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1746276195362},{"_id":"themes/next/source/js/bookmark.js","hash":"9ba4cceafd12c6d5ba8a6b986a046ef8319a7811","modified":1746276195373},{"_id":"themes/next/source/js/motion.js","hash":"6f751f5c9499a39d7c5e1d323db3260342dd9431","modified":1746276195365},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1746276195373},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1746276195365},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1746276195364},{"_id":"themes/next/source/js/next-boot.js","hash":"523bbaeda463e82ab0be428cc0005717038ec63e","modified":1746276195365},{"_id":"themes/next/source/js/pjax.js","hash":"694b271819aab37ce473b15db9e6aded971d82e5","modified":1746276195363},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"93c1d103d9d16581c944c51f3d0638f57c80ee41","modified":1746276195328},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1746276195329},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1746276195329},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"a38c6d92b368bfc42c72ad799ad03f3274957065","modified":1746276195361},{"_id":"themes/next/source/js/sidebar.js","hash":"2ee359ae48273b01ba1e0768704524e08702c7eb","modified":1746276195363},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1746276195329},{"_id":"themes/next/source/js/utils.js","hash":"b870aae1271f3453b71e6d8cd6fc4a1448e52064","modified":1746276195365},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1746276195330},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1746276195324},{"_id":"themes/next/source/images/av1.jpg","hash":"56b4218758e739164496e716a98b00652dad20f4","modified":1746277635335},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1746276195325},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1746276195324},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1746276195364},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1746276195329},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1746276195325},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1746276195328},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"bfff923526d6800218f08dba6ce0bbf5c17755fd","modified":1746276195326},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1746276195326},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"16696990e4ce65fc8db18c4635082a5d5d06ff07","modified":1746276195327},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1746276195327},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1746276195327},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1746276195325},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"bc5708e38b6070dff0cab6bf9480971017ce4dda","modified":1746276195323},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1746276195337},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1746276195326},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1746276195337},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1746276195337},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1746276195338},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"1efeeda00db08a3c033798228dd0092ee532cc36","modified":1746276195336},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1746276195337},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1746276195337},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"3343750682fbd8535e50f8129be3003ad26015b4","modified":1746276195336},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1746276195333},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1746276195332},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1746276195332},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"6ad43135bd3aecf933ffdd750763e27ade36f97c","modified":1746276195328},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1746276195333},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1746276195332},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1746276195332},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1746276195333},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1746276195332},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1746276195332},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1746276195337},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1746276195334},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"41b28f05e6233fb37700f7151f55868be10a0965","modified":1746276195335},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1746276195334},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1746276195334},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1746276195331},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1746276195335},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1746276195331},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1746276195335},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1746276195331},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"8a8f752260be5b8098393f9879b61ffe904465e8","modified":1746276195389},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1746276195388},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1746276195335},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1746276195389},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"e2b4a9d6b08155735ec336eedc506763d5671821","modified":1746276195389},{"_id":"themes/next/layout/_third-party/tags/wavedrom.njk","hash":"02202bf563fb5eedde2ccad4d6c5b9109d30a703","modified":1746276195335},{"_id":"themes/next/scripts/events/lib/config.js","hash":"00af4f5f9a79eaccf051f9e372d233d65d44c8a5","modified":1746276195389},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1746276195383},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1746276195384},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1746276195384},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1746276195383},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1746276195383},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1746276195382},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1746276195384},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"5942feb3f31ed3480bf50b0f5a4a305b5bdca3d6","modified":1746276195389},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"55c2468b2b7f035881d494085527d6554f37b556","modified":1746276195331},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1746276195383},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1746276195354},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"2c800eaab6c613e5d091be2111aaa786641aa0c2","modified":1746276195355},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"879b49f693af0c04c285b2dd0c9cccaf77347b7c","modified":1746276195355},{"_id":"themes/next/source/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1746276195369},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"20d5c6aa136bbb55e03906d98ee90ad3fbaa80a7","modified":1746276195355},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1746276195367},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1746276195382},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1746276195369},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b8445c828d78a38e2de50bdc86b3bff66285ea0f","modified":1746276195348},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1746276195348},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1746276195348},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"48b2dfc04df6409c6e0736ccc11462ad97d349b1","modified":1746276195353},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f316ba87f8d3299677fbf8345e1e993c35210e2e","modified":1746276195343},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1746276195343},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1746276195353},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1746276195341},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1746276195342},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"69c66aab4651e2e7ae9e65f08600144970648c60","modified":1746276195340},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1746276195346},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"bcbf498d8d3ecea84324f0a59b7f95f389a52b8d","modified":1746276195358},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1746276195343},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1746276195360},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f23c53e32d140091b819be2603d1afbbb5d66933","modified":1746276195360},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1746276195360},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1746276195357},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1746276195357},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1746276195360},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e31f6adbb22a451f07e4661cff9a2f12e4e99a36","modified":1746276195357},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"c29a827e82d2820ed8977c92994da73721200fac","modified":1746276195357},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1746276195357},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"dc03835e42d82eaf2633cf3b627990ad3e1f5967","modified":1746276195359},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"a92c4eb16bdb7806079467eb022ccf193bb0f794","modified":1746276195358},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"a03f16ffc7dfdbdc6053f9fd68d77257ba0c559e","modified":1746276195359},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1746276195357},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e792a6233e1d4dbc5fd2f10ae97b7a790b82568b","modified":1746276195359},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1746276195359},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1746276195358},{"_id":"themes/next/source/css/_variables/base.styl","hash":"6ec500fa4005993f2e080e260194f4d5323f589f","modified":1746276195355},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1746276195345},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1746276195358},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1746276195372},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1746276195372},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1746276195366},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1746276195372},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1746276195369},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"313637fe3569f98fd926e8cd0fcc75d098eb6e6e","modified":1746276195339},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1746276195369},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1746276195368},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1746276195367},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1746276195368},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1746276195372},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1746276195368},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1746276195370},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1746276195367},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1746276195368},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1746276195366},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1746276195368},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"1d1b6d847215b16f26b230859d7e16501190ecc0","modified":1746276195370},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1746276195366},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1746276195370},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1746276195370},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"51a97a33879289904cb523ddc2d88b5b0c60fa72","modified":1746276195350},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4262628e173b16c4c6c18f817173dd103fb9e9a8","modified":1746276195371},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1746276195350},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1746276195350},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1746276195370},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1746276195350},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1746276195347},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"93f014809d6442da23f8b7d729f7375e2badba7d","modified":1746276195346},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1746276195350},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"809bab3414b1eb1ae44444eb821126868f764414","modified":1746276195347},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1746276195347},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"93d3c39aded8d0140e63e70b896bd3d34c187c68","modified":1746276195371},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"026cd5735fd2a75bb60b7bf8bd09139583d602b9","modified":1746276195348},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1746276195346},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1746276195349},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"ebfba158a0a4af3d1dabcacbc58986664de52140","modified":1746276195347},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1746276195347},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"b47fb36915962309553ff7fb1782341585ed2b76","modified":1746276195346},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1746276195349},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"54d12e2c5d9982f7b9e5b23be5133954a8514e9d","modified":1746276195349},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"424de4f64b12c521e8c6bfbc711d7961490ab36e","modified":1746276195347},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1746276195353},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1746276195349},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1746276195348},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"09afd355e9d55cb97bbfe55178aa3480adce8f31","modified":1746276195349},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1746276195354},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1746276195353},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1746276195354},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1746276195354},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"21acb11e397526132605eef23bde7b307aa1eab5","modified":1746276195351},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"ce36bf1602233298e0351b4babc592315529eb26","modified":1746276195351},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"a3dd3edea9c01b66b28a8367185269b9dcc3bdee","modified":1746276195354},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1746276195352},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1746276195352},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1746276195354},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"46eece42510c2c89bb9209afb0262ad76a4b0b36","modified":1746276195352},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1746276195352},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"0847400d8579b0a2dd1bf662c78954c10adf2680","modified":1746276195351},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"741566d6ac5f852b5c8dee6a8996b65e48e7c97f","modified":1746276195352},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1746276195351},{"_id":"themes/next/source/css/_common/scaffolding/highlight/fold.styl","hash":"42a0b65491ad85438596b3fe0b7f23973e4cef34","modified":1746276195341},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f634f94828620e88c3f5a8db56f7944f6ba232b0","modified":1746276195340},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-copyright.styl","hash":"56805b77fe236fac19e19c716a49363bcf986311","modified":1746276195352},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"9b0217e1caecd91e05572c7e8e52d32016ca312f","modified":1746276195340},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"22cd37bd5df9972d5074710896aba4424ad5161c","modified":1746276195344},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1746276195345},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1746276195344},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1746276195351},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1746276195344},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"49329a7144f3413d1c832e52a1f4954171ef11e1","modified":1746276195344},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1746276195344},{"_id":"themes/next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"af113411ad9cca7674177be36af8dd399680834d","modified":1746276195345},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"c3be8b0738f693e750486bb71769c3dbbec174cc","modified":1746276195343},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"8213015d9cae45d2c9945f8aba9d8db39c734efc","modified":1746276195344},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1746276195345},{"_id":"source/_posts/conda常用命令.md","hash":"f2e996f602273f4a4afcae71516395fdba724335","modified":1747738355358},{"_id":"source/_posts/go语言中之嵌入.md","hash":"a0c81ac1e914863f0f32334931f7df7eed3f88ee","modified":1747201162563},{"_id":"source/_posts/go语言中之无缓冲通道.md","hash":"5eb3a57cd68b3cf6291e0033ff18b72c918456a1","modified":1747726513760},{"_id":"source/_posts/go语言中之接口设计原则.md","hash":"db1049a9af1867a04e18c86558cc88b8c279ad58","modified":1747288989702},{"_id":"source/_posts/go语言中之枚举.md","hash":"a2a24ad4b5dd1f735668503be26c68a7a8640c56","modified":1747124865957},{"_id":"source/_posts/go语言并发编程入门指南.md","hash":"2b34be3ad6d5329be1a0332815aa90dd902dbead","modified":1747565240136},{"_id":"source/_posts/go语言中之错误处理.md","hash":"7c9b38412163755e8ee9d1f0b5435f7d44a64e26","modified":1747273814596},{"_id":"source/_posts/go语言之CLI框架cobra.md","hash":"e02c3e8d0d4845a8ad3aeed5d69adf18cafa3fe9","modified":1748220962166},{"_id":"source/_posts/go语言之嵌入.md","hash":"06d9b54695d8aebfa30763bbd867be33f826db89","modified":1747981548018},{"_id":"source/_posts/go语言之常用标准库.md","hash":"62037f63a8fc82570b9399cff20da44e1605d153","modified":1747981573771},{"_id":"source/_posts/go语言之并发编程入门指南.md","hash":"6e61073d19bbc088ee6a2e1360cf0887ac661e3e","modified":1747981630599},{"_id":"source/_posts/go语言之无缓冲通道.md","hash":"bbcc386867ffcb0079d06aa2447388fe55930cb2","modified":1747981529715},{"_id":"source/_posts/go语言之枚举.md","hash":"b0f25f23b2d7a9aec8e8a1398774537068da66a8","modified":1747981544894},{"_id":"source/_posts/go语言之错误处理.md","hash":"c3ecadb8ec50fb7d935cf2994fc1241760760fb9","modified":1747981535689},{"_id":"source/_posts/go语言之未知结构体反序列化.md","hash":"d3eac9b8a6ebf5699918f9dba598438f44092b5a","modified":1748052497205},{"_id":"source/_posts/go语言之接口设计原则.md","hash":"9306b7494a4325f743ff4f3e44439544a460ee36","modified":1747981540845},{"_id":"source/_posts/远程通信协议：RPCvsHTTP.md","hash":"1a59a4b41e9024383a490a752cf381707ef9b920","modified":1748058324272}],"Category":[{"name":"Cyfrin Updraft","_id":"cmal0vt8c0007p3j53b7o2q3c"},{"name":"Solidity学习","_id":"cmal0vt8g000mp3j5g8kq6liq"},{"name":"go","_id":"cmal0vt8h000yp3j5f810gwyw"},{"name":"经验分享","_id":"cmal0vt8i0017p3j50u7vargg"},{"name":"basic","parent":"cmal0vt8h000yp3j5f810gwyw","_id":"cmal0vt8i001cp3j58b3sd1di"}],"Data":[{"_id":"head","data":""},{"_id":"sidebar","data":""}],"Page":[{"title":"归档","date":"2024-03-20T16:00:00.000Z","type":"archives","comments":0,"_content":"","source":"archives/index.md","raw":"---\ntitle: 归档\ndate: 2024-03-21\ntype: \"archives\"\ncomments: false\n---\n","updated":"2025-05-03T14:06:45.875Z","path":"archives/index.html","layout":"page","_id":"cmal0vt860000p3j55zgaap41","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","excerpt":"","more":""},{"title":"分类","date":"2024-03-20T16:00:00.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2024-03-21\ntype: \"categories\"\ncomments: false\n---\n","updated":"2025-05-03T13:32:05.562Z","path":"categories/index.html","layout":"page","_id":"cmal0vt8a0002p3j5hc6zhfz3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","excerpt":"","more":""},{"title":"关于","date":"2024-03-20T16:00:00.000Z","type":"about","comments":0,"_content":"\n---  \n\n**👨‍💻 关于我**  \n\n欢迎来到我的博客！这里记录我的 技术思考、学习笔记 和 生活灵感。  \n\n📌 当前状态：  \n• 本科毕业一年，无聊的实习了半年  \n\n• 华北电力大学硕士新生（网络安全-密码学与区块链方向）  \n\n• 研究方向仍在探索中，没有导师指示  \n\n\n💡 兴趣与技能：  \n• 热爱探索新技术，目前对 区块链技术 感兴趣\n\n• 基本的 Web 开发（前端+后端），但是始终不够精进  \n\n• 正在寻找适合深入发展的技术领域  \n\n\n🌍 终极目标：  \n成为 数字游民，实现 远程工作自由！（财富自不自由无所谓）\n\n---  \n\n**📬 联系方式**  \n\n| 方式 | 信息 |  \n|------|------|  \n| 📧 Email | alan_root@outlook.com |  \n| 💻 Gitee | https://gitee.com/alan223 |  \n\n---  \n\n**🎯 近期目标**  \n\n| 目标 | 进度 |  \n|------|------|  \n| 🚀 提升英语（达到工作交流水平） | 🔄 进行中 |  \n| 📚 适应科研节奏（争取研一完成毕业要求） | 🔄 进行中 |  \n| 🔗 深入研究区块链（探索非金融应用） | 🔄 进行中 |  \n| 💼 建立核心竞争力（为就业做准备） | 🔄 进行中 |  \n\n> *（当前仍处于迷茫探索期，期待开学后导师能指条明路）*  \n\n---  \n\n**🦁 结语**  \n最后感谢您的访问！希望鼠鼠的博客能给您带来一些启发和帮助。如果您有任何问题或建议，欢迎随时联系我。祝您好运！\n\n---\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2024-03-21\ntype: \"about\"\ncomments: false\n---\n\n---  \n\n**👨‍💻 关于我**  \n\n欢迎来到我的博客！这里记录我的 技术思考、学习笔记 和 生活灵感。  \n\n📌 当前状态：  \n• 本科毕业一年，无聊的实习了半年  \n\n• 华北电力大学硕士新生（网络安全-密码学与区块链方向）  \n\n• 研究方向仍在探索中，没有导师指示  \n\n\n💡 兴趣与技能：  \n• 热爱探索新技术，目前对 区块链技术 感兴趣\n\n• 基本的 Web 开发（前端+后端），但是始终不够精进  \n\n• 正在寻找适合深入发展的技术领域  \n\n\n🌍 终极目标：  \n成为 数字游民，实现 远程工作自由！（财富自不自由无所谓）\n\n---  \n\n**📬 联系方式**  \n\n| 方式 | 信息 |  \n|------|------|  \n| 📧 Email | alan_root@outlook.com |  \n| 💻 Gitee | https://gitee.com/alan223 |  \n\n---  \n\n**🎯 近期目标**  \n\n| 目标 | 进度 |  \n|------|------|  \n| 🚀 提升英语（达到工作交流水平） | 🔄 进行中 |  \n| 📚 适应科研节奏（争取研一完成毕业要求） | 🔄 进行中 |  \n| 🔗 深入研究区块链（探索非金融应用） | 🔄 进行中 |  \n| 💼 建立核心竞争力（为就业做准备） | 🔄 进行中 |  \n\n> *（当前仍处于迷茫探索期，期待开学后导师能指条明路）*  \n\n---  \n\n**🦁 结语**  \n最后感谢您的访问！希望鼠鼠的博客能给您带来一些启发和帮助。如果您有任何问题或建议，欢迎随时联系我。祝您好运！\n\n---\n","updated":"2025-05-05T03:25:28.286Z","path":"about/index.html","layout":"page","_id":"cmal0vt8b0005p3j5fsytd2o4","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><hr>\n<p><strong>👨‍💻 关于我</strong>  </p>\n<p>欢迎来到我的博客！这里记录我的 技术思考、学习笔记 和 生活灵感。  </p>\n<p>📌 当前状态：<br>• 本科毕业一年，无聊的实习了半年  </p>\n<p>• 华北电力大学硕士新生（网络安全-密码学与区块链方向）  </p>\n<p>• 研究方向仍在探索中，没有导师指示  </p>\n<p>💡 兴趣与技能：<br>• 热爱探索新技术，目前对 区块链技术 感兴趣</p>\n<p>• 基本的 Web 开发（前端+后端），但是始终不够精进  </p>\n<p>• 正在寻找适合深入发展的技术领域  </p>\n<p>🌍 终极目标：<br>成为 数字游民，实现 远程工作自由！（财富自不自由无所谓）</p>\n<hr>\n<p><strong>📬 联系方式</strong>  </p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>📧 Email</td>\n<td><a href=\"mailto:&#x61;&#x6c;&#x61;&#x6e;&#95;&#x72;&#x6f;&#111;&#x74;&#x40;&#x6f;&#x75;&#116;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#99;&#x6f;&#x6d;\">&#x61;&#x6c;&#x61;&#x6e;&#95;&#x72;&#x6f;&#111;&#x74;&#x40;&#x6f;&#x75;&#116;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#99;&#x6f;&#x6d;</a></td>\n</tr>\n<tr>\n<td>💻 Gitee</td>\n<td><a href=\"https://gitee.com/alan223\">https://gitee.com/alan223</a></td>\n</tr>\n</tbody></table>\n<hr>\n<p><strong>🎯 近期目标</strong>  </p>\n<table>\n<thead>\n<tr>\n<th>目标</th>\n<th>进度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>🚀 提升英语（达到工作交流水平）</td>\n<td>🔄 进行中</td>\n</tr>\n<tr>\n<td>📚 适应科研节奏（争取研一完成毕业要求）</td>\n<td>🔄 进行中</td>\n</tr>\n<tr>\n<td>🔗 深入研究区块链（探索非金融应用）</td>\n<td>🔄 进行中</td>\n</tr>\n<tr>\n<td>💼 建立核心竞争力（为就业做准备）</td>\n<td>🔄 进行中</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><em>（当前仍处于迷茫探索期，期待开学后导师能指条明路）</em>  </p>\n</blockquote>\n<hr>\n<p><strong>🦁 结语</strong><br>最后感谢您的访问！希望鼠鼠的博客能给您带来一些启发和帮助。如果您有任何问题或建议，欢迎随时联系我。祝您好运！</p>\n<hr>\n","excerpt":"","more":"<hr>\n<p><strong>👨‍💻 关于我</strong>  </p>\n<p>欢迎来到我的博客！这里记录我的 技术思考、学习笔记 和 生活灵感。  </p>\n<p>📌 当前状态：<br>• 本科毕业一年，无聊的实习了半年  </p>\n<p>• 华北电力大学硕士新生（网络安全-密码学与区块链方向）  </p>\n<p>• 研究方向仍在探索中，没有导师指示  </p>\n<p>💡 兴趣与技能：<br>• 热爱探索新技术，目前对 区块链技术 感兴趣</p>\n<p>• 基本的 Web 开发（前端+后端），但是始终不够精进  </p>\n<p>• 正在寻找适合深入发展的技术领域  </p>\n<p>🌍 终极目标：<br>成为 数字游民，实现 远程工作自由！（财富自不自由无所谓）</p>\n<hr>\n<p><strong>📬 联系方式</strong>  </p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>📧 Email</td>\n<td><a href=\"mailto:&#x61;&#x6c;&#x61;&#x6e;&#95;&#x72;&#x6f;&#111;&#x74;&#x40;&#x6f;&#x75;&#116;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#99;&#x6f;&#x6d;\">&#x61;&#x6c;&#x61;&#x6e;&#95;&#x72;&#x6f;&#111;&#x74;&#x40;&#x6f;&#x75;&#116;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#99;&#x6f;&#x6d;</a></td>\n</tr>\n<tr>\n<td>💻 Gitee</td>\n<td><a href=\"https://gitee.com/alan223\">https://gitee.com/alan223</a></td>\n</tr>\n</tbody></table>\n<hr>\n<p><strong>🎯 近期目标</strong>  </p>\n<table>\n<thead>\n<tr>\n<th>目标</th>\n<th>进度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>🚀 提升英语（达到工作交流水平）</td>\n<td>🔄 进行中</td>\n</tr>\n<tr>\n<td>📚 适应科研节奏（争取研一完成毕业要求）</td>\n<td>🔄 进行中</td>\n</tr>\n<tr>\n<td>🔗 深入研究区块链（探索非金融应用）</td>\n<td>🔄 进行中</td>\n</tr>\n<tr>\n<td>💼 建立核心竞争力（为就业做准备）</td>\n<td>🔄 进行中</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><em>（当前仍处于迷茫探索期，期待开学后导师能指条明路）</em>  </p>\n</blockquote>\n<hr>\n<p><strong>🦁 结语</strong><br>最后感谢您的访问！希望鼠鼠的博客能给您带来一些启发和帮助。如果您有任何问题或建议，欢迎随时联系我。祝您好运！</p>\n<hr>\n"},{"title":"标签","date":"2024-03-20T16:00:00.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-03-21\ntype: \"tags\"\ncomments: false\n---\n","updated":"2025-05-03T13:25:38.835Z","path":"tags/index.html","layout":"page","_id":"cmal0vt8c0008p3j5edmthwl5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","excerpt":"","more":""}],"Post":[{"title":"ENS域名系统","description":"ENS（Ethereum Name Service，以太坊域名服务）是以太坊上的去中心化域名解析系统","toc":false,"date":"2025-05-04T12:05:20.000Z","_content":"\n### **ENS 域名简介**\n\nENS（Ethereum Name Service，以太坊域名服务）是以太坊上的去中心化域名解析系统，类似于传统互联网的DNS（域名系统），但它专门为区块链地址服务。ENS允许用户将复杂的以太坊钱包地址（如 `0x1234...abcd`）映射到易于记忆的**域名**（如 `alice.eth`）。\n\nENS不仅支持地址映射，还可以存储IPFS内容哈希、文本记录、加密钱包等信息，从而让区块链更具可读性和可用性。\n\n---\n\n### **ENS 的核心功能**\n\nENS 提供的主要功能包括：\n\n1. **钱包地址解析**：将 `alice.eth` 解析为 `0x1234...abcd`。\n\n2. **反向解析**：从钱包地址解析出 ENS 域名。\n\n3. **文本记录存储**：可以存储社交媒体链接、IPFS哈希、电子邮件等信息。\n\n4. **子域名管理**：可以创建如 `mail.alice.eth` 这样的子域名。\n\n---\n\n### **ENS 工作流程**\n\nENS 依赖智能合约运行在以太坊网络上，主要组件包括：\n\n5. **Registry（注册表合约）**：存储域名的所有者、解析器、到期时间等信息。\n\n6. **Resolver（解析器合约）**：处理域名的解析逻辑，将ENS名称转换为地址或其他记录。\n\n7. **Registrar（注册管理器）**：处理ENS域名的购买、转移和续费。\n\n---\n\n### **如何在DApp中集成ENS域名解析**\n\n为了在你的Web3Mail DApp中支持ENS域名，可以使用 `ethers.js` 库进行交互，ENS解析流程如下：\n\n#### **1. 检查用户是否拥有ENS域名**\n\n在用户登录时，我们可以使用 `ethers.js` 查询用户的ENS名称，如果没有，则显示其钱包地址。\n\n```JavaScript\nimport { ethers } from \"ethers\";\n\n// 连接以太坊钱包\nconst provider = new ethers.BrowserProvider(window.ethereum);\n\nasync function getENSName(address) {\n  try {\n    const ensName = await provider.lookupAddress(address);\n    if (ensName) {\n      console.log(`ENS 名称: ${ensName}`);\n      return ensName;\n    } else {\n      console.log(`未找到 ENS 名称，地址: ${address}`);\n      return address;\n    }\n  } catch (error) {\n    console.error(\"ENS 查询失败:\", error);\n    return address;\n  }\n}\n\n// 获取当前用户地址\nasync function fetchUserENS() {\n  const signer = await provider.getSigner();\n  const address = await signer.getAddress();\n  return getENSName(address);\n}\n\nfetchUserENS().then(console.log);\n```\n\n\n---\n\n#### **2. 发送邮件时解析 ENS 域名**\n\n当用户输入接收者 ENS 域名（如 `bob.eth`）时，需解析为以太坊地址，并存储到智能合约。\n\n```JavaScript\nasync function resolveENS(ensName) {\n  try {\n    const address = await provider.resolveName(ensName);\n    if (address) {\n      console.log(`ENS 解析结果: ${ensName} -> ${address}`);\n      return address;\n    } else {\n      throw new Error(\"ENS 名称解析失败\");\n    }\n  } catch (error) {\n    console.error(\"解析 ENS 时出错:\", error);\n    throw error;\n  }\n}\n\n// 示例: 发送邮件前解析 ENS 名称\nasync function sendMail(toENS, ipfsHash) {\n  try {\n    const recipientAddress = await resolveENS(toENS);\n    // 这里调用智能合约，将 recipientAddress 和 ipfsHash 存储\n  } catch (error) {\n    console.error(\"发送邮件失败:\", error);\n  }\n}\n```\n\n\n---\n\n#### **3. 反向解析（地址到 ENS 名称）**\n\n在收件箱列表中，你可以使用反向解析将以太坊地址转换为ENS名称。\n\n```JavaScript\nasync function reverseLookup(address) {\n  const ensName = await provider.lookupAddress(address);\n  return ensName ? ensName : address;\n}\n```\n\n\n---\n\n### **如何在 Solidity 智能合约中集成 ENS**\n\nENS 提供了官方的智能合约接口，可以在合约中直接查询 ENS 名称：\n\n#### **ENS 合约地址（Ethereum Mainnet）**\n\nENS 的注册表合约在以太坊主网上的地址为：\n`0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e`\n\n#### **在 Solidity 中解析 ENS**\n\n```Solidity\npragma solidity ^0.8.0;\n\ninterface IENSResolver {\n    function addr(bytes32 node) external view returns (address);\n}\n\ncontract ENSHelper {\n    IENSResolver ensResolver = IENSResolver(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n\n    function resolveENS(bytes32 node) public view returns (address) {\n        return ensResolver.addr(node);\n    }\n}\n```\n\n\n在合约中使用ENS解析时，ENS名称需要转换为 `keccak256` 哈希，例如：\n\n```JavaScript\nconst ensNameHash = ethers.keccak256(ethers.toUtf8Bytes(\"alice.eth\"));\n```\n\n\n---\n\n### **部署 ENS 域名**\n\n如果你想为你的 DApp 部署 ENS 域名，你可以使用 ENS 官方网站或脚本进行注册：\n\n8. 打开 [ens.domains](https://ens.domains/) 官方网站。\n\n9. 连接你的以太坊钱包（MetaMask等）。\n\n10. 搜索你的域名（如 `web3mail.eth`）。\n\n11. 按照提示完成注册并支付所需的GAS费用。\n\n注册完成后，你可以将ENS域名指向你的DApp前端或合约地址。\n\n---\n\n### **ENS 费用**\n\nENS 域名注册通常涉及：\n\n- **年费**：根据ENS域名的长度决定，3位字符的域名最贵，5位以上相对便宜。\n\n- **Gas 费**：进行注册或更新时需要支付以太坊的交易费用。\n\n- **子域名**：注册的ENS域名可以免费创建子域名，如 `inbox.alice.eth`。\n\n---\n\n\n\n\n\n","source":"_posts/ENS域名系统.md","raw":"---\ntitle: ENS域名系统\ndescription: 'ENS（Ethereum Name Service，以太坊域名服务）是以太坊上的去中心化域名解析系统'\ntags: ['web3']\ntoc: false\ndate: 2025-05-04 20:05:20\ncategories:\n---\n\n### **ENS 域名简介**\n\nENS（Ethereum Name Service，以太坊域名服务）是以太坊上的去中心化域名解析系统，类似于传统互联网的DNS（域名系统），但它专门为区块链地址服务。ENS允许用户将复杂的以太坊钱包地址（如 `0x1234...abcd`）映射到易于记忆的**域名**（如 `alice.eth`）。\n\nENS不仅支持地址映射，还可以存储IPFS内容哈希、文本记录、加密钱包等信息，从而让区块链更具可读性和可用性。\n\n---\n\n### **ENS 的核心功能**\n\nENS 提供的主要功能包括：\n\n1. **钱包地址解析**：将 `alice.eth` 解析为 `0x1234...abcd`。\n\n2. **反向解析**：从钱包地址解析出 ENS 域名。\n\n3. **文本记录存储**：可以存储社交媒体链接、IPFS哈希、电子邮件等信息。\n\n4. **子域名管理**：可以创建如 `mail.alice.eth` 这样的子域名。\n\n---\n\n### **ENS 工作流程**\n\nENS 依赖智能合约运行在以太坊网络上，主要组件包括：\n\n5. **Registry（注册表合约）**：存储域名的所有者、解析器、到期时间等信息。\n\n6. **Resolver（解析器合约）**：处理域名的解析逻辑，将ENS名称转换为地址或其他记录。\n\n7. **Registrar（注册管理器）**：处理ENS域名的购买、转移和续费。\n\n---\n\n### **如何在DApp中集成ENS域名解析**\n\n为了在你的Web3Mail DApp中支持ENS域名，可以使用 `ethers.js` 库进行交互，ENS解析流程如下：\n\n#### **1. 检查用户是否拥有ENS域名**\n\n在用户登录时，我们可以使用 `ethers.js` 查询用户的ENS名称，如果没有，则显示其钱包地址。\n\n```JavaScript\nimport { ethers } from \"ethers\";\n\n// 连接以太坊钱包\nconst provider = new ethers.BrowserProvider(window.ethereum);\n\nasync function getENSName(address) {\n  try {\n    const ensName = await provider.lookupAddress(address);\n    if (ensName) {\n      console.log(`ENS 名称: ${ensName}`);\n      return ensName;\n    } else {\n      console.log(`未找到 ENS 名称，地址: ${address}`);\n      return address;\n    }\n  } catch (error) {\n    console.error(\"ENS 查询失败:\", error);\n    return address;\n  }\n}\n\n// 获取当前用户地址\nasync function fetchUserENS() {\n  const signer = await provider.getSigner();\n  const address = await signer.getAddress();\n  return getENSName(address);\n}\n\nfetchUserENS().then(console.log);\n```\n\n\n---\n\n#### **2. 发送邮件时解析 ENS 域名**\n\n当用户输入接收者 ENS 域名（如 `bob.eth`）时，需解析为以太坊地址，并存储到智能合约。\n\n```JavaScript\nasync function resolveENS(ensName) {\n  try {\n    const address = await provider.resolveName(ensName);\n    if (address) {\n      console.log(`ENS 解析结果: ${ensName} -> ${address}`);\n      return address;\n    } else {\n      throw new Error(\"ENS 名称解析失败\");\n    }\n  } catch (error) {\n    console.error(\"解析 ENS 时出错:\", error);\n    throw error;\n  }\n}\n\n// 示例: 发送邮件前解析 ENS 名称\nasync function sendMail(toENS, ipfsHash) {\n  try {\n    const recipientAddress = await resolveENS(toENS);\n    // 这里调用智能合约，将 recipientAddress 和 ipfsHash 存储\n  } catch (error) {\n    console.error(\"发送邮件失败:\", error);\n  }\n}\n```\n\n\n---\n\n#### **3. 反向解析（地址到 ENS 名称）**\n\n在收件箱列表中，你可以使用反向解析将以太坊地址转换为ENS名称。\n\n```JavaScript\nasync function reverseLookup(address) {\n  const ensName = await provider.lookupAddress(address);\n  return ensName ? ensName : address;\n}\n```\n\n\n---\n\n### **如何在 Solidity 智能合约中集成 ENS**\n\nENS 提供了官方的智能合约接口，可以在合约中直接查询 ENS 名称：\n\n#### **ENS 合约地址（Ethereum Mainnet）**\n\nENS 的注册表合约在以太坊主网上的地址为：\n`0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e`\n\n#### **在 Solidity 中解析 ENS**\n\n```Solidity\npragma solidity ^0.8.0;\n\ninterface IENSResolver {\n    function addr(bytes32 node) external view returns (address);\n}\n\ncontract ENSHelper {\n    IENSResolver ensResolver = IENSResolver(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n\n    function resolveENS(bytes32 node) public view returns (address) {\n        return ensResolver.addr(node);\n    }\n}\n```\n\n\n在合约中使用ENS解析时，ENS名称需要转换为 `keccak256` 哈希，例如：\n\n```JavaScript\nconst ensNameHash = ethers.keccak256(ethers.toUtf8Bytes(\"alice.eth\"));\n```\n\n\n---\n\n### **部署 ENS 域名**\n\n如果你想为你的 DApp 部署 ENS 域名，你可以使用 ENS 官方网站或脚本进行注册：\n\n8. 打开 [ens.domains](https://ens.domains/) 官方网站。\n\n9. 连接你的以太坊钱包（MetaMask等）。\n\n10. 搜索你的域名（如 `web3mail.eth`）。\n\n11. 按照提示完成注册并支付所需的GAS费用。\n\n注册完成后，你可以将ENS域名指向你的DApp前端或合约地址。\n\n---\n\n### **ENS 费用**\n\nENS 域名注册通常涉及：\n\n- **年费**：根据ENS域名的长度决定，3位字符的域名最贵，5位以上相对便宜。\n\n- **Gas 费**：进行注册或更新时需要支付以太坊的交易费用。\n\n- **子域名**：注册的ENS域名可以免费创建子域名，如 `inbox.alice.eth`。\n\n---\n\n\n\n\n\n","slug":"ENS域名系统","published":1,"updated":"2025-05-04T12:06:15.916Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt880001p3j5e0fm5d2t","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"ENS-域名简介\"><a href=\"#ENS-域名简介\" class=\"headerlink\" title=\"ENS 域名简介\"></a><strong>ENS 域名简介</strong></h3><p>ENS（Ethereum Name Service，以太坊域名服务）是以太坊上的去中心化域名解析系统，类似于传统互联网的DNS（域名系统），但它专门为区块链地址服务。ENS允许用户将复杂的以太坊钱包地址（如 <code>0x1234...abcd</code>）映射到易于记忆的<strong>域名</strong>（如 <code>alice.eth</code>）。</p>\n<p>ENS不仅支持地址映射，还可以存储IPFS内容哈希、文本记录、加密钱包等信息，从而让区块链更具可读性和可用性。</p>\n<hr>\n<h3 id=\"ENS-的核心功能\"><a href=\"#ENS-的核心功能\" class=\"headerlink\" title=\"ENS 的核心功能\"></a><strong>ENS 的核心功能</strong></h3><p>ENS 提供的主要功能包括：</p>\n<ol>\n<li><p><strong>钱包地址解析</strong>：将 <code>alice.eth</code> 解析为 <code>0x1234...abcd</code>。</p>\n</li>\n<li><p><strong>反向解析</strong>：从钱包地址解析出 ENS 域名。</p>\n</li>\n<li><p><strong>文本记录存储</strong>：可以存储社交媒体链接、IPFS哈希、电子邮件等信息。</p>\n</li>\n<li><p><strong>子域名管理</strong>：可以创建如 <code>mail.alice.eth</code> 这样的子域名。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"ENS-工作流程\"><a href=\"#ENS-工作流程\" class=\"headerlink\" title=\"ENS 工作流程\"></a><strong>ENS 工作流程</strong></h3><p>ENS 依赖智能合约运行在以太坊网络上，主要组件包括：</p>\n<ol start=\"5\">\n<li><p><strong>Registry（注册表合约）</strong>：存储域名的所有者、解析器、到期时间等信息。</p>\n</li>\n<li><p><strong>Resolver（解析器合约）</strong>：处理域名的解析逻辑，将ENS名称转换为地址或其他记录。</p>\n</li>\n<li><p><strong>Registrar（注册管理器）</strong>：处理ENS域名的购买、转移和续费。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"如何在DApp中集成ENS域名解析\"><a href=\"#如何在DApp中集成ENS域名解析\" class=\"headerlink\" title=\"如何在DApp中集成ENS域名解析\"></a><strong>如何在DApp中集成ENS域名解析</strong></h3><p>为了在你的Web3Mail DApp中支持ENS域名，可以使用 <code>ethers.js</code> 库进行交互，ENS解析流程如下：</p>\n<h4 id=\"1-检查用户是否拥有ENS域名\"><a href=\"#1-检查用户是否拥有ENS域名\" class=\"headerlink\" title=\"1. 检查用户是否拥有ENS域名\"></a><strong>1. 检查用户是否拥有ENS域名</strong></h4><p>在用户登录时，我们可以使用 <code>ethers.js</code> 查询用户的ENS名称，如果没有，则显示其钱包地址。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ethers &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;ethers&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接以太坊钱包</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> provider = <span class=\"keyword\">new</span> ethers.<span class=\"title class_\">BrowserProvider</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">ethereum</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getENSName</span>(<span class=\"params\">address</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ensName = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">lookupAddress</span>(address);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ensName) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`ENS 名称: <span class=\"subst\">$&#123;ensName&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ensName;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`未找到 ENS 名称，地址: <span class=\"subst\">$&#123;address&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;ENS 查询失败:&quot;</span>, error);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> address;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取当前用户地址</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchUserENS</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> signer = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">getSigner</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> address = <span class=\"keyword\">await</span> signer.<span class=\"title function_\">getAddress</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getENSName</span>(address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">fetchUserENS</span>().<span class=\"title function_\">then</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h4 id=\"2-发送邮件时解析-ENS-域名\"><a href=\"#2-发送邮件时解析-ENS-域名\" class=\"headerlink\" title=\"2. 发送邮件时解析 ENS 域名\"></a><strong>2. 发送邮件时解析 ENS 域名</strong></h4><p>当用户输入接收者 ENS 域名（如 <code>bob.eth</code>）时，需解析为以太坊地址，并存储到智能合约。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">resolveENS</span>(<span class=\"params\">ensName</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> address = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">resolveName</span>(ensName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (address) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`ENS 解析结果: <span class=\"subst\">$&#123;ensName&#125;</span> -&gt; <span class=\"subst\">$&#123;address&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> address;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;ENS 名称解析失败&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;解析 ENS 时出错:&quot;</span>, error);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例: 发送邮件前解析 ENS 名称</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">sendMail</span>(<span class=\"params\">toENS, ipfsHash</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> recipientAddress = <span class=\"keyword\">await</span> <span class=\"title function_\">resolveENS</span>(toENS);</span><br><span class=\"line\">    <span class=\"comment\">// 这里调用智能合约，将 recipientAddress 和 ipfsHash 存储</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;发送邮件失败:&quot;</span>, error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h4 id=\"3-反向解析（地址到-ENS-名称）\"><a href=\"#3-反向解析（地址到-ENS-名称）\" class=\"headerlink\" title=\"3. 反向解析（地址到 ENS 名称）\"></a><strong>3. 反向解析（地址到 ENS 名称）</strong></h4><p>在收件箱列表中，你可以使用反向解析将以太坊地址转换为ENS名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reverseLookup</span>(<span class=\"params\">address</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ensName = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">lookupAddress</span>(address);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ensName ? ensName : address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"如何在-Solidity-智能合约中集成-ENS\"><a href=\"#如何在-Solidity-智能合约中集成-ENS\" class=\"headerlink\" title=\"如何在 Solidity 智能合约中集成 ENS\"></a><strong>如何在 Solidity 智能合约中集成 ENS</strong></h3><p>ENS 提供了官方的智能合约接口，可以在合约中直接查询 ENS 名称：</p>\n<h4 id=\"ENS-合约地址（Ethereum-Mainnet）\"><a href=\"#ENS-合约地址（Ethereum-Mainnet）\" class=\"headerlink\" title=\"ENS 合约地址（Ethereum Mainnet）\"></a><strong>ENS 合约地址（Ethereum Mainnet）</strong></h4><p>ENS 的注册表合约在以太坊主网上的地址为：<br><code>0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e</code></p>\n<h4 id=\"在-Solidity-中解析-ENS\"><a href=\"#在-Solidity-中解析-ENS\" class=\"headerlink\" title=\"在 Solidity 中解析 ENS\"></a><strong>在 Solidity 中解析 ENS</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">interface IENSResolver &#123;</span><br><span class=\"line\">    function addr(bytes32 node) external view returns (address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ENSHelper &#123;</span><br><span class=\"line\">    IENSResolver ensResolver = IENSResolver(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);</span><br><span class=\"line\"></span><br><span class=\"line\">    function resolveENS(bytes32 node) public view returns (address) &#123;</span><br><span class=\"line\">        return ensResolver.addr(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在合约中使用ENS解析时，ENS名称需要转换为 <code>keccak256</code> 哈希，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ensNameHash = ethers.<span class=\"title function_\">keccak256</span>(ethers.<span class=\"title function_\">toUtf8Bytes</span>(<span class=\"string\">&quot;alice.eth&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"部署-ENS-域名\"><a href=\"#部署-ENS-域名\" class=\"headerlink\" title=\"部署 ENS 域名\"></a><strong>部署 ENS 域名</strong></h3><p>如果你想为你的 DApp 部署 ENS 域名，你可以使用 ENS 官方网站或脚本进行注册：</p>\n<ol start=\"8\">\n<li><p>打开 <a href=\"https://ens.domains/\">ens.domains</a> 官方网站。</p>\n</li>\n<li><p>连接你的以太坊钱包（MetaMask等）。</p>\n</li>\n<li><p>搜索你的域名（如 <code>web3mail.eth</code>）。</p>\n</li>\n<li><p>按照提示完成注册并支付所需的GAS费用。</p>\n</li>\n</ol>\n<p>注册完成后，你可以将ENS域名指向你的DApp前端或合约地址。</p>\n<hr>\n<h3 id=\"ENS-费用\"><a href=\"#ENS-费用\" class=\"headerlink\" title=\"ENS 费用\"></a><strong>ENS 费用</strong></h3><p>ENS 域名注册通常涉及：</p>\n<ul>\n<li><p><strong>年费</strong>：根据ENS域名的长度决定，3位字符的域名最贵，5位以上相对便宜。</p>\n</li>\n<li><p><strong>Gas 费</strong>：进行注册或更新时需要支付以太坊的交易费用。</p>\n</li>\n<li><p><strong>子域名</strong>：注册的ENS域名可以免费创建子域名，如 <code>inbox.alice.eth</code>。</p>\n</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h3 id=\"ENS-域名简介\"><a href=\"#ENS-域名简介\" class=\"headerlink\" title=\"ENS 域名简介\"></a><strong>ENS 域名简介</strong></h3><p>ENS（Ethereum Name Service，以太坊域名服务）是以太坊上的去中心化域名解析系统，类似于传统互联网的DNS（域名系统），但它专门为区块链地址服务。ENS允许用户将复杂的以太坊钱包地址（如 <code>0x1234...abcd</code>）映射到易于记忆的<strong>域名</strong>（如 <code>alice.eth</code>）。</p>\n<p>ENS不仅支持地址映射，还可以存储IPFS内容哈希、文本记录、加密钱包等信息，从而让区块链更具可读性和可用性。</p>\n<hr>\n<h3 id=\"ENS-的核心功能\"><a href=\"#ENS-的核心功能\" class=\"headerlink\" title=\"ENS 的核心功能\"></a><strong>ENS 的核心功能</strong></h3><p>ENS 提供的主要功能包括：</p>\n<ol>\n<li><p><strong>钱包地址解析</strong>：将 <code>alice.eth</code> 解析为 <code>0x1234...abcd</code>。</p>\n</li>\n<li><p><strong>反向解析</strong>：从钱包地址解析出 ENS 域名。</p>\n</li>\n<li><p><strong>文本记录存储</strong>：可以存储社交媒体链接、IPFS哈希、电子邮件等信息。</p>\n</li>\n<li><p><strong>子域名管理</strong>：可以创建如 <code>mail.alice.eth</code> 这样的子域名。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"ENS-工作流程\"><a href=\"#ENS-工作流程\" class=\"headerlink\" title=\"ENS 工作流程\"></a><strong>ENS 工作流程</strong></h3><p>ENS 依赖智能合约运行在以太坊网络上，主要组件包括：</p>\n<ol start=\"5\">\n<li><p><strong>Registry（注册表合约）</strong>：存储域名的所有者、解析器、到期时间等信息。</p>\n</li>\n<li><p><strong>Resolver（解析器合约）</strong>：处理域名的解析逻辑，将ENS名称转换为地址或其他记录。</p>\n</li>\n<li><p><strong>Registrar（注册管理器）</strong>：处理ENS域名的购买、转移和续费。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"如何在DApp中集成ENS域名解析\"><a href=\"#如何在DApp中集成ENS域名解析\" class=\"headerlink\" title=\"如何在DApp中集成ENS域名解析\"></a><strong>如何在DApp中集成ENS域名解析</strong></h3><p>为了在你的Web3Mail DApp中支持ENS域名，可以使用 <code>ethers.js</code> 库进行交互，ENS解析流程如下：</p>\n<h4 id=\"1-检查用户是否拥有ENS域名\"><a href=\"#1-检查用户是否拥有ENS域名\" class=\"headerlink\" title=\"1. 检查用户是否拥有ENS域名\"></a><strong>1. 检查用户是否拥有ENS域名</strong></h4><p>在用户登录时，我们可以使用 <code>ethers.js</code> 查询用户的ENS名称，如果没有，则显示其钱包地址。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ethers &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;ethers&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接以太坊钱包</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> provider = <span class=\"keyword\">new</span> ethers.<span class=\"title class_\">BrowserProvider</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">ethereum</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getENSName</span>(<span class=\"params\">address</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ensName = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">lookupAddress</span>(address);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ensName) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`ENS 名称: <span class=\"subst\">$&#123;ensName&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ensName;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`未找到 ENS 名称，地址: <span class=\"subst\">$&#123;address&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;ENS 查询失败:&quot;</span>, error);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> address;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取当前用户地址</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchUserENS</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> signer = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">getSigner</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> address = <span class=\"keyword\">await</span> signer.<span class=\"title function_\">getAddress</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getENSName</span>(address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">fetchUserENS</span>().<span class=\"title function_\">then</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h4 id=\"2-发送邮件时解析-ENS-域名\"><a href=\"#2-发送邮件时解析-ENS-域名\" class=\"headerlink\" title=\"2. 发送邮件时解析 ENS 域名\"></a><strong>2. 发送邮件时解析 ENS 域名</strong></h4><p>当用户输入接收者 ENS 域名（如 <code>bob.eth</code>）时，需解析为以太坊地址，并存储到智能合约。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">resolveENS</span>(<span class=\"params\">ensName</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> address = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">resolveName</span>(ensName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (address) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`ENS 解析结果: <span class=\"subst\">$&#123;ensName&#125;</span> -&gt; <span class=\"subst\">$&#123;address&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> address;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;ENS 名称解析失败&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;解析 ENS 时出错:&quot;</span>, error);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例: 发送邮件前解析 ENS 名称</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">sendMail</span>(<span class=\"params\">toENS, ipfsHash</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> recipientAddress = <span class=\"keyword\">await</span> <span class=\"title function_\">resolveENS</span>(toENS);</span><br><span class=\"line\">    <span class=\"comment\">// 这里调用智能合约，将 recipientAddress 和 ipfsHash 存储</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;发送邮件失败:&quot;</span>, error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h4 id=\"3-反向解析（地址到-ENS-名称）\"><a href=\"#3-反向解析（地址到-ENS-名称）\" class=\"headerlink\" title=\"3. 反向解析（地址到 ENS 名称）\"></a><strong>3. 反向解析（地址到 ENS 名称）</strong></h4><p>在收件箱列表中，你可以使用反向解析将以太坊地址转换为ENS名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reverseLookup</span>(<span class=\"params\">address</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ensName = <span class=\"keyword\">await</span> provider.<span class=\"title function_\">lookupAddress</span>(address);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ensName ? ensName : address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"如何在-Solidity-智能合约中集成-ENS\"><a href=\"#如何在-Solidity-智能合约中集成-ENS\" class=\"headerlink\" title=\"如何在 Solidity 智能合约中集成 ENS\"></a><strong>如何在 Solidity 智能合约中集成 ENS</strong></h3><p>ENS 提供了官方的智能合约接口，可以在合约中直接查询 ENS 名称：</p>\n<h4 id=\"ENS-合约地址（Ethereum-Mainnet）\"><a href=\"#ENS-合约地址（Ethereum-Mainnet）\" class=\"headerlink\" title=\"ENS 合约地址（Ethereum Mainnet）\"></a><strong>ENS 合约地址（Ethereum Mainnet）</strong></h4><p>ENS 的注册表合约在以太坊主网上的地址为：<br><code>0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e</code></p>\n<h4 id=\"在-Solidity-中解析-ENS\"><a href=\"#在-Solidity-中解析-ENS\" class=\"headerlink\" title=\"在 Solidity 中解析 ENS\"></a><strong>在 Solidity 中解析 ENS</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">interface IENSResolver &#123;</span><br><span class=\"line\">    function addr(bytes32 node) external view returns (address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ENSHelper &#123;</span><br><span class=\"line\">    IENSResolver ensResolver = IENSResolver(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);</span><br><span class=\"line\"></span><br><span class=\"line\">    function resolveENS(bytes32 node) public view returns (address) &#123;</span><br><span class=\"line\">        return ensResolver.addr(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在合约中使用ENS解析时，ENS名称需要转换为 <code>keccak256</code> 哈希，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ensNameHash = ethers.<span class=\"title function_\">keccak256</span>(ethers.<span class=\"title function_\">toUtf8Bytes</span>(<span class=\"string\">&quot;alice.eth&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"部署-ENS-域名\"><a href=\"#部署-ENS-域名\" class=\"headerlink\" title=\"部署 ENS 域名\"></a><strong>部署 ENS 域名</strong></h3><p>如果你想为你的 DApp 部署 ENS 域名，你可以使用 ENS 官方网站或脚本进行注册：</p>\n<ol start=\"8\">\n<li><p>打开 <a href=\"https://ens.domains/\">ens.domains</a> 官方网站。</p>\n</li>\n<li><p>连接你的以太坊钱包（MetaMask等）。</p>\n</li>\n<li><p>搜索你的域名（如 <code>web3mail.eth</code>）。</p>\n</li>\n<li><p>按照提示完成注册并支付所需的GAS费用。</p>\n</li>\n</ol>\n<p>注册完成后，你可以将ENS域名指向你的DApp前端或合约地址。</p>\n<hr>\n<h3 id=\"ENS-费用\"><a href=\"#ENS-费用\" class=\"headerlink\" title=\"ENS 费用\"></a><strong>ENS 费用</strong></h3><p>ENS 域名注册通常涉及：</p>\n<ul>\n<li><p><strong>年费</strong>：根据ENS域名的长度决定，3位字符的域名最贵，5位以上相对便宜。</p>\n</li>\n<li><p><strong>Gas 费</strong>：进行注册或更新时需要支付以太坊的交易费用。</p>\n</li>\n<li><p><strong>子域名</strong>：注册的ENS域名可以免费创建子域名，如 <code>inbox.alice.eth</code>。</p>\n</li>\n</ul>\n<hr>\n"},{"title":"Foundry上手指南","description":"Foundry 是一个开源的以太坊智能合约开发工具包，旨在提供快速、便携、模块化的开发体验。Foundry 完全用 Rust 编写，避免了繁重的 Node.js 依赖，性能暴打Hardhat","toc":true,"date":"2025-05-05T11:03:16.000Z","_content":"\n## Foundry 是什么\n\nFoundry 是一个开源的以太坊智能合约开发工具包，由 Paradigm 等团队开发，旨在提供**快速、便携、模块化**的开发体验。Foundry 完全用 Rust 编写，避免了繁重的 Node.js 依赖，支持多种 Solidity 版本。它主要包含四个组件：\n\n- **Forge**：测试框架（类似于 Truffle/Hardhat），可直接用 Solidity 编写测试合约。\n\n- **Cast**：多功能命令行工具，可执行以太坊 RPC 调用、查询链上数据和发送交易。\n\n- **Anvil**：本地 EVM 节点（类似于 Ganache 或 Hardhat Network），支持快速启动和主网状态分叉（fork）测试。\n\n- **Chisel**：Solidity 解释器（REPL），方便交互式调试和尝试合约代码。\n\n总体而言，Foundry 适合专注于智能合约本身的开发场景，尤其是需要高效测试、模糊测试以及本地链调试的项目。\n\n## 核心特性\n\n- **原生支持 Solidity 编译与测试**：Foundry 的工具链直接调用本地 `solc` 编译合约，并允许在 Solidity 中编写测试，无需 JavaScript/TypeScript 环境。\n\n- **极快的编译和测试速度**：基于 Rust 的二进制程序，编译和运行测试速度远超传统的 Hardhat/Truffle 等 JS 工具。对于大型项目或频繁迭代而言，这带来了明显效率提升。\n\n- **内置模糊测试（Fuzz Testing）**：支持属性（property-based）测试，只要测试函数带有参数（如 `function testFuzz_XXX(uint256 x)`），Forge 会自动生成随机输入进行测试。如果找到失败的输入，还会给出最小化的反例，帮助发现边界问题。\n\n- **丰富的 Cheatcodes**：提供多种“作弊码”用于修改测试时的区块链状态。例如，可以使用 `vm.prank(address)` 伪造交易发送者、`vm.warp(uint)` 修改区块时间戳、`vm.roll(uint)` 改变区块高度、`vm.deal(address, amount)` 设定地址余额、`vm.expectRevert(...)` 预期下一次调用回退等。这些功能可以大幅简化测试场景，如设置账户余额、时间推进等操作无需真实链交互。\n\n- **与 EVM 的高度一致性**：Anvil 作为本地节点，与官方客户端行为高度相符，支持如 Hardhat 那样的主网分叉。测试时可直接以当前或指定区块高度的主网状态作为基础，更真实地模拟生产环境。\n\n## 与 Hardhat 的区别和迁移考量\n\nFoundry 和 Hardhat 都是主流的以太坊开发框架，但在设计理念和生态上有明显差别：\n\n- **语言和依赖**：Hardhat 以 JavaScript/TypeScript 为主，依赖大量 Node.js 包；而 Foundry 是用 Rust 编写的 CLI 工具，不依赖 JS 环境。这意味着 Foundry 安装包更轻量、跨平台性好，但如果项目需要使用 JS 工具链（如前端脚本或第三方 JS 库），可能需要额外集成。\n\n- **测试框架**：Hardhat 测试基于 Mocha/Chai 和 ethers.js，需要编写 JS 脚本来部署合约、发送交易和断言结果；Foundry 测试在 Solidity 内部进行，使用 `DSTest` 或 `forge-std` 标准库中的断言函数，测试代码更贴近合约本身。这对于纯 Solidity 团队来说，上手更快、避免了语言上下文切换。\n\n- **性能**：Foundry 的编译和测试速度显著高于 Hardhat。如果项目测试规模大、迭代频繁，Foundry 可以节省大量时间。\n\n- **生态和插件**：Hardhat 拥有成熟的插件生态，可与各种工具（如 Gas 报告、安全检查、前端框架等）无缝集成；Foundry 生态相对新兴，但也支持部分集成（例如官方提供了 Hardhat 插件，可在同一个项目中同时使用两者）。选择时应考虑团队技术栈：如果以 JS/TS 开发前端和自动化脚本为主，Hardhat 更方便；如果团队主要关心合约逻辑和高效测试，Foundry 更具吸引力。\n\n- **迁移注意**：从 Hardhat 迁移到 Foundry 时，需要将测试代码从 JS 重写为 Solidity 脚本，并将配置文件从 `hardhat.config.js` 转换为 `foundry.toml`。依赖管理也有所不同，Foundry 使用 `forge install` 将依赖以 Git 子模块形式安装到 `lib/` 目录。\n\n## 安装和初始化项目\n\n- **安装 Foundryup**：Foundry 官方提供了安装脚本。执行以下命令即可安装 Foundryup 管理工具：\n\n  ```Shell\ncurl -L https://foundry.paradigm.xyz | bash\n```\n\n\n  按提示完成安装后，即可在终端使用 `foundryup` 命令。运行 `foundryup` 将自动下载并安装最新稳定版本的 Forge、Cast、Anvil、Chisel 等组件。若要安装最新夜间版，可使用 `foundryup --install nightly`。**注意**：在 Windows 上应通过 Git Bash 或 WSL 环境执行此脚本。\n\n- **初始化新项目**：安装完成后，可以使用 `forge init` 创建新项目。比如：\n\n  ```Shell\nforge init hello_foundry\n```\n\n\n  上述命令会在当前目录下创建 `hello_foundry` 文件夹，并根据模板生成项目结构。默认情况下，它还会初始化一个 Git 仓库并安装所需子模块。若不需要 Git 仓库，可加上 `--no-git` 参数。\n\n## 项目结构说明\n\n默认模板创建的 Foundry 项目结构如下：\n\n```Solidity\n.\n├── foundry.toml       // Foundry 配置文件\n├── src                // 智能合约源代码目录\n├── test               // 测试合约目录\n├── lib                // 依赖库目录（git 子模块）\n└── script             // Solidity 脚本目录\n```\n\n\n- **foundry.toml**：项目配置文件，可在其中指定编译器版本、文件路径、编译参数等。\n\n- **src/**：存放待部署的 Solidity 合约源文件，所有最终部署的合约都应放在此目录下。\n\n- **test/**：存放测试合约，文件名通常以 `.t.sol` 结尾。Forge 会编译此目录中的合约，并运行所有函数名以 `test` 开头的函数。例如，`MyContract.t.sol` 中的 `function testFoo()` 会被识别为一个测试用例。\n\n- **lib/**：存放项目依赖的库代码，以 Git 子模块方式管理。例如通过 `forge install` 安装 OpenZeppelin 库时，会将其放在 `lib/openzeppelin-contracts` 子目录中。\n\n- **script/**：通常放置使用 Solidity 编写的脚本文件（后缀 `.s.sol`），用于与链交互（如部署合约或执行操作）。这些脚本可以通过 `forge script` 命令运行，将生成事务并发送到指定网络。\n\n以上目录结构可以通过 `foundry.toml` 或命令行参数进行自定义。同时，Foundry 支持使用 `--hh` 参数来兼容 Hardhat 项目结构（自动设置 `--lib-paths node_modules --contracts contracts`）。\n\n## 编写和运行测试\n\nFoundry 允许直接用 Solidity 编写测试合约。通常在测试文件中导入 Forge 标准库，然后让测试合约继承 `Test`（或 `DSTest`）基类。下面是一个简单示例：\n\n```Solidity\nimport \"forge-std/Test.sol\";\ncontract MyContractTest is Test {\n    MyContract c;\n    function setUp() public {\n        c = new MyContract();\n    }\n    function testFunctionality() public {\n        // 在这里进行断言\n        assertTrue(c.value() == 42);\n    }\n}\n```\n\n\n上述代码在 `test/` 目录下，例如命名为 `MyContract.t.sol`。`setUp()` 函数会在每个测试运行前调用，用于初始化状态（类似于 JS 测试中的 `beforeEach`）。以 `test` 开头的函数（如 `testFunctionality`）会被 Forge 自动识别为测试。测试内部可使用 `assertEq`、`assertTrue`、`assertRevert` 等函数进行断言，无需手动捕捉异常。\n\n运行测试非常简单：在项目根目录运行\n\n```Shell\nforge test\n```\n\n\nForge 会自动编译 `src/` 和 `test/` 目录下的合约，并执行所有测试用例。测试输出会列出每个测试的执行结果及 Gas 消耗情况。如果测试失败，会展示失败信息和回溯调用栈。\n\n与 Hardhat 不同，Foundry 测试过程不依赖 Mocha/Chai，也不需要启动额外节点，完全在本地进行，运行速度更快。而且测试代码与合约语言一致，Solidity 开发者无需切换语言即可编写和调试测试。\n\n## 使用 Cheatcodes\n\nFoundry 的测试框架内置了大量“作弊码”，用于在测试中修改链上状态或检查行为。这些作弊码通过一个预设地址（`0x7109...DD12D`）暴露，通常通过 `vm` 变量调用。例如：\n\n- `vm.prank(address)`：将下一笔交易的发送者伪造为指定地址。\n\n- `vm.startPrank(address)` / `vm.stopPrank()`：连续伪造后续多笔交易的发送者。\n\n- `vm.warp(uint256 timestamp)`：设置区块的时间戳。\n\n- `vm.roll(uint256 blockNumber)`：设置区块高度。\n\n- `vm.deal(address who, uint256 amount)`：为指定地址设置以太币余额。\n\n- `vm.load(address who, bytes32 slot)` / `vm.store(address who, bytes32 slot, bytes32 val)`：直接读写任意地址的存储槽。\n\n- `vm.expectRevert() / vm.expectRevert(bytes4) / vm.expectRevert(string)`：预期下一次合约调用会回退（可指定错误选择子或错误信息）。\n\n- `vm.expectEmit(bool,bool,bool,bool)`：预期下一笔交易会发出某个事件，并可部分匹配事件的索引参数。\n\n例如，下面的测试片段使用 `expectRevert` 和 `prank` 来断言非合约所有者调用失败：\n\n```Solidity\nfunction test_RevertWhen_CallerIsNotOwner() public {\n    vm.expectRevert(Unauthorized.selector);\n    vm.prank(address(0));\n    upOnly.increment();\n}\n```\n\n\n通过这些 Cheatcodes，测试可以方便地模拟各种链上操作（例如快速推进时间、设置账户余额、模拟外部合约调用等），从而覆盖更多场景。\n\n## 使用 Fuzz Testing 和属性测试\n\nFoundry 支持“属性测试”（Property-Based Testing），即模糊测试。如果测试函数带有至少一个参数，Forge 会将其视为模糊测试，并自动生成随机输入执行多次测试。例如：\n\n```Solidity\nfunction testFuzz_Withdraw(uint256 amount) public {\n    payable(address(safe)).transfer(amount);\n    uint256 pre = address(this).balance;\n    safe.withdraw();\n    uint256 post = address(this).balance;\n    assertEq(pre + amount, post);\n}\n```\n\n\n在上例中，`testFuzz_Withdraw` 会被 Forge 多次调用，每次传入不同的随机 `amount` 值。Forge 会寻找导致测试失败的输入，并给出经过“缩小”处理（minimal counterexample）的反例。这种方法有助于自动发现边界情况和潜在错误，使得测试覆盖更全面。测试函数名可以以 `testFuzz_` 开头（或者任何 `test` 前缀带参数的函数都会自动 fuzz），也可配合分支条件等，以明确表示这是一个模糊测试场景。\n\n## 合约部署和与前端交互方式简介\n\nFoundry 提供了 `forge` 和 `cast` 两个命令行工具来进行部署和与链交互：\n\n- **部署合约**：使用 `forge create` 命令。例如：\n\n  ```Shell\nforge create MyContract --private-key <YOUR_PRIVATE_KEY> --rpc-url <RPC_URL>\n```\n\n\n  这会编译 `MyContract` 合约并使用指定的私钥在指定网络（通过 `--rpc-url`）上部署该合约。可以通过 `--constructor-args` 传入构造函数参数，通过 `--verify` 启用 Etherscan 等服务的源码验证。\n\n- **读取链上数据（只读调用）**：使用 `cast call`，无需私钥。例如，可以调用一个 ERC20 合约的 `balanceOf`：\n\n  ```Shell\ncast call 0x6B175474E89094C44Da98b954EedeAC495271d0F \"balanceOf(address)(uint256)\" --rpc-url <RPC_URL>\n```\n\n\n  该命令通过 ABI 编码并调用合约函数，然后输出返回结果。\n\n- **发送交易**：使用 `cast send` 并提供私钥。比如向 ERC20 合约发送一笔 `transfer` 交易：\n\n  ```Shell\ncast send --private-key <YOUR_PRIVATE_KEY> 0xTOKEN_ADDRESS \"transfer(address,uint256)\" 0xRECIPIENT 100\n```\n\n\n  `cast send` 会使用指定私钥签名并发送交易，可通过 `--rpc-url` 指定节点。这些工具使得在脚本或命令行下即可完成链上交互，无需像 Hardhat 那样启动整个框架环境。\n\n## 最佳实践\n\n- **测试组织**：测试合约文件一般与源合约同名（`MyContract.sol` 对应 `MyContract.t.sol`）。可以为同一个合约创建多个测试合约或分组：一种方式是按功能拆分小的测试合约；另一种方式是每个待测合约对应一个测试合约，内含多个测试函数。无论采用哪种，都建议保持一致的结构便于维护。\n\n- **命名规范**：统一的函数命名有助于管理测试。常见约定如 `testXXX`（一般测试）、`testFuzz_XXX`（模糊测试）、`test_RevertIfYYY`（预期发生回退）等。例如，可使用 `testFork_...` 前缀表示需要主网分叉的测试。遵循这些模式可以在运行 `forge test` 时方便地筛选测试用例。\n\n- **代码格式和静态检查**：建议使用 `forge fmt` 格式化代码，保持代码风格统一。Foundry 还提供静态分析工具（如 `forge check`）检查可能的错误。此外，尽量编写清晰可读的合约和测试代码，例如使用有意义的变量名、避免冗余逻辑、将相关代码放在一起等。\n\n- **持续集成（CI）**：在 CI 流水线中集成 Foundry 通常只需安装 Rust 环境并运行 `forge test`。官方文档提供了 GitHub Actions、Travis CI、GitLab CI 等示例配置。例如，在 GitHub Actions 中可在 push 时触发，安装 Foundry 后执行 `forge test` 验证所有测试通过即可。通过自动化 CI，可确保每次代码提交都经过 Foundry 测试套件的检查。\n\n\n\n**参考资料：** Foundry 官方文档和示例等。 \n\n\n\n","source":"_posts/Foundry上手指南.md","raw":"---\ntitle: Foundry上手指南\ndescription: 'Foundry 是一个开源的以太坊智能合约开发工具包，旨在提供快速、便携、模块化的开发体验。Foundry 完全用 Rust 编写，避免了繁重的 Node.js 依赖，性能暴打Hardhat'\ntags: ['Foundry','web3']\ntoc: true\ndate: 2025-05-05 19:03:16\ncategories: Cyfrin Updraft\n---\n\n## Foundry 是什么\n\nFoundry 是一个开源的以太坊智能合约开发工具包，由 Paradigm 等团队开发，旨在提供**快速、便携、模块化**的开发体验。Foundry 完全用 Rust 编写，避免了繁重的 Node.js 依赖，支持多种 Solidity 版本。它主要包含四个组件：\n\n- **Forge**：测试框架（类似于 Truffle/Hardhat），可直接用 Solidity 编写测试合约。\n\n- **Cast**：多功能命令行工具，可执行以太坊 RPC 调用、查询链上数据和发送交易。\n\n- **Anvil**：本地 EVM 节点（类似于 Ganache 或 Hardhat Network），支持快速启动和主网状态分叉（fork）测试。\n\n- **Chisel**：Solidity 解释器（REPL），方便交互式调试和尝试合约代码。\n\n总体而言，Foundry 适合专注于智能合约本身的开发场景，尤其是需要高效测试、模糊测试以及本地链调试的项目。\n\n## 核心特性\n\n- **原生支持 Solidity 编译与测试**：Foundry 的工具链直接调用本地 `solc` 编译合约，并允许在 Solidity 中编写测试，无需 JavaScript/TypeScript 环境。\n\n- **极快的编译和测试速度**：基于 Rust 的二进制程序，编译和运行测试速度远超传统的 Hardhat/Truffle 等 JS 工具。对于大型项目或频繁迭代而言，这带来了明显效率提升。\n\n- **内置模糊测试（Fuzz Testing）**：支持属性（property-based）测试，只要测试函数带有参数（如 `function testFuzz_XXX(uint256 x)`），Forge 会自动生成随机输入进行测试。如果找到失败的输入，还会给出最小化的反例，帮助发现边界问题。\n\n- **丰富的 Cheatcodes**：提供多种“作弊码”用于修改测试时的区块链状态。例如，可以使用 `vm.prank(address)` 伪造交易发送者、`vm.warp(uint)` 修改区块时间戳、`vm.roll(uint)` 改变区块高度、`vm.deal(address, amount)` 设定地址余额、`vm.expectRevert(...)` 预期下一次调用回退等。这些功能可以大幅简化测试场景，如设置账户余额、时间推进等操作无需真实链交互。\n\n- **与 EVM 的高度一致性**：Anvil 作为本地节点，与官方客户端行为高度相符，支持如 Hardhat 那样的主网分叉。测试时可直接以当前或指定区块高度的主网状态作为基础，更真实地模拟生产环境。\n\n## 与 Hardhat 的区别和迁移考量\n\nFoundry 和 Hardhat 都是主流的以太坊开发框架，但在设计理念和生态上有明显差别：\n\n- **语言和依赖**：Hardhat 以 JavaScript/TypeScript 为主，依赖大量 Node.js 包；而 Foundry 是用 Rust 编写的 CLI 工具，不依赖 JS 环境。这意味着 Foundry 安装包更轻量、跨平台性好，但如果项目需要使用 JS 工具链（如前端脚本或第三方 JS 库），可能需要额外集成。\n\n- **测试框架**：Hardhat 测试基于 Mocha/Chai 和 ethers.js，需要编写 JS 脚本来部署合约、发送交易和断言结果；Foundry 测试在 Solidity 内部进行，使用 `DSTest` 或 `forge-std` 标准库中的断言函数，测试代码更贴近合约本身。这对于纯 Solidity 团队来说，上手更快、避免了语言上下文切换。\n\n- **性能**：Foundry 的编译和测试速度显著高于 Hardhat。如果项目测试规模大、迭代频繁，Foundry 可以节省大量时间。\n\n- **生态和插件**：Hardhat 拥有成熟的插件生态，可与各种工具（如 Gas 报告、安全检查、前端框架等）无缝集成；Foundry 生态相对新兴，但也支持部分集成（例如官方提供了 Hardhat 插件，可在同一个项目中同时使用两者）。选择时应考虑团队技术栈：如果以 JS/TS 开发前端和自动化脚本为主，Hardhat 更方便；如果团队主要关心合约逻辑和高效测试，Foundry 更具吸引力。\n\n- **迁移注意**：从 Hardhat 迁移到 Foundry 时，需要将测试代码从 JS 重写为 Solidity 脚本，并将配置文件从 `hardhat.config.js` 转换为 `foundry.toml`。依赖管理也有所不同，Foundry 使用 `forge install` 将依赖以 Git 子模块形式安装到 `lib/` 目录。\n\n## 安装和初始化项目\n\n- **安装 Foundryup**：Foundry 官方提供了安装脚本。执行以下命令即可安装 Foundryup 管理工具：\n\n  ```Shell\ncurl -L https://foundry.paradigm.xyz | bash\n```\n\n\n  按提示完成安装后，即可在终端使用 `foundryup` 命令。运行 `foundryup` 将自动下载并安装最新稳定版本的 Forge、Cast、Anvil、Chisel 等组件。若要安装最新夜间版，可使用 `foundryup --install nightly`。**注意**：在 Windows 上应通过 Git Bash 或 WSL 环境执行此脚本。\n\n- **初始化新项目**：安装完成后，可以使用 `forge init` 创建新项目。比如：\n\n  ```Shell\nforge init hello_foundry\n```\n\n\n  上述命令会在当前目录下创建 `hello_foundry` 文件夹，并根据模板生成项目结构。默认情况下，它还会初始化一个 Git 仓库并安装所需子模块。若不需要 Git 仓库，可加上 `--no-git` 参数。\n\n## 项目结构说明\n\n默认模板创建的 Foundry 项目结构如下：\n\n```Solidity\n.\n├── foundry.toml       // Foundry 配置文件\n├── src                // 智能合约源代码目录\n├── test               // 测试合约目录\n├── lib                // 依赖库目录（git 子模块）\n└── script             // Solidity 脚本目录\n```\n\n\n- **foundry.toml**：项目配置文件，可在其中指定编译器版本、文件路径、编译参数等。\n\n- **src/**：存放待部署的 Solidity 合约源文件，所有最终部署的合约都应放在此目录下。\n\n- **test/**：存放测试合约，文件名通常以 `.t.sol` 结尾。Forge 会编译此目录中的合约，并运行所有函数名以 `test` 开头的函数。例如，`MyContract.t.sol` 中的 `function testFoo()` 会被识别为一个测试用例。\n\n- **lib/**：存放项目依赖的库代码，以 Git 子模块方式管理。例如通过 `forge install` 安装 OpenZeppelin 库时，会将其放在 `lib/openzeppelin-contracts` 子目录中。\n\n- **script/**：通常放置使用 Solidity 编写的脚本文件（后缀 `.s.sol`），用于与链交互（如部署合约或执行操作）。这些脚本可以通过 `forge script` 命令运行，将生成事务并发送到指定网络。\n\n以上目录结构可以通过 `foundry.toml` 或命令行参数进行自定义。同时，Foundry 支持使用 `--hh` 参数来兼容 Hardhat 项目结构（自动设置 `--lib-paths node_modules --contracts contracts`）。\n\n## 编写和运行测试\n\nFoundry 允许直接用 Solidity 编写测试合约。通常在测试文件中导入 Forge 标准库，然后让测试合约继承 `Test`（或 `DSTest`）基类。下面是一个简单示例：\n\n```Solidity\nimport \"forge-std/Test.sol\";\ncontract MyContractTest is Test {\n    MyContract c;\n    function setUp() public {\n        c = new MyContract();\n    }\n    function testFunctionality() public {\n        // 在这里进行断言\n        assertTrue(c.value() == 42);\n    }\n}\n```\n\n\n上述代码在 `test/` 目录下，例如命名为 `MyContract.t.sol`。`setUp()` 函数会在每个测试运行前调用，用于初始化状态（类似于 JS 测试中的 `beforeEach`）。以 `test` 开头的函数（如 `testFunctionality`）会被 Forge 自动识别为测试。测试内部可使用 `assertEq`、`assertTrue`、`assertRevert` 等函数进行断言，无需手动捕捉异常。\n\n运行测试非常简单：在项目根目录运行\n\n```Shell\nforge test\n```\n\n\nForge 会自动编译 `src/` 和 `test/` 目录下的合约，并执行所有测试用例。测试输出会列出每个测试的执行结果及 Gas 消耗情况。如果测试失败，会展示失败信息和回溯调用栈。\n\n与 Hardhat 不同，Foundry 测试过程不依赖 Mocha/Chai，也不需要启动额外节点，完全在本地进行，运行速度更快。而且测试代码与合约语言一致，Solidity 开发者无需切换语言即可编写和调试测试。\n\n## 使用 Cheatcodes\n\nFoundry 的测试框架内置了大量“作弊码”，用于在测试中修改链上状态或检查行为。这些作弊码通过一个预设地址（`0x7109...DD12D`）暴露，通常通过 `vm` 变量调用。例如：\n\n- `vm.prank(address)`：将下一笔交易的发送者伪造为指定地址。\n\n- `vm.startPrank(address)` / `vm.stopPrank()`：连续伪造后续多笔交易的发送者。\n\n- `vm.warp(uint256 timestamp)`：设置区块的时间戳。\n\n- `vm.roll(uint256 blockNumber)`：设置区块高度。\n\n- `vm.deal(address who, uint256 amount)`：为指定地址设置以太币余额。\n\n- `vm.load(address who, bytes32 slot)` / `vm.store(address who, bytes32 slot, bytes32 val)`：直接读写任意地址的存储槽。\n\n- `vm.expectRevert() / vm.expectRevert(bytes4) / vm.expectRevert(string)`：预期下一次合约调用会回退（可指定错误选择子或错误信息）。\n\n- `vm.expectEmit(bool,bool,bool,bool)`：预期下一笔交易会发出某个事件，并可部分匹配事件的索引参数。\n\n例如，下面的测试片段使用 `expectRevert` 和 `prank` 来断言非合约所有者调用失败：\n\n```Solidity\nfunction test_RevertWhen_CallerIsNotOwner() public {\n    vm.expectRevert(Unauthorized.selector);\n    vm.prank(address(0));\n    upOnly.increment();\n}\n```\n\n\n通过这些 Cheatcodes，测试可以方便地模拟各种链上操作（例如快速推进时间、设置账户余额、模拟外部合约调用等），从而覆盖更多场景。\n\n## 使用 Fuzz Testing 和属性测试\n\nFoundry 支持“属性测试”（Property-Based Testing），即模糊测试。如果测试函数带有至少一个参数，Forge 会将其视为模糊测试，并自动生成随机输入执行多次测试。例如：\n\n```Solidity\nfunction testFuzz_Withdraw(uint256 amount) public {\n    payable(address(safe)).transfer(amount);\n    uint256 pre = address(this).balance;\n    safe.withdraw();\n    uint256 post = address(this).balance;\n    assertEq(pre + amount, post);\n}\n```\n\n\n在上例中，`testFuzz_Withdraw` 会被 Forge 多次调用，每次传入不同的随机 `amount` 值。Forge 会寻找导致测试失败的输入，并给出经过“缩小”处理（minimal counterexample）的反例。这种方法有助于自动发现边界情况和潜在错误，使得测试覆盖更全面。测试函数名可以以 `testFuzz_` 开头（或者任何 `test` 前缀带参数的函数都会自动 fuzz），也可配合分支条件等，以明确表示这是一个模糊测试场景。\n\n## 合约部署和与前端交互方式简介\n\nFoundry 提供了 `forge` 和 `cast` 两个命令行工具来进行部署和与链交互：\n\n- **部署合约**：使用 `forge create` 命令。例如：\n\n  ```Shell\nforge create MyContract --private-key <YOUR_PRIVATE_KEY> --rpc-url <RPC_URL>\n```\n\n\n  这会编译 `MyContract` 合约并使用指定的私钥在指定网络（通过 `--rpc-url`）上部署该合约。可以通过 `--constructor-args` 传入构造函数参数，通过 `--verify` 启用 Etherscan 等服务的源码验证。\n\n- **读取链上数据（只读调用）**：使用 `cast call`，无需私钥。例如，可以调用一个 ERC20 合约的 `balanceOf`：\n\n  ```Shell\ncast call 0x6B175474E89094C44Da98b954EedeAC495271d0F \"balanceOf(address)(uint256)\" --rpc-url <RPC_URL>\n```\n\n\n  该命令通过 ABI 编码并调用合约函数，然后输出返回结果。\n\n- **发送交易**：使用 `cast send` 并提供私钥。比如向 ERC20 合约发送一笔 `transfer` 交易：\n\n  ```Shell\ncast send --private-key <YOUR_PRIVATE_KEY> 0xTOKEN_ADDRESS \"transfer(address,uint256)\" 0xRECIPIENT 100\n```\n\n\n  `cast send` 会使用指定私钥签名并发送交易，可通过 `--rpc-url` 指定节点。这些工具使得在脚本或命令行下即可完成链上交互，无需像 Hardhat 那样启动整个框架环境。\n\n## 最佳实践\n\n- **测试组织**：测试合约文件一般与源合约同名（`MyContract.sol` 对应 `MyContract.t.sol`）。可以为同一个合约创建多个测试合约或分组：一种方式是按功能拆分小的测试合约；另一种方式是每个待测合约对应一个测试合约，内含多个测试函数。无论采用哪种，都建议保持一致的结构便于维护。\n\n- **命名规范**：统一的函数命名有助于管理测试。常见约定如 `testXXX`（一般测试）、`testFuzz_XXX`（模糊测试）、`test_RevertIfYYY`（预期发生回退）等。例如，可使用 `testFork_...` 前缀表示需要主网分叉的测试。遵循这些模式可以在运行 `forge test` 时方便地筛选测试用例。\n\n- **代码格式和静态检查**：建议使用 `forge fmt` 格式化代码，保持代码风格统一。Foundry 还提供静态分析工具（如 `forge check`）检查可能的错误。此外，尽量编写清晰可读的合约和测试代码，例如使用有意义的变量名、避免冗余逻辑、将相关代码放在一起等。\n\n- **持续集成（CI）**：在 CI 流水线中集成 Foundry 通常只需安装 Rust 环境并运行 `forge test`。官方文档提供了 GitHub Actions、Travis CI、GitLab CI 等示例配置。例如，在 GitHub Actions 中可在 push 时触发，安装 Foundry 后执行 `forge test` 验证所有测试通过即可。通过自动化 CI，可确保每次代码提交都经过 Foundry 测试套件的检查。\n\n\n\n**参考资料：** Foundry 官方文档和示例等。 \n\n\n\n","slug":"Foundry上手指南","published":1,"updated":"2025-05-05T11:06:51.706Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8a0003p3j51249coph","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"Foundry-是什么\"><a href=\"#Foundry-是什么\" class=\"headerlink\" title=\"Foundry 是什么\"></a>Foundry 是什么</h2><p>Foundry 是一个开源的以太坊智能合约开发工具包，由 Paradigm 等团队开发，旨在提供<strong>快速、便携、模块化</strong>的开发体验。Foundry 完全用 Rust 编写，避免了繁重的 Node.js 依赖，支持多种 Solidity 版本。它主要包含四个组件：</p>\n<ul>\n<li><p><strong>Forge</strong>：测试框架（类似于 Truffle&#x2F;Hardhat），可直接用 Solidity 编写测试合约。</p>\n</li>\n<li><p><strong>Cast</strong>：多功能命令行工具，可执行以太坊 RPC 调用、查询链上数据和发送交易。</p>\n</li>\n<li><p><strong>Anvil</strong>：本地 EVM 节点（类似于 Ganache 或 Hardhat Network），支持快速启动和主网状态分叉（fork）测试。</p>\n</li>\n<li><p><strong>Chisel</strong>：Solidity 解释器（REPL），方便交互式调试和尝试合约代码。</p>\n</li>\n</ul>\n<p>总体而言，Foundry 适合专注于智能合约本身的开发场景，尤其是需要高效测试、模糊测试以及本地链调试的项目。</p>\n<h2 id=\"核心特性\"><a href=\"#核心特性\" class=\"headerlink\" title=\"核心特性\"></a>核心特性</h2><ul>\n<li><p><strong>原生支持 Solidity 编译与测试</strong>：Foundry 的工具链直接调用本地 <code>solc</code> 编译合约，并允许在 Solidity 中编写测试，无需 JavaScript&#x2F;TypeScript 环境。</p>\n</li>\n<li><p><strong>极快的编译和测试速度</strong>：基于 Rust 的二进制程序，编译和运行测试速度远超传统的 Hardhat&#x2F;Truffle 等 JS 工具。对于大型项目或频繁迭代而言，这带来了明显效率提升。</p>\n</li>\n<li><p><strong>内置模糊测试（Fuzz Testing）</strong>：支持属性（property-based）测试，只要测试函数带有参数（如 <code>function testFuzz_XXX(uint256 x)</code>），Forge 会自动生成随机输入进行测试。如果找到失败的输入，还会给出最小化的反例，帮助发现边界问题。</p>\n</li>\n<li><p><strong>丰富的 Cheatcodes</strong>：提供多种“作弊码”用于修改测试时的区块链状态。例如，可以使用 <code>vm.prank(address)</code> 伪造交易发送者、<code>vm.warp(uint)</code> 修改区块时间戳、<code>vm.roll(uint)</code> 改变区块高度、<code>vm.deal(address, amount)</code> 设定地址余额、<code>vm.expectRevert(...)</code> 预期下一次调用回退等。这些功能可以大幅简化测试场景，如设置账户余额、时间推进等操作无需真实链交互。</p>\n</li>\n<li><p><strong>与 EVM 的高度一致性</strong>：Anvil 作为本地节点，与官方客户端行为高度相符，支持如 Hardhat 那样的主网分叉。测试时可直接以当前或指定区块高度的主网状态作为基础，更真实地模拟生产环境。</p>\n</li>\n</ul>\n<h2 id=\"与-Hardhat-的区别和迁移考量\"><a href=\"#与-Hardhat-的区别和迁移考量\" class=\"headerlink\" title=\"与 Hardhat 的区别和迁移考量\"></a>与 Hardhat 的区别和迁移考量</h2><p>Foundry 和 Hardhat 都是主流的以太坊开发框架，但在设计理念和生态上有明显差别：</p>\n<ul>\n<li><p><strong>语言和依赖</strong>：Hardhat 以 JavaScript&#x2F;TypeScript 为主，依赖大量 Node.js 包；而 Foundry 是用 Rust 编写的 CLI 工具，不依赖 JS 环境。这意味着 Foundry 安装包更轻量、跨平台性好，但如果项目需要使用 JS 工具链（如前端脚本或第三方 JS 库），可能需要额外集成。</p>\n</li>\n<li><p><strong>测试框架</strong>：Hardhat 测试基于 Mocha&#x2F;Chai 和 ethers.js，需要编写 JS 脚本来部署合约、发送交易和断言结果；Foundry 测试在 Solidity 内部进行，使用 <code>DSTest</code> 或 <code>forge-std</code> 标准库中的断言函数，测试代码更贴近合约本身。这对于纯 Solidity 团队来说，上手更快、避免了语言上下文切换。</p>\n</li>\n<li><p><strong>性能</strong>：Foundry 的编译和测试速度显著高于 Hardhat。如果项目测试规模大、迭代频繁，Foundry 可以节省大量时间。</p>\n</li>\n<li><p><strong>生态和插件</strong>：Hardhat 拥有成熟的插件生态，可与各种工具（如 Gas 报告、安全检查、前端框架等）无缝集成；Foundry 生态相对新兴，但也支持部分集成（例如官方提供了 Hardhat 插件，可在同一个项目中同时使用两者）。选择时应考虑团队技术栈：如果以 JS&#x2F;TS 开发前端和自动化脚本为主，Hardhat 更方便；如果团队主要关心合约逻辑和高效测试，Foundry 更具吸引力。</p>\n</li>\n<li><p><strong>迁移注意</strong>：从 Hardhat 迁移到 Foundry 时，需要将测试代码从 JS 重写为 Solidity 脚本，并将配置文件从 <code>hardhat.config.js</code> 转换为 <code>foundry.toml</code>。依赖管理也有所不同，Foundry 使用 <code>forge install</code> 将依赖以 Git 子模块形式安装到 <code>lib/</code> 目录。</p>\n</li>\n</ul>\n<h2 id=\"安装和初始化项目\"><a href=\"#安装和初始化项目\" class=\"headerlink\" title=\"安装和初始化项目\"></a>安装和初始化项目</h2><ul>\n<li><p><strong>安装 Foundryup</strong>：Foundry 官方提供了安装脚本。执行以下命令即可安装 Foundryup 管理工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https://foundry.paradigm.xyz | bash</span><br></pre></td></tr></table></figure>\n\n\n<p>按提示完成安装后，即可在终端使用 <code>foundryup</code> 命令。运行 <code>foundryup</code> 将自动下载并安装最新稳定版本的 Forge、Cast、Anvil、Chisel 等组件。若要安装最新夜间版，可使用 <code>foundryup --install nightly</code>。<strong>注意</strong>：在 Windows 上应通过 Git Bash 或 WSL 环境执行此脚本。</p>\n</li>\n<li><p><strong>初始化新项目</strong>：安装完成后，可以使用 <code>forge init</code> 创建新项目。比如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge init hello_foundry</span><br></pre></td></tr></table></figure>\n\n\n<p>上述命令会在当前目录下创建 <code>hello_foundry</code> 文件夹，并根据模板生成项目结构。默认情况下，它还会初始化一个 Git 仓库并安装所需子模块。若不需要 Git 仓库，可加上 <code>--no-git</code> 参数。</p>\n</li>\n</ul>\n<h2 id=\"项目结构说明\"><a href=\"#项目结构说明\" class=\"headerlink\" title=\"项目结构说明\"></a>项目结构说明</h2><p>默认模板创建的 Foundry 项目结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── foundry.toml       // Foundry 配置文件</span><br><span class=\"line\">├── src                // 智能合约源代码目录</span><br><span class=\"line\">├── test               // 测试合约目录</span><br><span class=\"line\">├── lib                // 依赖库目录（git 子模块）</span><br><span class=\"line\">└── script             // Solidity 脚本目录</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><strong>foundry.toml</strong>：项目配置文件，可在其中指定编译器版本、文件路径、编译参数等。</p>\n</li>\n<li><p>**src&#x2F;**：存放待部署的 Solidity 合约源文件，所有最终部署的合约都应放在此目录下。</p>\n</li>\n<li><p>**test&#x2F;**：存放测试合约，文件名通常以 <code>.t.sol</code> 结尾。Forge 会编译此目录中的合约，并运行所有函数名以 <code>test</code> 开头的函数。例如，<code>MyContract.t.sol</code> 中的 <code>function testFoo()</code> 会被识别为一个测试用例。</p>\n</li>\n<li><p>**lib&#x2F;**：存放项目依赖的库代码，以 Git 子模块方式管理。例如通过 <code>forge install</code> 安装 OpenZeppelin 库时，会将其放在 <code>lib/openzeppelin-contracts</code> 子目录中。</p>\n</li>\n<li><p>**script&#x2F;**：通常放置使用 Solidity 编写的脚本文件（后缀 <code>.s.sol</code>），用于与链交互（如部署合约或执行操作）。这些脚本可以通过 <code>forge script</code> 命令运行，将生成事务并发送到指定网络。</p>\n</li>\n</ul>\n<p>以上目录结构可以通过 <code>foundry.toml</code> 或命令行参数进行自定义。同时，Foundry 支持使用 <code>--hh</code> 参数来兼容 Hardhat 项目结构（自动设置 <code>--lib-paths node_modules --contracts contracts</code>）。</p>\n<h2 id=\"编写和运行测试\"><a href=\"#编写和运行测试\" class=\"headerlink\" title=\"编写和运行测试\"></a>编写和运行测试</h2><p>Foundry 允许直接用 Solidity 编写测试合约。通常在测试文件中导入 Forge 标准库，然后让测试合约继承 <code>Test</code>（或 <code>DSTest</code>）基类。下面是一个简单示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">contract MyContractTest is Test &#123;</span><br><span class=\"line\">    MyContract c;</span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        c = new MyContract();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function testFunctionality() public &#123;</span><br><span class=\"line\">        // 在这里进行断言</span><br><span class=\"line\">        assertTrue(c.value() == 42);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>上述代码在 <code>test/</code> 目录下，例如命名为 <code>MyContract.t.sol</code>。<code>setUp()</code> 函数会在每个测试运行前调用，用于初始化状态（类似于 JS 测试中的 <code>beforeEach</code>）。以 <code>test</code> 开头的函数（如 <code>testFunctionality</code>）会被 Forge 自动识别为测试。测试内部可使用 <code>assertEq</code>、<code>assertTrue</code>、<code>assertRevert</code> 等函数进行断言，无需手动捕捉异常。</p>\n<p>运行测试非常简单：在项目根目录运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge test</span><br></pre></td></tr></table></figure>\n\n\n<p>Forge 会自动编译 <code>src/</code> 和 <code>test/</code> 目录下的合约，并执行所有测试用例。测试输出会列出每个测试的执行结果及 Gas 消耗情况。如果测试失败，会展示失败信息和回溯调用栈。</p>\n<p>与 Hardhat 不同，Foundry 测试过程不依赖 Mocha&#x2F;Chai，也不需要启动额外节点，完全在本地进行，运行速度更快。而且测试代码与合约语言一致，Solidity 开发者无需切换语言即可编写和调试测试。</p>\n<h2 id=\"使用-Cheatcodes\"><a href=\"#使用-Cheatcodes\" class=\"headerlink\" title=\"使用 Cheatcodes\"></a>使用 Cheatcodes</h2><p>Foundry 的测试框架内置了大量“作弊码”，用于在测试中修改链上状态或检查行为。这些作弊码通过一个预设地址（<code>0x7109...DD12D</code>）暴露，通常通过 <code>vm</code> 变量调用。例如：</p>\n<ul>\n<li><p><code>vm.prank(address)</code>：将下一笔交易的发送者伪造为指定地址。</p>\n</li>\n<li><p><code>vm.startPrank(address)</code> &#x2F; <code>vm.stopPrank()</code>：连续伪造后续多笔交易的发送者。</p>\n</li>\n<li><p><code>vm.warp(uint256 timestamp)</code>：设置区块的时间戳。</p>\n</li>\n<li><p><code>vm.roll(uint256 blockNumber)</code>：设置区块高度。</p>\n</li>\n<li><p><code>vm.deal(address who, uint256 amount)</code>：为指定地址设置以太币余额。</p>\n</li>\n<li><p><code>vm.load(address who, bytes32 slot)</code> &#x2F; <code>vm.store(address who, bytes32 slot, bytes32 val)</code>：直接读写任意地址的存储槽。</p>\n</li>\n<li><p><code>vm.expectRevert() / vm.expectRevert(bytes4) / vm.expectRevert(string)</code>：预期下一次合约调用会回退（可指定错误选择子或错误信息）。</p>\n</li>\n<li><p><code>vm.expectEmit(bool,bool,bool,bool)</code>：预期下一笔交易会发出某个事件，并可部分匹配事件的索引参数。</p>\n</li>\n</ul>\n<p>例如，下面的测试片段使用 <code>expectRevert</code> 和 <code>prank</code> 来断言非合约所有者调用失败：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test_RevertWhen_CallerIsNotOwner() public &#123;</span><br><span class=\"line\">    vm.expectRevert(Unauthorized.selector);</span><br><span class=\"line\">    vm.prank(address(0));</span><br><span class=\"line\">    upOnly.increment();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>通过这些 Cheatcodes，测试可以方便地模拟各种链上操作（例如快速推进时间、设置账户余额、模拟外部合约调用等），从而覆盖更多场景。</p>\n<h2 id=\"使用-Fuzz-Testing-和属性测试\"><a href=\"#使用-Fuzz-Testing-和属性测试\" class=\"headerlink\" title=\"使用 Fuzz Testing 和属性测试\"></a>使用 Fuzz Testing 和属性测试</h2><p>Foundry 支持“属性测试”（Property-Based Testing），即模糊测试。如果测试函数带有至少一个参数，Forge 会将其视为模糊测试，并自动生成随机输入执行多次测试。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function testFuzz_Withdraw(uint256 amount) public &#123;</span><br><span class=\"line\">    payable(address(safe)).transfer(amount);</span><br><span class=\"line\">    uint256 pre = address(this).balance;</span><br><span class=\"line\">    safe.withdraw();</span><br><span class=\"line\">    uint256 post = address(this).balance;</span><br><span class=\"line\">    assertEq(pre + amount, post);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在上例中，<code>testFuzz_Withdraw</code> 会被 Forge 多次调用，每次传入不同的随机 <code>amount</code> 值。Forge 会寻找导致测试失败的输入，并给出经过“缩小”处理（minimal counterexample）的反例。这种方法有助于自动发现边界情况和潜在错误，使得测试覆盖更全面。测试函数名可以以 <code>testFuzz_</code> 开头（或者任何 <code>test</code> 前缀带参数的函数都会自动 fuzz），也可配合分支条件等，以明确表示这是一个模糊测试场景。</p>\n<h2 id=\"合约部署和与前端交互方式简介\"><a href=\"#合约部署和与前端交互方式简介\" class=\"headerlink\" title=\"合约部署和与前端交互方式简介\"></a>合约部署和与前端交互方式简介</h2><p>Foundry 提供了 <code>forge</code> 和 <code>cast</code> 两个命令行工具来进行部署和与链交互：</p>\n<ul>\n<li><p><strong>部署合约</strong>：使用 <code>forge create</code> 命令。例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge create MyContract --private-key &lt;YOUR_PRIVATE_KEY&gt; --rpc-url &lt;RPC_URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>这会编译 <code>MyContract</code> 合约并使用指定的私钥在指定网络（通过 <code>--rpc-url</code>）上部署该合约。可以通过 <code>--constructor-args</code> 传入构造函数参数，通过 <code>--verify</code> 启用 Etherscan 等服务的源码验证。</p>\n</li>\n<li><p><strong>读取链上数据（只读调用）</strong>：使用 <code>cast call</code>，无需私钥。例如，可以调用一个 ERC20 合约的 <code>balanceOf</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cast call 0x6B175474E89094C44Da98b954EedeAC495271d0F &quot;balanceOf(address)(uint256)&quot; --rpc-url &lt;RPC_URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>该命令通过 ABI 编码并调用合约函数，然后输出返回结果。</p>\n</li>\n<li><p><strong>发送交易</strong>：使用 <code>cast send</code> 并提供私钥。比如向 ERC20 合约发送一笔 <code>transfer</code> 交易：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cast send --private-key &lt;YOUR_PRIVATE_KEY&gt; 0xTOKEN_ADDRESS &quot;transfer(address,uint256)&quot; 0xRECIPIENT 100</span><br></pre></td></tr></table></figure>\n\n\n<p><code>cast send</code> 会使用指定私钥签名并发送交易，可通过 <code>--rpc-url</code> 指定节点。这些工具使得在脚本或命令行下即可完成链上交互，无需像 Hardhat 那样启动整个框架环境。</p>\n</li>\n</ul>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ul>\n<li><p><strong>测试组织</strong>：测试合约文件一般与源合约同名（<code>MyContract.sol</code> 对应 <code>MyContract.t.sol</code>）。可以为同一个合约创建多个测试合约或分组：一种方式是按功能拆分小的测试合约；另一种方式是每个待测合约对应一个测试合约，内含多个测试函数。无论采用哪种，都建议保持一致的结构便于维护。</p>\n</li>\n<li><p><strong>命名规范</strong>：统一的函数命名有助于管理测试。常见约定如 <code>testXXX</code>（一般测试）、<code>testFuzz_XXX</code>（模糊测试）、<code>test_RevertIfYYY</code>（预期发生回退）等。例如，可使用 <code>testFork_...</code> 前缀表示需要主网分叉的测试。遵循这些模式可以在运行 <code>forge test</code> 时方便地筛选测试用例。</p>\n</li>\n<li><p><strong>代码格式和静态检查</strong>：建议使用 <code>forge fmt</code> 格式化代码，保持代码风格统一。Foundry 还提供静态分析工具（如 <code>forge check</code>）检查可能的错误。此外，尽量编写清晰可读的合约和测试代码，例如使用有意义的变量名、避免冗余逻辑、将相关代码放在一起等。</p>\n</li>\n<li><p><strong>持续集成（CI）</strong>：在 CI 流水线中集成 Foundry 通常只需安装 Rust 环境并运行 <code>forge test</code>。官方文档提供了 GitHub Actions、Travis CI、GitLab CI 等示例配置。例如，在 GitHub Actions 中可在 push 时触发，安装 Foundry 后执行 <code>forge test</code> 验证所有测试通过即可。通过自动化 CI，可确保每次代码提交都经过 Foundry 测试套件的检查。</p>\n</li>\n</ul>\n<p><strong>参考资料：</strong> Foundry 官方文档和示例等。 </p>\n","excerpt":"","more":"<h2 id=\"Foundry-是什么\"><a href=\"#Foundry-是什么\" class=\"headerlink\" title=\"Foundry 是什么\"></a>Foundry 是什么</h2><p>Foundry 是一个开源的以太坊智能合约开发工具包，由 Paradigm 等团队开发，旨在提供<strong>快速、便携、模块化</strong>的开发体验。Foundry 完全用 Rust 编写，避免了繁重的 Node.js 依赖，支持多种 Solidity 版本。它主要包含四个组件：</p>\n<ul>\n<li><p><strong>Forge</strong>：测试框架（类似于 Truffle&#x2F;Hardhat），可直接用 Solidity 编写测试合约。</p>\n</li>\n<li><p><strong>Cast</strong>：多功能命令行工具，可执行以太坊 RPC 调用、查询链上数据和发送交易。</p>\n</li>\n<li><p><strong>Anvil</strong>：本地 EVM 节点（类似于 Ganache 或 Hardhat Network），支持快速启动和主网状态分叉（fork）测试。</p>\n</li>\n<li><p><strong>Chisel</strong>：Solidity 解释器（REPL），方便交互式调试和尝试合约代码。</p>\n</li>\n</ul>\n<p>总体而言，Foundry 适合专注于智能合约本身的开发场景，尤其是需要高效测试、模糊测试以及本地链调试的项目。</p>\n<h2 id=\"核心特性\"><a href=\"#核心特性\" class=\"headerlink\" title=\"核心特性\"></a>核心特性</h2><ul>\n<li><p><strong>原生支持 Solidity 编译与测试</strong>：Foundry 的工具链直接调用本地 <code>solc</code> 编译合约，并允许在 Solidity 中编写测试，无需 JavaScript&#x2F;TypeScript 环境。</p>\n</li>\n<li><p><strong>极快的编译和测试速度</strong>：基于 Rust 的二进制程序，编译和运行测试速度远超传统的 Hardhat&#x2F;Truffle 等 JS 工具。对于大型项目或频繁迭代而言，这带来了明显效率提升。</p>\n</li>\n<li><p><strong>内置模糊测试（Fuzz Testing）</strong>：支持属性（property-based）测试，只要测试函数带有参数（如 <code>function testFuzz_XXX(uint256 x)</code>），Forge 会自动生成随机输入进行测试。如果找到失败的输入，还会给出最小化的反例，帮助发现边界问题。</p>\n</li>\n<li><p><strong>丰富的 Cheatcodes</strong>：提供多种“作弊码”用于修改测试时的区块链状态。例如，可以使用 <code>vm.prank(address)</code> 伪造交易发送者、<code>vm.warp(uint)</code> 修改区块时间戳、<code>vm.roll(uint)</code> 改变区块高度、<code>vm.deal(address, amount)</code> 设定地址余额、<code>vm.expectRevert(...)</code> 预期下一次调用回退等。这些功能可以大幅简化测试场景，如设置账户余额、时间推进等操作无需真实链交互。</p>\n</li>\n<li><p><strong>与 EVM 的高度一致性</strong>：Anvil 作为本地节点，与官方客户端行为高度相符，支持如 Hardhat 那样的主网分叉。测试时可直接以当前或指定区块高度的主网状态作为基础，更真实地模拟生产环境。</p>\n</li>\n</ul>\n<h2 id=\"与-Hardhat-的区别和迁移考量\"><a href=\"#与-Hardhat-的区别和迁移考量\" class=\"headerlink\" title=\"与 Hardhat 的区别和迁移考量\"></a>与 Hardhat 的区别和迁移考量</h2><p>Foundry 和 Hardhat 都是主流的以太坊开发框架，但在设计理念和生态上有明显差别：</p>\n<ul>\n<li><p><strong>语言和依赖</strong>：Hardhat 以 JavaScript&#x2F;TypeScript 为主，依赖大量 Node.js 包；而 Foundry 是用 Rust 编写的 CLI 工具，不依赖 JS 环境。这意味着 Foundry 安装包更轻量、跨平台性好，但如果项目需要使用 JS 工具链（如前端脚本或第三方 JS 库），可能需要额外集成。</p>\n</li>\n<li><p><strong>测试框架</strong>：Hardhat 测试基于 Mocha&#x2F;Chai 和 ethers.js，需要编写 JS 脚本来部署合约、发送交易和断言结果；Foundry 测试在 Solidity 内部进行，使用 <code>DSTest</code> 或 <code>forge-std</code> 标准库中的断言函数，测试代码更贴近合约本身。这对于纯 Solidity 团队来说，上手更快、避免了语言上下文切换。</p>\n</li>\n<li><p><strong>性能</strong>：Foundry 的编译和测试速度显著高于 Hardhat。如果项目测试规模大、迭代频繁，Foundry 可以节省大量时间。</p>\n</li>\n<li><p><strong>生态和插件</strong>：Hardhat 拥有成熟的插件生态，可与各种工具（如 Gas 报告、安全检查、前端框架等）无缝集成；Foundry 生态相对新兴，但也支持部分集成（例如官方提供了 Hardhat 插件，可在同一个项目中同时使用两者）。选择时应考虑团队技术栈：如果以 JS&#x2F;TS 开发前端和自动化脚本为主，Hardhat 更方便；如果团队主要关心合约逻辑和高效测试，Foundry 更具吸引力。</p>\n</li>\n<li><p><strong>迁移注意</strong>：从 Hardhat 迁移到 Foundry 时，需要将测试代码从 JS 重写为 Solidity 脚本，并将配置文件从 <code>hardhat.config.js</code> 转换为 <code>foundry.toml</code>。依赖管理也有所不同，Foundry 使用 <code>forge install</code> 将依赖以 Git 子模块形式安装到 <code>lib/</code> 目录。</p>\n</li>\n</ul>\n<h2 id=\"安装和初始化项目\"><a href=\"#安装和初始化项目\" class=\"headerlink\" title=\"安装和初始化项目\"></a>安装和初始化项目</h2><ul>\n<li><p><strong>安装 Foundryup</strong>：Foundry 官方提供了安装脚本。执行以下命令即可安装 Foundryup 管理工具：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https://foundry.paradigm.xyz | bash</span><br></pre></td></tr></table></figure>\n\n\n<p>按提示完成安装后，即可在终端使用 <code>foundryup</code> 命令。运行 <code>foundryup</code> 将自动下载并安装最新稳定版本的 Forge、Cast、Anvil、Chisel 等组件。若要安装最新夜间版，可使用 <code>foundryup --install nightly</code>。<strong>注意</strong>：在 Windows 上应通过 Git Bash 或 WSL 环境执行此脚本。</p>\n</li>\n<li><p><strong>初始化新项目</strong>：安装完成后，可以使用 <code>forge init</code> 创建新项目。比如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge init hello_foundry</span><br></pre></td></tr></table></figure>\n\n\n<p>上述命令会在当前目录下创建 <code>hello_foundry</code> 文件夹，并根据模板生成项目结构。默认情况下，它还会初始化一个 Git 仓库并安装所需子模块。若不需要 Git 仓库，可加上 <code>--no-git</code> 参数。</p>\n</li>\n</ul>\n<h2 id=\"项目结构说明\"><a href=\"#项目结构说明\" class=\"headerlink\" title=\"项目结构说明\"></a>项目结构说明</h2><p>默认模板创建的 Foundry 项目结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── foundry.toml       // Foundry 配置文件</span><br><span class=\"line\">├── src                // 智能合约源代码目录</span><br><span class=\"line\">├── test               // 测试合约目录</span><br><span class=\"line\">├── lib                // 依赖库目录（git 子模块）</span><br><span class=\"line\">└── script             // Solidity 脚本目录</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><strong>foundry.toml</strong>：项目配置文件，可在其中指定编译器版本、文件路径、编译参数等。</p>\n</li>\n<li><p>**src&#x2F;**：存放待部署的 Solidity 合约源文件，所有最终部署的合约都应放在此目录下。</p>\n</li>\n<li><p>**test&#x2F;**：存放测试合约，文件名通常以 <code>.t.sol</code> 结尾。Forge 会编译此目录中的合约，并运行所有函数名以 <code>test</code> 开头的函数。例如，<code>MyContract.t.sol</code> 中的 <code>function testFoo()</code> 会被识别为一个测试用例。</p>\n</li>\n<li><p>**lib&#x2F;**：存放项目依赖的库代码，以 Git 子模块方式管理。例如通过 <code>forge install</code> 安装 OpenZeppelin 库时，会将其放在 <code>lib/openzeppelin-contracts</code> 子目录中。</p>\n</li>\n<li><p>**script&#x2F;**：通常放置使用 Solidity 编写的脚本文件（后缀 <code>.s.sol</code>），用于与链交互（如部署合约或执行操作）。这些脚本可以通过 <code>forge script</code> 命令运行，将生成事务并发送到指定网络。</p>\n</li>\n</ul>\n<p>以上目录结构可以通过 <code>foundry.toml</code> 或命令行参数进行自定义。同时，Foundry 支持使用 <code>--hh</code> 参数来兼容 Hardhat 项目结构（自动设置 <code>--lib-paths node_modules --contracts contracts</code>）。</p>\n<h2 id=\"编写和运行测试\"><a href=\"#编写和运行测试\" class=\"headerlink\" title=\"编写和运行测试\"></a>编写和运行测试</h2><p>Foundry 允许直接用 Solidity 编写测试合约。通常在测试文件中导入 Forge 标准库，然后让测试合约继承 <code>Test</code>（或 <code>DSTest</code>）基类。下面是一个简单示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">contract MyContractTest is Test &#123;</span><br><span class=\"line\">    MyContract c;</span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        c = new MyContract();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function testFunctionality() public &#123;</span><br><span class=\"line\">        // 在这里进行断言</span><br><span class=\"line\">        assertTrue(c.value() == 42);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>上述代码在 <code>test/</code> 目录下，例如命名为 <code>MyContract.t.sol</code>。<code>setUp()</code> 函数会在每个测试运行前调用，用于初始化状态（类似于 JS 测试中的 <code>beforeEach</code>）。以 <code>test</code> 开头的函数（如 <code>testFunctionality</code>）会被 Forge 自动识别为测试。测试内部可使用 <code>assertEq</code>、<code>assertTrue</code>、<code>assertRevert</code> 等函数进行断言，无需手动捕捉异常。</p>\n<p>运行测试非常简单：在项目根目录运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge test</span><br></pre></td></tr></table></figure>\n\n\n<p>Forge 会自动编译 <code>src/</code> 和 <code>test/</code> 目录下的合约，并执行所有测试用例。测试输出会列出每个测试的执行结果及 Gas 消耗情况。如果测试失败，会展示失败信息和回溯调用栈。</p>\n<p>与 Hardhat 不同，Foundry 测试过程不依赖 Mocha&#x2F;Chai，也不需要启动额外节点，完全在本地进行，运行速度更快。而且测试代码与合约语言一致，Solidity 开发者无需切换语言即可编写和调试测试。</p>\n<h2 id=\"使用-Cheatcodes\"><a href=\"#使用-Cheatcodes\" class=\"headerlink\" title=\"使用 Cheatcodes\"></a>使用 Cheatcodes</h2><p>Foundry 的测试框架内置了大量“作弊码”，用于在测试中修改链上状态或检查行为。这些作弊码通过一个预设地址（<code>0x7109...DD12D</code>）暴露，通常通过 <code>vm</code> 变量调用。例如：</p>\n<ul>\n<li><p><code>vm.prank(address)</code>：将下一笔交易的发送者伪造为指定地址。</p>\n</li>\n<li><p><code>vm.startPrank(address)</code> &#x2F; <code>vm.stopPrank()</code>：连续伪造后续多笔交易的发送者。</p>\n</li>\n<li><p><code>vm.warp(uint256 timestamp)</code>：设置区块的时间戳。</p>\n</li>\n<li><p><code>vm.roll(uint256 blockNumber)</code>：设置区块高度。</p>\n</li>\n<li><p><code>vm.deal(address who, uint256 amount)</code>：为指定地址设置以太币余额。</p>\n</li>\n<li><p><code>vm.load(address who, bytes32 slot)</code> &#x2F; <code>vm.store(address who, bytes32 slot, bytes32 val)</code>：直接读写任意地址的存储槽。</p>\n</li>\n<li><p><code>vm.expectRevert() / vm.expectRevert(bytes4) / vm.expectRevert(string)</code>：预期下一次合约调用会回退（可指定错误选择子或错误信息）。</p>\n</li>\n<li><p><code>vm.expectEmit(bool,bool,bool,bool)</code>：预期下一笔交易会发出某个事件，并可部分匹配事件的索引参数。</p>\n</li>\n</ul>\n<p>例如，下面的测试片段使用 <code>expectRevert</code> 和 <code>prank</code> 来断言非合约所有者调用失败：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test_RevertWhen_CallerIsNotOwner() public &#123;</span><br><span class=\"line\">    vm.expectRevert(Unauthorized.selector);</span><br><span class=\"line\">    vm.prank(address(0));</span><br><span class=\"line\">    upOnly.increment();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>通过这些 Cheatcodes，测试可以方便地模拟各种链上操作（例如快速推进时间、设置账户余额、模拟外部合约调用等），从而覆盖更多场景。</p>\n<h2 id=\"使用-Fuzz-Testing-和属性测试\"><a href=\"#使用-Fuzz-Testing-和属性测试\" class=\"headerlink\" title=\"使用 Fuzz Testing 和属性测试\"></a>使用 Fuzz Testing 和属性测试</h2><p>Foundry 支持“属性测试”（Property-Based Testing），即模糊测试。如果测试函数带有至少一个参数，Forge 会将其视为模糊测试，并自动生成随机输入执行多次测试。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function testFuzz_Withdraw(uint256 amount) public &#123;</span><br><span class=\"line\">    payable(address(safe)).transfer(amount);</span><br><span class=\"line\">    uint256 pre = address(this).balance;</span><br><span class=\"line\">    safe.withdraw();</span><br><span class=\"line\">    uint256 post = address(this).balance;</span><br><span class=\"line\">    assertEq(pre + amount, post);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在上例中，<code>testFuzz_Withdraw</code> 会被 Forge 多次调用，每次传入不同的随机 <code>amount</code> 值。Forge 会寻找导致测试失败的输入，并给出经过“缩小”处理（minimal counterexample）的反例。这种方法有助于自动发现边界情况和潜在错误，使得测试覆盖更全面。测试函数名可以以 <code>testFuzz_</code> 开头（或者任何 <code>test</code> 前缀带参数的函数都会自动 fuzz），也可配合分支条件等，以明确表示这是一个模糊测试场景。</p>\n<h2 id=\"合约部署和与前端交互方式简介\"><a href=\"#合约部署和与前端交互方式简介\" class=\"headerlink\" title=\"合约部署和与前端交互方式简介\"></a>合约部署和与前端交互方式简介</h2><p>Foundry 提供了 <code>forge</code> 和 <code>cast</code> 两个命令行工具来进行部署和与链交互：</p>\n<ul>\n<li><p><strong>部署合约</strong>：使用 <code>forge create</code> 命令。例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge create MyContract --private-key &lt;YOUR_PRIVATE_KEY&gt; --rpc-url &lt;RPC_URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>这会编译 <code>MyContract</code> 合约并使用指定的私钥在指定网络（通过 <code>--rpc-url</code>）上部署该合约。可以通过 <code>--constructor-args</code> 传入构造函数参数，通过 <code>--verify</code> 启用 Etherscan 等服务的源码验证。</p>\n</li>\n<li><p><strong>读取链上数据（只读调用）</strong>：使用 <code>cast call</code>，无需私钥。例如，可以调用一个 ERC20 合约的 <code>balanceOf</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cast call 0x6B175474E89094C44Da98b954EedeAC495271d0F &quot;balanceOf(address)(uint256)&quot; --rpc-url &lt;RPC_URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>该命令通过 ABI 编码并调用合约函数，然后输出返回结果。</p>\n</li>\n<li><p><strong>发送交易</strong>：使用 <code>cast send</code> 并提供私钥。比如向 ERC20 合约发送一笔 <code>transfer</code> 交易：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cast send --private-key &lt;YOUR_PRIVATE_KEY&gt; 0xTOKEN_ADDRESS &quot;transfer(address,uint256)&quot; 0xRECIPIENT 100</span><br></pre></td></tr></table></figure>\n\n\n<p><code>cast send</code> 会使用指定私钥签名并发送交易，可通过 <code>--rpc-url</code> 指定节点。这些工具使得在脚本或命令行下即可完成链上交互，无需像 Hardhat 那样启动整个框架环境。</p>\n</li>\n</ul>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ul>\n<li><p><strong>测试组织</strong>：测试合约文件一般与源合约同名（<code>MyContract.sol</code> 对应 <code>MyContract.t.sol</code>）。可以为同一个合约创建多个测试合约或分组：一种方式是按功能拆分小的测试合约；另一种方式是每个待测合约对应一个测试合约，内含多个测试函数。无论采用哪种，都建议保持一致的结构便于维护。</p>\n</li>\n<li><p><strong>命名规范</strong>：统一的函数命名有助于管理测试。常见约定如 <code>testXXX</code>（一般测试）、<code>testFuzz_XXX</code>（模糊测试）、<code>test_RevertIfYYY</code>（预期发生回退）等。例如，可使用 <code>testFork_...</code> 前缀表示需要主网分叉的测试。遵循这些模式可以在运行 <code>forge test</code> 时方便地筛选测试用例。</p>\n</li>\n<li><p><strong>代码格式和静态检查</strong>：建议使用 <code>forge fmt</code> 格式化代码，保持代码风格统一。Foundry 还提供静态分析工具（如 <code>forge check</code>）检查可能的错误。此外，尽量编写清晰可读的合约和测试代码，例如使用有意义的变量名、避免冗余逻辑、将相关代码放在一起等。</p>\n</li>\n<li><p><strong>持续集成（CI）</strong>：在 CI 流水线中集成 Foundry 通常只需安装 Rust 环境并运行 <code>forge test</code>。官方文档提供了 GitHub Actions、Travis CI、GitLab CI 等示例配置。例如，在 GitHub Actions 中可在 push 时触发，安装 Foundry 后执行 <code>forge test</code> 验证所有测试通过即可。通过自动化 CI，可确保每次代码提交都经过 Foundry 测试套件的检查。</p>\n</li>\n</ul>\n<p><strong>参考资料：</strong> Foundry 官方文档和示例等。 </p>\n"},{"title":"Git Commit术语","description":"在使用 git commit -m 提交代码时，通常会在提交信息中使用一些常见的前缀来描述提交的类型和目的","date":"2025-05-03T13:34:37.000Z","_content":"\n在使用 `git commit -m` 提交代码时，通常会在提交信息中使用一些常见的前缀来描述提交的类型和目的。这些前缀有助于团队更好地理解提交的内容，尤其是在查看提交历史或生成变更日志时。以下是一些常用的前缀及其含义：\n\n---\n\n### 1. **`fix`**\n\n表示修复了一个 bug 或问题。\n\n```Shell\ngit commit -m \"fix: 修复登录页面无法加载的问题\"\n```\n\n\n---\n\n### 2. **`feat`**\n\n表示新增了一个功能。\n\n```Shell\ngit commit -m \"feat: 添加用户注册功能\"\n```\n\n\n---\n\n### 3. **`docs`**\n\n表示文档相关的更改（如 README、注释等）。\n\n```Shell\ngit commit -m \"docs: 更新项目 README 文件\"\n```\n\n\n---\n\n### 4. **`style`**\n\n表示代码风格的更改（如格式化、缩进等），不涉及功能或逻辑的修改。\n\n```Shell\ngit commit -m \"style: 格式化代码缩进\"\n```\n\n\n---\n\n### 5. **`refactor`**\n\n表示代码重构，既不修复 bug 也不添加新功能。\n\n```Shell\ngit commit -m \"refactor: 重构用户模块的代码结构\"\n```\n\n\n---\n\n### 6. **`test`**\n\n表示测试相关的更改（如添加或修改测试用例）。\n\n```Shell\ngit commit -m \"test: 添加用户登录功能的单元测试\"\n```\n\n\n---\n\n### 7. **`chore`**\n\n表示日常维护或工具相关的更改（如依赖更新、构建配置等）。\n\n```Shell\ngit commit -m \"chore: 更新项目依赖包\"\n```\n\n\n---\n\n### 8. **`perf`**\n\n表示性能优化相关的更改。\n\n```Shell\ngit commit -m \"perf: 优化数据库查询性能\"\n```\n\n\n---\n\n### 9. **`ci`**\n\n表示持续集成（CI）相关的更改（如 GitHub Actions、Travis CI 等）。\n\n```Shell\ngit commit -m \"ci: 添加 GitHub Actions 自动化测试\"\n```\n\n\n---\n\n### 10. **`revert`**\n\n表示回滚之前的提交。\n\n```Shell\ngit commit -m \"revert: 回滚错误的用户注册功能提交\"\n```\n\n\n---\n\n### 11. **`build`**\n\n表示构建系统或外部依赖的更改（如 Webpack、Gulp 等）。\n\n```Shell\ngit commit -m \"build: 更新 Webpack 配置\"\n```\n\n\n---\n\n### 12. **`wip`**\n\n表示正在进行中的工作（Work In Progress），通常用于临时提交。\n\n```Shell\ngit commit -m \"wip: 用户模块开发中\"\n```\n\n\n---\n\n### 13. **`hotfix`**\n\n表示紧急修复生产环境中的问题。\n\n```Shell\ngit commit -m \"hotfix: 紧急修复支付接口崩溃问题\"\n```\n\n\n---\n\n### 14. **`init`**\n\n表示项目初始化或首次提交。\n\n```Shell\ngit commit -m \"init: 初始化项目\"\n```\n\n\n---\n\n### 15. **`merge`**\n\n表示合并分支。\n\n```Shell\ngit commit -m \"merge: 合并 feature/login 分支到 main\"\n```\n\n\n---\n\n### 提交信息格式建议\n\n通常推荐使用以下格式：\n\n```Shell\n<类型>: <描述>\n```\n\n\n例如：\n\n```Shell\ngit commit -m \"feat: 添加用户登录功能\"\n```\n\n\n如果需要更详细的描述，可以使用多行提交信息：\n\n```Shell\ngit commit -m \"fix: 修复登录页面无法加载的问题\n\n- 修复了登录页面因 API 接口错误导致的加载失败问题\n- 优化了错误提示信息\"\n```\n\n\n---\n\n### 总结\n\n- 使用清晰的前缀（如 `fix`、`feat`、`docs` 等）来描述提交的类型。\n\n- 提交信息应简洁明了，便于团队协作和代码审查。\n\n- 如果需要更详细的描述，可以使用多行提交信息。\n\n这些规范可以帮助团队更好地管理提交历史，并生成更有意义的变更日志。\n\n","source":"_posts/Gitcommit术语.md","raw":"---\ntitle: Git Commit术语\ndescription: '在使用 git commit -m 提交代码时，通常会在提交信息中使用一些常见的前缀来描述提交的类型和目的'\ndate: 2025-05-03 21:34:37\ntags: git\n---\n\n在使用 `git commit -m` 提交代码时，通常会在提交信息中使用一些常见的前缀来描述提交的类型和目的。这些前缀有助于团队更好地理解提交的内容，尤其是在查看提交历史或生成变更日志时。以下是一些常用的前缀及其含义：\n\n---\n\n### 1. **`fix`**\n\n表示修复了一个 bug 或问题。\n\n```Shell\ngit commit -m \"fix: 修复登录页面无法加载的问题\"\n```\n\n\n---\n\n### 2. **`feat`**\n\n表示新增了一个功能。\n\n```Shell\ngit commit -m \"feat: 添加用户注册功能\"\n```\n\n\n---\n\n### 3. **`docs`**\n\n表示文档相关的更改（如 README、注释等）。\n\n```Shell\ngit commit -m \"docs: 更新项目 README 文件\"\n```\n\n\n---\n\n### 4. **`style`**\n\n表示代码风格的更改（如格式化、缩进等），不涉及功能或逻辑的修改。\n\n```Shell\ngit commit -m \"style: 格式化代码缩进\"\n```\n\n\n---\n\n### 5. **`refactor`**\n\n表示代码重构，既不修复 bug 也不添加新功能。\n\n```Shell\ngit commit -m \"refactor: 重构用户模块的代码结构\"\n```\n\n\n---\n\n### 6. **`test`**\n\n表示测试相关的更改（如添加或修改测试用例）。\n\n```Shell\ngit commit -m \"test: 添加用户登录功能的单元测试\"\n```\n\n\n---\n\n### 7. **`chore`**\n\n表示日常维护或工具相关的更改（如依赖更新、构建配置等）。\n\n```Shell\ngit commit -m \"chore: 更新项目依赖包\"\n```\n\n\n---\n\n### 8. **`perf`**\n\n表示性能优化相关的更改。\n\n```Shell\ngit commit -m \"perf: 优化数据库查询性能\"\n```\n\n\n---\n\n### 9. **`ci`**\n\n表示持续集成（CI）相关的更改（如 GitHub Actions、Travis CI 等）。\n\n```Shell\ngit commit -m \"ci: 添加 GitHub Actions 自动化测试\"\n```\n\n\n---\n\n### 10. **`revert`**\n\n表示回滚之前的提交。\n\n```Shell\ngit commit -m \"revert: 回滚错误的用户注册功能提交\"\n```\n\n\n---\n\n### 11. **`build`**\n\n表示构建系统或外部依赖的更改（如 Webpack、Gulp 等）。\n\n```Shell\ngit commit -m \"build: 更新 Webpack 配置\"\n```\n\n\n---\n\n### 12. **`wip`**\n\n表示正在进行中的工作（Work In Progress），通常用于临时提交。\n\n```Shell\ngit commit -m \"wip: 用户模块开发中\"\n```\n\n\n---\n\n### 13. **`hotfix`**\n\n表示紧急修复生产环境中的问题。\n\n```Shell\ngit commit -m \"hotfix: 紧急修复支付接口崩溃问题\"\n```\n\n\n---\n\n### 14. **`init`**\n\n表示项目初始化或首次提交。\n\n```Shell\ngit commit -m \"init: 初始化项目\"\n```\n\n\n---\n\n### 15. **`merge`**\n\n表示合并分支。\n\n```Shell\ngit commit -m \"merge: 合并 feature/login 分支到 main\"\n```\n\n\n---\n\n### 提交信息格式建议\n\n通常推荐使用以下格式：\n\n```Shell\n<类型>: <描述>\n```\n\n\n例如：\n\n```Shell\ngit commit -m \"feat: 添加用户登录功能\"\n```\n\n\n如果需要更详细的描述，可以使用多行提交信息：\n\n```Shell\ngit commit -m \"fix: 修复登录页面无法加载的问题\n\n- 修复了登录页面因 API 接口错误导致的加载失败问题\n- 优化了错误提示信息\"\n```\n\n\n---\n\n### 总结\n\n- 使用清晰的前缀（如 `fix`、`feat`、`docs` 等）来描述提交的类型。\n\n- 提交信息应简洁明了，便于团队协作和代码审查。\n\n- 如果需要更详细的描述，可以使用多行提交信息。\n\n这些规范可以帮助团队更好地管理提交历史，并生成更有意义的变更日志。\n\n","slug":"Gitcommit术语","published":1,"updated":"2025-05-04T12:01:02.765Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8c0006p3j5e6bz9sb2","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>在使用 <code>git commit -m</code> 提交代码时，通常会在提交信息中使用一些常见的前缀来描述提交的类型和目的。这些前缀有助于团队更好地理解提交的内容，尤其是在查看提交历史或生成变更日志时。以下是一些常用的前缀及其含义：</p>\n<hr>\n<h3 id=\"1-fix\"><a href=\"#1-fix\" class=\"headerlink\" title=\"1. fix\"></a>1. <strong><code>fix</code></strong></h3><p>表示修复了一个 bug 或问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;fix: 修复登录页面无法加载的问题&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"2-feat\"><a href=\"#2-feat\" class=\"headerlink\" title=\"2. feat\"></a>2. <strong><code>feat</code></strong></h3><p>表示新增了一个功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;feat: 添加用户注册功能&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"3-docs\"><a href=\"#3-docs\" class=\"headerlink\" title=\"3. docs\"></a>3. <strong><code>docs</code></strong></h3><p>表示文档相关的更改（如 README、注释等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;docs: 更新项目 README 文件&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"4-style\"><a href=\"#4-style\" class=\"headerlink\" title=\"4. style\"></a>4. <strong><code>style</code></strong></h3><p>表示代码风格的更改（如格式化、缩进等），不涉及功能或逻辑的修改。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;style: 格式化代码缩进&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"5-refactor\"><a href=\"#5-refactor\" class=\"headerlink\" title=\"5. refactor\"></a>5. <strong><code>refactor</code></strong></h3><p>表示代码重构，既不修复 bug 也不添加新功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;refactor: 重构用户模块的代码结构&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"6-test\"><a href=\"#6-test\" class=\"headerlink\" title=\"6. test\"></a>6. <strong><code>test</code></strong></h3><p>表示测试相关的更改（如添加或修改测试用例）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;test: 添加用户登录功能的单元测试&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"7-chore\"><a href=\"#7-chore\" class=\"headerlink\" title=\"7. chore\"></a>7. <strong><code>chore</code></strong></h3><p>表示日常维护或工具相关的更改（如依赖更新、构建配置等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;chore: 更新项目依赖包&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"8-perf\"><a href=\"#8-perf\" class=\"headerlink\" title=\"8. perf\"></a>8. <strong><code>perf</code></strong></h3><p>表示性能优化相关的更改。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;perf: 优化数据库查询性能&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"9-ci\"><a href=\"#9-ci\" class=\"headerlink\" title=\"9. ci\"></a>9. <strong><code>ci</code></strong></h3><p>表示持续集成（CI）相关的更改（如 GitHub Actions、Travis CI 等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;ci: 添加 GitHub Actions 自动化测试&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"10-revert\"><a href=\"#10-revert\" class=\"headerlink\" title=\"10. revert\"></a>10. <strong><code>revert</code></strong></h3><p>表示回滚之前的提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;revert: 回滚错误的用户注册功能提交&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"11-build\"><a href=\"#11-build\" class=\"headerlink\" title=\"11. build\"></a>11. <strong><code>build</code></strong></h3><p>表示构建系统或外部依赖的更改（如 Webpack、Gulp 等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;build: 更新 Webpack 配置&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"12-wip\"><a href=\"#12-wip\" class=\"headerlink\" title=\"12. wip\"></a>12. <strong><code>wip</code></strong></h3><p>表示正在进行中的工作（Work In Progress），通常用于临时提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;wip: 用户模块开发中&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"13-hotfix\"><a href=\"#13-hotfix\" class=\"headerlink\" title=\"13. hotfix\"></a>13. <strong><code>hotfix</code></strong></h3><p>表示紧急修复生产环境中的问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;hotfix: 紧急修复支付接口崩溃问题&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"14-init\"><a href=\"#14-init\" class=\"headerlink\" title=\"14. init\"></a>14. <strong><code>init</code></strong></h3><p>表示项目初始化或首次提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;init: 初始化项目&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"15-merge\"><a href=\"#15-merge\" class=\"headerlink\" title=\"15. merge\"></a>15. <strong><code>merge</code></strong></h3><p>表示合并分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;merge: 合并 feature/login 分支到 main&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"提交信息格式建议\"><a href=\"#提交信息格式建议\" class=\"headerlink\" title=\"提交信息格式建议\"></a>提交信息格式建议</h3><p>通常推荐使用以下格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;类型&gt;: &lt;描述&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;feat: 添加用户登录功能&quot;</span><br></pre></td></tr></table></figure>\n\n\n<p>如果需要更详细的描述，可以使用多行提交信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;fix: 修复登录页面无法加载的问题</span><br><span class=\"line\"></span><br><span class=\"line\">- 修复了登录页面因 API 接口错误导致的加载失败问题</span><br><span class=\"line\">- 优化了错误提示信息&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>使用清晰的前缀（如 <code>fix</code>、<code>feat</code>、<code>docs</code> 等）来描述提交的类型。</p>\n</li>\n<li><p>提交信息应简洁明了，便于团队协作和代码审查。</p>\n</li>\n<li><p>如果需要更详细的描述，可以使用多行提交信息。</p>\n</li>\n</ul>\n<p>这些规范可以帮助团队更好地管理提交历史，并生成更有意义的变更日志。</p>\n","excerpt":"","more":"<p>在使用 <code>git commit -m</code> 提交代码时，通常会在提交信息中使用一些常见的前缀来描述提交的类型和目的。这些前缀有助于团队更好地理解提交的内容，尤其是在查看提交历史或生成变更日志时。以下是一些常用的前缀及其含义：</p>\n<hr>\n<h3 id=\"1-fix\"><a href=\"#1-fix\" class=\"headerlink\" title=\"1. fix\"></a>1. <strong><code>fix</code></strong></h3><p>表示修复了一个 bug 或问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;fix: 修复登录页面无法加载的问题&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"2-feat\"><a href=\"#2-feat\" class=\"headerlink\" title=\"2. feat\"></a>2. <strong><code>feat</code></strong></h3><p>表示新增了一个功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;feat: 添加用户注册功能&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"3-docs\"><a href=\"#3-docs\" class=\"headerlink\" title=\"3. docs\"></a>3. <strong><code>docs</code></strong></h3><p>表示文档相关的更改（如 README、注释等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;docs: 更新项目 README 文件&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"4-style\"><a href=\"#4-style\" class=\"headerlink\" title=\"4. style\"></a>4. <strong><code>style</code></strong></h3><p>表示代码风格的更改（如格式化、缩进等），不涉及功能或逻辑的修改。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;style: 格式化代码缩进&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"5-refactor\"><a href=\"#5-refactor\" class=\"headerlink\" title=\"5. refactor\"></a>5. <strong><code>refactor</code></strong></h3><p>表示代码重构，既不修复 bug 也不添加新功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;refactor: 重构用户模块的代码结构&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"6-test\"><a href=\"#6-test\" class=\"headerlink\" title=\"6. test\"></a>6. <strong><code>test</code></strong></h3><p>表示测试相关的更改（如添加或修改测试用例）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;test: 添加用户登录功能的单元测试&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"7-chore\"><a href=\"#7-chore\" class=\"headerlink\" title=\"7. chore\"></a>7. <strong><code>chore</code></strong></h3><p>表示日常维护或工具相关的更改（如依赖更新、构建配置等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;chore: 更新项目依赖包&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"8-perf\"><a href=\"#8-perf\" class=\"headerlink\" title=\"8. perf\"></a>8. <strong><code>perf</code></strong></h3><p>表示性能优化相关的更改。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;perf: 优化数据库查询性能&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"9-ci\"><a href=\"#9-ci\" class=\"headerlink\" title=\"9. ci\"></a>9. <strong><code>ci</code></strong></h3><p>表示持续集成（CI）相关的更改（如 GitHub Actions、Travis CI 等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;ci: 添加 GitHub Actions 自动化测试&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"10-revert\"><a href=\"#10-revert\" class=\"headerlink\" title=\"10. revert\"></a>10. <strong><code>revert</code></strong></h3><p>表示回滚之前的提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;revert: 回滚错误的用户注册功能提交&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"11-build\"><a href=\"#11-build\" class=\"headerlink\" title=\"11. build\"></a>11. <strong><code>build</code></strong></h3><p>表示构建系统或外部依赖的更改（如 Webpack、Gulp 等）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;build: 更新 Webpack 配置&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"12-wip\"><a href=\"#12-wip\" class=\"headerlink\" title=\"12. wip\"></a>12. <strong><code>wip</code></strong></h3><p>表示正在进行中的工作（Work In Progress），通常用于临时提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;wip: 用户模块开发中&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"13-hotfix\"><a href=\"#13-hotfix\" class=\"headerlink\" title=\"13. hotfix\"></a>13. <strong><code>hotfix</code></strong></h3><p>表示紧急修复生产环境中的问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;hotfix: 紧急修复支付接口崩溃问题&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"14-init\"><a href=\"#14-init\" class=\"headerlink\" title=\"14. init\"></a>14. <strong><code>init</code></strong></h3><p>表示项目初始化或首次提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;init: 初始化项目&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"15-merge\"><a href=\"#15-merge\" class=\"headerlink\" title=\"15. merge\"></a>15. <strong><code>merge</code></strong></h3><p>表示合并分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;merge: 合并 feature/login 分支到 main&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"提交信息格式建议\"><a href=\"#提交信息格式建议\" class=\"headerlink\" title=\"提交信息格式建议\"></a>提交信息格式建议</h3><p>通常推荐使用以下格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;类型&gt;: &lt;描述&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;feat: 添加用户登录功能&quot;</span><br></pre></td></tr></table></figure>\n\n\n<p>如果需要更详细的描述，可以使用多行提交信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;fix: 修复登录页面无法加载的问题</span><br><span class=\"line\"></span><br><span class=\"line\">- 修复了登录页面因 API 接口错误导致的加载失败问题</span><br><span class=\"line\">- 优化了错误提示信息&quot;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>使用清晰的前缀（如 <code>fix</code>、<code>feat</code>、<code>docs</code> 等）来描述提交的类型。</p>\n</li>\n<li><p>提交信息应简洁明了，便于团队协作和代码审查。</p>\n</li>\n<li><p>如果需要更详细的描述，可以使用多行提交信息。</p>\n</li>\n</ul>\n<p>这些规范可以帮助团队更好地管理提交历史，并生成更有意义的变更日志。</p>\n"},{"title":"Git合作开发流程","description":"使用Git进行团队协作开发可以高效管理代码","toc":false,"date":"2025-05-04T12:00:20.000Z","_content":"\n使用Git进行团队协作开发可以高效管理代码，以下是详细步骤和最佳实践：\n\n---\n\n### **1. 创建远程仓库**\n\n- **选择平台**：在GitHub、GitLab或Gitee上创建远程仓库。\n\n- **初始化仓库**：由一人创建空仓库，或推送现有项目：\n\n  ```Shell\ngit init\ngit add .\ngit commit -m \"Initial commit\"\ngit remote add origin <远程仓库URL>\ngit push -u origin main\n```\n\n\n---\n\n### **2. 克隆仓库到本地**\n\n其他成员克隆仓库到本地：\n\n```Shell\ngit clone <远程仓库URL>\n```\n\n\n---\n\n### **3. 分支管理策略**\n\n- **主分支（main/master）**：稳定版本，仅通过合并更新。\n\n- **开发分支（develop）**（可选）：集成新功能，适合复杂项目。\n\n- **功能分支（feature/xxx）**：每个新功能在独立分支开发。\n\n**常用命令**：\n\n- 创建并切换分支：\n\n  ```Shell\ngit checkout -b feature/login\n```\n\n\n- 推送分支到远程：\n\n  ```Shell\ngit push origin feature/login\n```\n\n\n---\n\n### **4. 日常开发流程**\n\n- **频繁提交**：小步提交，描述清晰：\n\n  ```Shell\ngit add .\ngit commit -m \"feat: 添加用户登录功能\"\n```\n\n\n- **推送更改**：\n\n  ```Shell\ngit push origin feature/login\n```\n\n\n---\n\n### **5. 代码合并与审查**\n\n- **发起Pull Request (PR)/Merge Request (MR)**：\n\n  1. 在远程仓库页面选择分支发起PR。\n\n  2. 团队成员审查代码，讨论修改。\n\n  3. 确认无误后合并到主分支。\n\n- **合并分支**（本地操作）：\n\n  ```Shell\ngit checkout main\ngit pull origin main       # 更新主分支\ngit merge feature/login    # 合并功能分支\ngit push origin main       # 推送合并结果\n```\n\n\n---\n\n### **6. 处理冲突**\n\n- 当多人修改同一文件时，拉取最新代码并解决冲突：\n\n  ```Shell\ngit pull origin main       # 拉取最新代码，发现冲突\n# 手动编辑冲突文件，保留需要的代码\ngit add .\ngit commit -m \"fix: 解决合并冲突\"\ngit push origin feature/login\n```\n\n\n---\n\n### **7. 同步更新**\n\n- **定期拉取主分支**：\n\n  ```Shell\ngit checkout main\ngit pull origin main\n```\n\n\n- **Rebase保持历史整洁**（可选）：\n\n  ```Shell\ngit checkout feature/login\ngit rebase main           # 将主分支更新应用到当前分支\n```\n\n\n---\n\n### **8. 其他最佳实践**\n\n- **.gitignore文件**：排除临时文件、日志、编译产物。\n\n- **Commit规范**：使用语义化标签（如`feat:`, `fix:`, `docs:`）。\n\n- **分支清理**：合并后删除已无用的分支：\n\n  ```Shell\ngit branch -d feature/login   # 删除本地分支\ngit push origin --delete feature/login  # 删除远程分支\n```\n\n\n---\n\n### **9. 选择协作模型**\n\n- **GitHub Flow**（简单）：\n\n  - 主分支始终可部署。\n\n  - 功能分支开发 → PR合并 → 立即部署。\n\n- **Git Flow**（复杂）：\n\n  - 包含`develop`、`release`、`hotfix`等分支，适合定期发布。\n\n---\n\n\n\n\n","source":"_posts/Git合作开发流程.md","raw":"---\ntitle: Git合作开发流程\ndescription: '使用Git进行团队协作开发可以高效管理代码'\ntags: ['git']\ntoc: false\ndate: 2025-05-04 20:00:20\ncategories:\n---\n\n使用Git进行团队协作开发可以高效管理代码，以下是详细步骤和最佳实践：\n\n---\n\n### **1. 创建远程仓库**\n\n- **选择平台**：在GitHub、GitLab或Gitee上创建远程仓库。\n\n- **初始化仓库**：由一人创建空仓库，或推送现有项目：\n\n  ```Shell\ngit init\ngit add .\ngit commit -m \"Initial commit\"\ngit remote add origin <远程仓库URL>\ngit push -u origin main\n```\n\n\n---\n\n### **2. 克隆仓库到本地**\n\n其他成员克隆仓库到本地：\n\n```Shell\ngit clone <远程仓库URL>\n```\n\n\n---\n\n### **3. 分支管理策略**\n\n- **主分支（main/master）**：稳定版本，仅通过合并更新。\n\n- **开发分支（develop）**（可选）：集成新功能，适合复杂项目。\n\n- **功能分支（feature/xxx）**：每个新功能在独立分支开发。\n\n**常用命令**：\n\n- 创建并切换分支：\n\n  ```Shell\ngit checkout -b feature/login\n```\n\n\n- 推送分支到远程：\n\n  ```Shell\ngit push origin feature/login\n```\n\n\n---\n\n### **4. 日常开发流程**\n\n- **频繁提交**：小步提交，描述清晰：\n\n  ```Shell\ngit add .\ngit commit -m \"feat: 添加用户登录功能\"\n```\n\n\n- **推送更改**：\n\n  ```Shell\ngit push origin feature/login\n```\n\n\n---\n\n### **5. 代码合并与审查**\n\n- **发起Pull Request (PR)/Merge Request (MR)**：\n\n  1. 在远程仓库页面选择分支发起PR。\n\n  2. 团队成员审查代码，讨论修改。\n\n  3. 确认无误后合并到主分支。\n\n- **合并分支**（本地操作）：\n\n  ```Shell\ngit checkout main\ngit pull origin main       # 更新主分支\ngit merge feature/login    # 合并功能分支\ngit push origin main       # 推送合并结果\n```\n\n\n---\n\n### **6. 处理冲突**\n\n- 当多人修改同一文件时，拉取最新代码并解决冲突：\n\n  ```Shell\ngit pull origin main       # 拉取最新代码，发现冲突\n# 手动编辑冲突文件，保留需要的代码\ngit add .\ngit commit -m \"fix: 解决合并冲突\"\ngit push origin feature/login\n```\n\n\n---\n\n### **7. 同步更新**\n\n- **定期拉取主分支**：\n\n  ```Shell\ngit checkout main\ngit pull origin main\n```\n\n\n- **Rebase保持历史整洁**（可选）：\n\n  ```Shell\ngit checkout feature/login\ngit rebase main           # 将主分支更新应用到当前分支\n```\n\n\n---\n\n### **8. 其他最佳实践**\n\n- **.gitignore文件**：排除临时文件、日志、编译产物。\n\n- **Commit规范**：使用语义化标签（如`feat:`, `fix:`, `docs:`）。\n\n- **分支清理**：合并后删除已无用的分支：\n\n  ```Shell\ngit branch -d feature/login   # 删除本地分支\ngit push origin --delete feature/login  # 删除远程分支\n```\n\n\n---\n\n### **9. 选择协作模型**\n\n- **GitHub Flow**（简单）：\n\n  - 主分支始终可部署。\n\n  - 功能分支开发 → PR合并 → 立即部署。\n\n- **Git Flow**（复杂）：\n\n  - 包含`develop`、`release`、`hotfix`等分支，适合定期发布。\n\n---\n\n\n\n\n","slug":"Git合作开发流程","published":1,"updated":"2025-05-04T12:01:56.905Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8c0009p3j5brsi3n0j","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>使用Git进行团队协作开发可以高效管理代码，以下是详细步骤和最佳实践：</p>\n<hr>\n<h3 id=\"1-创建远程仓库\"><a href=\"#1-创建远程仓库\" class=\"headerlink\" title=\"1. 创建远程仓库\"></a><strong>1. 创建远程仓库</strong></h3><ul>\n<li><p><strong>选择平台</strong>：在GitHub、GitLab或Gitee上创建远程仓库。</p>\n</li>\n<li><p><strong>初始化仓库</strong>：由一人创建空仓库，或推送现有项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;Initial commit&quot;</span><br><span class=\"line\">git remote add origin &lt;远程仓库URL&gt;</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"2-克隆仓库到本地\"><a href=\"#2-克隆仓库到本地\" class=\"headerlink\" title=\"2. 克隆仓库到本地\"></a><strong>2. 克隆仓库到本地</strong></h3><p>其他成员克隆仓库到本地：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;远程仓库URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"3-分支管理策略\"><a href=\"#3-分支管理策略\" class=\"headerlink\" title=\"3. 分支管理策略\"></a><strong>3. 分支管理策略</strong></h3><ul>\n<li><p><strong>主分支（main&#x2F;master）</strong>：稳定版本，仅通过合并更新。</p>\n</li>\n<li><p><strong>开发分支（develop）</strong>（可选）：集成新功能，适合复杂项目。</p>\n</li>\n<li><p><strong>功能分支（feature&#x2F;xxx）</strong>：每个新功能在独立分支开发。</p>\n</li>\n</ul>\n<p><strong>常用命令</strong>：</p>\n<ul>\n<li><p>创建并切换分支：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature/login</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>推送分支到远程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"4-日常开发流程\"><a href=\"#4-日常开发流程\" class=\"headerlink\" title=\"4. 日常开发流程\"></a><strong>4. 日常开发流程</strong></h3><ul>\n<li><p><strong>频繁提交</strong>：小步提交，描述清晰：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;feat: 添加用户登录功能&quot;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>推送更改</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"5-代码合并与审查\"><a href=\"#5-代码合并与审查\" class=\"headerlink\" title=\"5. 代码合并与审查\"></a><strong>5. 代码合并与审查</strong></h3><ul>\n<li><p>**发起Pull Request (PR)&#x2F;Merge Request (MR)**：</p>\n<ol>\n<li><p>在远程仓库页面选择分支发起PR。</p>\n</li>\n<li><p>团队成员审查代码，讨论修改。</p>\n</li>\n<li><p>确认无误后合并到主分支。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>合并分支</strong>（本地操作）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout main</span><br><span class=\"line\">git pull origin main       # 更新主分支</span><br><span class=\"line\">git merge feature/login    # 合并功能分支</span><br><span class=\"line\">git push origin main       # 推送合并结果</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"6-处理冲突\"><a href=\"#6-处理冲突\" class=\"headerlink\" title=\"6. 处理冲突\"></a><strong>6. 处理冲突</strong></h3><ul>\n<li><p>当多人修改同一文件时，拉取最新代码并解决冲突：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin main       # 拉取最新代码，发现冲突</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">手动编辑冲突文件，保留需要的代码</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;fix: 解决合并冲突&quot;</span><br><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"7-同步更新\"><a href=\"#7-同步更新\" class=\"headerlink\" title=\"7. 同步更新\"></a><strong>7. 同步更新</strong></h3><ul>\n<li><p><strong>定期拉取主分支</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout main</span><br><span class=\"line\">git pull origin main</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>Rebase保持历史整洁</strong>（可选）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout feature/login</span><br><span class=\"line\">git rebase main           # 将主分支更新应用到当前分支</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"8-其他最佳实践\"><a href=\"#8-其他最佳实践\" class=\"headerlink\" title=\"8. 其他最佳实践\"></a><strong>8. 其他最佳实践</strong></h3><ul>\n<li><p><strong>.gitignore文件</strong>：排除临时文件、日志、编译产物。</p>\n</li>\n<li><p><strong>Commit规范</strong>：使用语义化标签（如<code>feat:</code>, <code>fix:</code>, <code>docs:</code>）。</p>\n</li>\n<li><p><strong>分支清理</strong>：合并后删除已无用的分支：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature/login   # 删除本地分支</span><br><span class=\"line\">git push origin --delete feature/login  # 删除远程分支</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"9-选择协作模型\"><a href=\"#9-选择协作模型\" class=\"headerlink\" title=\"9. 选择协作模型\"></a><strong>9. 选择协作模型</strong></h3><ul>\n<li><p><strong>GitHub Flow</strong>（简单）：</p>\n<ul>\n<li><p>主分支始终可部署。</p>\n</li>\n<li><p>功能分支开发 → PR合并 → 立即部署。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Git Flow</strong>（复杂）：</p>\n<ul>\n<li>包含<code>develop</code>、<code>release</code>、<code>hotfix</code>等分支，适合定期发布。</li>\n</ul>\n</li>\n</ul>\n<hr>\n","excerpt":"","more":"<p>使用Git进行团队协作开发可以高效管理代码，以下是详细步骤和最佳实践：</p>\n<hr>\n<h3 id=\"1-创建远程仓库\"><a href=\"#1-创建远程仓库\" class=\"headerlink\" title=\"1. 创建远程仓库\"></a><strong>1. 创建远程仓库</strong></h3><ul>\n<li><p><strong>选择平台</strong>：在GitHub、GitLab或Gitee上创建远程仓库。</p>\n</li>\n<li><p><strong>初始化仓库</strong>：由一人创建空仓库，或推送现有项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;Initial commit&quot;</span><br><span class=\"line\">git remote add origin &lt;远程仓库URL&gt;</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"2-克隆仓库到本地\"><a href=\"#2-克隆仓库到本地\" class=\"headerlink\" title=\"2. 克隆仓库到本地\"></a><strong>2. 克隆仓库到本地</strong></h3><p>其他成员克隆仓库到本地：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;远程仓库URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"3-分支管理策略\"><a href=\"#3-分支管理策略\" class=\"headerlink\" title=\"3. 分支管理策略\"></a><strong>3. 分支管理策略</strong></h3><ul>\n<li><p><strong>主分支（main&#x2F;master）</strong>：稳定版本，仅通过合并更新。</p>\n</li>\n<li><p><strong>开发分支（develop）</strong>（可选）：集成新功能，适合复杂项目。</p>\n</li>\n<li><p><strong>功能分支（feature&#x2F;xxx）</strong>：每个新功能在独立分支开发。</p>\n</li>\n</ul>\n<p><strong>常用命令</strong>：</p>\n<ul>\n<li><p>创建并切换分支：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature/login</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>推送分支到远程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"4-日常开发流程\"><a href=\"#4-日常开发流程\" class=\"headerlink\" title=\"4. 日常开发流程\"></a><strong>4. 日常开发流程</strong></h3><ul>\n<li><p><strong>频繁提交</strong>：小步提交，描述清晰：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;feat: 添加用户登录功能&quot;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>推送更改</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"5-代码合并与审查\"><a href=\"#5-代码合并与审查\" class=\"headerlink\" title=\"5. 代码合并与审查\"></a><strong>5. 代码合并与审查</strong></h3><ul>\n<li><p>**发起Pull Request (PR)&#x2F;Merge Request (MR)**：</p>\n<ol>\n<li><p>在远程仓库页面选择分支发起PR。</p>\n</li>\n<li><p>团队成员审查代码，讨论修改。</p>\n</li>\n<li><p>确认无误后合并到主分支。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>合并分支</strong>（本地操作）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout main</span><br><span class=\"line\">git pull origin main       # 更新主分支</span><br><span class=\"line\">git merge feature/login    # 合并功能分支</span><br><span class=\"line\">git push origin main       # 推送合并结果</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"6-处理冲突\"><a href=\"#6-处理冲突\" class=\"headerlink\" title=\"6. 处理冲突\"></a><strong>6. 处理冲突</strong></h3><ul>\n<li><p>当多人修改同一文件时，拉取最新代码并解决冲突：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin main       # 拉取最新代码，发现冲突</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">手动编辑冲突文件，保留需要的代码</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;fix: 解决合并冲突&quot;</span><br><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"7-同步更新\"><a href=\"#7-同步更新\" class=\"headerlink\" title=\"7. 同步更新\"></a><strong>7. 同步更新</strong></h3><ul>\n<li><p><strong>定期拉取主分支</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout main</span><br><span class=\"line\">git pull origin main</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>Rebase保持历史整洁</strong>（可选）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout feature/login</span><br><span class=\"line\">git rebase main           # 将主分支更新应用到当前分支</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"8-其他最佳实践\"><a href=\"#8-其他最佳实践\" class=\"headerlink\" title=\"8. 其他最佳实践\"></a><strong>8. 其他最佳实践</strong></h3><ul>\n<li><p><strong>.gitignore文件</strong>：排除临时文件、日志、编译产物。</p>\n</li>\n<li><p><strong>Commit规范</strong>：使用语义化标签（如<code>feat:</code>, <code>fix:</code>, <code>docs:</code>）。</p>\n</li>\n<li><p><strong>分支清理</strong>：合并后删除已无用的分支：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature/login   # 删除本地分支</span><br><span class=\"line\">git push origin --delete feature/login  # 删除远程分支</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"9-选择协作模型\"><a href=\"#9-选择协作模型\" class=\"headerlink\" title=\"9. 选择协作模型\"></a><strong>9. 选择协作模型</strong></h3><ul>\n<li><p><strong>GitHub Flow</strong>（简单）：</p>\n<ul>\n<li><p>主分支始终可部署。</p>\n</li>\n<li><p>功能分支开发 → PR合并 → 立即部署。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Git Flow</strong>（复杂）：</p>\n<ul>\n<li>包含<code>develop</code>、<code>release</code>、<code>hotfix</code>等分支，适合定期发布。</li>\n</ul>\n</li>\n</ul>\n<hr>\n"},{"title":"Hardhat-ignition","description":"Hardhat Ignition 是 Hardhat 的一个插件，用于管理和自动化智能合约的部署流程","toc":false,"date":"2025-05-04T12:10:35.000Z","_content":"**Hardhat Ignition** 是 Hardhat 的一个插件，用于管理和自动化智能合约的部署流程。它特别适合复杂的部署场景，例如需要部署多个合约、处理合约依赖关系或按特定顺序部署的场景。以下是 Hardhat Ignition 的常见用法和详细介绍：\n\n---\n\n## **1. 安装 Hardhat Ignition**\n\n首先，确保你已经安装了 Hardhat 和 Hardhat Ignition：\n\n```Shell\nnpm install --save-dev @nomicfoundation/hardhat-ignition\n```\n\n\n然后在 `hardhat.config.js` 中引入插件：\n\n```JavaScript\nrequire(\"@nomicfoundation/hardhat-ignition\");\n```\n\n\n---\n\n## **2. 定义部署模块**\n\nHardhat Ignition 的核心概念是 **模块（Module）**。一个模块是一个独立的部署单元，可以包含多个合约部署和配置。\n\n### **基本模块定义**\n\n```JavaScript\nconst { buildModule } = require(\"@nomicfoundation/hardhat-ignition/modules\");\n\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myContract = m.contract(\"MyContract\");\n\n  return { myContract };\n});\n```\n\n\n- `buildModule`：定义一个模块。\n\n- `\"MyModule\"`：模块的名称。\n\n- `m.contract(\"MyContract\")`：部署名为 `MyContract` 的合约。\n\n- `return { myContract }`：返回部署后的合约实例。\n\n---\n\n### **带参数的模块**\n\n你可以通过 `m.getParameter` 动态设置部署参数：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const initialValue = m.getParameter(\"initialValue\", 100); // 默认值为 100\n  const myContract = m.contract(\"MyContract\", [initialValue]);\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **部署多个合约**\n\n在一个模块中可以部署多个合约，并处理它们之间的依赖关系：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const contractA = m.contract(\"ContractA\");\n  const contractB = m.contract(\"ContractB\", [contractA.address]);\n\n  return { contractA, contractB };\n});\n```\n\n\n- `contractB` 依赖于 `contractA` 的地址，Hardhat Ignition 会自动按正确顺序部署。\n\n---\n\n### **调用合约函数**\n\n在部署过程中，你可以调用合约的函数：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myContract = m.contract(\"MyContract\");\n  m.call(myContract, \"initialize\", [42]); // 调用 initialize 函数\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **使用库合约**\n\n如果合约依赖于库合约，可以先部署库合约，然后将其链接到主合约：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myLibrary = m.library(\"MyLibrary\");\n  const myContract = m.contract(\"MyContract\", [], {\n    libraries: {\n      MyLibrary: myLibrary.address,\n    },\n  });\n\n  return { myContract };\n});\n```\n\n\n---\n\n## **3. 运行部署**\n\n使用 `ignition.deploy` 运行部署模块：\n\n```JavaScript\nconst { ignition } = require(\"hardhat\");\n\nasync function main() {\n  const { myContract } = await ignition.deploy(\"./path/to/MyModule\");\n  console.log(\"MyContract deployed to:\", myContract.address);\n}\n\nmain();\n```\n\n\n运行部署脚本：\n\n```Shell\nnpx hardhat run scripts/deploy.js --network localhost\n```\n\n\n---\n\n## **4. 高级功能**\n\n### **分阶段部署**\n\nHardhat Ignition 支持分阶段部署，例如先部署合约，然后初始化：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myContract = m.contract(\"MyContract\");\n\n  m.stage(\"Initialize\", async () => {\n    await myContract.initialize(42);\n  });\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **条件部署**\n\n你可以根据条件决定是否部署某个合约：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const shouldDeploy = m.getParameter(\"shouldDeploy\", true);\n\n  if (shouldDeploy) {\n    const myContract = m.contract(\"MyContract\");\n    return { myContract };\n  }\n\n  return {};\n});\n```\n\n\n---\n\n### **使用现有合约**\n\n如果某个合约已经部署，可以直接使用其地址，而不重新部署：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const existingContract = m.getParameter(\"existingContract\", \"0x...\");\n  const myContract = m.contractAt(\"MyContract\", existingContract);\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **多网络支持**\n\nHardhat Ignition 支持多网络配置。你可以在 `hardhat.config.js` 中定义不同的网络，并在部署时指定网络：\n\n```JavaScript\nmodule.exports = {\n  networks: {\n    localhost: {\n      url: \"http://localhost:8545\",\n    },\n    mainnet: {\n      url: \"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\",\n      accounts: [\"0x...\"], // 私钥\n    },\n  },\n};\n```\n\n\n运行部署时指定网络：\n\n```Shell\nnpx hardhat run scripts/deploy.js --network mainnet\n```\n\n\n---\n\n## **5. 使用场景**\n\n### **复杂部署流程**\n\n- 部署多个合约并处理依赖关系。\n\n- 按特定顺序初始化合约。\n\n### **多环境部署**\n\n- 在测试网和主网之间切换部署配置。\n\n- 动态调整部署参数（如初始值、管理员地址等）。\n\n### **自动化测试**\n\n- 在测试中自动部署合约并初始化状态。\n\n### **升级合约**\n\n- 部署新版本的合约并迁移数据。\n\n---\n\n\n\n\n","source":"_posts/Hardhat-ignition.md","raw":"---\ntitle: Hardhat-ignition\ndescription: 'Hardhat Ignition 是 Hardhat 的一个插件，用于管理和自动化智能合约的部署流程'\ntags: ['hardhat','web3']\ntoc: false\ndate: 2025-05-04 20:10:35\ncategories:\n---\n**Hardhat Ignition** 是 Hardhat 的一个插件，用于管理和自动化智能合约的部署流程。它特别适合复杂的部署场景，例如需要部署多个合约、处理合约依赖关系或按特定顺序部署的场景。以下是 Hardhat Ignition 的常见用法和详细介绍：\n\n---\n\n## **1. 安装 Hardhat Ignition**\n\n首先，确保你已经安装了 Hardhat 和 Hardhat Ignition：\n\n```Shell\nnpm install --save-dev @nomicfoundation/hardhat-ignition\n```\n\n\n然后在 `hardhat.config.js` 中引入插件：\n\n```JavaScript\nrequire(\"@nomicfoundation/hardhat-ignition\");\n```\n\n\n---\n\n## **2. 定义部署模块**\n\nHardhat Ignition 的核心概念是 **模块（Module）**。一个模块是一个独立的部署单元，可以包含多个合约部署和配置。\n\n### **基本模块定义**\n\n```JavaScript\nconst { buildModule } = require(\"@nomicfoundation/hardhat-ignition/modules\");\n\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myContract = m.contract(\"MyContract\");\n\n  return { myContract };\n});\n```\n\n\n- `buildModule`：定义一个模块。\n\n- `\"MyModule\"`：模块的名称。\n\n- `m.contract(\"MyContract\")`：部署名为 `MyContract` 的合约。\n\n- `return { myContract }`：返回部署后的合约实例。\n\n---\n\n### **带参数的模块**\n\n你可以通过 `m.getParameter` 动态设置部署参数：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const initialValue = m.getParameter(\"initialValue\", 100); // 默认值为 100\n  const myContract = m.contract(\"MyContract\", [initialValue]);\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **部署多个合约**\n\n在一个模块中可以部署多个合约，并处理它们之间的依赖关系：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const contractA = m.contract(\"ContractA\");\n  const contractB = m.contract(\"ContractB\", [contractA.address]);\n\n  return { contractA, contractB };\n});\n```\n\n\n- `contractB` 依赖于 `contractA` 的地址，Hardhat Ignition 会自动按正确顺序部署。\n\n---\n\n### **调用合约函数**\n\n在部署过程中，你可以调用合约的函数：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myContract = m.contract(\"MyContract\");\n  m.call(myContract, \"initialize\", [42]); // 调用 initialize 函数\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **使用库合约**\n\n如果合约依赖于库合约，可以先部署库合约，然后将其链接到主合约：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myLibrary = m.library(\"MyLibrary\");\n  const myContract = m.contract(\"MyContract\", [], {\n    libraries: {\n      MyLibrary: myLibrary.address,\n    },\n  });\n\n  return { myContract };\n});\n```\n\n\n---\n\n## **3. 运行部署**\n\n使用 `ignition.deploy` 运行部署模块：\n\n```JavaScript\nconst { ignition } = require(\"hardhat\");\n\nasync function main() {\n  const { myContract } = await ignition.deploy(\"./path/to/MyModule\");\n  console.log(\"MyContract deployed to:\", myContract.address);\n}\n\nmain();\n```\n\n\n运行部署脚本：\n\n```Shell\nnpx hardhat run scripts/deploy.js --network localhost\n```\n\n\n---\n\n## **4. 高级功能**\n\n### **分阶段部署**\n\nHardhat Ignition 支持分阶段部署，例如先部署合约，然后初始化：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const myContract = m.contract(\"MyContract\");\n\n  m.stage(\"Initialize\", async () => {\n    await myContract.initialize(42);\n  });\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **条件部署**\n\n你可以根据条件决定是否部署某个合约：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const shouldDeploy = m.getParameter(\"shouldDeploy\", true);\n\n  if (shouldDeploy) {\n    const myContract = m.contract(\"MyContract\");\n    return { myContract };\n  }\n\n  return {};\n});\n```\n\n\n---\n\n### **使用现有合约**\n\n如果某个合约已经部署，可以直接使用其地址，而不重新部署：\n\n```JavaScript\nmodule.exports = buildModule(\"MyModule\", (m) => {\n  const existingContract = m.getParameter(\"existingContract\", \"0x...\");\n  const myContract = m.contractAt(\"MyContract\", existingContract);\n\n  return { myContract };\n});\n```\n\n\n---\n\n### **多网络支持**\n\nHardhat Ignition 支持多网络配置。你可以在 `hardhat.config.js` 中定义不同的网络，并在部署时指定网络：\n\n```JavaScript\nmodule.exports = {\n  networks: {\n    localhost: {\n      url: \"http://localhost:8545\",\n    },\n    mainnet: {\n      url: \"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\",\n      accounts: [\"0x...\"], // 私钥\n    },\n  },\n};\n```\n\n\n运行部署时指定网络：\n\n```Shell\nnpx hardhat run scripts/deploy.js --network mainnet\n```\n\n\n---\n\n## **5. 使用场景**\n\n### **复杂部署流程**\n\n- 部署多个合约并处理依赖关系。\n\n- 按特定顺序初始化合约。\n\n### **多环境部署**\n\n- 在测试网和主网之间切换部署配置。\n\n- 动态调整部署参数（如初始值、管理员地址等）。\n\n### **自动化测试**\n\n- 在测试中自动部署合约并初始化状态。\n\n### **升级合约**\n\n- 部署新版本的合约并迁移数据。\n\n---\n\n\n\n\n","slug":"Hardhat-ignition","published":1,"updated":"2025-05-04T12:11:25.793Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8d000ap3j59wmwbzm7","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>Hardhat Ignition</strong> 是 Hardhat 的一个插件，用于管理和自动化智能合约的部署流程。它特别适合复杂的部署场景，例如需要部署多个合约、处理合约依赖关系或按特定顺序部署的场景。以下是 Hardhat Ignition 的常见用法和详细介绍：</p>\n<hr>\n<h2 id=\"1-安装-Hardhat-Ignition\"><a href=\"#1-安装-Hardhat-Ignition\" class=\"headerlink\" title=\"1. 安装 Hardhat Ignition\"></a><strong>1. 安装 Hardhat Ignition</strong></h2><p>首先，确保你已经安装了 Hardhat 和 Hardhat Ignition：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev @nomicfoundation/hardhat-ignition</span><br></pre></td></tr></table></figure>\n\n\n<p>然后在 <code>hardhat.config.js</code> 中引入插件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomicfoundation/hardhat-ignition&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"2-定义部署模块\"><a href=\"#2-定义部署模块\" class=\"headerlink\" title=\"2. 定义部署模块\"></a><strong>2. 定义部署模块</strong></h2><p>Hardhat Ignition 的核心概念是 <strong>模块（Module）</strong>。一个模块是一个独立的部署单元，可以包含多个合约部署和配置。</p>\n<h3 id=\"基本模块定义\"><a href=\"#基本模块定义\" class=\"headerlink\" title=\"基本模块定义\"></a><strong>基本模块定义</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; buildModule &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomicfoundation/hardhat-ignition/modules&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><code>buildModule</code>：定义一个模块。</p>\n</li>\n<li><p><code>&quot;MyModule&quot;</code>：模块的名称。</p>\n</li>\n<li><p><code>m.contract(&quot;MyContract&quot;)</code>：部署名为 <code>MyContract</code> 的合约。</p>\n</li>\n<li><p><code>return &#123; myContract &#125;</code>：返回部署后的合约实例。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"带参数的模块\"><a href=\"#带参数的模块\" class=\"headerlink\" title=\"带参数的模块\"></a><strong>带参数的模块</strong></h3><p>你可以通过 <code>m.getParameter</code> 动态设置部署参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> initialValue = m.<span class=\"title function_\">getParameter</span>(<span class=\"string\">&quot;initialValue&quot;</span>, <span class=\"number\">100</span>); <span class=\"comment\">// 默认值为 100</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>, [initialValue]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"部署多个合约\"><a href=\"#部署多个合约\" class=\"headerlink\" title=\"部署多个合约\"></a><strong>部署多个合约</strong></h3><p>在一个模块中可以部署多个合约，并处理它们之间的依赖关系：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> contractA = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;ContractA&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> contractB = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;ContractB&quot;</span>, [contractA.<span class=\"property\">address</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; contractA, contractB &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><code>contractB</code> 依赖于 <code>contractA</code> 的地址，Hardhat Ignition 会自动按正确顺序部署。</li>\n</ul>\n<hr>\n<h3 id=\"调用合约函数\"><a href=\"#调用合约函数\" class=\"headerlink\" title=\"调用合约函数\"></a><strong>调用合约函数</strong></h3><p>在部署过程中，你可以调用合约的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\">  m.<span class=\"title function_\">call</span>(myContract, <span class=\"string\">&quot;initialize&quot;</span>, [<span class=\"number\">42</span>]); <span class=\"comment\">// 调用 initialize 函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"使用库合约\"><a href=\"#使用库合约\" class=\"headerlink\" title=\"使用库合约\"></a><strong>使用库合约</strong></h3><p>如果合约依赖于库合约，可以先部署库合约，然后将其链接到主合约：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myLibrary = m.<span class=\"title function_\">library</span>(<span class=\"string\">&quot;MyLibrary&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>, [], &#123;</span><br><span class=\"line\">    <span class=\"attr\">libraries</span>: &#123;</span><br><span class=\"line\">      <span class=\"title class_\">MyLibrary</span>: myLibrary.<span class=\"property\">address</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"3-运行部署\"><a href=\"#3-运行部署\" class=\"headerlink\" title=\"3. 运行部署\"></a><strong>3. 运行部署</strong></h2><p>使用 <code>ignition.deploy</code> 运行部署模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; ignition &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; myContract &#125; = <span class=\"keyword\">await</span> ignition.<span class=\"title function_\">deploy</span>(<span class=\"string\">&quot;./path/to/MyModule&quot;</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;MyContract deployed to:&quot;</span>, myContract.<span class=\"property\">address</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">main</span>();</span><br></pre></td></tr></table></figure>\n\n\n<p>运行部署脚本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat run scripts/deploy.js --network localhost</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"4-高级功能\"><a href=\"#4-高级功能\" class=\"headerlink\" title=\"4. 高级功能\"></a><strong>4. 高级功能</strong></h2><h3 id=\"分阶段部署\"><a href=\"#分阶段部署\" class=\"headerlink\" title=\"分阶段部署\"></a><strong>分阶段部署</strong></h3><p>Hardhat Ignition 支持分阶段部署，例如先部署合约，然后初始化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  m.<span class=\"title function_\">stage</span>(<span class=\"string\">&quot;Initialize&quot;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> myContract.<span class=\"title function_\">initialize</span>(<span class=\"number\">42</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"条件部署\"><a href=\"#条件部署\" class=\"headerlink\" title=\"条件部署\"></a><strong>条件部署</strong></h3><p>你可以根据条件决定是否部署某个合约：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> shouldDeploy = m.<span class=\"title function_\">getParameter</span>(<span class=\"string\">&quot;shouldDeploy&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldDeploy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"使用现有合约\"><a href=\"#使用现有合约\" class=\"headerlink\" title=\"使用现有合约\"></a><strong>使用现有合约</strong></h3><p>如果某个合约已经部署，可以直接使用其地址，而不重新部署：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> existingContract = m.<span class=\"title function_\">getParameter</span>(<span class=\"string\">&quot;existingContract&quot;</span>, <span class=\"string\">&quot;0x...&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contractAt</span>(<span class=\"string\">&quot;MyContract&quot;</span>, existingContract);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"多网络支持\"><a href=\"#多网络支持\" class=\"headerlink\" title=\"多网络支持\"></a><strong>多网络支持</strong></h3><p>Hardhat Ignition 支持多网络配置。你可以在 <code>hardhat.config.js</code> 中定义不同的网络，并在部署时指定网络：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">networks</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">localhost</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;http://localhost:8545&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">mainnet</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">accounts</span>: [<span class=\"string\">&quot;0x...&quot;</span>], <span class=\"comment\">// 私钥</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>运行部署时指定网络：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat run scripts/deploy.js --network mainnet</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"5-使用场景\"><a href=\"#5-使用场景\" class=\"headerlink\" title=\"5. 使用场景\"></a><strong>5. 使用场景</strong></h2><h3 id=\"复杂部署流程\"><a href=\"#复杂部署流程\" class=\"headerlink\" title=\"复杂部署流程\"></a><strong>复杂部署流程</strong></h3><ul>\n<li><p>部署多个合约并处理依赖关系。</p>\n</li>\n<li><p>按特定顺序初始化合约。</p>\n</li>\n</ul>\n<h3 id=\"多环境部署\"><a href=\"#多环境部署\" class=\"headerlink\" title=\"多环境部署\"></a><strong>多环境部署</strong></h3><ul>\n<li><p>在测试网和主网之间切换部署配置。</p>\n</li>\n<li><p>动态调整部署参数（如初始值、管理员地址等）。</p>\n</li>\n</ul>\n<h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a><strong>自动化测试</strong></h3><ul>\n<li>在测试中自动部署合约并初始化状态。</li>\n</ul>\n<h3 id=\"升级合约\"><a href=\"#升级合约\" class=\"headerlink\" title=\"升级合约\"></a><strong>升级合约</strong></h3><ul>\n<li>部署新版本的合约并迁移数据。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<p><strong>Hardhat Ignition</strong> 是 Hardhat 的一个插件，用于管理和自动化智能合约的部署流程。它特别适合复杂的部署场景，例如需要部署多个合约、处理合约依赖关系或按特定顺序部署的场景。以下是 Hardhat Ignition 的常见用法和详细介绍：</p>\n<hr>\n<h2 id=\"1-安装-Hardhat-Ignition\"><a href=\"#1-安装-Hardhat-Ignition\" class=\"headerlink\" title=\"1. 安装 Hardhat Ignition\"></a><strong>1. 安装 Hardhat Ignition</strong></h2><p>首先，确保你已经安装了 Hardhat 和 Hardhat Ignition：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev @nomicfoundation/hardhat-ignition</span><br></pre></td></tr></table></figure>\n\n\n<p>然后在 <code>hardhat.config.js</code> 中引入插件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomicfoundation/hardhat-ignition&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"2-定义部署模块\"><a href=\"#2-定义部署模块\" class=\"headerlink\" title=\"2. 定义部署模块\"></a><strong>2. 定义部署模块</strong></h2><p>Hardhat Ignition 的核心概念是 <strong>模块（Module）</strong>。一个模块是一个独立的部署单元，可以包含多个合约部署和配置。</p>\n<h3 id=\"基本模块定义\"><a href=\"#基本模块定义\" class=\"headerlink\" title=\"基本模块定义\"></a><strong>基本模块定义</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; buildModule &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomicfoundation/hardhat-ignition/modules&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><code>buildModule</code>：定义一个模块。</p>\n</li>\n<li><p><code>&quot;MyModule&quot;</code>：模块的名称。</p>\n</li>\n<li><p><code>m.contract(&quot;MyContract&quot;)</code>：部署名为 <code>MyContract</code> 的合约。</p>\n</li>\n<li><p><code>return &#123; myContract &#125;</code>：返回部署后的合约实例。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"带参数的模块\"><a href=\"#带参数的模块\" class=\"headerlink\" title=\"带参数的模块\"></a><strong>带参数的模块</strong></h3><p>你可以通过 <code>m.getParameter</code> 动态设置部署参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> initialValue = m.<span class=\"title function_\">getParameter</span>(<span class=\"string\">&quot;initialValue&quot;</span>, <span class=\"number\">100</span>); <span class=\"comment\">// 默认值为 100</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>, [initialValue]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"部署多个合约\"><a href=\"#部署多个合约\" class=\"headerlink\" title=\"部署多个合约\"></a><strong>部署多个合约</strong></h3><p>在一个模块中可以部署多个合约，并处理它们之间的依赖关系：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> contractA = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;ContractA&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> contractB = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;ContractB&quot;</span>, [contractA.<span class=\"property\">address</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; contractA, contractB &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><code>contractB</code> 依赖于 <code>contractA</code> 的地址，Hardhat Ignition 会自动按正确顺序部署。</li>\n</ul>\n<hr>\n<h3 id=\"调用合约函数\"><a href=\"#调用合约函数\" class=\"headerlink\" title=\"调用合约函数\"></a><strong>调用合约函数</strong></h3><p>在部署过程中，你可以调用合约的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\">  m.<span class=\"title function_\">call</span>(myContract, <span class=\"string\">&quot;initialize&quot;</span>, [<span class=\"number\">42</span>]); <span class=\"comment\">// 调用 initialize 函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"使用库合约\"><a href=\"#使用库合约\" class=\"headerlink\" title=\"使用库合约\"></a><strong>使用库合约</strong></h3><p>如果合约依赖于库合约，可以先部署库合约，然后将其链接到主合约：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myLibrary = m.<span class=\"title function_\">library</span>(<span class=\"string\">&quot;MyLibrary&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>, [], &#123;</span><br><span class=\"line\">    <span class=\"attr\">libraries</span>: &#123;</span><br><span class=\"line\">      <span class=\"title class_\">MyLibrary</span>: myLibrary.<span class=\"property\">address</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"3-运行部署\"><a href=\"#3-运行部署\" class=\"headerlink\" title=\"3. 运行部署\"></a><strong>3. 运行部署</strong></h2><p>使用 <code>ignition.deploy</code> 运行部署模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; ignition &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; myContract &#125; = <span class=\"keyword\">await</span> ignition.<span class=\"title function_\">deploy</span>(<span class=\"string\">&quot;./path/to/MyModule&quot;</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;MyContract deployed to:&quot;</span>, myContract.<span class=\"property\">address</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">main</span>();</span><br></pre></td></tr></table></figure>\n\n\n<p>运行部署脚本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat run scripts/deploy.js --network localhost</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"4-高级功能\"><a href=\"#4-高级功能\" class=\"headerlink\" title=\"4. 高级功能\"></a><strong>4. 高级功能</strong></h2><h3 id=\"分阶段部署\"><a href=\"#分阶段部署\" class=\"headerlink\" title=\"分阶段部署\"></a><strong>分阶段部署</strong></h3><p>Hardhat Ignition 支持分阶段部署，例如先部署合约，然后初始化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  m.<span class=\"title function_\">stage</span>(<span class=\"string\">&quot;Initialize&quot;</span>, <span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> myContract.<span class=\"title function_\">initialize</span>(<span class=\"number\">42</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"条件部署\"><a href=\"#条件部署\" class=\"headerlink\" title=\"条件部署\"></a><strong>条件部署</strong></h3><p>你可以根据条件决定是否部署某个合约：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> shouldDeploy = m.<span class=\"title function_\">getParameter</span>(<span class=\"string\">&quot;shouldDeploy&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldDeploy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contract</span>(<span class=\"string\">&quot;MyContract&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"使用现有合约\"><a href=\"#使用现有合约\" class=\"headerlink\" title=\"使用现有合约\"></a><strong>使用现有合约</strong></h3><p>如果某个合约已经部署，可以直接使用其地址，而不重新部署：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title function_\">buildModule</span>(<span class=\"string\">&quot;MyModule&quot;</span>, <span class=\"function\">(<span class=\"params\">m</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> existingContract = m.<span class=\"title function_\">getParameter</span>(<span class=\"string\">&quot;existingContract&quot;</span>, <span class=\"string\">&quot;0x...&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myContract = m.<span class=\"title function_\">contractAt</span>(<span class=\"string\">&quot;MyContract&quot;</span>, existingContract);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; myContract &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"多网络支持\"><a href=\"#多网络支持\" class=\"headerlink\" title=\"多网络支持\"></a><strong>多网络支持</strong></h3><p>Hardhat Ignition 支持多网络配置。你可以在 <code>hardhat.config.js</code> 中定义不同的网络，并在部署时指定网络：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">networks</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">localhost</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;http://localhost:8545&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">mainnet</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">accounts</span>: [<span class=\"string\">&quot;0x...&quot;</span>], <span class=\"comment\">// 私钥</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>运行部署时指定网络：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat run scripts/deploy.js --network mainnet</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h2 id=\"5-使用场景\"><a href=\"#5-使用场景\" class=\"headerlink\" title=\"5. 使用场景\"></a><strong>5. 使用场景</strong></h2><h3 id=\"复杂部署流程\"><a href=\"#复杂部署流程\" class=\"headerlink\" title=\"复杂部署流程\"></a><strong>复杂部署流程</strong></h3><ul>\n<li><p>部署多个合约并处理依赖关系。</p>\n</li>\n<li><p>按特定顺序初始化合约。</p>\n</li>\n</ul>\n<h3 id=\"多环境部署\"><a href=\"#多环境部署\" class=\"headerlink\" title=\"多环境部署\"></a><strong>多环境部署</strong></h3><ul>\n<li><p>在测试网和主网之间切换部署配置。</p>\n</li>\n<li><p>动态调整部署参数（如初始值、管理员地址等）。</p>\n</li>\n</ul>\n<h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a><strong>自动化测试</strong></h3><ul>\n<li>在测试中自动部署合约并初始化状态。</li>\n</ul>\n<h3 id=\"升级合约\"><a href=\"#升级合约\" class=\"headerlink\" title=\"升级合约\"></a><strong>升级合约</strong></h3><ul>\n<li>部署新版本的合约并迁移数据。</li>\n</ul>\n<hr>\n"},{"title":"Hardhat上手指南","description":"Hardhat 是一个用于开发、测试和部署智能合约的开发环境。它提供了强大的工具和插件，帮助开发者更高效地构建以太坊和其他区块链应用","toc":false,"date":"2025-05-04T12:11:14.000Z","_content":"\nHardhat 是一个用于开发、测试和部署智能合约的开发环境。它提供了强大的工具和插件，帮助开发者更高效地构建以太坊和其他区块链应用。以下是 Hardhat 的基本使用指南：\n\n### 1. 安装 Hardhat\n\n首先，确保你已经安装了 Node.js 和 npm。然后，可以通过以下命令全局安装 Hardhat：\n\n```Shell\nnpm install -g hardhat\n```\n\n\n或者在项目目录中局部安装：\n\n```Shell\nnpm install --save-dev hardhat\n```\n\n\n### 2. 初始化项目\n\n在项目目录中运行以下命令来初始化一个新的 Hardhat 项目：\n\n```Shell\nnpx hardhat\n```\n\n\n这将启动一个交互式命令行界面，你可以选择创建一个新的 Hardhat 项目或使用示例项目。\n\n### 3. 项目结构\n\n初始化后，项目目录结构通常如下：\n\n```Plain Text\nmy-project/\n├── contracts/           # 存放智能合约\n├── scripts/             # 存放部署脚本\n├── test/                # 存放测试脚本\n├── hardhat.config.js    # Hardhat 配置文件\n└── package.json         # Node.js 项目配置文件\n```\n\n\n### 4. 编写智能合约\n\n在 `contracts/` 目录中编写你的智能合约。例如，创建一个简单的 `Greeter.sol` 合约：\n\n```Solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Greeter {\n    string private greeting;\n\n    constructor(string memory _greeting) {\n        greeting = _greeting;\n    }\n\n    function greet() public view returns (string memory) {\n        return greeting;\n    }\n\n    function setGreeting(string memory _greeting) public {\n        greeting = _greeting;\n    }\n}\n```\n\n\n### 5. 编译合约\n\n使用以下命令编译合约：\n\n```Shell\nnpx hardhat compile\n```\n\n\n编译后的文件将存储在 `artifacts/` 目录中。\n\n### 6. 编写测试\n\n在 `test/` 目录中编写测试脚本。例如，创建一个 `Greeter.test.js` 文件：\n\n```JavaScript\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"Greeter\", function () {\n  it(\"Should return the new greeting once it's changed\", async function () {\n    const Greeter = await ethers.getContractFactory(\"Greeter\");\n    const greeter = await Greeter.deploy(\"Hello, world!\");\n    await greeter.deployed();\n\n    expect(await greeter.greet()).to.equal(\"Hello, world!\");\n\n    const setGreetingTx = await greeter.setGreeting(\"Hola, mundo!\");\n\n    // wait until the transaction is mined\n    await setGreetingTx.wait();\n\n    expect(await greeter.greet()).to.equal(\"Hola, mundo!\");\n  });\n});\n```\n\n\n### 7. 运行测试\n\n使用以下命令运行测试：\n\n```Shell\nnpx hardhat test\n```\n\n\n### 8. 部署合约\n\n在 `scripts/` 目录中编写部署脚本。例如，创建一个 `deploy.js` 文件：\n\n```JavaScript\nasync function main() {\n  const Greeter = await ethers.getContractFactory(\"Greeter\");\n  const greeter = await Greeter.deploy(\"Hello, Hardhat!\");\n\n  await greeter.deployed();\n\n  console.log(\"Greeter deployed to:\", greeter.address);\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\n```\n\n\n然后使用以下命令部署合约：\n\n```Shell\nnpx hardhat run scripts/deploy.js\n```\n\n\n### 9. 配置网络\n\n在 `hardhat.config.js` 中配置网络。例如，配置本地网络和以太坊测试网络：\n\n```JavaScript\nrequire(\"@nomiclabs/hardhat-waffle\");\n\nmodule.exports = {\n  solidity: \"0.8.4\",\n  networks: {\n    localhost: {\n      url: \"http://127.0.0.1:8545\"\n    },\n    ropsten: {\n      url: `https://ropsten.infura.io/v3/YOUR_INFURA_PROJECT_ID`,\n      accounts: [`0x${YOUR_PRIVATE_KEY}`]\n    }\n  }\n};\n```\n\n\n### 10. 使用插件\n\nHardhat 支持许多插件，例如：\n\n- `@nomiclabs/hardhat-ethers`：用于与以太坊交互。\n\n- `@nomiclabs/hardhat-waffle`：用于测试。\n\n- `hardhat-gas-reporter`：用于报告 Gas 使用情况。\n\n可以通过 npm 安装这些插件，并在 `hardhat.config.js` 中配置。\n\n### 11. 其他命令\n\n- `npx hardhat clean`：清理编译缓存。\n\n- `npx hardhat node`：启动本地以太坊节点。\n\n- `npx hardhat console`：启动 Hardhat 控制台。\n\n\n\n\n\nHardhat 的强大之处在于其丰富的插件生态系统，这些插件可以帮助开发者更高效地进行智能合约开发、测试和部署。以下是一些常用的 Hardhat 插件及其功能：\n\n---\n\n### 1. **@nomiclabs/hardhat-ethers**\n\n- **功能**: 集成 `ethers.js` 库，用于与以太坊网络交互。\n\n- **用途**: 部署合约、发送交易、调用合约方法等。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomiclabs/hardhat-ethers ethers\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomiclabs/hardhat-ethers\");\n```\n\n\n---\n\n### 2. **@nomiclabs/hardhat-waffle**\n\n- **功能**: 集成 `Waffle` 测试框架，用于编写和运行智能合约测试。\n\n- **用途**: 提供 Chai 匹配器和工具，方便测试智能合约。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomiclabs/hardhat-waffle ethereum-waffle chai\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomiclabs/hardhat-waffle\");\n```\n\n\n---\n\n### 3. **hardhat-deploy**\n\n- **功能**: 提供更强大的合约部署功能，支持命名部署、依赖管理和部署脚本的组织。\n\n- **用途**: 管理复杂的部署流程，支持多网络部署。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-deploy\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-deploy\");\n```\n\n\n---\n\n### 4. **hardhat-gas-reporter**\n\n- **功能**: 在运行测试时报告 Gas 使用情况。\n\n- **用途**: 优化合约的 Gas 消耗。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-gas-reporter\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-gas-reporter\");\nmodule.exports = {\n  gasReporter: {\n    currency: 'USD', // 设置货币单位\n    gasPrice: 21,    // 设置 Gas 价格\n  },\n};\n```\n\n\n---\n\n### 5. **solidity-coverage**\n\n- **功能**: 生成智能合约的代码覆盖率报告。\n\n- **用途**: 确保测试覆盖了合约的所有代码路径。\n\n- **安装**:\n\n  ```Shell\nnpm install solidity-coverage\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"solidity-coverage\");\n```\n\n\n- **使用**:\n运行以下命令生成覆盖率报告：\n\n  ```Shell\nnpx hardhat coverage\n```\n\n\n---\n\n### 6. **@nomicfoundation/hardhat-toolbox**\n\n- **功能**: 集成了多个常用插件（如 `hardhat-ethers`、`hardhat-waffle`、`hardhat-gas-reporter` 等）。\n\n- **用途**: 快速启动项目，避免手动安装多个插件。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomicfoundation/hardhat-toolbox\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomicfoundation/hardhat-toolbox\");\n```\n\n\n---\n\n### 7. **hardhat-etherscan**\n\n- **功能**: 用于验证合约源码并发布到 Etherscan。\n\n- **用途**: 在 Etherscan 上公开合约源码，方便用户查看和验证。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomiclabs/hardhat-etherscan\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomiclabs/hardhat-etherscan\");\nmodule.exports = {\n  etherscan: {\n    apiKey: \"YOUR_ETHERSCAN_API_KEY\", // 替换为你的 Etherscan API Key\n  },\n};\n```\n\n\n- **使用**:\n运行以下命令验证合约：\n\n  ```Shell\nnpx hardhat verify --network <network_name> <contract_address> <constructor_args>\n```\n\n\n---\n\n### 8. **hardhat-abi-exporter**\n\n- **功能**: 自动导出合约的 ABI 到指定目录。\n\n- **用途**: 方便前端或其他应用使用合约的 ABI。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-abi-exporter\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-abi-exporter\");\nmodule.exports = {\n  abiExporter: {\n    path: './abi', // 导出目录\n    clear: true,   // 每次编译前清空目录\n  },\n};\n```\n\n\n---\n\n### 9. **hardhat-contract-sizer**\n\n- **功能**: 分析合约的字节码大小。\n\n- **用途**: 确保合约不超过以太坊的字节码大小限制。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-contract-sizer\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-contract-sizer\");\n```\n\n\n---\n\n### 10. **hardhat-ignition**\n\n- **功能**: 提供更高级的部署管理功能，支持模块化部署。\n\n- **用途**: 管理复杂的部署流程，支持依赖关系和条件部署。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-ignition\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-ignition\");\n```\n\n\n---\n\n### 11. **hardhat-typechain**\n\n- **功能**: 自动生成 TypeScript 类型定义文件。\n\n- **用途**: 在 TypeScript 项目中提供类型安全的合约交互。\n\n- **安装**:\n\n  ```Shell\nnpm install @typechain/hardhat typechain @typechain/ethers-v5\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@typechain/hardhat\");\nmodule.exports = {\n  typechain: {\n    outDir: 'typechain', // 类型定义文件输出目录\n    target: 'ethers-v5', // 目标框架\n  },\n};\n```\n\n\n---\n\n### 12. **hardhat-storage-layout**\n\n- **功能**: 导出合约的存储布局信息。\n\n- **用途**: 分析合约的存储结构，方便升级和调试。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-storage-layout\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-storage-layout\");\n```\n\n\n---\n\n### 13. **hardhat-tracer**\n\n- **功能**: 提供更详细的交易调试信息。\n\n- **用途**: 调试复杂的交易和合约调用。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-tracer\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-tracer\");\n```\n\n\n---\n\n### 14. **hardhat-interface-generator**\n\n- **功能**: 自动生成合约的接口文件。\n\n- **用途**: 方便其他合约或应用与当前合约交互。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-interface-generator\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-interface-generator\");\n```\n\n\n---\n\n","source":"_posts/Hardhat上手指南.md","raw":"---\ntitle: Hardhat上手指南\ndescription: 'Hardhat 是一个用于开发、测试和部署智能合约的开发环境。它提供了强大的工具和插件，帮助开发者更高效地构建以太坊和其他区块链应用'\ntags: ['hardhat', 'web3']\ntoc: false\ndate: 2025-05-04 20:11:14\ncategories:\n---\n\nHardhat 是一个用于开发、测试和部署智能合约的开发环境。它提供了强大的工具和插件，帮助开发者更高效地构建以太坊和其他区块链应用。以下是 Hardhat 的基本使用指南：\n\n### 1. 安装 Hardhat\n\n首先，确保你已经安装了 Node.js 和 npm。然后，可以通过以下命令全局安装 Hardhat：\n\n```Shell\nnpm install -g hardhat\n```\n\n\n或者在项目目录中局部安装：\n\n```Shell\nnpm install --save-dev hardhat\n```\n\n\n### 2. 初始化项目\n\n在项目目录中运行以下命令来初始化一个新的 Hardhat 项目：\n\n```Shell\nnpx hardhat\n```\n\n\n这将启动一个交互式命令行界面，你可以选择创建一个新的 Hardhat 项目或使用示例项目。\n\n### 3. 项目结构\n\n初始化后，项目目录结构通常如下：\n\n```Plain Text\nmy-project/\n├── contracts/           # 存放智能合约\n├── scripts/             # 存放部署脚本\n├── test/                # 存放测试脚本\n├── hardhat.config.js    # Hardhat 配置文件\n└── package.json         # Node.js 项目配置文件\n```\n\n\n### 4. 编写智能合约\n\n在 `contracts/` 目录中编写你的智能合约。例如，创建一个简单的 `Greeter.sol` 合约：\n\n```Solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Greeter {\n    string private greeting;\n\n    constructor(string memory _greeting) {\n        greeting = _greeting;\n    }\n\n    function greet() public view returns (string memory) {\n        return greeting;\n    }\n\n    function setGreeting(string memory _greeting) public {\n        greeting = _greeting;\n    }\n}\n```\n\n\n### 5. 编译合约\n\n使用以下命令编译合约：\n\n```Shell\nnpx hardhat compile\n```\n\n\n编译后的文件将存储在 `artifacts/` 目录中。\n\n### 6. 编写测试\n\n在 `test/` 目录中编写测试脚本。例如，创建一个 `Greeter.test.js` 文件：\n\n```JavaScript\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"Greeter\", function () {\n  it(\"Should return the new greeting once it's changed\", async function () {\n    const Greeter = await ethers.getContractFactory(\"Greeter\");\n    const greeter = await Greeter.deploy(\"Hello, world!\");\n    await greeter.deployed();\n\n    expect(await greeter.greet()).to.equal(\"Hello, world!\");\n\n    const setGreetingTx = await greeter.setGreeting(\"Hola, mundo!\");\n\n    // wait until the transaction is mined\n    await setGreetingTx.wait();\n\n    expect(await greeter.greet()).to.equal(\"Hola, mundo!\");\n  });\n});\n```\n\n\n### 7. 运行测试\n\n使用以下命令运行测试：\n\n```Shell\nnpx hardhat test\n```\n\n\n### 8. 部署合约\n\n在 `scripts/` 目录中编写部署脚本。例如，创建一个 `deploy.js` 文件：\n\n```JavaScript\nasync function main() {\n  const Greeter = await ethers.getContractFactory(\"Greeter\");\n  const greeter = await Greeter.deploy(\"Hello, Hardhat!\");\n\n  await greeter.deployed();\n\n  console.log(\"Greeter deployed to:\", greeter.address);\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\n```\n\n\n然后使用以下命令部署合约：\n\n```Shell\nnpx hardhat run scripts/deploy.js\n```\n\n\n### 9. 配置网络\n\n在 `hardhat.config.js` 中配置网络。例如，配置本地网络和以太坊测试网络：\n\n```JavaScript\nrequire(\"@nomiclabs/hardhat-waffle\");\n\nmodule.exports = {\n  solidity: \"0.8.4\",\n  networks: {\n    localhost: {\n      url: \"http://127.0.0.1:8545\"\n    },\n    ropsten: {\n      url: `https://ropsten.infura.io/v3/YOUR_INFURA_PROJECT_ID`,\n      accounts: [`0x${YOUR_PRIVATE_KEY}`]\n    }\n  }\n};\n```\n\n\n### 10. 使用插件\n\nHardhat 支持许多插件，例如：\n\n- `@nomiclabs/hardhat-ethers`：用于与以太坊交互。\n\n- `@nomiclabs/hardhat-waffle`：用于测试。\n\n- `hardhat-gas-reporter`：用于报告 Gas 使用情况。\n\n可以通过 npm 安装这些插件，并在 `hardhat.config.js` 中配置。\n\n### 11. 其他命令\n\n- `npx hardhat clean`：清理编译缓存。\n\n- `npx hardhat node`：启动本地以太坊节点。\n\n- `npx hardhat console`：启动 Hardhat 控制台。\n\n\n\n\n\nHardhat 的强大之处在于其丰富的插件生态系统，这些插件可以帮助开发者更高效地进行智能合约开发、测试和部署。以下是一些常用的 Hardhat 插件及其功能：\n\n---\n\n### 1. **@nomiclabs/hardhat-ethers**\n\n- **功能**: 集成 `ethers.js` 库，用于与以太坊网络交互。\n\n- **用途**: 部署合约、发送交易、调用合约方法等。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomiclabs/hardhat-ethers ethers\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomiclabs/hardhat-ethers\");\n```\n\n\n---\n\n### 2. **@nomiclabs/hardhat-waffle**\n\n- **功能**: 集成 `Waffle` 测试框架，用于编写和运行智能合约测试。\n\n- **用途**: 提供 Chai 匹配器和工具，方便测试智能合约。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomiclabs/hardhat-waffle ethereum-waffle chai\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomiclabs/hardhat-waffle\");\n```\n\n\n---\n\n### 3. **hardhat-deploy**\n\n- **功能**: 提供更强大的合约部署功能，支持命名部署、依赖管理和部署脚本的组织。\n\n- **用途**: 管理复杂的部署流程，支持多网络部署。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-deploy\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-deploy\");\n```\n\n\n---\n\n### 4. **hardhat-gas-reporter**\n\n- **功能**: 在运行测试时报告 Gas 使用情况。\n\n- **用途**: 优化合约的 Gas 消耗。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-gas-reporter\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-gas-reporter\");\nmodule.exports = {\n  gasReporter: {\n    currency: 'USD', // 设置货币单位\n    gasPrice: 21,    // 设置 Gas 价格\n  },\n};\n```\n\n\n---\n\n### 5. **solidity-coverage**\n\n- **功能**: 生成智能合约的代码覆盖率报告。\n\n- **用途**: 确保测试覆盖了合约的所有代码路径。\n\n- **安装**:\n\n  ```Shell\nnpm install solidity-coverage\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"solidity-coverage\");\n```\n\n\n- **使用**:\n运行以下命令生成覆盖率报告：\n\n  ```Shell\nnpx hardhat coverage\n```\n\n\n---\n\n### 6. **@nomicfoundation/hardhat-toolbox**\n\n- **功能**: 集成了多个常用插件（如 `hardhat-ethers`、`hardhat-waffle`、`hardhat-gas-reporter` 等）。\n\n- **用途**: 快速启动项目，避免手动安装多个插件。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomicfoundation/hardhat-toolbox\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomicfoundation/hardhat-toolbox\");\n```\n\n\n---\n\n### 7. **hardhat-etherscan**\n\n- **功能**: 用于验证合约源码并发布到 Etherscan。\n\n- **用途**: 在 Etherscan 上公开合约源码，方便用户查看和验证。\n\n- **安装**:\n\n  ```Shell\nnpm install @nomiclabs/hardhat-etherscan\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@nomiclabs/hardhat-etherscan\");\nmodule.exports = {\n  etherscan: {\n    apiKey: \"YOUR_ETHERSCAN_API_KEY\", // 替换为你的 Etherscan API Key\n  },\n};\n```\n\n\n- **使用**:\n运行以下命令验证合约：\n\n  ```Shell\nnpx hardhat verify --network <network_name> <contract_address> <constructor_args>\n```\n\n\n---\n\n### 8. **hardhat-abi-exporter**\n\n- **功能**: 自动导出合约的 ABI 到指定目录。\n\n- **用途**: 方便前端或其他应用使用合约的 ABI。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-abi-exporter\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-abi-exporter\");\nmodule.exports = {\n  abiExporter: {\n    path: './abi', // 导出目录\n    clear: true,   // 每次编译前清空目录\n  },\n};\n```\n\n\n---\n\n### 9. **hardhat-contract-sizer**\n\n- **功能**: 分析合约的字节码大小。\n\n- **用途**: 确保合约不超过以太坊的字节码大小限制。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-contract-sizer\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-contract-sizer\");\n```\n\n\n---\n\n### 10. **hardhat-ignition**\n\n- **功能**: 提供更高级的部署管理功能，支持模块化部署。\n\n- **用途**: 管理复杂的部署流程，支持依赖关系和条件部署。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-ignition\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-ignition\");\n```\n\n\n---\n\n### 11. **hardhat-typechain**\n\n- **功能**: 自动生成 TypeScript 类型定义文件。\n\n- **用途**: 在 TypeScript 项目中提供类型安全的合约交互。\n\n- **安装**:\n\n  ```Shell\nnpm install @typechain/hardhat typechain @typechain/ethers-v5\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"@typechain/hardhat\");\nmodule.exports = {\n  typechain: {\n    outDir: 'typechain', // 类型定义文件输出目录\n    target: 'ethers-v5', // 目标框架\n  },\n};\n```\n\n\n---\n\n### 12. **hardhat-storage-layout**\n\n- **功能**: 导出合约的存储布局信息。\n\n- **用途**: 分析合约的存储结构，方便升级和调试。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-storage-layout\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-storage-layout\");\n```\n\n\n---\n\n### 13. **hardhat-tracer**\n\n- **功能**: 提供更详细的交易调试信息。\n\n- **用途**: 调试复杂的交易和合约调用。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-tracer\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-tracer\");\n```\n\n\n---\n\n### 14. **hardhat-interface-generator**\n\n- **功能**: 自动生成合约的接口文件。\n\n- **用途**: 方便其他合约或应用与当前合约交互。\n\n- **安装**:\n\n  ```Shell\nnpm install hardhat-interface-generator\n```\n\n\n- **配置**:\n在 `hardhat.config.js` 中添加：\n\n  ```JavaScript\nrequire(\"hardhat-interface-generator\");\n```\n\n\n---\n\n","slug":"Hardhat上手指南","published":1,"updated":"2025-05-04T12:14:20.879Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8d000dp3j56mvg7iu6","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Hardhat 是一个用于开发、测试和部署智能合约的开发环境。它提供了强大的工具和插件，帮助开发者更高效地构建以太坊和其他区块链应用。以下是 Hardhat 的基本使用指南：</p>\n<h3 id=\"1-安装-Hardhat\"><a href=\"#1-安装-Hardhat\" class=\"headerlink\" title=\"1. 安装 Hardhat\"></a>1. 安装 Hardhat</h3><p>首先，确保你已经安装了 Node.js 和 npm。然后，可以通过以下命令全局安装 Hardhat：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hardhat</span><br></pre></td></tr></table></figure>\n\n\n<p>或者在项目目录中局部安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2. 初始化项目\"></a>2. 初始化项目</h3><p>在项目目录中运行以下命令来初始化一个新的 Hardhat 项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat</span><br></pre></td></tr></table></figure>\n\n\n<p>这将启动一个交互式命令行界面，你可以选择创建一个新的 Hardhat 项目或使用示例项目。</p>\n<h3 id=\"3-项目结构\"><a href=\"#3-项目结构\" class=\"headerlink\" title=\"3. 项目结构\"></a>3. 项目结构</h3><p>初始化后，项目目录结构通常如下：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-project/</span><br><span class=\"line\">├── contracts/           # 存放智能合约</span><br><span class=\"line\">├── scripts/             # 存放部署脚本</span><br><span class=\"line\">├── test/                # 存放测试脚本</span><br><span class=\"line\">├── hardhat.config.js    # Hardhat 配置文件</span><br><span class=\"line\">└── package.json         # Node.js 项目配置文件</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-编写智能合约\"><a href=\"#4-编写智能合约\" class=\"headerlink\" title=\"4. 编写智能合约\"></a>4. 编写智能合约</h3><p>在 <code>contracts/</code> 目录中编写你的智能合约。例如，创建一个简单的 <code>Greeter.sol</code> 合约：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Greeter &#123;</span><br><span class=\"line\">    string private greeting;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(string memory _greeting) &#123;</span><br><span class=\"line\">        greeting = _greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function greet() public view returns (string memory) &#123;</span><br><span class=\"line\">        return greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setGreeting(string memory _greeting) public &#123;</span><br><span class=\"line\">        greeting = _greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-编译合约\"><a href=\"#5-编译合约\" class=\"headerlink\" title=\"5. 编译合约\"></a>5. 编译合约</h3><p>使用以下命令编译合约：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat compile</span><br></pre></td></tr></table></figure>\n\n\n<p>编译后的文件将存储在 <code>artifacts/</code> 目录中。</p>\n<h3 id=\"6-编写测试\"><a href=\"#6-编写测试\" class=\"headerlink\" title=\"6. 编写测试\"></a>6. 编写测试</h3><p>在 <code>test/</code> 目录中编写测试脚本。例如，创建一个 <code>Greeter.test.js</code> 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; expect &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;chai&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; ethers &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&quot;Greeter&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">it</span>(<span class=\"string\">&quot;Should return the new greeting once it&#x27;s changed&quot;</span>, <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title class_\">Greeter</span> = <span class=\"keyword\">await</span> ethers.<span class=\"title function_\">getContractFactory</span>(<span class=\"string\">&quot;Greeter&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> greeter = <span class=\"keyword\">await</span> <span class=\"title class_\">Greeter</span>.<span class=\"title function_\">deploy</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> greeter.<span class=\"title function_\">deployed</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">expect</span>(<span class=\"keyword\">await</span> greeter.<span class=\"title function_\">greet</span>()).<span class=\"property\">to</span>.<span class=\"title function_\">equal</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> setGreetingTx = <span class=\"keyword\">await</span> greeter.<span class=\"title function_\">setGreeting</span>(<span class=\"string\">&quot;Hola, mundo!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// wait until the transaction is mined</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> setGreetingTx.<span class=\"title function_\">wait</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">expect</span>(<span class=\"keyword\">await</span> greeter.<span class=\"title function_\">greet</span>()).<span class=\"property\">to</span>.<span class=\"title function_\">equal</span>(<span class=\"string\">&quot;Hola, mundo!&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-运行测试\"><a href=\"#7-运行测试\" class=\"headerlink\" title=\"7. 运行测试\"></a>7. 运行测试</h3><p>使用以下命令运行测试：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat test</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"8-部署合约\"><a href=\"#8-部署合约\" class=\"headerlink\" title=\"8. 部署合约\"></a>8. 部署合约</h3><p>在 <code>scripts/</code> 目录中编写部署脚本。例如，创建一个 <code>deploy.js</code> 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title class_\">Greeter</span> = <span class=\"keyword\">await</span> ethers.<span class=\"title function_\">getContractFactory</span>(<span class=\"string\">&quot;Greeter&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> greeter = <span class=\"keyword\">await</span> <span class=\"title class_\">Greeter</span>.<span class=\"title function_\">deploy</span>(<span class=\"string\">&quot;Hello, Hardhat!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">await</span> greeter.<span class=\"title function_\">deployed</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Greeter deployed to:&quot;</span>, greeter.<span class=\"property\">address</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">main</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> process.<span class=\"title function_\">exit</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error);</span><br><span class=\"line\">    process.<span class=\"title function_\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>然后使用以下命令部署合约：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat run scripts/deploy.js</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"9-配置网络\"><a href=\"#9-配置网络\" class=\"headerlink\" title=\"9. 配置网络\"></a>9. 配置网络</h3><p>在 <code>hardhat.config.js</code> 中配置网络。例如，配置本地网络和以太坊测试网络：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-waffle&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">solidity</span>: <span class=\"string\">&quot;0.8.4&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">networks</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">localhost</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;http://127.0.0.1:8545&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">ropsten</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">`https://ropsten.infura.io/v3/YOUR_INFURA_PROJECT_ID`</span>,</span><br><span class=\"line\">      <span class=\"attr\">accounts</span>: [<span class=\"string\">`0x<span class=\"subst\">$&#123;YOUR_PRIVATE_KEY&#125;</span>`</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"10-使用插件\"><a href=\"#10-使用插件\" class=\"headerlink\" title=\"10. 使用插件\"></a>10. 使用插件</h3><p>Hardhat 支持许多插件，例如：</p>\n<ul>\n<li><p><code>@nomiclabs/hardhat-ethers</code>：用于与以太坊交互。</p>\n</li>\n<li><p><code>@nomiclabs/hardhat-waffle</code>：用于测试。</p>\n</li>\n<li><p><code>hardhat-gas-reporter</code>：用于报告 Gas 使用情况。</p>\n</li>\n</ul>\n<p>可以通过 npm 安装这些插件，并在 <code>hardhat.config.js</code> 中配置。</p>\n<h3 id=\"11-其他命令\"><a href=\"#11-其他命令\" class=\"headerlink\" title=\"11. 其他命令\"></a>11. 其他命令</h3><ul>\n<li><p><code>npx hardhat clean</code>：清理编译缓存。</p>\n</li>\n<li><p><code>npx hardhat node</code>：启动本地以太坊节点。</p>\n</li>\n<li><p><code>npx hardhat console</code>：启动 Hardhat 控制台。</p>\n</li>\n</ul>\n<p>Hardhat 的强大之处在于其丰富的插件生态系统，这些插件可以帮助开发者更高效地进行智能合约开发、测试和部署。以下是一些常用的 Hardhat 插件及其功能：</p>\n<hr>\n<h3 id=\"1-nomiclabs-hardhat-ethers\"><a href=\"#1-nomiclabs-hardhat-ethers\" class=\"headerlink\" title=\"1. @nomiclabs&#x2F;hardhat-ethers\"></a>1. <strong>@nomiclabs&#x2F;hardhat-ethers</strong></h3><ul>\n<li><p><strong>功能</strong>: 集成 <code>ethers.js</code> 库，用于与以太坊网络交互。</p>\n</li>\n<li><p><strong>用途</strong>: 部署合约、发送交易、调用合约方法等。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomiclabs/hardhat-ethers ethers</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-ethers&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"2-nomiclabs-hardhat-waffle\"><a href=\"#2-nomiclabs-hardhat-waffle\" class=\"headerlink\" title=\"2. @nomiclabs&#x2F;hardhat-waffle\"></a>2. <strong>@nomiclabs&#x2F;hardhat-waffle</strong></h3><ul>\n<li><p><strong>功能</strong>: 集成 <code>Waffle</code> 测试框架，用于编写和运行智能合约测试。</p>\n</li>\n<li><p><strong>用途</strong>: 提供 Chai 匹配器和工具，方便测试智能合约。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomiclabs/hardhat-waffle ethereum-waffle chai</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-waffle&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"3-hardhat-deploy\"><a href=\"#3-hardhat-deploy\" class=\"headerlink\" title=\"3. hardhat-deploy\"></a>3. <strong>hardhat-deploy</strong></h3><ul>\n<li><p><strong>功能</strong>: 提供更强大的合约部署功能，支持命名部署、依赖管理和部署脚本的组织。</p>\n</li>\n<li><p><strong>用途</strong>: 管理复杂的部署流程，支持多网络部署。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-deploy</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-deploy&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"4-hardhat-gas-reporter\"><a href=\"#4-hardhat-gas-reporter\" class=\"headerlink\" title=\"4. hardhat-gas-reporter\"></a>4. <strong>hardhat-gas-reporter</strong></h3><ul>\n<li><p><strong>功能</strong>: 在运行测试时报告 Gas 使用情况。</p>\n</li>\n<li><p><strong>用途</strong>: 优化合约的 Gas 消耗。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-gas-reporter</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-gas-reporter&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">gasReporter</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">currency</span>: <span class=\"string\">&#x27;USD&#x27;</span>, <span class=\"comment\">// 设置货币单位</span></span><br><span class=\"line\">    <span class=\"attr\">gasPrice</span>: <span class=\"number\">21</span>,    <span class=\"comment\">// 设置 Gas 价格</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"5-solidity-coverage\"><a href=\"#5-solidity-coverage\" class=\"headerlink\" title=\"5. solidity-coverage\"></a>5. <strong>solidity-coverage</strong></h3><ul>\n<li><p><strong>功能</strong>: 生成智能合约的代码覆盖率报告。</p>\n</li>\n<li><p><strong>用途</strong>: 确保测试覆盖了合约的所有代码路径。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install solidity-coverage</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;solidity-coverage&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>使用</strong>:<br>运行以下命令生成覆盖率报告：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat coverage</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"6-nomicfoundation-hardhat-toolbox\"><a href=\"#6-nomicfoundation-hardhat-toolbox\" class=\"headerlink\" title=\"6. @nomicfoundation&#x2F;hardhat-toolbox\"></a>6. <strong>@nomicfoundation&#x2F;hardhat-toolbox</strong></h3><ul>\n<li><p><strong>功能</strong>: 集成了多个常用插件（如 <code>hardhat-ethers</code>、<code>hardhat-waffle</code>、<code>hardhat-gas-reporter</code> 等）。</p>\n</li>\n<li><p><strong>用途</strong>: 快速启动项目，避免手动安装多个插件。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomicfoundation/hardhat-toolbox</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"7-hardhat-etherscan\"><a href=\"#7-hardhat-etherscan\" class=\"headerlink\" title=\"7. hardhat-etherscan\"></a>7. <strong>hardhat-etherscan</strong></h3><ul>\n<li><p><strong>功能</strong>: 用于验证合约源码并发布到 Etherscan。</p>\n</li>\n<li><p><strong>用途</strong>: 在 Etherscan 上公开合约源码，方便用户查看和验证。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomiclabs/hardhat-etherscan</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-etherscan&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">etherscan</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">apiKey</span>: <span class=\"string\">&quot;YOUR_ETHERSCAN_API_KEY&quot;</span>, <span class=\"comment\">// 替换为你的 Etherscan API Key</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>使用</strong>:<br>运行以下命令验证合约：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat verify --network &lt;network_name&gt; &lt;contract_address&gt; &lt;constructor_args&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"8-hardhat-abi-exporter\"><a href=\"#8-hardhat-abi-exporter\" class=\"headerlink\" title=\"8. hardhat-abi-exporter\"></a>8. <strong>hardhat-abi-exporter</strong></h3><ul>\n<li><p><strong>功能</strong>: 自动导出合约的 ABI 到指定目录。</p>\n</li>\n<li><p><strong>用途</strong>: 方便前端或其他应用使用合约的 ABI。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-abi-exporter</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-abi-exporter&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">abiExporter</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&#x27;./abi&#x27;</span>, <span class=\"comment\">// 导出目录</span></span><br><span class=\"line\">    <span class=\"attr\">clear</span>: <span class=\"literal\">true</span>,   <span class=\"comment\">// 每次编译前清空目录</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"9-hardhat-contract-sizer\"><a href=\"#9-hardhat-contract-sizer\" class=\"headerlink\" title=\"9. hardhat-contract-sizer\"></a>9. <strong>hardhat-contract-sizer</strong></h3><ul>\n<li><p><strong>功能</strong>: 分析合约的字节码大小。</p>\n</li>\n<li><p><strong>用途</strong>: 确保合约不超过以太坊的字节码大小限制。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-contract-sizer</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-contract-sizer&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"10-hardhat-ignition\"><a href=\"#10-hardhat-ignition\" class=\"headerlink\" title=\"10. hardhat-ignition\"></a>10. <strong>hardhat-ignition</strong></h3><ul>\n<li><p><strong>功能</strong>: 提供更高级的部署管理功能，支持模块化部署。</p>\n</li>\n<li><p><strong>用途</strong>: 管理复杂的部署流程，支持依赖关系和条件部署。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-ignition</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-ignition&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"11-hardhat-typechain\"><a href=\"#11-hardhat-typechain\" class=\"headerlink\" title=\"11. hardhat-typechain\"></a>11. <strong>hardhat-typechain</strong></h3><ul>\n<li><p><strong>功能</strong>: 自动生成 TypeScript 类型定义文件。</p>\n</li>\n<li><p><strong>用途</strong>: 在 TypeScript 项目中提供类型安全的合约交互。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @typechain/hardhat typechain @typechain/ethers-v5</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@typechain/hardhat&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">typechain</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">outDir</span>: <span class=\"string\">&#x27;typechain&#x27;</span>, <span class=\"comment\">// 类型定义文件输出目录</span></span><br><span class=\"line\">    <span class=\"attr\">target</span>: <span class=\"string\">&#x27;ethers-v5&#x27;</span>, <span class=\"comment\">// 目标框架</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"12-hardhat-storage-layout\"><a href=\"#12-hardhat-storage-layout\" class=\"headerlink\" title=\"12. hardhat-storage-layout\"></a>12. <strong>hardhat-storage-layout</strong></h3><ul>\n<li><p><strong>功能</strong>: 导出合约的存储布局信息。</p>\n</li>\n<li><p><strong>用途</strong>: 分析合约的存储结构，方便升级和调试。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-storage-layout</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-storage-layout&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"13-hardhat-tracer\"><a href=\"#13-hardhat-tracer\" class=\"headerlink\" title=\"13. hardhat-tracer\"></a>13. <strong>hardhat-tracer</strong></h3><ul>\n<li><p><strong>功能</strong>: 提供更详细的交易调试信息。</p>\n</li>\n<li><p><strong>用途</strong>: 调试复杂的交易和合约调用。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-tracer</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-tracer&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"14-hardhat-interface-generator\"><a href=\"#14-hardhat-interface-generator\" class=\"headerlink\" title=\"14. hardhat-interface-generator\"></a>14. <strong>hardhat-interface-generator</strong></h3><ul>\n<li><p><strong>功能</strong>: 自动生成合约的接口文件。</p>\n</li>\n<li><p><strong>用途</strong>: 方便其他合约或应用与当前合约交互。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-interface-generator</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-interface-generator&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n","excerpt":"","more":"<p>Hardhat 是一个用于开发、测试和部署智能合约的开发环境。它提供了强大的工具和插件，帮助开发者更高效地构建以太坊和其他区块链应用。以下是 Hardhat 的基本使用指南：</p>\n<h3 id=\"1-安装-Hardhat\"><a href=\"#1-安装-Hardhat\" class=\"headerlink\" title=\"1. 安装 Hardhat\"></a>1. 安装 Hardhat</h3><p>首先，确保你已经安装了 Node.js 和 npm。然后，可以通过以下命令全局安装 Hardhat：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hardhat</span><br></pre></td></tr></table></figure>\n\n\n<p>或者在项目目录中局部安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2. 初始化项目\"></a>2. 初始化项目</h3><p>在项目目录中运行以下命令来初始化一个新的 Hardhat 项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat</span><br></pre></td></tr></table></figure>\n\n\n<p>这将启动一个交互式命令行界面，你可以选择创建一个新的 Hardhat 项目或使用示例项目。</p>\n<h3 id=\"3-项目结构\"><a href=\"#3-项目结构\" class=\"headerlink\" title=\"3. 项目结构\"></a>3. 项目结构</h3><p>初始化后，项目目录结构通常如下：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-project/</span><br><span class=\"line\">├── contracts/           # 存放智能合约</span><br><span class=\"line\">├── scripts/             # 存放部署脚本</span><br><span class=\"line\">├── test/                # 存放测试脚本</span><br><span class=\"line\">├── hardhat.config.js    # Hardhat 配置文件</span><br><span class=\"line\">└── package.json         # Node.js 项目配置文件</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-编写智能合约\"><a href=\"#4-编写智能合约\" class=\"headerlink\" title=\"4. 编写智能合约\"></a>4. 编写智能合约</h3><p>在 <code>contracts/</code> 目录中编写你的智能合约。例如，创建一个简单的 <code>Greeter.sol</code> 合约：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Greeter &#123;</span><br><span class=\"line\">    string private greeting;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(string memory _greeting) &#123;</span><br><span class=\"line\">        greeting = _greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function greet() public view returns (string memory) &#123;</span><br><span class=\"line\">        return greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setGreeting(string memory _greeting) public &#123;</span><br><span class=\"line\">        greeting = _greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-编译合约\"><a href=\"#5-编译合约\" class=\"headerlink\" title=\"5. 编译合约\"></a>5. 编译合约</h3><p>使用以下命令编译合约：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat compile</span><br></pre></td></tr></table></figure>\n\n\n<p>编译后的文件将存储在 <code>artifacts/</code> 目录中。</p>\n<h3 id=\"6-编写测试\"><a href=\"#6-编写测试\" class=\"headerlink\" title=\"6. 编写测试\"></a>6. 编写测试</h3><p>在 <code>test/</code> 目录中编写测试脚本。例如，创建一个 <code>Greeter.test.js</code> 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; expect &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;chai&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; ethers &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">describe</span>(<span class=\"string\">&quot;Greeter&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">it</span>(<span class=\"string\">&quot;Should return the new greeting once it&#x27;s changed&quot;</span>, <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title class_\">Greeter</span> = <span class=\"keyword\">await</span> ethers.<span class=\"title function_\">getContractFactory</span>(<span class=\"string\">&quot;Greeter&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> greeter = <span class=\"keyword\">await</span> <span class=\"title class_\">Greeter</span>.<span class=\"title function_\">deploy</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> greeter.<span class=\"title function_\">deployed</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">expect</span>(<span class=\"keyword\">await</span> greeter.<span class=\"title function_\">greet</span>()).<span class=\"property\">to</span>.<span class=\"title function_\">equal</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> setGreetingTx = <span class=\"keyword\">await</span> greeter.<span class=\"title function_\">setGreeting</span>(<span class=\"string\">&quot;Hola, mundo!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// wait until the transaction is mined</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> setGreetingTx.<span class=\"title function_\">wait</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">expect</span>(<span class=\"keyword\">await</span> greeter.<span class=\"title function_\">greet</span>()).<span class=\"property\">to</span>.<span class=\"title function_\">equal</span>(<span class=\"string\">&quot;Hola, mundo!&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-运行测试\"><a href=\"#7-运行测试\" class=\"headerlink\" title=\"7. 运行测试\"></a>7. 运行测试</h3><p>使用以下命令运行测试：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat test</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"8-部署合约\"><a href=\"#8-部署合约\" class=\"headerlink\" title=\"8. 部署合约\"></a>8. 部署合约</h3><p>在 <code>scripts/</code> 目录中编写部署脚本。例如，创建一个 <code>deploy.js</code> 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title class_\">Greeter</span> = <span class=\"keyword\">await</span> ethers.<span class=\"title function_\">getContractFactory</span>(<span class=\"string\">&quot;Greeter&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> greeter = <span class=\"keyword\">await</span> <span class=\"title class_\">Greeter</span>.<span class=\"title function_\">deploy</span>(<span class=\"string\">&quot;Hello, Hardhat!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">await</span> greeter.<span class=\"title function_\">deployed</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Greeter deployed to:&quot;</span>, greeter.<span class=\"property\">address</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">main</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> process.<span class=\"title function_\">exit</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error);</span><br><span class=\"line\">    process.<span class=\"title function_\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>然后使用以下命令部署合约：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat run scripts/deploy.js</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"9-配置网络\"><a href=\"#9-配置网络\" class=\"headerlink\" title=\"9. 配置网络\"></a>9. 配置网络</h3><p>在 <code>hardhat.config.js</code> 中配置网络。例如，配置本地网络和以太坊测试网络：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-waffle&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">solidity</span>: <span class=\"string\">&quot;0.8.4&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">networks</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">localhost</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;http://127.0.0.1:8545&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">ropsten</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">`https://ropsten.infura.io/v3/YOUR_INFURA_PROJECT_ID`</span>,</span><br><span class=\"line\">      <span class=\"attr\">accounts</span>: [<span class=\"string\">`0x<span class=\"subst\">$&#123;YOUR_PRIVATE_KEY&#125;</span>`</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"10-使用插件\"><a href=\"#10-使用插件\" class=\"headerlink\" title=\"10. 使用插件\"></a>10. 使用插件</h3><p>Hardhat 支持许多插件，例如：</p>\n<ul>\n<li><p><code>@nomiclabs/hardhat-ethers</code>：用于与以太坊交互。</p>\n</li>\n<li><p><code>@nomiclabs/hardhat-waffle</code>：用于测试。</p>\n</li>\n<li><p><code>hardhat-gas-reporter</code>：用于报告 Gas 使用情况。</p>\n</li>\n</ul>\n<p>可以通过 npm 安装这些插件，并在 <code>hardhat.config.js</code> 中配置。</p>\n<h3 id=\"11-其他命令\"><a href=\"#11-其他命令\" class=\"headerlink\" title=\"11. 其他命令\"></a>11. 其他命令</h3><ul>\n<li><p><code>npx hardhat clean</code>：清理编译缓存。</p>\n</li>\n<li><p><code>npx hardhat node</code>：启动本地以太坊节点。</p>\n</li>\n<li><p><code>npx hardhat console</code>：启动 Hardhat 控制台。</p>\n</li>\n</ul>\n<p>Hardhat 的强大之处在于其丰富的插件生态系统，这些插件可以帮助开发者更高效地进行智能合约开发、测试和部署。以下是一些常用的 Hardhat 插件及其功能：</p>\n<hr>\n<h3 id=\"1-nomiclabs-hardhat-ethers\"><a href=\"#1-nomiclabs-hardhat-ethers\" class=\"headerlink\" title=\"1. @nomiclabs&#x2F;hardhat-ethers\"></a>1. <strong>@nomiclabs&#x2F;hardhat-ethers</strong></h3><ul>\n<li><p><strong>功能</strong>: 集成 <code>ethers.js</code> 库，用于与以太坊网络交互。</p>\n</li>\n<li><p><strong>用途</strong>: 部署合约、发送交易、调用合约方法等。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomiclabs/hardhat-ethers ethers</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-ethers&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"2-nomiclabs-hardhat-waffle\"><a href=\"#2-nomiclabs-hardhat-waffle\" class=\"headerlink\" title=\"2. @nomiclabs&#x2F;hardhat-waffle\"></a>2. <strong>@nomiclabs&#x2F;hardhat-waffle</strong></h3><ul>\n<li><p><strong>功能</strong>: 集成 <code>Waffle</code> 测试框架，用于编写和运行智能合约测试。</p>\n</li>\n<li><p><strong>用途</strong>: 提供 Chai 匹配器和工具，方便测试智能合约。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomiclabs/hardhat-waffle ethereum-waffle chai</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-waffle&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"3-hardhat-deploy\"><a href=\"#3-hardhat-deploy\" class=\"headerlink\" title=\"3. hardhat-deploy\"></a>3. <strong>hardhat-deploy</strong></h3><ul>\n<li><p><strong>功能</strong>: 提供更强大的合约部署功能，支持命名部署、依赖管理和部署脚本的组织。</p>\n</li>\n<li><p><strong>用途</strong>: 管理复杂的部署流程，支持多网络部署。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-deploy</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-deploy&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"4-hardhat-gas-reporter\"><a href=\"#4-hardhat-gas-reporter\" class=\"headerlink\" title=\"4. hardhat-gas-reporter\"></a>4. <strong>hardhat-gas-reporter</strong></h3><ul>\n<li><p><strong>功能</strong>: 在运行测试时报告 Gas 使用情况。</p>\n</li>\n<li><p><strong>用途</strong>: 优化合约的 Gas 消耗。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-gas-reporter</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-gas-reporter&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">gasReporter</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">currency</span>: <span class=\"string\">&#x27;USD&#x27;</span>, <span class=\"comment\">// 设置货币单位</span></span><br><span class=\"line\">    <span class=\"attr\">gasPrice</span>: <span class=\"number\">21</span>,    <span class=\"comment\">// 设置 Gas 价格</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"5-solidity-coverage\"><a href=\"#5-solidity-coverage\" class=\"headerlink\" title=\"5. solidity-coverage\"></a>5. <strong>solidity-coverage</strong></h3><ul>\n<li><p><strong>功能</strong>: 生成智能合约的代码覆盖率报告。</p>\n</li>\n<li><p><strong>用途</strong>: 确保测试覆盖了合约的所有代码路径。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install solidity-coverage</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;solidity-coverage&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>使用</strong>:<br>运行以下命令生成覆盖率报告：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat coverage</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"6-nomicfoundation-hardhat-toolbox\"><a href=\"#6-nomicfoundation-hardhat-toolbox\" class=\"headerlink\" title=\"6. @nomicfoundation&#x2F;hardhat-toolbox\"></a>6. <strong>@nomicfoundation&#x2F;hardhat-toolbox</strong></h3><ul>\n<li><p><strong>功能</strong>: 集成了多个常用插件（如 <code>hardhat-ethers</code>、<code>hardhat-waffle</code>、<code>hardhat-gas-reporter</code> 等）。</p>\n</li>\n<li><p><strong>用途</strong>: 快速启动项目，避免手动安装多个插件。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomicfoundation/hardhat-toolbox</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"7-hardhat-etherscan\"><a href=\"#7-hardhat-etherscan\" class=\"headerlink\" title=\"7. hardhat-etherscan\"></a>7. <strong>hardhat-etherscan</strong></h3><ul>\n<li><p><strong>功能</strong>: 用于验证合约源码并发布到 Etherscan。</p>\n</li>\n<li><p><strong>用途</strong>: 在 Etherscan 上公开合约源码，方便用户查看和验证。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nomiclabs/hardhat-etherscan</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@nomiclabs/hardhat-etherscan&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">etherscan</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">apiKey</span>: <span class=\"string\">&quot;YOUR_ETHERSCAN_API_KEY&quot;</span>, <span class=\"comment\">// 替换为你的 Etherscan API Key</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>使用</strong>:<br>运行以下命令验证合约：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hardhat verify --network &lt;network_name&gt; &lt;contract_address&gt; &lt;constructor_args&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"8-hardhat-abi-exporter\"><a href=\"#8-hardhat-abi-exporter\" class=\"headerlink\" title=\"8. hardhat-abi-exporter\"></a>8. <strong>hardhat-abi-exporter</strong></h3><ul>\n<li><p><strong>功能</strong>: 自动导出合约的 ABI 到指定目录。</p>\n</li>\n<li><p><strong>用途</strong>: 方便前端或其他应用使用合约的 ABI。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-abi-exporter</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-abi-exporter&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">abiExporter</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&#x27;./abi&#x27;</span>, <span class=\"comment\">// 导出目录</span></span><br><span class=\"line\">    <span class=\"attr\">clear</span>: <span class=\"literal\">true</span>,   <span class=\"comment\">// 每次编译前清空目录</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"9-hardhat-contract-sizer\"><a href=\"#9-hardhat-contract-sizer\" class=\"headerlink\" title=\"9. hardhat-contract-sizer\"></a>9. <strong>hardhat-contract-sizer</strong></h3><ul>\n<li><p><strong>功能</strong>: 分析合约的字节码大小。</p>\n</li>\n<li><p><strong>用途</strong>: 确保合约不超过以太坊的字节码大小限制。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-contract-sizer</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-contract-sizer&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"10-hardhat-ignition\"><a href=\"#10-hardhat-ignition\" class=\"headerlink\" title=\"10. hardhat-ignition\"></a>10. <strong>hardhat-ignition</strong></h3><ul>\n<li><p><strong>功能</strong>: 提供更高级的部署管理功能，支持模块化部署。</p>\n</li>\n<li><p><strong>用途</strong>: 管理复杂的部署流程，支持依赖关系和条件部署。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-ignition</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-ignition&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"11-hardhat-typechain\"><a href=\"#11-hardhat-typechain\" class=\"headerlink\" title=\"11. hardhat-typechain\"></a>11. <strong>hardhat-typechain</strong></h3><ul>\n<li><p><strong>功能</strong>: 自动生成 TypeScript 类型定义文件。</p>\n</li>\n<li><p><strong>用途</strong>: 在 TypeScript 项目中提供类型安全的合约交互。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @typechain/hardhat typechain @typechain/ethers-v5</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;@typechain/hardhat&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">typechain</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">outDir</span>: <span class=\"string\">&#x27;typechain&#x27;</span>, <span class=\"comment\">// 类型定义文件输出目录</span></span><br><span class=\"line\">    <span class=\"attr\">target</span>: <span class=\"string\">&#x27;ethers-v5&#x27;</span>, <span class=\"comment\">// 目标框架</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"12-hardhat-storage-layout\"><a href=\"#12-hardhat-storage-layout\" class=\"headerlink\" title=\"12. hardhat-storage-layout\"></a>12. <strong>hardhat-storage-layout</strong></h3><ul>\n<li><p><strong>功能</strong>: 导出合约的存储布局信息。</p>\n</li>\n<li><p><strong>用途</strong>: 分析合约的存储结构，方便升级和调试。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-storage-layout</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-storage-layout&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"13-hardhat-tracer\"><a href=\"#13-hardhat-tracer\" class=\"headerlink\" title=\"13. hardhat-tracer\"></a>13. <strong>hardhat-tracer</strong></h3><ul>\n<li><p><strong>功能</strong>: 提供更详细的交易调试信息。</p>\n</li>\n<li><p><strong>用途</strong>: 调试复杂的交易和合约调用。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-tracer</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-tracer&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"14-hardhat-interface-generator\"><a href=\"#14-hardhat-interface-generator\" class=\"headerlink\" title=\"14. hardhat-interface-generator\"></a>14. <strong>hardhat-interface-generator</strong></h3><ul>\n<li><p><strong>功能</strong>: 自动生成合约的接口文件。</p>\n</li>\n<li><p><strong>用途</strong>: 方便其他合约或应用与当前合约交互。</p>\n</li>\n<li><p><strong>安装</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hardhat-interface-generator</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p><strong>配置</strong>:<br>在 <code>hardhat.config.js</code> 中添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&quot;hardhat-interface-generator&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n"},{"title":"JSXorJS","description":"小白疑惑：React项目中文件扩展名的选择，JSX还是JS？","toc":false,"date":"2025-05-04T09:07:58.000Z","_content":"在React项目中，文件扩展名通常使用 `.js` 或 `.jsx`，选择其中一个主要取决于以下几个因素：\n\n---\n\n### 1. **语法区别**\n\n- `.jsx` 文件通常用于包含 **JSX 语法**（即类似 HTML 的语法，用于描述 UI 结构）。\n\n- `.js` 文件可以包含普通的 JavaScript 代码，通常用于逻辑、数据处理、工具函数等，不一定涉及 JSX 代码。\n\n**示例：**\n\n**`App.jsx`（包含JSX的组件）**\n\n```Shell\nfunction App() {\n  return <h1>Hello, React!</h1>;\n}\n\nexport default App;\n```\n\n\n**`utils.js`（普通JS代码，无JSX）**\n\n```JavaScript\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n\n---\n\n### 2. **社区惯例**\n\n在早期，React 社区通常使用 `.jsx` 作为包含 JSX 语法的文件，以便区分哪些文件使用了 JSX。但随着现代 JavaScript 生态（比如 Webpack、Babel 等工具）普遍支持 JSX 解析，许多开发者认为 `.jsx` 变得不那么必要，直接使用 `.js` 也可以处理 JSX 代码。\n\n**实际情况：**\n\n- 有些团队或个人仍然喜欢用 `.jsx` 以明确文件用途。\n\n- 但大部分现代 React 项目（如 Create React App、Next.js）默认使用 `.js`，因为 Babel 已自动处理 JSX 语法，无需显式区分。\n\n---\n\n### 3. **工具链支持**\n\n如果你使用的工具链（如 ESLint、Prettier、Babel）对 `.jsx` 有特殊的 lint 规则或格式化方式，可能更适合使用 `.jsx`。否则，`.js` 足够满足需求。\n\n---\n\n### 4. **团队一致性**\n\n- 在团队协作中，统一使用 `.js` 或 `.jsx` 有助于提高代码一致性，减少认知负担。\n\n- 一些团队更倾向于将逻辑分离：\n\n  - 逻辑处理（无 JSX）使用 `.js`\n\n  - 组件（有 JSX）使用 `.jsx`\n\n---\n\n### 5. **Next.js 的惯例**\n\nNext.js 官方建议直接使用 `.js` 或 `.ts`，因为它的编译工具默认支持 JSX 解析。因此，在 Next.js 项目中，通常不会使用 `.jsx` 扩展名。\n\n---\n\n### **总结：何时使用哪种？**\n\n|文件类型|适用扩展名|推荐实践|\n|-|-|-|\n|纯 JavaScript 逻辑|`.js`|✅|\n|React 组件 (JSX)|`.jsx` 或 `.js`|随项目规范选择|\n|TypeScript 文件|`.ts` 或 `.tsx`|✅|\n\n如果你喜欢明确区分组件，使用 `.jsx`。如果你想保持简单，直接用 `.js` 也是完全可以的。\n\n---\n\n如果你是一个人开发或团队没有特别规定，推荐统一使用 `.js` 以减少额外的区分工作。\n\n\n\n","source":"_posts/JSXorJS.md","raw":"---\ntitle: JSXorJS\ndescription: '小白疑惑：React项目中文件扩展名的选择，JSX还是JS？'\ntags: [js]\ntoc: false\ndate: 2025-05-04 17:07:58\ncategories:\n---\n在React项目中，文件扩展名通常使用 `.js` 或 `.jsx`，选择其中一个主要取决于以下几个因素：\n\n---\n\n### 1. **语法区别**\n\n- `.jsx` 文件通常用于包含 **JSX 语法**（即类似 HTML 的语法，用于描述 UI 结构）。\n\n- `.js` 文件可以包含普通的 JavaScript 代码，通常用于逻辑、数据处理、工具函数等，不一定涉及 JSX 代码。\n\n**示例：**\n\n**`App.jsx`（包含JSX的组件）**\n\n```Shell\nfunction App() {\n  return <h1>Hello, React!</h1>;\n}\n\nexport default App;\n```\n\n\n**`utils.js`（普通JS代码，无JSX）**\n\n```JavaScript\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n\n---\n\n### 2. **社区惯例**\n\n在早期，React 社区通常使用 `.jsx` 作为包含 JSX 语法的文件，以便区分哪些文件使用了 JSX。但随着现代 JavaScript 生态（比如 Webpack、Babel 等工具）普遍支持 JSX 解析，许多开发者认为 `.jsx` 变得不那么必要，直接使用 `.js` 也可以处理 JSX 代码。\n\n**实际情况：**\n\n- 有些团队或个人仍然喜欢用 `.jsx` 以明确文件用途。\n\n- 但大部分现代 React 项目（如 Create React App、Next.js）默认使用 `.js`，因为 Babel 已自动处理 JSX 语法，无需显式区分。\n\n---\n\n### 3. **工具链支持**\n\n如果你使用的工具链（如 ESLint、Prettier、Babel）对 `.jsx` 有特殊的 lint 规则或格式化方式，可能更适合使用 `.jsx`。否则，`.js` 足够满足需求。\n\n---\n\n### 4. **团队一致性**\n\n- 在团队协作中，统一使用 `.js` 或 `.jsx` 有助于提高代码一致性，减少认知负担。\n\n- 一些团队更倾向于将逻辑分离：\n\n  - 逻辑处理（无 JSX）使用 `.js`\n\n  - 组件（有 JSX）使用 `.jsx`\n\n---\n\n### 5. **Next.js 的惯例**\n\nNext.js 官方建议直接使用 `.js` 或 `.ts`，因为它的编译工具默认支持 JSX 解析。因此，在 Next.js 项目中，通常不会使用 `.jsx` 扩展名。\n\n---\n\n### **总结：何时使用哪种？**\n\n|文件类型|适用扩展名|推荐实践|\n|-|-|-|\n|纯 JavaScript 逻辑|`.js`|✅|\n|React 组件 (JSX)|`.jsx` 或 `.js`|随项目规范选择|\n|TypeScript 文件|`.ts` 或 `.tsx`|✅|\n\n如果你喜欢明确区分组件，使用 `.jsx`。如果你想保持简单，直接用 `.js` 也是完全可以的。\n\n---\n\n如果你是一个人开发或团队没有特别规定，推荐统一使用 `.js` 以减少额外的区分工作。\n\n\n\n","slug":"JSXorJS","published":1,"updated":"2025-05-04T12:09:13.331Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8d000ep3j5hd4uc4l1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>在React项目中，文件扩展名通常使用 <code>.js</code> 或 <code>.jsx</code>，选择其中一个主要取决于以下几个因素：</p>\n<hr>\n<h3 id=\"1-语法区别\"><a href=\"#1-语法区别\" class=\"headerlink\" title=\"1. 语法区别\"></a>1. <strong>语法区别</strong></h3><ul>\n<li><p><code>.jsx</code> 文件通常用于包含 <strong>JSX 语法</strong>（即类似 HTML 的语法，用于描述 UI 结构）。</p>\n</li>\n<li><p><code>.js</code> 文件可以包含普通的 JavaScript 代码，通常用于逻辑、数据处理、工具函数等，不一定涉及 JSX 代码。</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><strong><code>App.jsx</code>（包含JSX的组件）</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return &lt;h1&gt;Hello, React!&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong><code>utils.js</code>（普通JS代码，无JSX）</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"2-社区惯例\"><a href=\"#2-社区惯例\" class=\"headerlink\" title=\"2. 社区惯例\"></a>2. <strong>社区惯例</strong></h3><p>在早期，React 社区通常使用 <code>.jsx</code> 作为包含 JSX 语法的文件，以便区分哪些文件使用了 JSX。但随着现代 JavaScript 生态（比如 Webpack、Babel 等工具）普遍支持 JSX 解析，许多开发者认为 <code>.jsx</code> 变得不那么必要，直接使用 <code>.js</code> 也可以处理 JSX 代码。</p>\n<p><strong>实际情况：</strong></p>\n<ul>\n<li><p>有些团队或个人仍然喜欢用 <code>.jsx</code> 以明确文件用途。</p>\n</li>\n<li><p>但大部分现代 React 项目（如 Create React App、Next.js）默认使用 <code>.js</code>，因为 Babel 已自动处理 JSX 语法，无需显式区分。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-工具链支持\"><a href=\"#3-工具链支持\" class=\"headerlink\" title=\"3. 工具链支持\"></a>3. <strong>工具链支持</strong></h3><p>如果你使用的工具链（如 ESLint、Prettier、Babel）对 <code>.jsx</code> 有特殊的 lint 规则或格式化方式，可能更适合使用 <code>.jsx</code>。否则，<code>.js</code> 足够满足需求。</p>\n<hr>\n<h3 id=\"4-团队一致性\"><a href=\"#4-团队一致性\" class=\"headerlink\" title=\"4. 团队一致性\"></a>4. <strong>团队一致性</strong></h3><ul>\n<li><p>在团队协作中，统一使用 <code>.js</code> 或 <code>.jsx</code> 有助于提高代码一致性，减少认知负担。</p>\n</li>\n<li><p>一些团队更倾向于将逻辑分离：</p>\n<ul>\n<li><p>逻辑处理（无 JSX）使用 <code>.js</code></p>\n</li>\n<li><p>组件（有 JSX）使用 <code>.jsx</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"5-Next-js-的惯例\"><a href=\"#5-Next-js-的惯例\" class=\"headerlink\" title=\"5. Next.js 的惯例\"></a>5. <strong>Next.js 的惯例</strong></h3><p>Next.js 官方建议直接使用 <code>.js</code> 或 <code>.ts</code>，因为它的编译工具默认支持 JSX 解析。因此，在 Next.js 项目中，通常不会使用 <code>.jsx</code> 扩展名。</p>\n<hr>\n<h3 id=\"总结：何时使用哪种？\"><a href=\"#总结：何时使用哪种？\" class=\"headerlink\" title=\"总结：何时使用哪种？\"></a><strong>总结：何时使用哪种？</strong></h3><table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>适用扩展名</th>\n<th>推荐实践</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>纯 JavaScript 逻辑</td>\n<td><code>.js</code></td>\n<td>✅</td>\n</tr>\n<tr>\n<td>React 组件 (JSX)</td>\n<td><code>.jsx</code> 或 <code>.js</code></td>\n<td>随项目规范选择</td>\n</tr>\n<tr>\n<td>TypeScript 文件</td>\n<td><code>.ts</code> 或 <code>.tsx</code></td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<p>如果你喜欢明确区分组件，使用 <code>.jsx</code>。如果你想保持简单，直接用 <code>.js</code> 也是完全可以的。</p>\n<hr>\n<p>如果你是一个人开发或团队没有特别规定，推荐统一使用 <code>.js</code> 以减少额外的区分工作。</p>\n","excerpt":"","more":"<p>在React项目中，文件扩展名通常使用 <code>.js</code> 或 <code>.jsx</code>，选择其中一个主要取决于以下几个因素：</p>\n<hr>\n<h3 id=\"1-语法区别\"><a href=\"#1-语法区别\" class=\"headerlink\" title=\"1. 语法区别\"></a>1. <strong>语法区别</strong></h3><ul>\n<li><p><code>.jsx</code> 文件通常用于包含 <strong>JSX 语法</strong>（即类似 HTML 的语法，用于描述 UI 结构）。</p>\n</li>\n<li><p><code>.js</code> 文件可以包含普通的 JavaScript 代码，通常用于逻辑、数据处理、工具函数等，不一定涉及 JSX 代码。</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><strong><code>App.jsx</code>（包含JSX的组件）</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return &lt;h1&gt;Hello, React!&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong><code>utils.js</code>（普通JS代码，无JSX）</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"2-社区惯例\"><a href=\"#2-社区惯例\" class=\"headerlink\" title=\"2. 社区惯例\"></a>2. <strong>社区惯例</strong></h3><p>在早期，React 社区通常使用 <code>.jsx</code> 作为包含 JSX 语法的文件，以便区分哪些文件使用了 JSX。但随着现代 JavaScript 生态（比如 Webpack、Babel 等工具）普遍支持 JSX 解析，许多开发者认为 <code>.jsx</code> 变得不那么必要，直接使用 <code>.js</code> 也可以处理 JSX 代码。</p>\n<p><strong>实际情况：</strong></p>\n<ul>\n<li><p>有些团队或个人仍然喜欢用 <code>.jsx</code> 以明确文件用途。</p>\n</li>\n<li><p>但大部分现代 React 项目（如 Create React App、Next.js）默认使用 <code>.js</code>，因为 Babel 已自动处理 JSX 语法，无需显式区分。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-工具链支持\"><a href=\"#3-工具链支持\" class=\"headerlink\" title=\"3. 工具链支持\"></a>3. <strong>工具链支持</strong></h3><p>如果你使用的工具链（如 ESLint、Prettier、Babel）对 <code>.jsx</code> 有特殊的 lint 规则或格式化方式，可能更适合使用 <code>.jsx</code>。否则，<code>.js</code> 足够满足需求。</p>\n<hr>\n<h3 id=\"4-团队一致性\"><a href=\"#4-团队一致性\" class=\"headerlink\" title=\"4. 团队一致性\"></a>4. <strong>团队一致性</strong></h3><ul>\n<li><p>在团队协作中，统一使用 <code>.js</code> 或 <code>.jsx</code> 有助于提高代码一致性，减少认知负担。</p>\n</li>\n<li><p>一些团队更倾向于将逻辑分离：</p>\n<ul>\n<li><p>逻辑处理（无 JSX）使用 <code>.js</code></p>\n</li>\n<li><p>组件（有 JSX）使用 <code>.jsx</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"5-Next-js-的惯例\"><a href=\"#5-Next-js-的惯例\" class=\"headerlink\" title=\"5. Next.js 的惯例\"></a>5. <strong>Next.js 的惯例</strong></h3><p>Next.js 官方建议直接使用 <code>.js</code> 或 <code>.ts</code>，因为它的编译工具默认支持 JSX 解析。因此，在 Next.js 项目中，通常不会使用 <code>.jsx</code> 扩展名。</p>\n<hr>\n<h3 id=\"总结：何时使用哪种？\"><a href=\"#总结：何时使用哪种？\" class=\"headerlink\" title=\"总结：何时使用哪种？\"></a><strong>总结：何时使用哪种？</strong></h3><table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>适用扩展名</th>\n<th>推荐实践</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>纯 JavaScript 逻辑</td>\n<td><code>.js</code></td>\n<td>✅</td>\n</tr>\n<tr>\n<td>React 组件 (JSX)</td>\n<td><code>.jsx</code> 或 <code>.js</code></td>\n<td>随项目规范选择</td>\n</tr>\n<tr>\n<td>TypeScript 文件</td>\n<td><code>.ts</code> 或 <code>.tsx</code></td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<p>如果你喜欢明确区分组件，使用 <code>.jsx</code>。如果你想保持简单，直接用 <code>.js</code> 也是完全可以的。</p>\n<hr>\n<p>如果你是一个人开发或团队没有特别规定，推荐统一使用 <code>.js</code> 以减少额外的区分工作。</p>\n"},{"title":"RPC框架的概念","description":"RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许程序在不同的地址空间中执行子程序或过程，就像调用本地程序一样","toc":false,"date":"2025-05-04T11:57:57.000Z","_content":"RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许程序在不同的地址空间中执行子程序或过程，就像调用本地程序一样。RPC框架的主要目标是简化分布式系统中的通信，使得开发人员可以像调用本地函数一样调用远程服务，而无需关心底层的网络通信细节。\n\n### RPC框架的核心概念\n\n1. **客户端（Client）**：发起远程调用的程序。客户端通常会使用一个代理（Proxy）来隐藏远程调用的细节。\n\n2. **服务端（Server）**：提供远程服务的程序。服务端会监听来自客户端的请求，并执行相应的服务。\n\n3. **代理（Proxy）**：位于客户端，负责将本地调用转换为远程调用请求，并将远程调用的结果返回给客户端。\n\n4. **存根（Stub）**：位于服务端，负责接收远程调用请求，并将其转换为本地调用。\n\n5. **通信协议**：定义客户端和服务端之间的通信方式，如HTTP、TCP、UDP等。\n\n6. **序列化/反序列化**：将数据结构或对象状态转换为可传输格式的过程称为序列化，反之为反序列化。常用的序列化格式包括JSON、XML、Protobuf等。\n\n7. **服务注册与发现**：服务端将自己的服务信息注册到一个中心化的注册表中，客户端通过查询注册表来发现可用的服务。\n\n### RPC框架的工作流程\n\n8. **服务注册**：服务端将自己的服务信息（如IP地址、端口号、服务名等）注册到一个服务注册中心。\n\n9. **服务发现**：客户端通过查询服务注册中心，获取所需服务的地址信息。\n\n10. **客户端调用**：客户端通过代理发起远程调用请求，将请求参数序列化后发送到服务端。\n\n11. **服务端处理**：服务端接收到请求后，通过存根将请求反序列化，并执行相应的服务逻辑。\n\n12. **结果返回**：服务端将执行结果序列化后返回给客户端，客户端将结果反序列化并返回给调用者。\n\n### 常见的RPC框架\n\n- **Apache Thrift**：由Facebook开发，支持多种编程语言。\n\n- **gRPC**：由Google开发，基于HTTP/2和Protobuf，支持多种编程语言。\n\n- **Dubbo**：由阿里巴巴开发，主要用于Java生态系统。\n\n- **Spring Cloud**：基于Spring Boot，提供了一系列的分布式系统解决方案。\n\n### 设计RPC框架的步骤\n\n13. **定义通信协议**：选择合适的通信协议，如HTTP或TCP。\n\n14. **设计序列化格式**：选择合适的序列化格式，如JSON或Protobuf。\n\n15. **实现客户端代理**：创建客户端代理类，负责将本地调用转换为远程调用请求。\n\n16. **实现服务端存根**：创建服务端存根类，负责接收远程调用请求并转换为本地调用。\n\n17. **实现服务注册与发现**：设计服务注册中心，实现服务的注册和发现机制。\n\n18. **编写测试用例**：编写单元测试和集成测试，确保框架的正确性和稳定性。\n\n19. **文档编写**：编写详细的设计文档和使用手册，方便其他开发人员理解和使用。\n","source":"_posts/RPC框架的概念.md","raw":"---\ntitle: RPC框架的概念\ndescription: 'RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许程序在不同的地址空间中执行子程序或过程，就像调用本地程序一样'\ntags: []\ntoc: false\ndate: 2025-05-04 19:57:57\ncategories:\n---\nRPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许程序在不同的地址空间中执行子程序或过程，就像调用本地程序一样。RPC框架的主要目标是简化分布式系统中的通信，使得开发人员可以像调用本地函数一样调用远程服务，而无需关心底层的网络通信细节。\n\n### RPC框架的核心概念\n\n1. **客户端（Client）**：发起远程调用的程序。客户端通常会使用一个代理（Proxy）来隐藏远程调用的细节。\n\n2. **服务端（Server）**：提供远程服务的程序。服务端会监听来自客户端的请求，并执行相应的服务。\n\n3. **代理（Proxy）**：位于客户端，负责将本地调用转换为远程调用请求，并将远程调用的结果返回给客户端。\n\n4. **存根（Stub）**：位于服务端，负责接收远程调用请求，并将其转换为本地调用。\n\n5. **通信协议**：定义客户端和服务端之间的通信方式，如HTTP、TCP、UDP等。\n\n6. **序列化/反序列化**：将数据结构或对象状态转换为可传输格式的过程称为序列化，反之为反序列化。常用的序列化格式包括JSON、XML、Protobuf等。\n\n7. **服务注册与发现**：服务端将自己的服务信息注册到一个中心化的注册表中，客户端通过查询注册表来发现可用的服务。\n\n### RPC框架的工作流程\n\n8. **服务注册**：服务端将自己的服务信息（如IP地址、端口号、服务名等）注册到一个服务注册中心。\n\n9. **服务发现**：客户端通过查询服务注册中心，获取所需服务的地址信息。\n\n10. **客户端调用**：客户端通过代理发起远程调用请求，将请求参数序列化后发送到服务端。\n\n11. **服务端处理**：服务端接收到请求后，通过存根将请求反序列化，并执行相应的服务逻辑。\n\n12. **结果返回**：服务端将执行结果序列化后返回给客户端，客户端将结果反序列化并返回给调用者。\n\n### 常见的RPC框架\n\n- **Apache Thrift**：由Facebook开发，支持多种编程语言。\n\n- **gRPC**：由Google开发，基于HTTP/2和Protobuf，支持多种编程语言。\n\n- **Dubbo**：由阿里巴巴开发，主要用于Java生态系统。\n\n- **Spring Cloud**：基于Spring Boot，提供了一系列的分布式系统解决方案。\n\n### 设计RPC框架的步骤\n\n13. **定义通信协议**：选择合适的通信协议，如HTTP或TCP。\n\n14. **设计序列化格式**：选择合适的序列化格式，如JSON或Protobuf。\n\n15. **实现客户端代理**：创建客户端代理类，负责将本地调用转换为远程调用请求。\n\n16. **实现服务端存根**：创建服务端存根类，负责接收远程调用请求并转换为本地调用。\n\n17. **实现服务注册与发现**：设计服务注册中心，实现服务的注册和发现机制。\n\n18. **编写测试用例**：编写单元测试和集成测试，确保框架的正确性和稳定性。\n\n19. **文档编写**：编写详细的设计文档和使用手册，方便其他开发人员理解和使用。\n","slug":"RPC框架的概念","published":1,"updated":"2025-05-04T13:00:56.440Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8e000gp3j5cofv0cma","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许程序在不同的地址空间中执行子程序或过程，就像调用本地程序一样。RPC框架的主要目标是简化分布式系统中的通信，使得开发人员可以像调用本地函数一样调用远程服务，而无需关心底层的网络通信细节。</p>\n<h3 id=\"RPC框架的核心概念\"><a href=\"#RPC框架的核心概念\" class=\"headerlink\" title=\"RPC框架的核心概念\"></a>RPC框架的核心概念</h3><ol>\n<li><p><strong>客户端（Client）</strong>：发起远程调用的程序。客户端通常会使用一个代理（Proxy）来隐藏远程调用的细节。</p>\n</li>\n<li><p><strong>服务端（Server）</strong>：提供远程服务的程序。服务端会监听来自客户端的请求，并执行相应的服务。</p>\n</li>\n<li><p><strong>代理（Proxy）</strong>：位于客户端，负责将本地调用转换为远程调用请求，并将远程调用的结果返回给客户端。</p>\n</li>\n<li><p><strong>存根（Stub）</strong>：位于服务端，负责接收远程调用请求，并将其转换为本地调用。</p>\n</li>\n<li><p><strong>通信协议</strong>：定义客户端和服务端之间的通信方式，如HTTP、TCP、UDP等。</p>\n</li>\n<li><p><strong>序列化&#x2F;反序列化</strong>：将数据结构或对象状态转换为可传输格式的过程称为序列化，反之为反序列化。常用的序列化格式包括JSON、XML、Protobuf等。</p>\n</li>\n<li><p><strong>服务注册与发现</strong>：服务端将自己的服务信息注册到一个中心化的注册表中，客户端通过查询注册表来发现可用的服务。</p>\n</li>\n</ol>\n<h3 id=\"RPC框架的工作流程\"><a href=\"#RPC框架的工作流程\" class=\"headerlink\" title=\"RPC框架的工作流程\"></a>RPC框架的工作流程</h3><ol start=\"8\">\n<li><p><strong>服务注册</strong>：服务端将自己的服务信息（如IP地址、端口号、服务名等）注册到一个服务注册中心。</p>\n</li>\n<li><p><strong>服务发现</strong>：客户端通过查询服务注册中心，获取所需服务的地址信息。</p>\n</li>\n<li><p><strong>客户端调用</strong>：客户端通过代理发起远程调用请求，将请求参数序列化后发送到服务端。</p>\n</li>\n<li><p><strong>服务端处理</strong>：服务端接收到请求后，通过存根将请求反序列化，并执行相应的服务逻辑。</p>\n</li>\n<li><p><strong>结果返回</strong>：服务端将执行结果序列化后返回给客户端，客户端将结果反序列化并返回给调用者。</p>\n</li>\n</ol>\n<h3 id=\"常见的RPC框架\"><a href=\"#常见的RPC框架\" class=\"headerlink\" title=\"常见的RPC框架\"></a>常见的RPC框架</h3><ul>\n<li><p><strong>Apache Thrift</strong>：由Facebook开发，支持多种编程语言。</p>\n</li>\n<li><p><strong>gRPC</strong>：由Google开发，基于HTTP&#x2F;2和Protobuf，支持多种编程语言。</p>\n</li>\n<li><p><strong>Dubbo</strong>：由阿里巴巴开发，主要用于Java生态系统。</p>\n</li>\n<li><p><strong>Spring Cloud</strong>：基于Spring Boot，提供了一系列的分布式系统解决方案。</p>\n</li>\n</ul>\n<h3 id=\"设计RPC框架的步骤\"><a href=\"#设计RPC框架的步骤\" class=\"headerlink\" title=\"设计RPC框架的步骤\"></a>设计RPC框架的步骤</h3><ol start=\"13\">\n<li><p><strong>定义通信协议</strong>：选择合适的通信协议，如HTTP或TCP。</p>\n</li>\n<li><p><strong>设计序列化格式</strong>：选择合适的序列化格式，如JSON或Protobuf。</p>\n</li>\n<li><p><strong>实现客户端代理</strong>：创建客户端代理类，负责将本地调用转换为远程调用请求。</p>\n</li>\n<li><p><strong>实现服务端存根</strong>：创建服务端存根类，负责接收远程调用请求并转换为本地调用。</p>\n</li>\n<li><p><strong>实现服务注册与发现</strong>：设计服务注册中心，实现服务的注册和发现机制。</p>\n</li>\n<li><p><strong>编写测试用例</strong>：编写单元测试和集成测试，确保框架的正确性和稳定性。</p>\n</li>\n<li><p><strong>文档编写</strong>：编写详细的设计文档和使用手册，方便其他开发人员理解和使用。</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许程序在不同的地址空间中执行子程序或过程，就像调用本地程序一样。RPC框架的主要目标是简化分布式系统中的通信，使得开发人员可以像调用本地函数一样调用远程服务，而无需关心底层的网络通信细节。</p>\n<h3 id=\"RPC框架的核心概念\"><a href=\"#RPC框架的核心概念\" class=\"headerlink\" title=\"RPC框架的核心概念\"></a>RPC框架的核心概念</h3><ol>\n<li><p><strong>客户端（Client）</strong>：发起远程调用的程序。客户端通常会使用一个代理（Proxy）来隐藏远程调用的细节。</p>\n</li>\n<li><p><strong>服务端（Server）</strong>：提供远程服务的程序。服务端会监听来自客户端的请求，并执行相应的服务。</p>\n</li>\n<li><p><strong>代理（Proxy）</strong>：位于客户端，负责将本地调用转换为远程调用请求，并将远程调用的结果返回给客户端。</p>\n</li>\n<li><p><strong>存根（Stub）</strong>：位于服务端，负责接收远程调用请求，并将其转换为本地调用。</p>\n</li>\n<li><p><strong>通信协议</strong>：定义客户端和服务端之间的通信方式，如HTTP、TCP、UDP等。</p>\n</li>\n<li><p><strong>序列化&#x2F;反序列化</strong>：将数据结构或对象状态转换为可传输格式的过程称为序列化，反之为反序列化。常用的序列化格式包括JSON、XML、Protobuf等。</p>\n</li>\n<li><p><strong>服务注册与发现</strong>：服务端将自己的服务信息注册到一个中心化的注册表中，客户端通过查询注册表来发现可用的服务。</p>\n</li>\n</ol>\n<h3 id=\"RPC框架的工作流程\"><a href=\"#RPC框架的工作流程\" class=\"headerlink\" title=\"RPC框架的工作流程\"></a>RPC框架的工作流程</h3><ol start=\"8\">\n<li><p><strong>服务注册</strong>：服务端将自己的服务信息（如IP地址、端口号、服务名等）注册到一个服务注册中心。</p>\n</li>\n<li><p><strong>服务发现</strong>：客户端通过查询服务注册中心，获取所需服务的地址信息。</p>\n</li>\n<li><p><strong>客户端调用</strong>：客户端通过代理发起远程调用请求，将请求参数序列化后发送到服务端。</p>\n</li>\n<li><p><strong>服务端处理</strong>：服务端接收到请求后，通过存根将请求反序列化，并执行相应的服务逻辑。</p>\n</li>\n<li><p><strong>结果返回</strong>：服务端将执行结果序列化后返回给客户端，客户端将结果反序列化并返回给调用者。</p>\n</li>\n</ol>\n<h3 id=\"常见的RPC框架\"><a href=\"#常见的RPC框架\" class=\"headerlink\" title=\"常见的RPC框架\"></a>常见的RPC框架</h3><ul>\n<li><p><strong>Apache Thrift</strong>：由Facebook开发，支持多种编程语言。</p>\n</li>\n<li><p><strong>gRPC</strong>：由Google开发，基于HTTP&#x2F;2和Protobuf，支持多种编程语言。</p>\n</li>\n<li><p><strong>Dubbo</strong>：由阿里巴巴开发，主要用于Java生态系统。</p>\n</li>\n<li><p><strong>Spring Cloud</strong>：基于Spring Boot，提供了一系列的分布式系统解决方案。</p>\n</li>\n</ul>\n<h3 id=\"设计RPC框架的步骤\"><a href=\"#设计RPC框架的步骤\" class=\"headerlink\" title=\"设计RPC框架的步骤\"></a>设计RPC框架的步骤</h3><ol start=\"13\">\n<li><p><strong>定义通信协议</strong>：选择合适的通信协议，如HTTP或TCP。</p>\n</li>\n<li><p><strong>设计序列化格式</strong>：选择合适的序列化格式，如JSON或Protobuf。</p>\n</li>\n<li><p><strong>实现客户端代理</strong>：创建客户端代理类，负责将本地调用转换为远程调用请求。</p>\n</li>\n<li><p><strong>实现服务端存根</strong>：创建服务端存根类，负责接收远程调用请求并转换为本地调用。</p>\n</li>\n<li><p><strong>实现服务注册与发现</strong>：设计服务注册中心，实现服务的注册和发现机制。</p>\n</li>\n<li><p><strong>编写测试用例</strong>：编写单元测试和集成测试，确保框架的正确性和稳定性。</p>\n</li>\n<li><p><strong>文档编写</strong>：编写详细的设计文档和使用手册，方便其他开发人员理解和使用。</p>\n</li>\n</ol>\n"},{"title":"Solidity中的不可变量和常量","description":"通过合理使用 `constant` 和 `immutable`，可以提升合约的 Gas 效率和安全可靠性。","toc":false,"date":"2025-05-04T11:56:46.000Z","_content":"\n---\n\n### 1. **Constants（常量）**\n\n• **定义**：常量是编译时确定且永不改变的值，必须在声明时初始化。\n• **特点**：\n• 值在编译时硬编码到合约字节码中，不占用存储空间（节省 Gas）。\n• 必须是值类型（如 `uint`, `address`）或固定长度的简单类型（如 `bytes32`）。\n• 命名通常全大写（约定俗成）。\n• **语法**：\n\n```Solidity\nuint256 public constant MAX_SUPPLY = 1000;\naddress public constant OWNER = 0x123...;\n```\n\n\n---\n\n### 2. **Immutables（不可变量）**\n\n• **定义**：不可变量在构造函数中初始化一次，之后不可更改，但在部署时才能确定值。\n• **特点**：\n• 值存储在合约的代码区（而非存储槽），访问成本低于普通状态变量。\n• 可以是任意类型（包括复杂类型如 `address payable`）。\n• 适合在部署时动态赋值（如合约创建者的地址）。\n• **语法**：\n\n```Solidity\nuint256 public immutable maxSupply;\naddress public immutable owner;\n\nconstructor(uint256 _maxSupply) {\n    maxSupply = _maxSupply;\n    owner = msg.sender;\n}\n```\n\n\n---\n\n### 3. **关键区别**\n\n|特性|Constants|Immutables|\n|-|-|-|\n|**初始化时机**|编译时|构造函数运行时|\n|**支持类型**|简单值类型|任意类型|\n|**Gas 成本**|最低（直接内联）|低（代码区存储）|\n|**适用场景**|固定已知值|部署时动态确定的值|\n\n---\n\n### 4. **最佳实践**\n\n#### 对于 Constants：\n\n• **适用场景**：\n• 固定参数（如数学常数、固定代币小数位）。\n• 无需部署时动态赋值的值（如 `DECIMALS = 18`）。\n• **示例**：\n\n```Solidity\nuint8 public constant DECIMALS = 18;\nbytes32 public constant DEFAULT_ADMIN_ROLE = keccak256(\"ADMIN\");\n```\n\n\n#### 对于 Immutables：\n\n• **适用场景**：\n• 部署时确定的参数（如管理员地址、合约创建时间）。\n• 需要节省 Gas 的动态值（如代币的最大供应量）。\n• **示例**：\n\n```Solidity\naddress payable public immutable treasury;\nuint256 public immutable deploymentTime;\n\nconstructor(address payable _treasury) {\n    treasury = _treasury;\n    deploymentTime = block.timestamp;\n}\n```\n\n\n#### 通用建议：\n\n1. **优先使用 Immutables**：如果值需要在部署时动态赋值（如 `msg.sender`），用 `immutable`。\n\n2. **优化 Gas**：对频繁访问的不变量使用 `immutable` 或 `constant`，减少存储读取开销。\n\n3. **安全性**：通过不可变性保护关键参数（如管理员地址），防止后续被篡改。\n\n4. **命名清晰**：全大写命名 `CONSTANTS`，驼峰命名 `immutables`（如 `maxSupply`）。\n\n---\n\n### 5. **反模式与注意事项**\n\n• **避免滥用 Constants**：复杂计算或动态值无法用 `constant`。\n• **构造函数赋值限制**：`immutable` 只能在构造函数中赋值一次。\n• **验证输入**：对 `immutable` 的构造函数参数做校验（如非零地址）：\n\n```Solidity\nconstructor(address _admin) {\n    require(_admin != address(0), \"Invalid address\");\n    admin = _admin;\n}\n```\n\n\n---\n\n\n\n","source":"_posts/Solidity中的不可变量和常量.md","raw":"---\ntitle: Solidity中的不可变量和常量\ndescription: '通过合理使用 `constant` 和 `immutable`，可以提升合约的 Gas 效率和安全可靠性。'\ntags: ['Solidity','web3']\ntoc: false\ndate: 2025-05-04 19:56:46\ncategories: Solidity学习\n---\n\n---\n\n### 1. **Constants（常量）**\n\n• **定义**：常量是编译时确定且永不改变的值，必须在声明时初始化。\n• **特点**：\n• 值在编译时硬编码到合约字节码中，不占用存储空间（节省 Gas）。\n• 必须是值类型（如 `uint`, `address`）或固定长度的简单类型（如 `bytes32`）。\n• 命名通常全大写（约定俗成）。\n• **语法**：\n\n```Solidity\nuint256 public constant MAX_SUPPLY = 1000;\naddress public constant OWNER = 0x123...;\n```\n\n\n---\n\n### 2. **Immutables（不可变量）**\n\n• **定义**：不可变量在构造函数中初始化一次，之后不可更改，但在部署时才能确定值。\n• **特点**：\n• 值存储在合约的代码区（而非存储槽），访问成本低于普通状态变量。\n• 可以是任意类型（包括复杂类型如 `address payable`）。\n• 适合在部署时动态赋值（如合约创建者的地址）。\n• **语法**：\n\n```Solidity\nuint256 public immutable maxSupply;\naddress public immutable owner;\n\nconstructor(uint256 _maxSupply) {\n    maxSupply = _maxSupply;\n    owner = msg.sender;\n}\n```\n\n\n---\n\n### 3. **关键区别**\n\n|特性|Constants|Immutables|\n|-|-|-|\n|**初始化时机**|编译时|构造函数运行时|\n|**支持类型**|简单值类型|任意类型|\n|**Gas 成本**|最低（直接内联）|低（代码区存储）|\n|**适用场景**|固定已知值|部署时动态确定的值|\n\n---\n\n### 4. **最佳实践**\n\n#### 对于 Constants：\n\n• **适用场景**：\n• 固定参数（如数学常数、固定代币小数位）。\n• 无需部署时动态赋值的值（如 `DECIMALS = 18`）。\n• **示例**：\n\n```Solidity\nuint8 public constant DECIMALS = 18;\nbytes32 public constant DEFAULT_ADMIN_ROLE = keccak256(\"ADMIN\");\n```\n\n\n#### 对于 Immutables：\n\n• **适用场景**：\n• 部署时确定的参数（如管理员地址、合约创建时间）。\n• 需要节省 Gas 的动态值（如代币的最大供应量）。\n• **示例**：\n\n```Solidity\naddress payable public immutable treasury;\nuint256 public immutable deploymentTime;\n\nconstructor(address payable _treasury) {\n    treasury = _treasury;\n    deploymentTime = block.timestamp;\n}\n```\n\n\n#### 通用建议：\n\n1. **优先使用 Immutables**：如果值需要在部署时动态赋值（如 `msg.sender`），用 `immutable`。\n\n2. **优化 Gas**：对频繁访问的不变量使用 `immutable` 或 `constant`，减少存储读取开销。\n\n3. **安全性**：通过不可变性保护关键参数（如管理员地址），防止后续被篡改。\n\n4. **命名清晰**：全大写命名 `CONSTANTS`，驼峰命名 `immutables`（如 `maxSupply`）。\n\n---\n\n### 5. **反模式与注意事项**\n\n• **避免滥用 Constants**：复杂计算或动态值无法用 `constant`。\n• **构造函数赋值限制**：`immutable` 只能在构造函数中赋值一次。\n• **验证输入**：对 `immutable` 的构造函数参数做校验（如非零地址）：\n\n```Solidity\nconstructor(address _admin) {\n    require(_admin != address(0), \"Invalid address\");\n    admin = _admin;\n}\n```\n\n\n---\n\n\n\n","slug":"Solidity中的不可变量和常量","published":1,"updated":"2025-05-04T11:58:27.354Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8f000ip3j5b9w7agoj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><hr>\n<h3 id=\"1-Constants（常量）\"><a href=\"#1-Constants（常量）\" class=\"headerlink\" title=\"1. Constants（常量）\"></a>1. <strong>Constants（常量）</strong></h3><p>• <strong>定义</strong>：常量是编译时确定且永不改变的值，必须在声明时初始化。<br>• <strong>特点</strong>：<br>• 值在编译时硬编码到合约字节码中，不占用存储空间（节省 Gas）。<br>• 必须是值类型（如 <code>uint</code>, <code>address</code>）或固定长度的简单类型（如 <code>bytes32</code>）。<br>• 命名通常全大写（约定俗成）。<br>• <strong>语法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 public constant MAX_SUPPLY = 1000;</span><br><span class=\"line\">address public constant OWNER = 0x123...;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"2-Immutables（不可变量）\"><a href=\"#2-Immutables（不可变量）\" class=\"headerlink\" title=\"2. Immutables（不可变量）\"></a>2. <strong>Immutables（不可变量）</strong></h3><p>• <strong>定义</strong>：不可变量在构造函数中初始化一次，之后不可更改，但在部署时才能确定值。<br>• <strong>特点</strong>：<br>• 值存储在合约的代码区（而非存储槽），访问成本低于普通状态变量。<br>• 可以是任意类型（包括复杂类型如 <code>address payable</code>）。<br>• 适合在部署时动态赋值（如合约创建者的地址）。<br>• <strong>语法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 public immutable maxSupply;</span><br><span class=\"line\">address public immutable owner;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(uint256 _maxSupply) &#123;</span><br><span class=\"line\">    maxSupply = _maxSupply;</span><br><span class=\"line\">    owner = msg.sender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"3-关键区别\"><a href=\"#3-关键区别\" class=\"headerlink\" title=\"3. 关键区别\"></a>3. <strong>关键区别</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Constants</th>\n<th>Immutables</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>初始化时机</strong></td>\n<td>编译时</td>\n<td>构造函数运行时</td>\n</tr>\n<tr>\n<td><strong>支持类型</strong></td>\n<td>简单值类型</td>\n<td>任意类型</td>\n</tr>\n<tr>\n<td><strong>Gas 成本</strong></td>\n<td>最低（直接内联）</td>\n<td>低（代码区存储）</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>固定已知值</td>\n<td>部署时动态确定的值</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"4-最佳实践\"><a href=\"#4-最佳实践\" class=\"headerlink\" title=\"4. 最佳实践\"></a>4. <strong>最佳实践</strong></h3><h4 id=\"对于-Constants：\"><a href=\"#对于-Constants：\" class=\"headerlink\" title=\"对于 Constants：\"></a>对于 Constants：</h4><p>• <strong>适用场景</strong>：<br>• 固定参数（如数学常数、固定代币小数位）。<br>• 无需部署时动态赋值的值（如 <code>DECIMALS = 18</code>）。<br>• <strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint8 public constant DECIMALS = 18;</span><br><span class=\"line\">bytes32 public constant DEFAULT_ADMIN_ROLE = keccak256(&quot;ADMIN&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"对于-Immutables：\"><a href=\"#对于-Immutables：\" class=\"headerlink\" title=\"对于 Immutables：\"></a>对于 Immutables：</h4><p>• <strong>适用场景</strong>：<br>• 部署时确定的参数（如管理员地址、合约创建时间）。<br>• 需要节省 Gas 的动态值（如代币的最大供应量）。<br>• <strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable public immutable treasury;</span><br><span class=\"line\">uint256 public immutable deploymentTime;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(address payable _treasury) &#123;</span><br><span class=\"line\">    treasury = _treasury;</span><br><span class=\"line\">    deploymentTime = block.timestamp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"通用建议：\"><a href=\"#通用建议：\" class=\"headerlink\" title=\"通用建议：\"></a>通用建议：</h4><ol>\n<li><p><strong>优先使用 Immutables</strong>：如果值需要在部署时动态赋值（如 <code>msg.sender</code>），用 <code>immutable</code>。</p>\n</li>\n<li><p><strong>优化 Gas</strong>：对频繁访问的不变量使用 <code>immutable</code> 或 <code>constant</code>，减少存储读取开销。</p>\n</li>\n<li><p><strong>安全性</strong>：通过不可变性保护关键参数（如管理员地址），防止后续被篡改。</p>\n</li>\n<li><p><strong>命名清晰</strong>：全大写命名 <code>CONSTANTS</code>，驼峰命名 <code>immutables</code>（如 <code>maxSupply</code>）。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"5-反模式与注意事项\"><a href=\"#5-反模式与注意事项\" class=\"headerlink\" title=\"5. 反模式与注意事项\"></a>5. <strong>反模式与注意事项</strong></h3><p>• <strong>避免滥用 Constants</strong>：复杂计算或动态值无法用 <code>constant</code>。<br>• <strong>构造函数赋值限制</strong>：<code>immutable</code> 只能在构造函数中赋值一次。<br>• <strong>验证输入</strong>：对 <code>immutable</code> 的构造函数参数做校验（如非零地址）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor(address _admin) &#123;</span><br><span class=\"line\">    require(_admin != address(0), &quot;Invalid address&quot;);</span><br><span class=\"line\">    admin = _admin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n","excerpt":"","more":"<hr>\n<h3 id=\"1-Constants（常量）\"><a href=\"#1-Constants（常量）\" class=\"headerlink\" title=\"1. Constants（常量）\"></a>1. <strong>Constants（常量）</strong></h3><p>• <strong>定义</strong>：常量是编译时确定且永不改变的值，必须在声明时初始化。<br>• <strong>特点</strong>：<br>• 值在编译时硬编码到合约字节码中，不占用存储空间（节省 Gas）。<br>• 必须是值类型（如 <code>uint</code>, <code>address</code>）或固定长度的简单类型（如 <code>bytes32</code>）。<br>• 命名通常全大写（约定俗成）。<br>• <strong>语法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 public constant MAX_SUPPLY = 1000;</span><br><span class=\"line\">address public constant OWNER = 0x123...;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"2-Immutables（不可变量）\"><a href=\"#2-Immutables（不可变量）\" class=\"headerlink\" title=\"2. Immutables（不可变量）\"></a>2. <strong>Immutables（不可变量）</strong></h3><p>• <strong>定义</strong>：不可变量在构造函数中初始化一次，之后不可更改，但在部署时才能确定值。<br>• <strong>特点</strong>：<br>• 值存储在合约的代码区（而非存储槽），访问成本低于普通状态变量。<br>• 可以是任意类型（包括复杂类型如 <code>address payable</code>）。<br>• 适合在部署时动态赋值（如合约创建者的地址）。<br>• <strong>语法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 public immutable maxSupply;</span><br><span class=\"line\">address public immutable owner;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(uint256 _maxSupply) &#123;</span><br><span class=\"line\">    maxSupply = _maxSupply;</span><br><span class=\"line\">    owner = msg.sender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"3-关键区别\"><a href=\"#3-关键区别\" class=\"headerlink\" title=\"3. 关键区别\"></a>3. <strong>关键区别</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Constants</th>\n<th>Immutables</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>初始化时机</strong></td>\n<td>编译时</td>\n<td>构造函数运行时</td>\n</tr>\n<tr>\n<td><strong>支持类型</strong></td>\n<td>简单值类型</td>\n<td>任意类型</td>\n</tr>\n<tr>\n<td><strong>Gas 成本</strong></td>\n<td>最低（直接内联）</td>\n<td>低（代码区存储）</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>固定已知值</td>\n<td>部署时动态确定的值</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"4-最佳实践\"><a href=\"#4-最佳实践\" class=\"headerlink\" title=\"4. 最佳实践\"></a>4. <strong>最佳实践</strong></h3><h4 id=\"对于-Constants：\"><a href=\"#对于-Constants：\" class=\"headerlink\" title=\"对于 Constants：\"></a>对于 Constants：</h4><p>• <strong>适用场景</strong>：<br>• 固定参数（如数学常数、固定代币小数位）。<br>• 无需部署时动态赋值的值（如 <code>DECIMALS = 18</code>）。<br>• <strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint8 public constant DECIMALS = 18;</span><br><span class=\"line\">bytes32 public constant DEFAULT_ADMIN_ROLE = keccak256(&quot;ADMIN&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"对于-Immutables：\"><a href=\"#对于-Immutables：\" class=\"headerlink\" title=\"对于 Immutables：\"></a>对于 Immutables：</h4><p>• <strong>适用场景</strong>：<br>• 部署时确定的参数（如管理员地址、合约创建时间）。<br>• 需要节省 Gas 的动态值（如代币的最大供应量）。<br>• <strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable public immutable treasury;</span><br><span class=\"line\">uint256 public immutable deploymentTime;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(address payable _treasury) &#123;</span><br><span class=\"line\">    treasury = _treasury;</span><br><span class=\"line\">    deploymentTime = block.timestamp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"通用建议：\"><a href=\"#通用建议：\" class=\"headerlink\" title=\"通用建议：\"></a>通用建议：</h4><ol>\n<li><p><strong>优先使用 Immutables</strong>：如果值需要在部署时动态赋值（如 <code>msg.sender</code>），用 <code>immutable</code>。</p>\n</li>\n<li><p><strong>优化 Gas</strong>：对频繁访问的不变量使用 <code>immutable</code> 或 <code>constant</code>，减少存储读取开销。</p>\n</li>\n<li><p><strong>安全性</strong>：通过不可变性保护关键参数（如管理员地址），防止后续被篡改。</p>\n</li>\n<li><p><strong>命名清晰</strong>：全大写命名 <code>CONSTANTS</code>，驼峰命名 <code>immutables</code>（如 <code>maxSupply</code>）。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"5-反模式与注意事项\"><a href=\"#5-反模式与注意事项\" class=\"headerlink\" title=\"5. 反模式与注意事项\"></a>5. <strong>反模式与注意事项</strong></h3><p>• <strong>避免滥用 Constants</strong>：复杂计算或动态值无法用 <code>constant</code>。<br>• <strong>构造函数赋值限制</strong>：<code>immutable</code> 只能在构造函数中赋值一次。<br>• <strong>验证输入</strong>：对 <code>immutable</code> 的构造函数参数做校验（如非零地址）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor(address _admin) &#123;</span><br><span class=\"line\">    require(_admin != address(0), &quot;Invalid address&quot;);</span><br><span class=\"line\">    admin = _admin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n"},{"title":"Solidity中的自定义错误","description":"Solidity 0.8.4 引入了自定义错误(Custom Errors)功能，这是一种比传统 require 语句更高效的错误处理方式，可以显著节省 Gas 消耗","date":"2025-05-03T13:26:17.000Z","toc":true,"_content":"\n\nSolidity 0.8.4 引入了自定义错误(Custom Errors)功能，这是一种比传统 `require` 语句更高效的错误处理方式，可以显著节省 Gas 消耗。\n\n## 为什么自定义错误能节省 Gas\n\n1. **更小的字节码**：自定义错误不需要存储错误字符串\n\n2. **更低的运行时成本**：回滚时只需传递 4 字节的选择器，而不是完整的字符串\n\n3. **更少的存储开销**：字符串错误信息需要存储在合约字节码中\n\n## 基本语法\n\n```Solidity\n// 定义自定义错误\nerror InsufficientBalance(uint256 available, uint256 required);\n\ncontract MyContract {\n    function withdraw(uint256 amount) public {\n        uint256 balance = address(this).balance;\n        if (balance < amount) {\n            revert InsufficientBalance(balance, amount);\n        }\n        // 其他逻辑...\n    }\n}\n```\n\n\n## 最佳实践\n\n### 1. 为常见错误条件定义明确的错误\n\n```Solidity\nerror Unauthorized();\nerror InvalidAddress();\nerror ValueTooLow(uint256 min, uint256 actual);\nerror DeadlineExpired(uint256 deadline);\n```\n\n\n### 2. 在复杂合约中组织错误\n\n```Solidity\nlibrary Errors {\n    error Unauthorized();\n    error InsufficientBalance(uint256 available, uint256 required);\n}\n\ncontract MyContract {\n    using Errors for *;\n    \n    function withdraw(uint256 amount) public {\n        if (msg.sender != owner) revert Errors.Unauthorized();\n        // ...\n    }\n}\n```\n\n\n### 3. 提供有用的上下文信息\n\n```Solidity\nerror TransferFailed(address from, address to, uint256 amount);\n\nfunction transfer(address to, uint256 amount) public {\n    bool success = _transfer(msg.sender, to, amount);\n    if (!success) revert TransferFailed(msg.sender, to, amount);\n}\n```\n\n\n### 4. 与 require 对比\n\n```Solidity\n// 传统方式 - 消耗更多 Gas\nrequire(balance >= amount, \"Insufficient balance\");\n\n// 自定义错误方式 - 更高效\nif (balance < amount) revert InsufficientBalance(balance, amount);\n```\n\n\n### 5. 在接口中定义错误\n\n```Solidity\ninterface IERC20 {\n    error InsufficientBalance();\n    error InsufficientAllowance();\n    \n    function transfer(address to, uint256 amount) external;\n}\n```\n\n\n## Gas 节省示例\n\n假设一个简单的转账合约：\n\n```Solidity\n// 使用 require\nfunction transferWithRequire(address to, uint256 amount) public {\n    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n}\n\n// 使用自定义错误\nerror InsufficientBalance(uint256 available, uint256 required);\n\nfunction transferWithError(address to, uint256 amount) public {\n    uint256 available = balances[msg.sender];\n    if (available < amount) revert InsufficientBalance(available, amount);\n    balances[msg.sender] = available - amount;\n    balances[to] += amount;\n}\n```\n\n\n**Gas 消耗比较**：\n• `require` 版本：约 22,000 Gas（成功时），失败时更高\n• 自定义错误版本：约 21,500 Gas（成功时），失败时显著更低\n\n失败时的 Gas 节省更为明显，因为不需要存储和传递错误字符串。\n\n## 结论\n\n自定义错误是 Solidity 中优化 Gas 消耗的重要工具，特别是在频繁可能失败的函数中。通过遵循这些最佳实践，你可以编写出更高效、更清晰的智能合约代码。\n\n\n\n","source":"_posts/Solidity中的自定义错误.md","raw":"---\ntitle: Solidity中的自定义错误\ndescription: 'Solidity 0.8.4 引入了自定义错误(Custom Errors)功能，这是一种比传统 require 语句更高效的错误处理方式，可以显著节省 Gas 消耗'\ndate: 2025-05-03 21:26:17\ntags: ['Solidity']\ncategories: Solidity学习\ntoc: true\n---\n\n\nSolidity 0.8.4 引入了自定义错误(Custom Errors)功能，这是一种比传统 `require` 语句更高效的错误处理方式，可以显著节省 Gas 消耗。\n\n## 为什么自定义错误能节省 Gas\n\n1. **更小的字节码**：自定义错误不需要存储错误字符串\n\n2. **更低的运行时成本**：回滚时只需传递 4 字节的选择器，而不是完整的字符串\n\n3. **更少的存储开销**：字符串错误信息需要存储在合约字节码中\n\n## 基本语法\n\n```Solidity\n// 定义自定义错误\nerror InsufficientBalance(uint256 available, uint256 required);\n\ncontract MyContract {\n    function withdraw(uint256 amount) public {\n        uint256 balance = address(this).balance;\n        if (balance < amount) {\n            revert InsufficientBalance(balance, amount);\n        }\n        // 其他逻辑...\n    }\n}\n```\n\n\n## 最佳实践\n\n### 1. 为常见错误条件定义明确的错误\n\n```Solidity\nerror Unauthorized();\nerror InvalidAddress();\nerror ValueTooLow(uint256 min, uint256 actual);\nerror DeadlineExpired(uint256 deadline);\n```\n\n\n### 2. 在复杂合约中组织错误\n\n```Solidity\nlibrary Errors {\n    error Unauthorized();\n    error InsufficientBalance(uint256 available, uint256 required);\n}\n\ncontract MyContract {\n    using Errors for *;\n    \n    function withdraw(uint256 amount) public {\n        if (msg.sender != owner) revert Errors.Unauthorized();\n        // ...\n    }\n}\n```\n\n\n### 3. 提供有用的上下文信息\n\n```Solidity\nerror TransferFailed(address from, address to, uint256 amount);\n\nfunction transfer(address to, uint256 amount) public {\n    bool success = _transfer(msg.sender, to, amount);\n    if (!success) revert TransferFailed(msg.sender, to, amount);\n}\n```\n\n\n### 4. 与 require 对比\n\n```Solidity\n// 传统方式 - 消耗更多 Gas\nrequire(balance >= amount, \"Insufficient balance\");\n\n// 自定义错误方式 - 更高效\nif (balance < amount) revert InsufficientBalance(balance, amount);\n```\n\n\n### 5. 在接口中定义错误\n\n```Solidity\ninterface IERC20 {\n    error InsufficientBalance();\n    error InsufficientAllowance();\n    \n    function transfer(address to, uint256 amount) external;\n}\n```\n\n\n## Gas 节省示例\n\n假设一个简单的转账合约：\n\n```Solidity\n// 使用 require\nfunction transferWithRequire(address to, uint256 amount) public {\n    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n}\n\n// 使用自定义错误\nerror InsufficientBalance(uint256 available, uint256 required);\n\nfunction transferWithError(address to, uint256 amount) public {\n    uint256 available = balances[msg.sender];\n    if (available < amount) revert InsufficientBalance(available, amount);\n    balances[msg.sender] = available - amount;\n    balances[to] += amount;\n}\n```\n\n\n**Gas 消耗比较**：\n• `require` 版本：约 22,000 Gas（成功时），失败时更高\n• 自定义错误版本：约 21,500 Gas（成功时），失败时显著更低\n\n失败时的 Gas 节省更为明显，因为不需要存储和传递错误字符串。\n\n## 结论\n\n自定义错误是 Solidity 中优化 Gas 消耗的重要工具，特别是在频繁可能失败的函数中。通过遵循这些最佳实践，你可以编写出更高效、更清晰的智能合约代码。\n\n\n\n","slug":"Solidity中的自定义错误","published":1,"updated":"2025-05-04T10:19:03.724Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8f000kp3j59pl7c209","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Solidity 0.8.4 引入了自定义错误(Custom Errors)功能，这是一种比传统 <code>require</code> 语句更高效的错误处理方式，可以显著节省 Gas 消耗。</p>\n<h2 id=\"为什么自定义错误能节省-Gas\"><a href=\"#为什么自定义错误能节省-Gas\" class=\"headerlink\" title=\"为什么自定义错误能节省 Gas\"></a>为什么自定义错误能节省 Gas</h2><ol>\n<li><p><strong>更小的字节码</strong>：自定义错误不需要存储错误字符串</p>\n</li>\n<li><p><strong>更低的运行时成本</strong>：回滚时只需传递 4 字节的选择器，而不是完整的字符串</p>\n</li>\n<li><p><strong>更少的存储开销</strong>：字符串错误信息需要存储在合约字节码中</p>\n</li>\n</ol>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义自定义错误</span><br><span class=\"line\">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">    function withdraw(uint256 amount) public &#123;</span><br><span class=\"line\">        uint256 balance = address(this).balance;</span><br><span class=\"line\">        if (balance &lt; amount) &#123;</span><br><span class=\"line\">            revert InsufficientBalance(balance, amount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 其他逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"1-为常见错误条件定义明确的错误\"><a href=\"#1-为常见错误条件定义明确的错误\" class=\"headerlink\" title=\"1. 为常见错误条件定义明确的错误\"></a>1. 为常见错误条件定义明确的错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error Unauthorized();</span><br><span class=\"line\">error InvalidAddress();</span><br><span class=\"line\">error ValueTooLow(uint256 min, uint256 actual);</span><br><span class=\"line\">error DeadlineExpired(uint256 deadline);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-在复杂合约中组织错误\"><a href=\"#2-在复杂合约中组织错误\" class=\"headerlink\" title=\"2. 在复杂合约中组织错误\"></a>2. 在复杂合约中组织错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library Errors &#123;</span><br><span class=\"line\">    error Unauthorized();</span><br><span class=\"line\">    error InsufficientBalance(uint256 available, uint256 required);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">    using Errors for *;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint256 amount) public &#123;</span><br><span class=\"line\">        if (msg.sender != owner) revert Errors.Unauthorized();</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-提供有用的上下文信息\"><a href=\"#3-提供有用的上下文信息\" class=\"headerlink\" title=\"3. 提供有用的上下文信息\"></a>3. 提供有用的上下文信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TransferFailed(address from, address to, uint256 amount);</span><br><span class=\"line\"></span><br><span class=\"line\">function transfer(address to, uint256 amount) public &#123;</span><br><span class=\"line\">    bool success = _transfer(msg.sender, to, amount);</span><br><span class=\"line\">    if (!success) revert TransferFailed(msg.sender, to, amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-与-require-对比\"><a href=\"#4-与-require-对比\" class=\"headerlink\" title=\"4. 与 require 对比\"></a>4. 与 require 对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传统方式 - 消耗更多 Gas</span><br><span class=\"line\">require(balance &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 自定义错误方式 - 更高效</span><br><span class=\"line\">if (balance &lt; amount) revert InsufficientBalance(balance, amount);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-在接口中定义错误\"><a href=\"#5-在接口中定义错误\" class=\"headerlink\" title=\"5. 在接口中定义错误\"></a>5. 在接口中定义错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IERC20 &#123;</span><br><span class=\"line\">    error InsufficientBalance();</span><br><span class=\"line\">    error InsufficientAllowance();</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address to, uint256 amount) external;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Gas-节省示例\"><a href=\"#Gas-节省示例\" class=\"headerlink\" title=\"Gas 节省示例\"></a>Gas 节省示例</h2><p>假设一个简单的转账合约：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 require</span><br><span class=\"line\">function transferWithRequire(address to, uint256 amount) public &#123;</span><br><span class=\"line\">    require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">    balances[msg.sender] -= amount;</span><br><span class=\"line\">    balances[to] += amount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用自定义错误</span><br><span class=\"line\">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class=\"line\"></span><br><span class=\"line\">function transferWithError(address to, uint256 amount) public &#123;</span><br><span class=\"line\">    uint256 available = balances[msg.sender];</span><br><span class=\"line\">    if (available &lt; amount) revert InsufficientBalance(available, amount);</span><br><span class=\"line\">    balances[msg.sender] = available - amount;</span><br><span class=\"line\">    balances[to] += amount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>Gas 消耗比较</strong>：<br>• <code>require</code> 版本：约 22,000 Gas（成功时），失败时更高<br>• 自定义错误版本：约 21,500 Gas（成功时），失败时显著更低</p>\n<p>失败时的 Gas 节省更为明显，因为不需要存储和传递错误字符串。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>自定义错误是 Solidity 中优化 Gas 消耗的重要工具，特别是在频繁可能失败的函数中。通过遵循这些最佳实践，你可以编写出更高效、更清晰的智能合约代码。</p>\n","excerpt":"","more":"<p>Solidity 0.8.4 引入了自定义错误(Custom Errors)功能，这是一种比传统 <code>require</code> 语句更高效的错误处理方式，可以显著节省 Gas 消耗。</p>\n<h2 id=\"为什么自定义错误能节省-Gas\"><a href=\"#为什么自定义错误能节省-Gas\" class=\"headerlink\" title=\"为什么自定义错误能节省 Gas\"></a>为什么自定义错误能节省 Gas</h2><ol>\n<li><p><strong>更小的字节码</strong>：自定义错误不需要存储错误字符串</p>\n</li>\n<li><p><strong>更低的运行时成本</strong>：回滚时只需传递 4 字节的选择器，而不是完整的字符串</p>\n</li>\n<li><p><strong>更少的存储开销</strong>：字符串错误信息需要存储在合约字节码中</p>\n</li>\n</ol>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义自定义错误</span><br><span class=\"line\">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">    function withdraw(uint256 amount) public &#123;</span><br><span class=\"line\">        uint256 balance = address(this).balance;</span><br><span class=\"line\">        if (balance &lt; amount) &#123;</span><br><span class=\"line\">            revert InsufficientBalance(balance, amount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 其他逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"1-为常见错误条件定义明确的错误\"><a href=\"#1-为常见错误条件定义明确的错误\" class=\"headerlink\" title=\"1. 为常见错误条件定义明确的错误\"></a>1. 为常见错误条件定义明确的错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error Unauthorized();</span><br><span class=\"line\">error InvalidAddress();</span><br><span class=\"line\">error ValueTooLow(uint256 min, uint256 actual);</span><br><span class=\"line\">error DeadlineExpired(uint256 deadline);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-在复杂合约中组织错误\"><a href=\"#2-在复杂合约中组织错误\" class=\"headerlink\" title=\"2. 在复杂合约中组织错误\"></a>2. 在复杂合约中组织错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library Errors &#123;</span><br><span class=\"line\">    error Unauthorized();</span><br><span class=\"line\">    error InsufficientBalance(uint256 available, uint256 required);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">    using Errors for *;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint256 amount) public &#123;</span><br><span class=\"line\">        if (msg.sender != owner) revert Errors.Unauthorized();</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-提供有用的上下文信息\"><a href=\"#3-提供有用的上下文信息\" class=\"headerlink\" title=\"3. 提供有用的上下文信息\"></a>3. 提供有用的上下文信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TransferFailed(address from, address to, uint256 amount);</span><br><span class=\"line\"></span><br><span class=\"line\">function transfer(address to, uint256 amount) public &#123;</span><br><span class=\"line\">    bool success = _transfer(msg.sender, to, amount);</span><br><span class=\"line\">    if (!success) revert TransferFailed(msg.sender, to, amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-与-require-对比\"><a href=\"#4-与-require-对比\" class=\"headerlink\" title=\"4. 与 require 对比\"></a>4. 与 require 对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传统方式 - 消耗更多 Gas</span><br><span class=\"line\">require(balance &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 自定义错误方式 - 更高效</span><br><span class=\"line\">if (balance &lt; amount) revert InsufficientBalance(balance, amount);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-在接口中定义错误\"><a href=\"#5-在接口中定义错误\" class=\"headerlink\" title=\"5. 在接口中定义错误\"></a>5. 在接口中定义错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IERC20 &#123;</span><br><span class=\"line\">    error InsufficientBalance();</span><br><span class=\"line\">    error InsufficientAllowance();</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address to, uint256 amount) external;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Gas-节省示例\"><a href=\"#Gas-节省示例\" class=\"headerlink\" title=\"Gas 节省示例\"></a>Gas 节省示例</h2><p>假设一个简单的转账合约：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 require</span><br><span class=\"line\">function transferWithRequire(address to, uint256 amount) public &#123;</span><br><span class=\"line\">    require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">    balances[msg.sender] -= amount;</span><br><span class=\"line\">    balances[to] += amount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用自定义错误</span><br><span class=\"line\">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class=\"line\"></span><br><span class=\"line\">function transferWithError(address to, uint256 amount) public &#123;</span><br><span class=\"line\">    uint256 available = balances[msg.sender];</span><br><span class=\"line\">    if (available &lt; amount) revert InsufficientBalance(available, amount);</span><br><span class=\"line\">    balances[msg.sender] = available - amount;</span><br><span class=\"line\">    balances[to] += amount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>Gas 消耗比较</strong>：<br>• <code>require</code> 版本：约 22,000 Gas（成功时），失败时更高<br>• 自定义错误版本：约 21,500 Gas（成功时），失败时显著更低</p>\n<p>失败时的 Gas 节省更为明显，因为不需要存储和传递错误字符串。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>自定义错误是 Solidity 中优化 Gas 消耗的重要工具，特别是在频繁可能失败的函数中。通过遵循这些最佳实践，你可以编写出更高效、更清晰的智能合约代码。</p>\n"},{"title":"ethers和viem快速入门","description":"通过两段示例，对比ethers和viem的使用方法和设计思路","toc":false,"date":"2025-05-04T10:10:43.000Z","_content":"\n### Ethers\n```Solidity\nimport { ethers, Wallet } from \"ethers\";\nimport { abi, bytecode } from \"./erc20\";\n\nasync function main() {\n\n    // 基本使用： 获取当前块高，钱包地址，钱包余额，发送交易等等\n    const url = \"http://localhost:8545\"\n    const provider = new ethers.JsonRpcProvider(url);\n    const blockNumber = await provider.getBlockNumber();\n    console.log(`Current block number: ${blockNumber}`);\n\n    const privateKey = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\n    const wallet = new Wallet(privateKey, provider);\n    const walletAddress = await wallet.getAddress();\n    console.log(`Wallet address: ${walletAddress}`);\n\n    const balance = await provider.getBalance(walletAddress);\n    console.log(`Wallet balance: ${ethers.formatEther(balance)} ETH`);\n\n    const transaction = {\n        to: \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n        value: \"1000000000000000000\"\n    }\n    const tx = await wallet.sendTransaction(transaction);\n    await tx.wait()\n    console.log(`Transaction hash: ${tx.hash}`);\n\n    const newBalance = await provider.getBalance(walletAddress);\n    console.log(`New wallet balance: ${ethers.formatEther(newBalance)} ETH`);\n\n    // 合约交互： 部署合约，调用合约方法等等\n    const contract = new ethers.ContractFactory(abi,bytecode,wallet);\n    const contractInstance = await contract.deploy(\"name\",\"symbol\",18,100000);\n    await contractInstance.waitForDeployment();// 等待合约部署完成(打包到区块链)\n    const contractAddress = contractInstance.target.toString();\n    console.log(`Contract address: ${contractInstance.target}`);\n\n    const readContract = new ethers.Contract(contractAddress,abi,provider);\n    const totalSupply = await readContract.totalSupply();\n    console.log(`Total supply: ${totalSupply}`);\n\n    const writeContract = new ethers.Contract(contractAddress,abi,wallet);\n    const contractTransaction = await writeContract.transfer(\"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",12345);\n    await contractTransaction.wait();\n    const erc20Balance = await readContract.balanceOf(\"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\");\n    console.log(`New balance: ${erc20Balance}`);\n\n    // 事件监听： 监听合约事件等等\n    provider.on(\"block\", async (blockNumber) => {\n        console.log(`New block number: ${blockNumber}`);\n    });\n\n}\n\nmain()\n```\n\n### Viem\n```Solidity\nimport { createPublicClient, createWalletClient, defineChain, getContract, hexToBigInt, http } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { abi, bytecode } from \"./erc20\";\n\nexport const localChain = (url: string) => defineChain({\n    id: 31337,\n    name: \"testnet\",\n    network: \"testnet\",\n    nativeCurrency: {\n        decimals: 18,\n        name: \"Ether\",\n        symbol: \"ETH\",\n    },\n    rpcUrls: {\n        default: {\n            http: [url],\n        },\n        public: {\n            http: [url],\n        },\n    },\n    testnet: true,\n});\n\nasync function main() {\n    const url = \"http://127.0.0.1:8545\";\n    const publicClient = createPublicClient({\n        chain: localChain(url),\n        transport: http(),\n    });\n\n    // Public client\n    const blockNumber = await publicClient.getBlockNumber();\n    console.log(`Current block number: ${blockNumber}`);\n\n    const pk = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\n    const wallet = privateKeyToAccount(pk);\n    const address = wallet.address;\n    console.log(`Wallet address: ${address}`);\n    const balance = await publicClient.getBalance({ address });\n    console.log(`Wallet balance: ${balance}`);\n\n    // Wallet client\n    const walletClient = createWalletClient({\n        account: wallet,\n        chain: localChain(url),\n        transport: http(),\n    });\n\n    const tx = await walletClient.sendTransaction({\n        to: \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n        value: hexToBigInt(\"0x100\"),\n    });\n    console.log(`Transaction hash: ${tx}`);\n\n    // Deploy contract (return hash)\n    const formattedBytecode = `0x${bytecode}`;\n    const contract = await walletClient.deployContract({\n        abi,\n        bytecode: formattedBytecode,\n        account: wallet,\n        args: [\"Test Token\", \"TST\", 18, BigInt(10000)],\n    });\n\n    // Get contract address\n    const receipt = await publicClient.waitForTransactionReceipt({ hash: contract });\n    if (!receipt.contractAddress) {\n        throw new Error(\"Contract deployment failed or no contract address returned.\");\n    }\n    const contractAddress = receipt.contractAddress;\n    console.log(`Contract address: ${contractAddress}`);\n\n    // Call contract\n    const totalSupply = await publicClient.readContract({\n        address: contractAddress, // TypeScript now ensures this is non-null\n        abi,\n        functionName: \"totalSupply\",\n    });\n    console.log(`Total supply: ${totalSupply}`);\n\n    // Transfer tokens\n    const writeContract = getContract({\n        address: contractAddress,\n        abi: abi,\n        client: walletClient,\n    })\n    const tx2 = await writeContract.write.transfer([\n        \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n        321,\n    ]);\n    const erc20balance = await publicClient.readContract({\n        address: contractAddress,\n        abi: abi,\n        functionName: \"balanceOf\",\n        args: [\"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\"],\n    });\n    console.log(`ERC20 balance: ${erc20balance}`);\n\n    // Watch block\n    publicClient.watchBlockNumber({\n        onBlockNumber: (blockNumber) => {\n            console.log(`Current block number: ${blockNumber}`);\n        },\n    });\n}\n\nmain().catch((error) => {\n    console.error(\"An error occurred:\", error);\n});\n```\n","source":"_posts/ethers和viem.md","raw":"---\ntitle: ethers和viem快速入门\ndescription: '通过两段示例，对比ethers和viem的使用方法和设计思路'\ntags: ['ethers', 'viem', 'web3']\ntoc: false\ndate: 2025-05-04 18:10:43\ncategories:\n---\n\n### Ethers\n```Solidity\nimport { ethers, Wallet } from \"ethers\";\nimport { abi, bytecode } from \"./erc20\";\n\nasync function main() {\n\n    // 基本使用： 获取当前块高，钱包地址，钱包余额，发送交易等等\n    const url = \"http://localhost:8545\"\n    const provider = new ethers.JsonRpcProvider(url);\n    const blockNumber = await provider.getBlockNumber();\n    console.log(`Current block number: ${blockNumber}`);\n\n    const privateKey = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\n    const wallet = new Wallet(privateKey, provider);\n    const walletAddress = await wallet.getAddress();\n    console.log(`Wallet address: ${walletAddress}`);\n\n    const balance = await provider.getBalance(walletAddress);\n    console.log(`Wallet balance: ${ethers.formatEther(balance)} ETH`);\n\n    const transaction = {\n        to: \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n        value: \"1000000000000000000\"\n    }\n    const tx = await wallet.sendTransaction(transaction);\n    await tx.wait()\n    console.log(`Transaction hash: ${tx.hash}`);\n\n    const newBalance = await provider.getBalance(walletAddress);\n    console.log(`New wallet balance: ${ethers.formatEther(newBalance)} ETH`);\n\n    // 合约交互： 部署合约，调用合约方法等等\n    const contract = new ethers.ContractFactory(abi,bytecode,wallet);\n    const contractInstance = await contract.deploy(\"name\",\"symbol\",18,100000);\n    await contractInstance.waitForDeployment();// 等待合约部署完成(打包到区块链)\n    const contractAddress = contractInstance.target.toString();\n    console.log(`Contract address: ${contractInstance.target}`);\n\n    const readContract = new ethers.Contract(contractAddress,abi,provider);\n    const totalSupply = await readContract.totalSupply();\n    console.log(`Total supply: ${totalSupply}`);\n\n    const writeContract = new ethers.Contract(contractAddress,abi,wallet);\n    const contractTransaction = await writeContract.transfer(\"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",12345);\n    await contractTransaction.wait();\n    const erc20Balance = await readContract.balanceOf(\"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\");\n    console.log(`New balance: ${erc20Balance}`);\n\n    // 事件监听： 监听合约事件等等\n    provider.on(\"block\", async (blockNumber) => {\n        console.log(`New block number: ${blockNumber}`);\n    });\n\n}\n\nmain()\n```\n\n### Viem\n```Solidity\nimport { createPublicClient, createWalletClient, defineChain, getContract, hexToBigInt, http } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { abi, bytecode } from \"./erc20\";\n\nexport const localChain = (url: string) => defineChain({\n    id: 31337,\n    name: \"testnet\",\n    network: \"testnet\",\n    nativeCurrency: {\n        decimals: 18,\n        name: \"Ether\",\n        symbol: \"ETH\",\n    },\n    rpcUrls: {\n        default: {\n            http: [url],\n        },\n        public: {\n            http: [url],\n        },\n    },\n    testnet: true,\n});\n\nasync function main() {\n    const url = \"http://127.0.0.1:8545\";\n    const publicClient = createPublicClient({\n        chain: localChain(url),\n        transport: http(),\n    });\n\n    // Public client\n    const blockNumber = await publicClient.getBlockNumber();\n    console.log(`Current block number: ${blockNumber}`);\n\n    const pk = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\n    const wallet = privateKeyToAccount(pk);\n    const address = wallet.address;\n    console.log(`Wallet address: ${address}`);\n    const balance = await publicClient.getBalance({ address });\n    console.log(`Wallet balance: ${balance}`);\n\n    // Wallet client\n    const walletClient = createWalletClient({\n        account: wallet,\n        chain: localChain(url),\n        transport: http(),\n    });\n\n    const tx = await walletClient.sendTransaction({\n        to: \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n        value: hexToBigInt(\"0x100\"),\n    });\n    console.log(`Transaction hash: ${tx}`);\n\n    // Deploy contract (return hash)\n    const formattedBytecode = `0x${bytecode}`;\n    const contract = await walletClient.deployContract({\n        abi,\n        bytecode: formattedBytecode,\n        account: wallet,\n        args: [\"Test Token\", \"TST\", 18, BigInt(10000)],\n    });\n\n    // Get contract address\n    const receipt = await publicClient.waitForTransactionReceipt({ hash: contract });\n    if (!receipt.contractAddress) {\n        throw new Error(\"Contract deployment failed or no contract address returned.\");\n    }\n    const contractAddress = receipt.contractAddress;\n    console.log(`Contract address: ${contractAddress}`);\n\n    // Call contract\n    const totalSupply = await publicClient.readContract({\n        address: contractAddress, // TypeScript now ensures this is non-null\n        abi,\n        functionName: \"totalSupply\",\n    });\n    console.log(`Total supply: ${totalSupply}`);\n\n    // Transfer tokens\n    const writeContract = getContract({\n        address: contractAddress,\n        abi: abi,\n        client: walletClient,\n    })\n    const tx2 = await writeContract.write.transfer([\n        \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n        321,\n    ]);\n    const erc20balance = await publicClient.readContract({\n        address: contractAddress,\n        abi: abi,\n        functionName: \"balanceOf\",\n        args: [\"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\"],\n    });\n    console.log(`ERC20 balance: ${erc20balance}`);\n\n    // Watch block\n    publicClient.watchBlockNumber({\n        onBlockNumber: (blockNumber) => {\n            console.log(`Current block number: ${blockNumber}`);\n        },\n    });\n}\n\nmain().catch((error) => {\n    console.error(\"An error occurred:\", error);\n});\n```\n","slug":"ethers和viem","published":1,"updated":"2025-05-04T10:13:58.355Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8g000np3j5hdudbx2w","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"Ethers\"><a href=\"#Ethers\" class=\"headerlink\" title=\"Ethers\"></a>Ethers</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; ethers, Wallet &#125; from &quot;ethers&quot;;</span><br><span class=\"line\">import &#123; abi, bytecode &#125; from &quot;./erc20&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">async function main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 基本使用： 获取当前块高，钱包地址，钱包余额，发送交易等等</span><br><span class=\"line\">    const url = &quot;http://localhost:8545&quot;</span><br><span class=\"line\">    const provider = new ethers.JsonRpcProvider(url);</span><br><span class=\"line\">    const blockNumber = await provider.getBlockNumber();</span><br><span class=\"line\">    console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const privateKey = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;</span><br><span class=\"line\">    const wallet = new Wallet(privateKey, provider);</span><br><span class=\"line\">    const walletAddress = await wallet.getAddress();</span><br><span class=\"line\">    console.log(`Wallet address: $&#123;walletAddress&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const balance = await provider.getBalance(walletAddress);</span><br><span class=\"line\">    console.log(`Wallet balance: $&#123;ethers.formatEther(balance)&#125; ETH`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const transaction = &#123;</span><br><span class=\"line\">        to: &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class=\"line\">        value: &quot;1000000000000000000&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const tx = await wallet.sendTransaction(transaction);</span><br><span class=\"line\">    await tx.wait()</span><br><span class=\"line\">    console.log(`Transaction hash: $&#123;tx.hash&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const newBalance = await provider.getBalance(walletAddress);</span><br><span class=\"line\">    console.log(`New wallet balance: $&#123;ethers.formatEther(newBalance)&#125; ETH`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 合约交互： 部署合约，调用合约方法等等</span><br><span class=\"line\">    const contract = new ethers.ContractFactory(abi,bytecode,wallet);</span><br><span class=\"line\">    const contractInstance = await contract.deploy(&quot;name&quot;,&quot;symbol&quot;,18,100000);</span><br><span class=\"line\">    await contractInstance.waitForDeployment();// 等待合约部署完成(打包到区块链)</span><br><span class=\"line\">    const contractAddress = contractInstance.target.toString();</span><br><span class=\"line\">    console.log(`Contract address: $&#123;contractInstance.target&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const readContract = new ethers.Contract(contractAddress,abi,provider);</span><br><span class=\"line\">    const totalSupply = await readContract.totalSupply();</span><br><span class=\"line\">    console.log(`Total supply: $&#123;totalSupply&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const writeContract = new ethers.Contract(contractAddress,abi,wallet);</span><br><span class=\"line\">    const contractTransaction = await writeContract.transfer(&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,12345);</span><br><span class=\"line\">    await contractTransaction.wait();</span><br><span class=\"line\">    const erc20Balance = await readContract.balanceOf(&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;);</span><br><span class=\"line\">    console.log(`New balance: $&#123;erc20Balance&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 事件监听： 监听合约事件等等</span><br><span class=\"line\">    provider.on(&quot;block&quot;, async (blockNumber) =&gt; &#123;</span><br><span class=\"line\">        console.log(`New block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Viem\"><a href=\"#Viem\" class=\"headerlink\" title=\"Viem\"></a>Viem</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createPublicClient, createWalletClient, defineChain, getContract, hexToBigInt, http &#125; from &quot;viem&quot;;</span><br><span class=\"line\">import &#123; privateKeyToAccount &#125; from &quot;viem/accounts&quot;;</span><br><span class=\"line\">import &#123; abi, bytecode &#125; from &quot;./erc20&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const localChain = (url: string) =&gt; defineChain(&#123;</span><br><span class=\"line\">    id: 31337,</span><br><span class=\"line\">    name: &quot;testnet&quot;,</span><br><span class=\"line\">    network: &quot;testnet&quot;,</span><br><span class=\"line\">    nativeCurrency: &#123;</span><br><span class=\"line\">        decimals: 18,</span><br><span class=\"line\">        name: &quot;Ether&quot;,</span><br><span class=\"line\">        symbol: &quot;ETH&quot;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    rpcUrls: &#123;</span><br><span class=\"line\">        default: &#123;</span><br><span class=\"line\">            http: [url],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        public: &#123;</span><br><span class=\"line\">            http: [url],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    testnet: true,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">async function main() &#123;</span><br><span class=\"line\">    const url = &quot;http://127.0.0.1:8545&quot;;</span><br><span class=\"line\">    const publicClient = createPublicClient(&#123;</span><br><span class=\"line\">        chain: localChain(url),</span><br><span class=\"line\">        transport: http(),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Public client</span><br><span class=\"line\">    const blockNumber = await publicClient.getBlockNumber();</span><br><span class=\"line\">    console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const pk = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;</span><br><span class=\"line\">    const wallet = privateKeyToAccount(pk);</span><br><span class=\"line\">    const address = wallet.address;</span><br><span class=\"line\">    console.log(`Wallet address: $&#123;address&#125;`);</span><br><span class=\"line\">    const balance = await publicClient.getBalance(&#123; address &#125;);</span><br><span class=\"line\">    console.log(`Wallet balance: $&#123;balance&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Wallet client</span><br><span class=\"line\">    const walletClient = createWalletClient(&#123;</span><br><span class=\"line\">        account: wallet,</span><br><span class=\"line\">        chain: localChain(url),</span><br><span class=\"line\">        transport: http(),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const tx = await walletClient.sendTransaction(&#123;</span><br><span class=\"line\">        to: &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class=\"line\">        value: hexToBigInt(&quot;0x100&quot;),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(`Transaction hash: $&#123;tx&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Deploy contract (return hash)</span><br><span class=\"line\">    const formattedBytecode = `0x$&#123;bytecode&#125;`;</span><br><span class=\"line\">    const contract = await walletClient.deployContract(&#123;</span><br><span class=\"line\">        abi,</span><br><span class=\"line\">        bytecode: formattedBytecode,</span><br><span class=\"line\">        account: wallet,</span><br><span class=\"line\">        args: [&quot;Test Token&quot;, &quot;TST&quot;, 18, BigInt(10000)],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Get contract address</span><br><span class=\"line\">    const receipt = await publicClient.waitForTransactionReceipt(&#123; hash: contract &#125;);</span><br><span class=\"line\">    if (!receipt.contractAddress) &#123;</span><br><span class=\"line\">        throw new Error(&quot;Contract deployment failed or no contract address returned.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const contractAddress = receipt.contractAddress;</span><br><span class=\"line\">    console.log(`Contract address: $&#123;contractAddress&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Call contract</span><br><span class=\"line\">    const totalSupply = await publicClient.readContract(&#123;</span><br><span class=\"line\">        address: contractAddress, // TypeScript now ensures this is non-null</span><br><span class=\"line\">        abi,</span><br><span class=\"line\">        functionName: &quot;totalSupply&quot;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(`Total supply: $&#123;totalSupply&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Transfer tokens</span><br><span class=\"line\">    const writeContract = getContract(&#123;</span><br><span class=\"line\">        address: contractAddress,</span><br><span class=\"line\">        abi: abi,</span><br><span class=\"line\">        client: walletClient,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    const tx2 = await writeContract.write.transfer([</span><br><span class=\"line\">        &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class=\"line\">        321,</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">    const erc20balance = await publicClient.readContract(&#123;</span><br><span class=\"line\">        address: contractAddress,</span><br><span class=\"line\">        abi: abi,</span><br><span class=\"line\">        functionName: &quot;balanceOf&quot;,</span><br><span class=\"line\">        args: [&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(`ERC20 balance: $&#123;erc20balance&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Watch block</span><br><span class=\"line\">    publicClient.watchBlockNumber(&#123;</span><br><span class=\"line\">        onBlockNumber: (blockNumber) =&gt; &#123;</span><br><span class=\"line\">            console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main().catch((error) =&gt; &#123;</span><br><span class=\"line\">    console.error(&quot;An error occurred:&quot;, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"Ethers\"><a href=\"#Ethers\" class=\"headerlink\" title=\"Ethers\"></a>Ethers</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; ethers, Wallet &#125; from &quot;ethers&quot;;</span><br><span class=\"line\">import &#123; abi, bytecode &#125; from &quot;./erc20&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">async function main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 基本使用： 获取当前块高，钱包地址，钱包余额，发送交易等等</span><br><span class=\"line\">    const url = &quot;http://localhost:8545&quot;</span><br><span class=\"line\">    const provider = new ethers.JsonRpcProvider(url);</span><br><span class=\"line\">    const blockNumber = await provider.getBlockNumber();</span><br><span class=\"line\">    console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const privateKey = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;</span><br><span class=\"line\">    const wallet = new Wallet(privateKey, provider);</span><br><span class=\"line\">    const walletAddress = await wallet.getAddress();</span><br><span class=\"line\">    console.log(`Wallet address: $&#123;walletAddress&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const balance = await provider.getBalance(walletAddress);</span><br><span class=\"line\">    console.log(`Wallet balance: $&#123;ethers.formatEther(balance)&#125; ETH`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const transaction = &#123;</span><br><span class=\"line\">        to: &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class=\"line\">        value: &quot;1000000000000000000&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const tx = await wallet.sendTransaction(transaction);</span><br><span class=\"line\">    await tx.wait()</span><br><span class=\"line\">    console.log(`Transaction hash: $&#123;tx.hash&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const newBalance = await provider.getBalance(walletAddress);</span><br><span class=\"line\">    console.log(`New wallet balance: $&#123;ethers.formatEther(newBalance)&#125; ETH`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 合约交互： 部署合约，调用合约方法等等</span><br><span class=\"line\">    const contract = new ethers.ContractFactory(abi,bytecode,wallet);</span><br><span class=\"line\">    const contractInstance = await contract.deploy(&quot;name&quot;,&quot;symbol&quot;,18,100000);</span><br><span class=\"line\">    await contractInstance.waitForDeployment();// 等待合约部署完成(打包到区块链)</span><br><span class=\"line\">    const contractAddress = contractInstance.target.toString();</span><br><span class=\"line\">    console.log(`Contract address: $&#123;contractInstance.target&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const readContract = new ethers.Contract(contractAddress,abi,provider);</span><br><span class=\"line\">    const totalSupply = await readContract.totalSupply();</span><br><span class=\"line\">    console.log(`Total supply: $&#123;totalSupply&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const writeContract = new ethers.Contract(contractAddress,abi,wallet);</span><br><span class=\"line\">    const contractTransaction = await writeContract.transfer(&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,12345);</span><br><span class=\"line\">    await contractTransaction.wait();</span><br><span class=\"line\">    const erc20Balance = await readContract.balanceOf(&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;);</span><br><span class=\"line\">    console.log(`New balance: $&#123;erc20Balance&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 事件监听： 监听合约事件等等</span><br><span class=\"line\">    provider.on(&quot;block&quot;, async (blockNumber) =&gt; &#123;</span><br><span class=\"line\">        console.log(`New block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Viem\"><a href=\"#Viem\" class=\"headerlink\" title=\"Viem\"></a>Viem</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createPublicClient, createWalletClient, defineChain, getContract, hexToBigInt, http &#125; from &quot;viem&quot;;</span><br><span class=\"line\">import &#123; privateKeyToAccount &#125; from &quot;viem/accounts&quot;;</span><br><span class=\"line\">import &#123; abi, bytecode &#125; from &quot;./erc20&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const localChain = (url: string) =&gt; defineChain(&#123;</span><br><span class=\"line\">    id: 31337,</span><br><span class=\"line\">    name: &quot;testnet&quot;,</span><br><span class=\"line\">    network: &quot;testnet&quot;,</span><br><span class=\"line\">    nativeCurrency: &#123;</span><br><span class=\"line\">        decimals: 18,</span><br><span class=\"line\">        name: &quot;Ether&quot;,</span><br><span class=\"line\">        symbol: &quot;ETH&quot;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    rpcUrls: &#123;</span><br><span class=\"line\">        default: &#123;</span><br><span class=\"line\">            http: [url],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        public: &#123;</span><br><span class=\"line\">            http: [url],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    testnet: true,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">async function main() &#123;</span><br><span class=\"line\">    const url = &quot;http://127.0.0.1:8545&quot;;</span><br><span class=\"line\">    const publicClient = createPublicClient(&#123;</span><br><span class=\"line\">        chain: localChain(url),</span><br><span class=\"line\">        transport: http(),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Public client</span><br><span class=\"line\">    const blockNumber = await publicClient.getBlockNumber();</span><br><span class=\"line\">    console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    const pk = &quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;;</span><br><span class=\"line\">    const wallet = privateKeyToAccount(pk);</span><br><span class=\"line\">    const address = wallet.address;</span><br><span class=\"line\">    console.log(`Wallet address: $&#123;address&#125;`);</span><br><span class=\"line\">    const balance = await publicClient.getBalance(&#123; address &#125;);</span><br><span class=\"line\">    console.log(`Wallet balance: $&#123;balance&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Wallet client</span><br><span class=\"line\">    const walletClient = createWalletClient(&#123;</span><br><span class=\"line\">        account: wallet,</span><br><span class=\"line\">        chain: localChain(url),</span><br><span class=\"line\">        transport: http(),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const tx = await walletClient.sendTransaction(&#123;</span><br><span class=\"line\">        to: &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class=\"line\">        value: hexToBigInt(&quot;0x100&quot;),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(`Transaction hash: $&#123;tx&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Deploy contract (return hash)</span><br><span class=\"line\">    const formattedBytecode = `0x$&#123;bytecode&#125;`;</span><br><span class=\"line\">    const contract = await walletClient.deployContract(&#123;</span><br><span class=\"line\">        abi,</span><br><span class=\"line\">        bytecode: formattedBytecode,</span><br><span class=\"line\">        account: wallet,</span><br><span class=\"line\">        args: [&quot;Test Token&quot;, &quot;TST&quot;, 18, BigInt(10000)],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Get contract address</span><br><span class=\"line\">    const receipt = await publicClient.waitForTransactionReceipt(&#123; hash: contract &#125;);</span><br><span class=\"line\">    if (!receipt.contractAddress) &#123;</span><br><span class=\"line\">        throw new Error(&quot;Contract deployment failed or no contract address returned.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const contractAddress = receipt.contractAddress;</span><br><span class=\"line\">    console.log(`Contract address: $&#123;contractAddress&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Call contract</span><br><span class=\"line\">    const totalSupply = await publicClient.readContract(&#123;</span><br><span class=\"line\">        address: contractAddress, // TypeScript now ensures this is non-null</span><br><span class=\"line\">        abi,</span><br><span class=\"line\">        functionName: &quot;totalSupply&quot;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(`Total supply: $&#123;totalSupply&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Transfer tokens</span><br><span class=\"line\">    const writeContract = getContract(&#123;</span><br><span class=\"line\">        address: contractAddress,</span><br><span class=\"line\">        abi: abi,</span><br><span class=\"line\">        client: walletClient,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    const tx2 = await writeContract.write.transfer([</span><br><span class=\"line\">        &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,</span><br><span class=\"line\">        321,</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">    const erc20balance = await publicClient.readContract(&#123;</span><br><span class=\"line\">        address: contractAddress,</span><br><span class=\"line\">        abi: abi,</span><br><span class=\"line\">        functionName: &quot;balanceOf&quot;,</span><br><span class=\"line\">        args: [&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(`ERC20 balance: $&#123;erc20balance&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Watch block</span><br><span class=\"line\">    publicClient.watchBlockNumber(&#123;</span><br><span class=\"line\">        onBlockNumber: (blockNumber) =&gt; &#123;</span><br><span class=\"line\">            console.log(`Current block number: $&#123;blockNumber&#125;`);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main().catch((error) =&gt; &#123;</span><br><span class=\"line\">    console.error(&quot;An error occurred:&quot;, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"gobyexample学习笔记01","description":"golang基础语法","toc":false,"date":"2025-05-12T11:41:03.000Z","_content":"\n# Go 语言学习笔记 - Lesson 01\n\n项目地址：https://gitee.com/alan223/gobyexample\n\n## 1. 基础语法特点\n\n### 1.1 包管理\n- Go 语言使用 `package` 关键字声明包\n- 主程序必须使用 `package main`\n- 导入包使用 `import` 关键字，支持多种导入方式：\n  ```go\n  import \"fmt\"\n  import (\n      \"fmt\"\n      \"math\"\n  )\n  ```\n\n### 1.2 变量声明\n- 使用 `var` 关键字声明变量\n- 支持类型推导：`:=` 操作符\n- 变量声明后必须使用，否则会编译错误\n- 支持多变量声明：\n  ```go\n  var a, b int = 1, 2\n  c, d := 3, 4\n  ```\n\n### 1.3 常量\n- 使用 `const` 关键字声明常量\n- 常量可以是字符、字符串、布尔值或数值\n- 常量不能使用 `:=` 语法声明\n\n## 2. 数据结构\n\n### 2.1 数组和切片\n- 数组：固定长度，声明时需要指定长度\n  ```go\n  var a [5]int\n  ```\n- 切片：动态数组，更灵活\n  ```go\n  s := make([]int, 5)\n  ```\n- 切片操作：\n  - 追加：`append()`\n  - 截取：`s[low:high]`\n  - 长度：`len()`\n  - 容量：`cap()`\n\n### 2.2 Map\n- 键值对集合\n- 声明和初始化：\n  ```go\n  m := make(map[string]int)\n  m[\"key\"] = 42\n  ```\n- 检查键是否存在：\n  ```go\n  value, exists := m[\"key\"]\n  ```\n\n## 3. 控制结构\n\n### 3.1 循环\n- Go 只有 `for` 循环，没有 `while`\n- 支持多种 for 循环形式：\n  ```go\n  for i := 0; i < 10; i++ {}\n  for i < 10 {}\n  for {}\n  ```\n\n### 3.2 条件语句\n- `if` 语句可以包含初始化语句\n  ```go\n  if v := math.Pow(x, n); v < lim {\n      return v\n  }\n  ```\n- `switch` 语句：\n  - 不需要 `break`\n  - 可以使用 `fallthrough`\n  - 支持多条件\n\n## 4. 函数特性\n\n### 4.1 函数声明\n- 支持多返回值\n- 支持命名返回值\n- 支持可变参数\n  ```go\n  func sum(nums ...int) int {}\n  ```\n\n### 4.2 闭包\n- 函数可以返回函数\n- 闭包可以访问外部变量\n- 常用于实现函数工厂\n\n## 5. 面向对象特性\n\n### 5.1 结构体\n- 使用 `struct` 关键字\n- 支持匿名字段\n- 可以定义方法\n\n### 5.2 方法\n- 可以为任何类型定义方法\n- 方法接收者可以是值或指针\n  ```go\n  func (v Vertex) Abs() float64 {}\n  func (v *Vertex) Scale(f float64) {}\n  ```\n\n### 5.3 接口\n- 隐式实现接口\n- 接口可以包含多个方法\n- 空接口 `interface{}` 可以存储任何类型\n\n## 6. 指针\n- 使用 `&` 获取地址\n- 使用 `*` 获取值\n- 支持指针接收者方法\n\n## 7. 字符串和符文\n- 字符串是不可变的字节序列\n- 使用 `rune` 处理 Unicode 字符\n- 支持字符串切片和连接\n\n## 8. 递归\n- 支持函数递归调用\n- 常用于树结构和分治算法\n\n## 9. 范围遍历\n- 使用 `range` 遍历数组、切片、map 等\n- 可以获取索引和值\n  ```go\n  for i, v := range slice {}\n  for k, v := range m {}\n  ```\n\n## 注意事项\n1. Go 语言强调简洁性和实用性\n2. 错误处理通常使用返回值而不是异常\n4. 代码格式化使用 `go fmt`\n","source":"_posts/gobyexample学习笔记01.md","raw":"---\ntitle: gobyexample学习笔记01\ndescription: 'golang基础语法'\ntags: ['go']\ntoc: false\ndate: 2025-05-12 19:41:03\ncategories:\n    - go\n    - basic\n---\n\n# Go 语言学习笔记 - Lesson 01\n\n项目地址：https://gitee.com/alan223/gobyexample\n\n## 1. 基础语法特点\n\n### 1.1 包管理\n- Go 语言使用 `package` 关键字声明包\n- 主程序必须使用 `package main`\n- 导入包使用 `import` 关键字，支持多种导入方式：\n  ```go\n  import \"fmt\"\n  import (\n      \"fmt\"\n      \"math\"\n  )\n  ```\n\n### 1.2 变量声明\n- 使用 `var` 关键字声明变量\n- 支持类型推导：`:=` 操作符\n- 变量声明后必须使用，否则会编译错误\n- 支持多变量声明：\n  ```go\n  var a, b int = 1, 2\n  c, d := 3, 4\n  ```\n\n### 1.3 常量\n- 使用 `const` 关键字声明常量\n- 常量可以是字符、字符串、布尔值或数值\n- 常量不能使用 `:=` 语法声明\n\n## 2. 数据结构\n\n### 2.1 数组和切片\n- 数组：固定长度，声明时需要指定长度\n  ```go\n  var a [5]int\n  ```\n- 切片：动态数组，更灵活\n  ```go\n  s := make([]int, 5)\n  ```\n- 切片操作：\n  - 追加：`append()`\n  - 截取：`s[low:high]`\n  - 长度：`len()`\n  - 容量：`cap()`\n\n### 2.2 Map\n- 键值对集合\n- 声明和初始化：\n  ```go\n  m := make(map[string]int)\n  m[\"key\"] = 42\n  ```\n- 检查键是否存在：\n  ```go\n  value, exists := m[\"key\"]\n  ```\n\n## 3. 控制结构\n\n### 3.1 循环\n- Go 只有 `for` 循环，没有 `while`\n- 支持多种 for 循环形式：\n  ```go\n  for i := 0; i < 10; i++ {}\n  for i < 10 {}\n  for {}\n  ```\n\n### 3.2 条件语句\n- `if` 语句可以包含初始化语句\n  ```go\n  if v := math.Pow(x, n); v < lim {\n      return v\n  }\n  ```\n- `switch` 语句：\n  - 不需要 `break`\n  - 可以使用 `fallthrough`\n  - 支持多条件\n\n## 4. 函数特性\n\n### 4.1 函数声明\n- 支持多返回值\n- 支持命名返回值\n- 支持可变参数\n  ```go\n  func sum(nums ...int) int {}\n  ```\n\n### 4.2 闭包\n- 函数可以返回函数\n- 闭包可以访问外部变量\n- 常用于实现函数工厂\n\n## 5. 面向对象特性\n\n### 5.1 结构体\n- 使用 `struct` 关键字\n- 支持匿名字段\n- 可以定义方法\n\n### 5.2 方法\n- 可以为任何类型定义方法\n- 方法接收者可以是值或指针\n  ```go\n  func (v Vertex) Abs() float64 {}\n  func (v *Vertex) Scale(f float64) {}\n  ```\n\n### 5.3 接口\n- 隐式实现接口\n- 接口可以包含多个方法\n- 空接口 `interface{}` 可以存储任何类型\n\n## 6. 指针\n- 使用 `&` 获取地址\n- 使用 `*` 获取值\n- 支持指针接收者方法\n\n## 7. 字符串和符文\n- 字符串是不可变的字节序列\n- 使用 `rune` 处理 Unicode 字符\n- 支持字符串切片和连接\n\n## 8. 递归\n- 支持函数递归调用\n- 常用于树结构和分治算法\n\n## 9. 范围遍历\n- 使用 `range` 遍历数组、切片、map 等\n- 可以获取索引和值\n  ```go\n  for i, v := range slice {}\n  for k, v := range m {}\n  ```\n\n## 注意事项\n1. Go 语言强调简洁性和实用性\n2. 错误处理通常使用返回值而不是异常\n4. 代码格式化使用 `go fmt`\n","slug":"gobyexample学习笔记01","published":1,"updated":"2025-05-12T11:48:07.804Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8g000qp3j52e4754q5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"Go-语言学习笔记-Lesson-01\"><a href=\"#Go-语言学习笔记-Lesson-01\" class=\"headerlink\" title=\"Go 语言学习笔记 - Lesson 01\"></a>Go 语言学习笔记 - Lesson 01</h1><p>项目地址：<a href=\"https://gitee.com/alan223/gobyexample\">https://gitee.com/alan223/gobyexample</a></p>\n<h2 id=\"1-基础语法特点\"><a href=\"#1-基础语法特点\" class=\"headerlink\" title=\"1. 基础语法特点\"></a>1. 基础语法特点</h2><h3 id=\"1-1-包管理\"><a href=\"#1-1-包管理\" class=\"headerlink\" title=\"1.1 包管理\"></a>1.1 包管理</h3><ul>\n<li>Go 语言使用 <code>package</code> 关键字声明包</li>\n<li>主程序必须使用 <code>package main</code></li>\n<li>导入包使用 <code>import</code> 关键字，支持多种导入方式：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-2-变量声明\"><a href=\"#1-2-变量声明\" class=\"headerlink\" title=\"1.2 变量声明\"></a>1.2 变量声明</h3><ul>\n<li>使用 <code>var</code> 关键字声明变量</li>\n<li>支持类型推导：<code>:=</code> 操作符</li>\n<li>变量声明后必须使用，否则会编译错误</li>\n<li>支持多变量声明：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b <span class=\"type\">int</span> = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\">c, d := <span class=\"number\">3</span>, <span class=\"number\">4</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-3-常量\"><a href=\"#1-3-常量\" class=\"headerlink\" title=\"1.3 常量\"></a>1.3 常量</h3><ul>\n<li>使用 <code>const</code> 关键字声明常量</li>\n<li>常量可以是字符、字符串、布尔值或数值</li>\n<li>常量不能使用 <code>:=</code> 语法声明</li>\n</ul>\n<h2 id=\"2-数据结构\"><a href=\"#2-数据结构\" class=\"headerlink\" title=\"2. 数据结构\"></a>2. 数据结构</h2><h3 id=\"2-1-数组和切片\"><a href=\"#2-1-数组和切片\" class=\"headerlink\" title=\"2.1 数组和切片\"></a>2.1 数组和切片</h3><ul>\n<li>数组：固定长度，声明时需要指定长度<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">5</span>]<span class=\"type\">int</span></span><br></pre></td></tr></table></figure></li>\n<li>切片：动态数组，更灵活<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></li>\n<li>切片操作：<ul>\n<li>追加：<code>append()</code></li>\n<li>截取：<code>s[low:high]</code></li>\n<li>长度：<code>len()</code></li>\n<li>容量：<code>cap()</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-Map\"><a href=\"#2-2-Map\" class=\"headerlink\" title=\"2.2 Map\"></a>2.2 Map</h3><ul>\n<li>键值对集合</li>\n<li>声明和初始化：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\">m[<span class=\"string\">&quot;key&quot;</span>] = <span class=\"number\">42</span></span><br></pre></td></tr></table></figure></li>\n<li>检查键是否存在：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value, exists := m[<span class=\"string\">&quot;key&quot;</span>]</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"3-控制结构\"><a href=\"#3-控制结构\" class=\"headerlink\" title=\"3. 控制结构\"></a>3. 控制结构</h2><h3 id=\"3-1-循环\"><a href=\"#3-1-循环\" class=\"headerlink\" title=\"3.1 循环\"></a>3.1 循环</h3><ul>\n<li>Go 只有 <code>for</code> 循环，没有 <code>while</code></li>\n<li>支持多种 for 循环形式：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i &lt; <span class=\"number\">10</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-2-条件语句\"><a href=\"#3-2-条件语句\" class=\"headerlink\" title=\"3.2 条件语句\"></a>3.2 条件语句</h3><ul>\n<li><code>if</code> 语句可以包含初始化语句<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>switch</code> 语句：<ul>\n<li>不需要 <code>break</code></li>\n<li>可以使用 <code>fallthrough</code></li>\n<li>支持多条件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-函数特性\"><a href=\"#4-函数特性\" class=\"headerlink\" title=\"4. 函数特性\"></a>4. 函数特性</h2><h3 id=\"4-1-函数声明\"><a href=\"#4-1-函数声明\" class=\"headerlink\" title=\"4.1 函数声明\"></a>4.1 函数声明</h3><ul>\n<li>支持多返回值</li>\n<li>支持命名返回值</li>\n<li>支持可变参数<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(nums ...<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-2-闭包\"><a href=\"#4-2-闭包\" class=\"headerlink\" title=\"4.2 闭包\"></a>4.2 闭包</h3><ul>\n<li>函数可以返回函数</li>\n<li>闭包可以访问外部变量</li>\n<li>常用于实现函数工厂</li>\n</ul>\n<h2 id=\"5-面向对象特性\"><a href=\"#5-面向对象特性\" class=\"headerlink\" title=\"5. 面向对象特性\"></a>5. 面向对象特性</h2><h3 id=\"5-1-结构体\"><a href=\"#5-1-结构体\" class=\"headerlink\" title=\"5.1 结构体\"></a>5.1 结构体</h3><ul>\n<li>使用 <code>struct</code> 关键字</li>\n<li>支持匿名字段</li>\n<li>可以定义方法</li>\n</ul>\n<h3 id=\"5-2-方法\"><a href=\"#5-2-方法\" class=\"headerlink\" title=\"5.2 方法\"></a>5.2 方法</h3><ul>\n<li>可以为任何类型定义方法</li>\n<li>方法接收者可以是值或指针<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-3-接口\"><a href=\"#5-3-接口\" class=\"headerlink\" title=\"5.3 接口\"></a>5.3 接口</h3><ul>\n<li>隐式实现接口</li>\n<li>接口可以包含多个方法</li>\n<li>空接口 <code>interface&#123;&#125;</code> 可以存储任何类型</li>\n</ul>\n<h2 id=\"6-指针\"><a href=\"#6-指针\" class=\"headerlink\" title=\"6. 指针\"></a>6. 指针</h2><ul>\n<li>使用 <code>&amp;</code> 获取地址</li>\n<li>使用 <code>*</code> 获取值</li>\n<li>支持指针接收者方法</li>\n</ul>\n<h2 id=\"7-字符串和符文\"><a href=\"#7-字符串和符文\" class=\"headerlink\" title=\"7. 字符串和符文\"></a>7. 字符串和符文</h2><ul>\n<li>字符串是不可变的字节序列</li>\n<li>使用 <code>rune</code> 处理 Unicode 字符</li>\n<li>支持字符串切片和连接</li>\n</ul>\n<h2 id=\"8-递归\"><a href=\"#8-递归\" class=\"headerlink\" title=\"8. 递归\"></a>8. 递归</h2><ul>\n<li>支持函数递归调用</li>\n<li>常用于树结构和分治算法</li>\n</ul>\n<h2 id=\"9-范围遍历\"><a href=\"#9-范围遍历\" class=\"headerlink\" title=\"9. 范围遍历\"></a>9. 范围遍历</h2><ul>\n<li>使用 <code>range</code> 遍历数组、切片、map 等</li>\n<li>可以获取索引和值<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> slice &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> m &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>Go 语言强调简洁性和实用性</li>\n<li>错误处理通常使用返回值而不是异常</li>\n<li>代码格式化使用 <code>go fmt</code></li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Go-语言学习笔记-Lesson-01\"><a href=\"#Go-语言学习笔记-Lesson-01\" class=\"headerlink\" title=\"Go 语言学习笔记 - Lesson 01\"></a>Go 语言学习笔记 - Lesson 01</h1><p>项目地址：<a href=\"https://gitee.com/alan223/gobyexample\">https://gitee.com/alan223/gobyexample</a></p>\n<h2 id=\"1-基础语法特点\"><a href=\"#1-基础语法特点\" class=\"headerlink\" title=\"1. 基础语法特点\"></a>1. 基础语法特点</h2><h3 id=\"1-1-包管理\"><a href=\"#1-1-包管理\" class=\"headerlink\" title=\"1.1 包管理\"></a>1.1 包管理</h3><ul>\n<li>Go 语言使用 <code>package</code> 关键字声明包</li>\n<li>主程序必须使用 <code>package main</code></li>\n<li>导入包使用 <code>import</code> 关键字，支持多种导入方式：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-2-变量声明\"><a href=\"#1-2-变量声明\" class=\"headerlink\" title=\"1.2 变量声明\"></a>1.2 变量声明</h3><ul>\n<li>使用 <code>var</code> 关键字声明变量</li>\n<li>支持类型推导：<code>:=</code> 操作符</li>\n<li>变量声明后必须使用，否则会编译错误</li>\n<li>支持多变量声明：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b <span class=\"type\">int</span> = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\">c, d := <span class=\"number\">3</span>, <span class=\"number\">4</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-3-常量\"><a href=\"#1-3-常量\" class=\"headerlink\" title=\"1.3 常量\"></a>1.3 常量</h3><ul>\n<li>使用 <code>const</code> 关键字声明常量</li>\n<li>常量可以是字符、字符串、布尔值或数值</li>\n<li>常量不能使用 <code>:=</code> 语法声明</li>\n</ul>\n<h2 id=\"2-数据结构\"><a href=\"#2-数据结构\" class=\"headerlink\" title=\"2. 数据结构\"></a>2. 数据结构</h2><h3 id=\"2-1-数组和切片\"><a href=\"#2-1-数组和切片\" class=\"headerlink\" title=\"2.1 数组和切片\"></a>2.1 数组和切片</h3><ul>\n<li>数组：固定长度，声明时需要指定长度<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">5</span>]<span class=\"type\">int</span></span><br></pre></td></tr></table></figure></li>\n<li>切片：动态数组，更灵活<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></li>\n<li>切片操作：<ul>\n<li>追加：<code>append()</code></li>\n<li>截取：<code>s[low:high]</code></li>\n<li>长度：<code>len()</code></li>\n<li>容量：<code>cap()</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-Map\"><a href=\"#2-2-Map\" class=\"headerlink\" title=\"2.2 Map\"></a>2.2 Map</h3><ul>\n<li>键值对集合</li>\n<li>声明和初始化：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\">m[<span class=\"string\">&quot;key&quot;</span>] = <span class=\"number\">42</span></span><br></pre></td></tr></table></figure></li>\n<li>检查键是否存在：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value, exists := m[<span class=\"string\">&quot;key&quot;</span>]</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"3-控制结构\"><a href=\"#3-控制结构\" class=\"headerlink\" title=\"3. 控制结构\"></a>3. 控制结构</h2><h3 id=\"3-1-循环\"><a href=\"#3-1-循环\" class=\"headerlink\" title=\"3.1 循环\"></a>3.1 循环</h3><ul>\n<li>Go 只有 <code>for</code> 循环，没有 <code>while</code></li>\n<li>支持多种 for 循环形式：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i &lt; <span class=\"number\">10</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-2-条件语句\"><a href=\"#3-2-条件语句\" class=\"headerlink\" title=\"3.2 条件语句\"></a>3.2 条件语句</h3><ul>\n<li><code>if</code> 语句可以包含初始化语句<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>switch</code> 语句：<ul>\n<li>不需要 <code>break</code></li>\n<li>可以使用 <code>fallthrough</code></li>\n<li>支持多条件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-函数特性\"><a href=\"#4-函数特性\" class=\"headerlink\" title=\"4. 函数特性\"></a>4. 函数特性</h2><h3 id=\"4-1-函数声明\"><a href=\"#4-1-函数声明\" class=\"headerlink\" title=\"4.1 函数声明\"></a>4.1 函数声明</h3><ul>\n<li>支持多返回值</li>\n<li>支持命名返回值</li>\n<li>支持可变参数<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(nums ...<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-2-闭包\"><a href=\"#4-2-闭包\" class=\"headerlink\" title=\"4.2 闭包\"></a>4.2 闭包</h3><ul>\n<li>函数可以返回函数</li>\n<li>闭包可以访问外部变量</li>\n<li>常用于实现函数工厂</li>\n</ul>\n<h2 id=\"5-面向对象特性\"><a href=\"#5-面向对象特性\" class=\"headerlink\" title=\"5. 面向对象特性\"></a>5. 面向对象特性</h2><h3 id=\"5-1-结构体\"><a href=\"#5-1-结构体\" class=\"headerlink\" title=\"5.1 结构体\"></a>5.1 结构体</h3><ul>\n<li>使用 <code>struct</code> 关键字</li>\n<li>支持匿名字段</li>\n<li>可以定义方法</li>\n</ul>\n<h3 id=\"5-2-方法\"><a href=\"#5-2-方法\" class=\"headerlink\" title=\"5.2 方法\"></a>5.2 方法</h3><ul>\n<li>可以为任何类型定义方法</li>\n<li>方法接收者可以是值或指针<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-3-接口\"><a href=\"#5-3-接口\" class=\"headerlink\" title=\"5.3 接口\"></a>5.3 接口</h3><ul>\n<li>隐式实现接口</li>\n<li>接口可以包含多个方法</li>\n<li>空接口 <code>interface&#123;&#125;</code> 可以存储任何类型</li>\n</ul>\n<h2 id=\"6-指针\"><a href=\"#6-指针\" class=\"headerlink\" title=\"6. 指针\"></a>6. 指针</h2><ul>\n<li>使用 <code>&amp;</code> 获取地址</li>\n<li>使用 <code>*</code> 获取值</li>\n<li>支持指针接收者方法</li>\n</ul>\n<h2 id=\"7-字符串和符文\"><a href=\"#7-字符串和符文\" class=\"headerlink\" title=\"7. 字符串和符文\"></a>7. 字符串和符文</h2><ul>\n<li>字符串是不可变的字节序列</li>\n<li>使用 <code>rune</code> 处理 Unicode 字符</li>\n<li>支持字符串切片和连接</li>\n</ul>\n<h2 id=\"8-递归\"><a href=\"#8-递归\" class=\"headerlink\" title=\"8. 递归\"></a>8. 递归</h2><ul>\n<li>支持函数递归调用</li>\n<li>常用于树结构和分治算法</li>\n</ul>\n<h2 id=\"9-范围遍历\"><a href=\"#9-范围遍历\" class=\"headerlink\" title=\"9. 范围遍历\"></a>9. 范围遍历</h2><ul>\n<li>使用 <code>range</code> 遍历数组、切片、map 等</li>\n<li>可以获取索引和值<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> slice &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> m &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>Go 语言强调简洁性和实用性</li>\n<li>错误处理通常使用返回值而不是异常</li>\n<li>代码格式化使用 <code>go fmt</code></li>\n</ol>\n"},{"title":"学习ERC-1155","description":"ERC-1155 是一种以太坊智能合约标准，专为实现多功能代币（Multi-Token Standard）而设计","toc":false,"date":"2025-05-04T12:02:54.000Z","_content":"\n## ERC-1155：可多功能代币标准\n\n### 什么是ERC-1155？\n\nERC-1155 是一种以太坊智能合约标准，专为实现多功能代币（Multi-Token Standard）而设计。与 ERC-20（同质化代币）和 ERC-721（非同质化代币）不同，ERC-1155 支持 **同质化代币（Fungible Tokens）** 和 **非同质化代币（Non-Fungible Tokens）** 的混合管理。该标准极大地提高了区块链代币管理的灵活性与效率，尤其适用于游戏、收藏品等对多种资产类型有需求的场景。\n\nERC-1155 的主要特点包括：\n\n- **批量操作**：可以同时转移或创建多个代币，降低了链上操作成本。\n\n- **单一合约管理多种代币**：一个合约中可以包含多种代币类型，而不需要单独部署多个合约。\n\n- **灵活性**：支持同质化代币（如游戏金币）、非同质化代币（如NFT角色）和半同质化代币（如门票）。\n\n- **节约Gas费用**：通过批量操作和共享逻辑减少链上交易成本。\n\n---\n\n### ERC-1155 的工作原理\n\nERC-1155 定义了一种标准接口，支持以下功能：\n\n1. **代币创建**：可以通过 `mint` 方法创建新的代币类型。\n\n2. **代币转移**：支持单个或批量的代币转移。\n\n3. **事件通知**：通过事件（如 `TransferSingle` 和 `TransferBatch`）提供透明且高效的状态更新。\n\n4. **安全检测**：增加了对智能合约接收代币的安全检测（如 `onERC1155Received` 和 `onERC1155BatchReceived`）。\n\nERC-1155 的核心方法：\n\n- `safeTransferFrom`：单个代币的安全转移。\n\n- `safeBatchTransferFrom`：批量代币的安全转移。\n\n- `balanceOf`：查询某个账户上的指定代币余额。\n\n- `balanceOfBatch`：批量查询多个账户的多个代币余额。\n\n- `setApprovalForAll`：授权某个地址管理所有代币。\n\n- `isApprovedForAll`：检查授权状态。\n\n---\n\n### ERC-1155 的用法：代码示例\n\n以下是一个简单的 ERC-1155 智能合约，基于 OpenZeppelin 提供的实现：\n\n```Solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 引入 OpenZeppelin 的 ERC1155 实现\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyERC1155Token is ERC1155, Ownable {\n\n    // 定义代币的 ID\n    uint256 public constant GOLD = 1;\n    uint256 public constant SILVER = 2;\n    uint256 public constant DIAMOND = 3;\n\n    // 构造函数：设置代币URI\n    constructor() ERC1155(\"https://game.example/api/token/{id}.json\") {\n        // 铸造初始代币\n        _mint(msg.sender, GOLD, 1000, \"\"); // 1000枚 GOLD 代币\n        _mint(msg.sender, SILVER, 5000, \"\"); // 5000枚 SILVER 代币\n        _mint(msg.sender, DIAMOND, 100, \"\"); // 100枚 DIAMOND 代币\n    }\n\n    // 自定义铸造函数\n    function mint(uint256 id, uint256 amount) public onlyOwner {\n        _mint(msg.sender, id, amount, \"\");\n    }\n\n    // 自定义批量铸造函数\n    function mintBatch(uint256[] memory ids, uint256[] memory amounts) public onlyOwner {\n        _mintBatch(msg.sender, ids, amounts, \"\");\n    }\n\n    // 自定义销毁函数\n    function burn(address account, uint256 id, uint256 amount) public {\n        require(msg.sender == account, \"Only the token owner can burn tokens\");\n        _burn(account, id, amount);\n    }\n\n    // 自定义批量销毁函数\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public {\n        require(msg.sender == account, \"Only the token owner can burn tokens\");\n        _burnBatch(account, ids, amounts);\n    }\n}\n```\n\n\n---\n\n### 合约说明\n\n5. **ERC1155 基础实现**：\n\n  - 我们继承了 OpenZeppelin 的 `ERC1155` 实现，能够快速实现 ERC-1155 标准的功能。\n\n  - `ERC1155` 构造函数中需要指定一个代币元数据的 URI，可以通过 `id` 动态替换。\n\n6. **代币 ID 和初始铸造**：\n\n  - 定义了 3 种代币类型：`GOLD`（ID 为 1），`SILVER`（ID 为 2），`DIAMOND`（ID 为 3）。\n\n  - 在合约部署时，分别铸造了 1000、5000 和 100 枚代币。\n\n7. **铸造与销毁**：\n\n  - 提供了 `mint` 和 `mintBatch` 方法供合约所有者调用，用于铸造新的代币。\n\n  - 提供了 `burn` 和 `burnBatch` 方法允许代币持有者销毁自己的代币。\n\n8. **批量操作**：\n\n  - 我们可以通过 `_mintBatch` 和 `_burnBatch` 一次性操作多个代币，极大减少了交易复杂度和成本。\n\n---\n\n### 部署与使用\n\n9. **部署**：\n\n  - 使用 Remix 或 Hardhat 部署上面的合约。\n\n  - 部署后，合约创建者会自动成为初始代币的持有者。\n\n10. **查询余额**：\n\n  - 使用 `balanceOf` 方法查询某个账户的指定代币余额。\n\n  - 示例：`balanceOf(address, GOLD)`。\n\n11. **转移代币**：\n\n  - 使用 `safeTransferFrom` 方法将代币发送给其他地址。\n\n  - 示例：\n\n    ```Solidity\n// 从 msg.sender 转移 10 枚 GOLD 给另一个地址\nsafeTransferFrom(msg.sender, recipient, GOLD, 10, \"\");\n```\n\n\n12. **批量转移代币**：\n\n  - 使用 `safeBatchTransferFrom` 方法批量转移多个代币。\n\n  - 示例：\n\n    ```Solidity\n// 从 msg.sender 转移 GOLD 和 SILVER 给另一个地址\nuint256[] memory ids = new uint256[](2);\nids[0] = GOLD;\nids[1] = SILVER;\n\nuint256[] memory amounts = new uint256[](2);\namounts[0] = 10;\namounts[1] = 20;\n\nsafeBatchTransferFrom(msg.sender, recipient, ids, amounts, \"\");\n```\n\n\n---\n\n### ERC-1155 的应用场景\n\n- **游戏资产**：\n\n  - 游戏道具、金币、装备等可以用 ERC-1155 统一管理，并支持批量交易。\n\n- **数字收藏品**：\n\n  - 一个合约中可以包含多种类型的收藏品（如卡牌游戏中的不同稀有度卡片）。\n\n- **门票系统**：\n\n  - 支持活动门票的发行、转移和销毁，既可以是同质化的（如普通票），也可以是非同质化的（如 VIP 定制票）。\n\n---\n\n\n\n","source":"_posts/学习ERC-1155.md","raw":"---\ntitle: 学习ERC-1155\ndescription: 'ERC-1155 是一种以太坊智能合约标准，专为实现多功能代币（Multi-Token Standard）而设计'\ntags: ['Solidity','web3']\ntoc: false\ndate: 2025-05-04 20:02:54\ncategories: Solidity学习\n---\n\n## ERC-1155：可多功能代币标准\n\n### 什么是ERC-1155？\n\nERC-1155 是一种以太坊智能合约标准，专为实现多功能代币（Multi-Token Standard）而设计。与 ERC-20（同质化代币）和 ERC-721（非同质化代币）不同，ERC-1155 支持 **同质化代币（Fungible Tokens）** 和 **非同质化代币（Non-Fungible Tokens）** 的混合管理。该标准极大地提高了区块链代币管理的灵活性与效率，尤其适用于游戏、收藏品等对多种资产类型有需求的场景。\n\nERC-1155 的主要特点包括：\n\n- **批量操作**：可以同时转移或创建多个代币，降低了链上操作成本。\n\n- **单一合约管理多种代币**：一个合约中可以包含多种代币类型，而不需要单独部署多个合约。\n\n- **灵活性**：支持同质化代币（如游戏金币）、非同质化代币（如NFT角色）和半同质化代币（如门票）。\n\n- **节约Gas费用**：通过批量操作和共享逻辑减少链上交易成本。\n\n---\n\n### ERC-1155 的工作原理\n\nERC-1155 定义了一种标准接口，支持以下功能：\n\n1. **代币创建**：可以通过 `mint` 方法创建新的代币类型。\n\n2. **代币转移**：支持单个或批量的代币转移。\n\n3. **事件通知**：通过事件（如 `TransferSingle` 和 `TransferBatch`）提供透明且高效的状态更新。\n\n4. **安全检测**：增加了对智能合约接收代币的安全检测（如 `onERC1155Received` 和 `onERC1155BatchReceived`）。\n\nERC-1155 的核心方法：\n\n- `safeTransferFrom`：单个代币的安全转移。\n\n- `safeBatchTransferFrom`：批量代币的安全转移。\n\n- `balanceOf`：查询某个账户上的指定代币余额。\n\n- `balanceOfBatch`：批量查询多个账户的多个代币余额。\n\n- `setApprovalForAll`：授权某个地址管理所有代币。\n\n- `isApprovedForAll`：检查授权状态。\n\n---\n\n### ERC-1155 的用法：代码示例\n\n以下是一个简单的 ERC-1155 智能合约，基于 OpenZeppelin 提供的实现：\n\n```Solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 引入 OpenZeppelin 的 ERC1155 实现\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyERC1155Token is ERC1155, Ownable {\n\n    // 定义代币的 ID\n    uint256 public constant GOLD = 1;\n    uint256 public constant SILVER = 2;\n    uint256 public constant DIAMOND = 3;\n\n    // 构造函数：设置代币URI\n    constructor() ERC1155(\"https://game.example/api/token/{id}.json\") {\n        // 铸造初始代币\n        _mint(msg.sender, GOLD, 1000, \"\"); // 1000枚 GOLD 代币\n        _mint(msg.sender, SILVER, 5000, \"\"); // 5000枚 SILVER 代币\n        _mint(msg.sender, DIAMOND, 100, \"\"); // 100枚 DIAMOND 代币\n    }\n\n    // 自定义铸造函数\n    function mint(uint256 id, uint256 amount) public onlyOwner {\n        _mint(msg.sender, id, amount, \"\");\n    }\n\n    // 自定义批量铸造函数\n    function mintBatch(uint256[] memory ids, uint256[] memory amounts) public onlyOwner {\n        _mintBatch(msg.sender, ids, amounts, \"\");\n    }\n\n    // 自定义销毁函数\n    function burn(address account, uint256 id, uint256 amount) public {\n        require(msg.sender == account, \"Only the token owner can burn tokens\");\n        _burn(account, id, amount);\n    }\n\n    // 自定义批量销毁函数\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public {\n        require(msg.sender == account, \"Only the token owner can burn tokens\");\n        _burnBatch(account, ids, amounts);\n    }\n}\n```\n\n\n---\n\n### 合约说明\n\n5. **ERC1155 基础实现**：\n\n  - 我们继承了 OpenZeppelin 的 `ERC1155` 实现，能够快速实现 ERC-1155 标准的功能。\n\n  - `ERC1155` 构造函数中需要指定一个代币元数据的 URI，可以通过 `id` 动态替换。\n\n6. **代币 ID 和初始铸造**：\n\n  - 定义了 3 种代币类型：`GOLD`（ID 为 1），`SILVER`（ID 为 2），`DIAMOND`（ID 为 3）。\n\n  - 在合约部署时，分别铸造了 1000、5000 和 100 枚代币。\n\n7. **铸造与销毁**：\n\n  - 提供了 `mint` 和 `mintBatch` 方法供合约所有者调用，用于铸造新的代币。\n\n  - 提供了 `burn` 和 `burnBatch` 方法允许代币持有者销毁自己的代币。\n\n8. **批量操作**：\n\n  - 我们可以通过 `_mintBatch` 和 `_burnBatch` 一次性操作多个代币，极大减少了交易复杂度和成本。\n\n---\n\n### 部署与使用\n\n9. **部署**：\n\n  - 使用 Remix 或 Hardhat 部署上面的合约。\n\n  - 部署后，合约创建者会自动成为初始代币的持有者。\n\n10. **查询余额**：\n\n  - 使用 `balanceOf` 方法查询某个账户的指定代币余额。\n\n  - 示例：`balanceOf(address, GOLD)`。\n\n11. **转移代币**：\n\n  - 使用 `safeTransferFrom` 方法将代币发送给其他地址。\n\n  - 示例：\n\n    ```Solidity\n// 从 msg.sender 转移 10 枚 GOLD 给另一个地址\nsafeTransferFrom(msg.sender, recipient, GOLD, 10, \"\");\n```\n\n\n12. **批量转移代币**：\n\n  - 使用 `safeBatchTransferFrom` 方法批量转移多个代币。\n\n  - 示例：\n\n    ```Solidity\n// 从 msg.sender 转移 GOLD 和 SILVER 给另一个地址\nuint256[] memory ids = new uint256[](2);\nids[0] = GOLD;\nids[1] = SILVER;\n\nuint256[] memory amounts = new uint256[](2);\namounts[0] = 10;\namounts[1] = 20;\n\nsafeBatchTransferFrom(msg.sender, recipient, ids, amounts, \"\");\n```\n\n\n---\n\n### ERC-1155 的应用场景\n\n- **游戏资产**：\n\n  - 游戏道具、金币、装备等可以用 ERC-1155 统一管理，并支持批量交易。\n\n- **数字收藏品**：\n\n  - 一个合约中可以包含多种类型的收藏品（如卡牌游戏中的不同稀有度卡片）。\n\n- **门票系统**：\n\n  - 支持活动门票的发行、转移和销毁，既可以是同质化的（如普通票），也可以是非同质化的（如 VIP 定制票）。\n\n---\n\n\n\n","slug":"学习ERC-1155","published":1,"updated":"2025-05-04T12:04:07.461Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8g000sp3j55kgxhhva","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"ERC-1155：可多功能代币标准\"><a href=\"#ERC-1155：可多功能代币标准\" class=\"headerlink\" title=\"ERC-1155：可多功能代币标准\"></a>ERC-1155：可多功能代币标准</h2><h3 id=\"什么是ERC-1155？\"><a href=\"#什么是ERC-1155？\" class=\"headerlink\" title=\"什么是ERC-1155？\"></a>什么是ERC-1155？</h3><p>ERC-1155 是一种以太坊智能合约标准，专为实现多功能代币（Multi-Token Standard）而设计。与 ERC-20（同质化代币）和 ERC-721（非同质化代币）不同，ERC-1155 支持 <strong>同质化代币（Fungible Tokens）</strong> 和 <strong>非同质化代币（Non-Fungible Tokens）</strong> 的混合管理。该标准极大地提高了区块链代币管理的灵活性与效率，尤其适用于游戏、收藏品等对多种资产类型有需求的场景。</p>\n<p>ERC-1155 的主要特点包括：</p>\n<ul>\n<li><p><strong>批量操作</strong>：可以同时转移或创建多个代币，降低了链上操作成本。</p>\n</li>\n<li><p><strong>单一合约管理多种代币</strong>：一个合约中可以包含多种代币类型，而不需要单独部署多个合约。</p>\n</li>\n<li><p><strong>灵活性</strong>：支持同质化代币（如游戏金币）、非同质化代币（如NFT角色）和半同质化代币（如门票）。</p>\n</li>\n<li><p><strong>节约Gas费用</strong>：通过批量操作和共享逻辑减少链上交易成本。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"ERC-1155-的工作原理\"><a href=\"#ERC-1155-的工作原理\" class=\"headerlink\" title=\"ERC-1155 的工作原理\"></a>ERC-1155 的工作原理</h3><p>ERC-1155 定义了一种标准接口，支持以下功能：</p>\n<ol>\n<li><p><strong>代币创建</strong>：可以通过 <code>mint</code> 方法创建新的代币类型。</p>\n</li>\n<li><p><strong>代币转移</strong>：支持单个或批量的代币转移。</p>\n</li>\n<li><p><strong>事件通知</strong>：通过事件（如 <code>TransferSingle</code> 和 <code>TransferBatch</code>）提供透明且高效的状态更新。</p>\n</li>\n<li><p><strong>安全检测</strong>：增加了对智能合约接收代币的安全检测（如 <code>onERC1155Received</code> 和 <code>onERC1155BatchReceived</code>）。</p>\n</li>\n</ol>\n<p>ERC-1155 的核心方法：</p>\n<ul>\n<li><p><code>safeTransferFrom</code>：单个代币的安全转移。</p>\n</li>\n<li><p><code>safeBatchTransferFrom</code>：批量代币的安全转移。</p>\n</li>\n<li><p><code>balanceOf</code>：查询某个账户上的指定代币余额。</p>\n</li>\n<li><p><code>balanceOfBatch</code>：批量查询多个账户的多个代币余额。</p>\n</li>\n<li><p><code>setApprovalForAll</code>：授权某个地址管理所有代币。</p>\n</li>\n<li><p><code>isApprovedForAll</code>：检查授权状态。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"ERC-1155-的用法：代码示例\"><a href=\"#ERC-1155-的用法：代码示例\" class=\"headerlink\" title=\"ERC-1155 的用法：代码示例\"></a>ERC-1155 的用法：代码示例</h3><p>以下是一个简单的 ERC-1155 智能合约，基于 OpenZeppelin 提供的实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">// 引入 OpenZeppelin 的 ERC1155 实现</span><br><span class=\"line\">import &quot;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&quot;;</span><br><span class=\"line\">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyERC1155Token is ERC1155, Ownable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定义代币的 ID</span><br><span class=\"line\">    uint256 public constant GOLD = 1;</span><br><span class=\"line\">    uint256 public constant SILVER = 2;</span><br><span class=\"line\">    uint256 public constant DIAMOND = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造函数：设置代币URI</span><br><span class=\"line\">    constructor() ERC1155(&quot;https://game.example/api/token/&#123;id&#125;.json&quot;) &#123;</span><br><span class=\"line\">        // 铸造初始代币</span><br><span class=\"line\">        _mint(msg.sender, GOLD, 1000, &quot;&quot;); // 1000枚 GOLD 代币</span><br><span class=\"line\">        _mint(msg.sender, SILVER, 5000, &quot;&quot;); // 5000枚 SILVER 代币</span><br><span class=\"line\">        _mint(msg.sender, DIAMOND, 100, &quot;&quot;); // 100枚 DIAMOND 代币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义铸造函数</span><br><span class=\"line\">    function mint(uint256 id, uint256 amount) public onlyOwner &#123;</span><br><span class=\"line\">        _mint(msg.sender, id, amount, &quot;&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义批量铸造函数</span><br><span class=\"line\">    function mintBatch(uint256[] memory ids, uint256[] memory amounts) public onlyOwner &#123;</span><br><span class=\"line\">        _mintBatch(msg.sender, ids, amounts, &quot;&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义销毁函数</span><br><span class=\"line\">    function burn(address account, uint256 id, uint256 amount) public &#123;</span><br><span class=\"line\">        require(msg.sender == account, &quot;Only the token owner can burn tokens&quot;);</span><br><span class=\"line\">        _burn(account, id, amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义批量销毁函数</span><br><span class=\"line\">    function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public &#123;</span><br><span class=\"line\">        require(msg.sender == account, &quot;Only the token owner can burn tokens&quot;);</span><br><span class=\"line\">        _burnBatch(account, ids, amounts);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"合约说明\"><a href=\"#合约说明\" class=\"headerlink\" title=\"合约说明\"></a>合约说明</h3><ol start=\"5\">\n<li><strong>ERC1155 基础实现</strong>：</li>\n</ol>\n<ul>\n<li><p>我们继承了 OpenZeppelin 的 <code>ERC1155</code> 实现，能够快速实现 ERC-1155 标准的功能。</p>\n</li>\n<li><p><code>ERC1155</code> 构造函数中需要指定一个代币元数据的 URI，可以通过 <code>id</code> 动态替换。</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>代币 ID 和初始铸造</strong>：</li>\n</ol>\n<ul>\n<li><p>定义了 3 种代币类型：<code>GOLD</code>（ID 为 1），<code>SILVER</code>（ID 为 2），<code>DIAMOND</code>（ID 为 3）。</p>\n</li>\n<li><p>在合约部署时，分别铸造了 1000、5000 和 100 枚代币。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><strong>铸造与销毁</strong>：</li>\n</ol>\n<ul>\n<li><p>提供了 <code>mint</code> 和 <code>mintBatch</code> 方法供合约所有者调用，用于铸造新的代币。</p>\n</li>\n<li><p>提供了 <code>burn</code> 和 <code>burnBatch</code> 方法允许代币持有者销毁自己的代币。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><strong>批量操作</strong>：</li>\n</ol>\n<ul>\n<li>我们可以通过 <code>_mintBatch</code> 和 <code>_burnBatch</code> 一次性操作多个代币，极大减少了交易复杂度和成本。</li>\n</ul>\n<hr>\n<h3 id=\"部署与使用\"><a href=\"#部署与使用\" class=\"headerlink\" title=\"部署与使用\"></a>部署与使用</h3><ol start=\"9\">\n<li><strong>部署</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 Remix 或 Hardhat 部署上面的合约。</p>\n</li>\n<li><p>部署后，合约创建者会自动成为初始代币的持有者。</p>\n</li>\n</ul>\n<ol start=\"10\">\n<li><strong>查询余额</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 <code>balanceOf</code> 方法查询某个账户的指定代币余额。</p>\n</li>\n<li><p>示例：<code>balanceOf(address, GOLD)</code>。</p>\n</li>\n</ul>\n<ol start=\"11\">\n<li><strong>转移代币</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 <code>safeTransferFrom</code> 方法将代币发送给其他地址。</p>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从 msg.sender 转移 10 枚 GOLD 给另一个地址</span><br><span class=\"line\">safeTransferFrom(msg.sender, recipient, GOLD, 10, &quot;&quot;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"12\">\n<li><strong>批量转移代币</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 <code>safeBatchTransferFrom</code> 方法批量转移多个代币。</p>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从 msg.sender 转移 GOLD 和 SILVER 给另一个地址</span><br><span class=\"line\">uint256[] memory ids = new uint256[](2);</span><br><span class=\"line\">ids[0] = GOLD;</span><br><span class=\"line\">ids[1] = SILVER;</span><br><span class=\"line\"></span><br><span class=\"line\">uint256[] memory amounts = new uint256[](2);</span><br><span class=\"line\">amounts[0] = 10;</span><br><span class=\"line\">amounts[1] = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">safeBatchTransferFrom(msg.sender, recipient, ids, amounts, &quot;&quot;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"ERC-1155-的应用场景\"><a href=\"#ERC-1155-的应用场景\" class=\"headerlink\" title=\"ERC-1155 的应用场景\"></a>ERC-1155 的应用场景</h3><ul>\n<li><p><strong>游戏资产</strong>：</p>\n<ul>\n<li>游戏道具、金币、装备等可以用 ERC-1155 统一管理，并支持批量交易。</li>\n</ul>\n</li>\n<li><p><strong>数字收藏品</strong>：</p>\n<ul>\n<li>一个合约中可以包含多种类型的收藏品（如卡牌游戏中的不同稀有度卡片）。</li>\n</ul>\n</li>\n<li><p><strong>门票系统</strong>：</p>\n<ul>\n<li>支持活动门票的发行、转移和销毁，既可以是同质化的（如普通票），也可以是非同质化的（如 VIP 定制票）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"ERC-1155：可多功能代币标准\"><a href=\"#ERC-1155：可多功能代币标准\" class=\"headerlink\" title=\"ERC-1155：可多功能代币标准\"></a>ERC-1155：可多功能代币标准</h2><h3 id=\"什么是ERC-1155？\"><a href=\"#什么是ERC-1155？\" class=\"headerlink\" title=\"什么是ERC-1155？\"></a>什么是ERC-1155？</h3><p>ERC-1155 是一种以太坊智能合约标准，专为实现多功能代币（Multi-Token Standard）而设计。与 ERC-20（同质化代币）和 ERC-721（非同质化代币）不同，ERC-1155 支持 <strong>同质化代币（Fungible Tokens）</strong> 和 <strong>非同质化代币（Non-Fungible Tokens）</strong> 的混合管理。该标准极大地提高了区块链代币管理的灵活性与效率，尤其适用于游戏、收藏品等对多种资产类型有需求的场景。</p>\n<p>ERC-1155 的主要特点包括：</p>\n<ul>\n<li><p><strong>批量操作</strong>：可以同时转移或创建多个代币，降低了链上操作成本。</p>\n</li>\n<li><p><strong>单一合约管理多种代币</strong>：一个合约中可以包含多种代币类型，而不需要单独部署多个合约。</p>\n</li>\n<li><p><strong>灵活性</strong>：支持同质化代币（如游戏金币）、非同质化代币（如NFT角色）和半同质化代币（如门票）。</p>\n</li>\n<li><p><strong>节约Gas费用</strong>：通过批量操作和共享逻辑减少链上交易成本。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"ERC-1155-的工作原理\"><a href=\"#ERC-1155-的工作原理\" class=\"headerlink\" title=\"ERC-1155 的工作原理\"></a>ERC-1155 的工作原理</h3><p>ERC-1155 定义了一种标准接口，支持以下功能：</p>\n<ol>\n<li><p><strong>代币创建</strong>：可以通过 <code>mint</code> 方法创建新的代币类型。</p>\n</li>\n<li><p><strong>代币转移</strong>：支持单个或批量的代币转移。</p>\n</li>\n<li><p><strong>事件通知</strong>：通过事件（如 <code>TransferSingle</code> 和 <code>TransferBatch</code>）提供透明且高效的状态更新。</p>\n</li>\n<li><p><strong>安全检测</strong>：增加了对智能合约接收代币的安全检测（如 <code>onERC1155Received</code> 和 <code>onERC1155BatchReceived</code>）。</p>\n</li>\n</ol>\n<p>ERC-1155 的核心方法：</p>\n<ul>\n<li><p><code>safeTransferFrom</code>：单个代币的安全转移。</p>\n</li>\n<li><p><code>safeBatchTransferFrom</code>：批量代币的安全转移。</p>\n</li>\n<li><p><code>balanceOf</code>：查询某个账户上的指定代币余额。</p>\n</li>\n<li><p><code>balanceOfBatch</code>：批量查询多个账户的多个代币余额。</p>\n</li>\n<li><p><code>setApprovalForAll</code>：授权某个地址管理所有代币。</p>\n</li>\n<li><p><code>isApprovedForAll</code>：检查授权状态。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"ERC-1155-的用法：代码示例\"><a href=\"#ERC-1155-的用法：代码示例\" class=\"headerlink\" title=\"ERC-1155 的用法：代码示例\"></a>ERC-1155 的用法：代码示例</h3><p>以下是一个简单的 ERC-1155 智能合约，基于 OpenZeppelin 提供的实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">// 引入 OpenZeppelin 的 ERC1155 实现</span><br><span class=\"line\">import &quot;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&quot;;</span><br><span class=\"line\">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyERC1155Token is ERC1155, Ownable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定义代币的 ID</span><br><span class=\"line\">    uint256 public constant GOLD = 1;</span><br><span class=\"line\">    uint256 public constant SILVER = 2;</span><br><span class=\"line\">    uint256 public constant DIAMOND = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造函数：设置代币URI</span><br><span class=\"line\">    constructor() ERC1155(&quot;https://game.example/api/token/&#123;id&#125;.json&quot;) &#123;</span><br><span class=\"line\">        // 铸造初始代币</span><br><span class=\"line\">        _mint(msg.sender, GOLD, 1000, &quot;&quot;); // 1000枚 GOLD 代币</span><br><span class=\"line\">        _mint(msg.sender, SILVER, 5000, &quot;&quot;); // 5000枚 SILVER 代币</span><br><span class=\"line\">        _mint(msg.sender, DIAMOND, 100, &quot;&quot;); // 100枚 DIAMOND 代币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义铸造函数</span><br><span class=\"line\">    function mint(uint256 id, uint256 amount) public onlyOwner &#123;</span><br><span class=\"line\">        _mint(msg.sender, id, amount, &quot;&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义批量铸造函数</span><br><span class=\"line\">    function mintBatch(uint256[] memory ids, uint256[] memory amounts) public onlyOwner &#123;</span><br><span class=\"line\">        _mintBatch(msg.sender, ids, amounts, &quot;&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义销毁函数</span><br><span class=\"line\">    function burn(address account, uint256 id, uint256 amount) public &#123;</span><br><span class=\"line\">        require(msg.sender == account, &quot;Only the token owner can burn tokens&quot;);</span><br><span class=\"line\">        _burn(account, id, amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义批量销毁函数</span><br><span class=\"line\">    function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public &#123;</span><br><span class=\"line\">        require(msg.sender == account, &quot;Only the token owner can burn tokens&quot;);</span><br><span class=\"line\">        _burnBatch(account, ids, amounts);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"合约说明\"><a href=\"#合约说明\" class=\"headerlink\" title=\"合约说明\"></a>合约说明</h3><ol start=\"5\">\n<li><strong>ERC1155 基础实现</strong>：</li>\n</ol>\n<ul>\n<li><p>我们继承了 OpenZeppelin 的 <code>ERC1155</code> 实现，能够快速实现 ERC-1155 标准的功能。</p>\n</li>\n<li><p><code>ERC1155</code> 构造函数中需要指定一个代币元数据的 URI，可以通过 <code>id</code> 动态替换。</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>代币 ID 和初始铸造</strong>：</li>\n</ol>\n<ul>\n<li><p>定义了 3 种代币类型：<code>GOLD</code>（ID 为 1），<code>SILVER</code>（ID 为 2），<code>DIAMOND</code>（ID 为 3）。</p>\n</li>\n<li><p>在合约部署时，分别铸造了 1000、5000 和 100 枚代币。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><strong>铸造与销毁</strong>：</li>\n</ol>\n<ul>\n<li><p>提供了 <code>mint</code> 和 <code>mintBatch</code> 方法供合约所有者调用，用于铸造新的代币。</p>\n</li>\n<li><p>提供了 <code>burn</code> 和 <code>burnBatch</code> 方法允许代币持有者销毁自己的代币。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><strong>批量操作</strong>：</li>\n</ol>\n<ul>\n<li>我们可以通过 <code>_mintBatch</code> 和 <code>_burnBatch</code> 一次性操作多个代币，极大减少了交易复杂度和成本。</li>\n</ul>\n<hr>\n<h3 id=\"部署与使用\"><a href=\"#部署与使用\" class=\"headerlink\" title=\"部署与使用\"></a>部署与使用</h3><ol start=\"9\">\n<li><strong>部署</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 Remix 或 Hardhat 部署上面的合约。</p>\n</li>\n<li><p>部署后，合约创建者会自动成为初始代币的持有者。</p>\n</li>\n</ul>\n<ol start=\"10\">\n<li><strong>查询余额</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 <code>balanceOf</code> 方法查询某个账户的指定代币余额。</p>\n</li>\n<li><p>示例：<code>balanceOf(address, GOLD)</code>。</p>\n</li>\n</ul>\n<ol start=\"11\">\n<li><strong>转移代币</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 <code>safeTransferFrom</code> 方法将代币发送给其他地址。</p>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从 msg.sender 转移 10 枚 GOLD 给另一个地址</span><br><span class=\"line\">safeTransferFrom(msg.sender, recipient, GOLD, 10, &quot;&quot;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"12\">\n<li><strong>批量转移代币</strong>：</li>\n</ol>\n<ul>\n<li><p>使用 <code>safeBatchTransferFrom</code> 方法批量转移多个代币。</p>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从 msg.sender 转移 GOLD 和 SILVER 给另一个地址</span><br><span class=\"line\">uint256[] memory ids = new uint256[](2);</span><br><span class=\"line\">ids[0] = GOLD;</span><br><span class=\"line\">ids[1] = SILVER;</span><br><span class=\"line\"></span><br><span class=\"line\">uint256[] memory amounts = new uint256[](2);</span><br><span class=\"line\">amounts[0] = 10;</span><br><span class=\"line\">amounts[1] = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">safeBatchTransferFrom(msg.sender, recipient, ids, amounts, &quot;&quot;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"ERC-1155-的应用场景\"><a href=\"#ERC-1155-的应用场景\" class=\"headerlink\" title=\"ERC-1155 的应用场景\"></a>ERC-1155 的应用场景</h3><ul>\n<li><p><strong>游戏资产</strong>：</p>\n<ul>\n<li>游戏道具、金币、装备等可以用 ERC-1155 统一管理，并支持批量交易。</li>\n</ul>\n</li>\n<li><p><strong>数字收藏品</strong>：</p>\n<ul>\n<li>一个合约中可以包含多种类型的收藏品（如卡牌游戏中的不同稀有度卡片）。</li>\n</ul>\n</li>\n<li><p><strong>门票系统</strong>：</p>\n<ul>\n<li>支持活动门票的发行、转移和销毁，既可以是同质化的（如普通票），也可以是非同质化的（如 VIP 定制票）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n"},{"title":"指针vs引用","description":" Java 和 Go 在实际开发中都大量使用“引用”，区别在于：Go 需要你手动声明使用指针，而 Java 默认一切对象就是引用。","toc":false,"date":"2025-05-11T01:41:27.000Z","_content":"\n---\n\n## 🧩 总体对比表：Go vs Java（指针 vs 引用）\n\n| 场景编号 | 场景描述          | Go（是否用指针）             | Java（是否需要显式指针）        |\n| ---- | ------------- | --------------------- | --------------------- |\n| 1    | 修改结构体字段       | ✅ 是，结构体传 `*Struct`    | ✅ 是，所有对象都是引用          |\n| 2    | 缓存中存对象引用      | ✅ 是，map\\[string]\\*Obj | ✅ 是，Map 存对象引用         |\n| 3    | 可选字段（判断是否有传参） | ✅ 是，字段类型设为指针          | ✅ 是，用 boxed 类型判断 null |\n| 4    | 大结构体传参/返回值    | ✅ 是，传 `*Config` 节省复制  | ✅ 是，对象就是引用            |\n| 5    | 链表/树结构        | ✅ 是，结构体内嵌指针字段         | ✅ 是，类字段是引用类型          |\n| 6    | 组合结构体         | ✅ 是，字段类型为指针           | ✅ 是，成员变量就是引用          |\n\n---\n\n## 🔍 分场景详解对比\n\n---\n\n### ✅ 场景 1：修改结构体字段\n\n#### Go：\n\n```go\ntype User struct {\n\tName string\n}\nfunc updateName(u *User) {\n\tu.Name = \"Alice\"\n}\n```\n\n#### Java：\n\n```java\nclass User {\n\tString name;\n}\nvoid updateName(User u) {\n\tu.name = \"Alice\";\n}\n```\n\n📌 **区别：**\n\n* Go 需要用 `*User` 明确是指针，否则值传递会拷贝。\n* Java 所有对象传参天然是引用，直接修改。\n\n---\n\n### ✅ 场景 2：缓存中引用对象\n\n#### Go：\n\n```go\ncache := map[string]*Product{}\n```\n\n#### Java：\n\n```java\nMap<String, Product> cache = new HashMap<>();\n```\n\n📌 **区别：**\n\n* Go 明确用 `*Product`，节省内存。\n* Java 中 `Product` 是引用，不需要额外操作。\n\n---\n\n### ✅ 场景 3：可选字段（如 API 请求中可能未传）\n\n#### Go：\n\n```go\ntype UpdateUserRequest struct {\n\tName *string // 可判断是否传\n}\n```\n\n#### Java：\n\n```java\nclass UpdateUserRequest {\n\tString name; // 默认 null 就是“没传”\n}\n```\n\n📌 **区别：**\n\n* Go 需要用指针来区分“没传” vs “传了默认值”。\n* Java 所有对象默认可能是 `null`，可以直接用 `if (req.name != null)` 判断。\n\n---\n\n### ✅ 场景 4：返回或传入大型配置对象\n\n#### Go：\n\n```go\nfunc LoadConfig() *Config {\n\treturn &Config{}\n}\n```\n\n#### Java：\n\n```java\nConfig loadConfig() {\n\treturn new Config();\n}\n```\n\n📌 **区别：**\n\n* Go：返回指针防止复制整个结构体。\n* Java：默认就是返回引用，天然高效。\n\n---\n\n### ✅ 场景 5：链表、树等结构体\n\n#### Go：\n\n```go\ntype Node struct {\n\tVal  int\n\tNext *Node\n}\n```\n\n#### Java：\n\n```java\nclass Node {\n\tint val;\n\tNode next;\n}\n```\n\n📌 **区别：**\n\n* Go 要用 `*Node` 明确引用关系。\n* Java 中 `Node` 字段天然就是引用类型。\n\n---\n\n### ✅ 场景 6：组合结构体\n\n#### Go：\n\n```go\ntype Order struct {\n\tUser *User\n}\n```\n\n#### Java：\n\n```java\nclass Order {\n\tUser user;\n}\n```\n\n📌 **区别：**\n\n* Go 中组合用指针字段可避免复制。\n* Java 所有类字段本身就是引用，默认行为就是组合。\n\n---\n\n## 🧠 总结：Go vs Java 指针/引用哲学\n\n| 方面          | Go                   | Java      |\n| ----------- | -------------------- | --------- |\n| 值 vs 引用     | 区分明确（值类型 vs 指针）      | 所有对象默认是引用 |\n| 是否需要手动加 `*` | ✅ 是，需要指明引用           | ❌ 不需要     |\n| 内存管理        | 自动垃圾回收（有指针但无手动 free） | 自动垃圾回收    |\n| 安全性         | 不支持指针运算，较安全          | 更安全，无裸指针  |\n| 可选字段建模      | 通过 `*T` 判断是否设置       | 判断 `null` |\n| 性能优化（避免复制）  | 手动使用指针传参             | 默认就是引用传递  |\n\n---\n\n## 📌 总结一句话：\n\n> Java 和 Go 在实际开发中都大量使用“引用”，区别在于：**Go 需要你手动声明使用指针，而 Java 默认一切对象就是引用。**\n\n---\n\n","source":"_posts/指针vs引用.md","raw":"---\ntitle: 指针vs引用\ndescription: ' Java 和 Go 在实际开发中都大量使用“引用”，区别在于：Go 需要你手动声明使用指针，而 Java 默认一切对象就是引用。'\ntags: []\ntoc: false\ndate: 2025-05-11 09:41:27\ncategories:\n---\n\n---\n\n## 🧩 总体对比表：Go vs Java（指针 vs 引用）\n\n| 场景编号 | 场景描述          | Go（是否用指针）             | Java（是否需要显式指针）        |\n| ---- | ------------- | --------------------- | --------------------- |\n| 1    | 修改结构体字段       | ✅ 是，结构体传 `*Struct`    | ✅ 是，所有对象都是引用          |\n| 2    | 缓存中存对象引用      | ✅ 是，map\\[string]\\*Obj | ✅ 是，Map 存对象引用         |\n| 3    | 可选字段（判断是否有传参） | ✅ 是，字段类型设为指针          | ✅ 是，用 boxed 类型判断 null |\n| 4    | 大结构体传参/返回值    | ✅ 是，传 `*Config` 节省复制  | ✅ 是，对象就是引用            |\n| 5    | 链表/树结构        | ✅ 是，结构体内嵌指针字段         | ✅ 是，类字段是引用类型          |\n| 6    | 组合结构体         | ✅ 是，字段类型为指针           | ✅ 是，成员变量就是引用          |\n\n---\n\n## 🔍 分场景详解对比\n\n---\n\n### ✅ 场景 1：修改结构体字段\n\n#### Go：\n\n```go\ntype User struct {\n\tName string\n}\nfunc updateName(u *User) {\n\tu.Name = \"Alice\"\n}\n```\n\n#### Java：\n\n```java\nclass User {\n\tString name;\n}\nvoid updateName(User u) {\n\tu.name = \"Alice\";\n}\n```\n\n📌 **区别：**\n\n* Go 需要用 `*User` 明确是指针，否则值传递会拷贝。\n* Java 所有对象传参天然是引用，直接修改。\n\n---\n\n### ✅ 场景 2：缓存中引用对象\n\n#### Go：\n\n```go\ncache := map[string]*Product{}\n```\n\n#### Java：\n\n```java\nMap<String, Product> cache = new HashMap<>();\n```\n\n📌 **区别：**\n\n* Go 明确用 `*Product`，节省内存。\n* Java 中 `Product` 是引用，不需要额外操作。\n\n---\n\n### ✅ 场景 3：可选字段（如 API 请求中可能未传）\n\n#### Go：\n\n```go\ntype UpdateUserRequest struct {\n\tName *string // 可判断是否传\n}\n```\n\n#### Java：\n\n```java\nclass UpdateUserRequest {\n\tString name; // 默认 null 就是“没传”\n}\n```\n\n📌 **区别：**\n\n* Go 需要用指针来区分“没传” vs “传了默认值”。\n* Java 所有对象默认可能是 `null`，可以直接用 `if (req.name != null)` 判断。\n\n---\n\n### ✅ 场景 4：返回或传入大型配置对象\n\n#### Go：\n\n```go\nfunc LoadConfig() *Config {\n\treturn &Config{}\n}\n```\n\n#### Java：\n\n```java\nConfig loadConfig() {\n\treturn new Config();\n}\n```\n\n📌 **区别：**\n\n* Go：返回指针防止复制整个结构体。\n* Java：默认就是返回引用，天然高效。\n\n---\n\n### ✅ 场景 5：链表、树等结构体\n\n#### Go：\n\n```go\ntype Node struct {\n\tVal  int\n\tNext *Node\n}\n```\n\n#### Java：\n\n```java\nclass Node {\n\tint val;\n\tNode next;\n}\n```\n\n📌 **区别：**\n\n* Go 要用 `*Node` 明确引用关系。\n* Java 中 `Node` 字段天然就是引用类型。\n\n---\n\n### ✅ 场景 6：组合结构体\n\n#### Go：\n\n```go\ntype Order struct {\n\tUser *User\n}\n```\n\n#### Java：\n\n```java\nclass Order {\n\tUser user;\n}\n```\n\n📌 **区别：**\n\n* Go 中组合用指针字段可避免复制。\n* Java 所有类字段本身就是引用，默认行为就是组合。\n\n---\n\n## 🧠 总结：Go vs Java 指针/引用哲学\n\n| 方面          | Go                   | Java      |\n| ----------- | -------------------- | --------- |\n| 值 vs 引用     | 区分明确（值类型 vs 指针）      | 所有对象默认是引用 |\n| 是否需要手动加 `*` | ✅ 是，需要指明引用           | ❌ 不需要     |\n| 内存管理        | 自动垃圾回收（有指针但无手动 free） | 自动垃圾回收    |\n| 安全性         | 不支持指针运算，较安全          | 更安全，无裸指针  |\n| 可选字段建模      | 通过 `*T` 判断是否设置       | 判断 `null` |\n| 性能优化（避免复制）  | 手动使用指针传参             | 默认就是引用传递  |\n\n---\n\n## 📌 总结一句话：\n\n> Java 和 Go 在实际开发中都大量使用“引用”，区别在于：**Go 需要你手动声明使用指针，而 Java 默认一切对象就是引用。**\n\n---\n\n","slug":"指针vs引用","published":1,"updated":"2025-05-11T01:42:15.990Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8h000vp3j5fa2ddyfo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><hr>\n<h2 id=\"🧩-总体对比表：Go-vs-Java（指针-vs-引用）\"><a href=\"#🧩-总体对比表：Go-vs-Java（指针-vs-引用）\" class=\"headerlink\" title=\"🧩 总体对比表：Go vs Java（指针 vs 引用）\"></a>🧩 总体对比表：Go vs Java（指针 vs 引用）</h2><table>\n<thead>\n<tr>\n<th>场景编号</th>\n<th>场景描述</th>\n<th>Go（是否用指针）</th>\n<th>Java（是否需要显式指针）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>修改结构体字段</td>\n<td>✅ 是，结构体传 <code>*Struct</code></td>\n<td>✅ 是，所有对象都是引用</td>\n</tr>\n<tr>\n<td>2</td>\n<td>缓存中存对象引用</td>\n<td>✅ 是，map[string]*Obj</td>\n<td>✅ 是，Map 存对象引用</td>\n</tr>\n<tr>\n<td>3</td>\n<td>可选字段（判断是否有传参）</td>\n<td>✅ 是，字段类型设为指针</td>\n<td>✅ 是，用 boxed 类型判断 null</td>\n</tr>\n<tr>\n<td>4</td>\n<td>大结构体传参&#x2F;返回值</td>\n<td>✅ 是，传 <code>*Config</code> 节省复制</td>\n<td>✅ 是，对象就是引用</td>\n</tr>\n<tr>\n<td>5</td>\n<td>链表&#x2F;树结构</td>\n<td>✅ 是，结构体内嵌指针字段</td>\n<td>✅ 是，类字段是引用类型</td>\n</tr>\n<tr>\n<td>6</td>\n<td>组合结构体</td>\n<td>✅ 是，字段类型为指针</td>\n<td>✅ 是，成员变量就是引用</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔍-分场景详解对比\"><a href=\"#🔍-分场景详解对比\" class=\"headerlink\" title=\"🔍 分场景详解对比\"></a>🔍 分场景详解对比</h2><hr>\n<h3 id=\"✅-场景-1：修改结构体字段\"><a href=\"#✅-场景-1：修改结构体字段\" class=\"headerlink\" title=\"✅ 场景 1：修改结构体字段\"></a>✅ 场景 1：修改结构体字段</h3><h4 id=\"Go：\"><a href=\"#Go：\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateName</span><span class=\"params\">(u *User)</span></span> &#123;</span><br><span class=\"line\">\tu.Name = <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：\"><a href=\"#Java：\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">updateName</span><span class=\"params\">(User u)</span> &#123;</span><br><span class=\"line\">\tu.name = <span class=\"string\">&quot;Alice&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 需要用 <code>*User</code> 明确是指针，否则值传递会拷贝。</li>\n<li>Java 所有对象传参天然是引用，直接修改。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-2：缓存中引用对象\"><a href=\"#✅-场景-2：缓存中引用对象\" class=\"headerlink\" title=\"✅ 场景 2：缓存中引用对象\"></a>✅ 场景 2：缓存中引用对象</h3><h4 id=\"Go：-1\"><a href=\"#Go：-1\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cache := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*Product&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-1\"><a href=\"#Java：-1\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Product&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 明确用 <code>*Product</code>，节省内存。</li>\n<li>Java 中 <code>Product</code> 是引用，不需要额外操作。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-3：可选字段（如-API-请求中可能未传）\"><a href=\"#✅-场景-3：可选字段（如-API-请求中可能未传）\" class=\"headerlink\" title=\"✅ 场景 3：可选字段（如 API 请求中可能未传）\"></a>✅ 场景 3：可选字段（如 API 请求中可能未传）</h3><h4 id=\"Go：-2\"><a href=\"#Go：-2\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UpdateUserRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tName *<span class=\"type\">string</span> <span class=\"comment\">// 可判断是否传</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-2\"><a href=\"#Java：-2\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpdateUserRequest</span> &#123;</span><br><span class=\"line\">\tString name; <span class=\"comment\">// 默认 null 就是“没传”</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 需要用指针来区分“没传” vs “传了默认值”。</li>\n<li>Java 所有对象默认可能是 <code>null</code>，可以直接用 <code>if (req.name != null)</code> 判断。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-4：返回或传入大型配置对象\"><a href=\"#✅-场景-4：返回或传入大型配置对象\" class=\"headerlink\" title=\"✅ 场景 4：返回或传入大型配置对象\"></a>✅ 场景 4：返回或传入大型配置对象</h3><h4 id=\"Go：-3\"><a href=\"#Go：-3\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConfig</span><span class=\"params\">()</span></span> *Config &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Config&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-3\"><a href=\"#Java：-3\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Config <span class=\"title function_\">loadConfig</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go：返回指针防止复制整个结构体。</li>\n<li>Java：默认就是返回引用，天然高效。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-5：链表、树等结构体\"><a href=\"#✅-场景-5：链表、树等结构体\" class=\"headerlink\" title=\"✅ 场景 5：链表、树等结构体\"></a>✅ 场景 5：链表、树等结构体</h3><h4 id=\"Go：-4\"><a href=\"#Go：-4\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tVal  <span class=\"type\">int</span></span><br><span class=\"line\">\tNext *Node</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-4\"><a href=\"#Java：-4\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> val;</span><br><span class=\"line\">\tNode next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 要用 <code>*Node</code> 明确引用关系。</li>\n<li>Java 中 <code>Node</code> 字段天然就是引用类型。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-6：组合结构体\"><a href=\"#✅-场景-6：组合结构体\" class=\"headerlink\" title=\"✅ 场景 6：组合结构体\"></a>✅ 场景 6：组合结构体</h3><h4 id=\"Go：-5\"><a href=\"#Go：-5\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Order <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tUser *User</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-5\"><a href=\"#Java：-5\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">\tUser user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 中组合用指针字段可避免复制。</li>\n<li>Java 所有类字段本身就是引用，默认行为就是组合。</li>\n</ul>\n<hr>\n<h2 id=\"🧠-总结：Go-vs-Java-指针-引用哲学\"><a href=\"#🧠-总结：Go-vs-Java-指针-引用哲学\" class=\"headerlink\" title=\"🧠 总结：Go vs Java 指针&#x2F;引用哲学\"></a>🧠 总结：Go vs Java 指针&#x2F;引用哲学</h2><table>\n<thead>\n<tr>\n<th>方面</th>\n<th>Go</th>\n<th>Java</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>值 vs 引用</td>\n<td>区分明确（值类型 vs 指针）</td>\n<td>所有对象默认是引用</td>\n</tr>\n<tr>\n<td>是否需要手动加 <code>*</code></td>\n<td>✅ 是，需要指明引用</td>\n<td>❌ 不需要</td>\n</tr>\n<tr>\n<td>内存管理</td>\n<td>自动垃圾回收（有指针但无手动 free）</td>\n<td>自动垃圾回收</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>不支持指针运算，较安全</td>\n<td>更安全，无裸指针</td>\n</tr>\n<tr>\n<td>可选字段建模</td>\n<td>通过 <code>*T</code> 判断是否设置</td>\n<td>判断 <code>null</code></td>\n</tr>\n<tr>\n<td>性能优化（避免复制）</td>\n<td>手动使用指针传参</td>\n<td>默认就是引用传递</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📌-总结一句话：\"><a href=\"#📌-总结一句话：\" class=\"headerlink\" title=\"📌 总结一句话：\"></a>📌 总结一句话：</h2><blockquote>\n<p>Java 和 Go 在实际开发中都大量使用“引用”，区别在于：<strong>Go 需要你手动声明使用指针，而 Java 默认一切对象就是引用。</strong></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<hr>\n<h2 id=\"🧩-总体对比表：Go-vs-Java（指针-vs-引用）\"><a href=\"#🧩-总体对比表：Go-vs-Java（指针-vs-引用）\" class=\"headerlink\" title=\"🧩 总体对比表：Go vs Java（指针 vs 引用）\"></a>🧩 总体对比表：Go vs Java（指针 vs 引用）</h2><table>\n<thead>\n<tr>\n<th>场景编号</th>\n<th>场景描述</th>\n<th>Go（是否用指针）</th>\n<th>Java（是否需要显式指针）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>修改结构体字段</td>\n<td>✅ 是，结构体传 <code>*Struct</code></td>\n<td>✅ 是，所有对象都是引用</td>\n</tr>\n<tr>\n<td>2</td>\n<td>缓存中存对象引用</td>\n<td>✅ 是，map[string]*Obj</td>\n<td>✅ 是，Map 存对象引用</td>\n</tr>\n<tr>\n<td>3</td>\n<td>可选字段（判断是否有传参）</td>\n<td>✅ 是，字段类型设为指针</td>\n<td>✅ 是，用 boxed 类型判断 null</td>\n</tr>\n<tr>\n<td>4</td>\n<td>大结构体传参&#x2F;返回值</td>\n<td>✅ 是，传 <code>*Config</code> 节省复制</td>\n<td>✅ 是，对象就是引用</td>\n</tr>\n<tr>\n<td>5</td>\n<td>链表&#x2F;树结构</td>\n<td>✅ 是，结构体内嵌指针字段</td>\n<td>✅ 是，类字段是引用类型</td>\n</tr>\n<tr>\n<td>6</td>\n<td>组合结构体</td>\n<td>✅ 是，字段类型为指针</td>\n<td>✅ 是，成员变量就是引用</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔍-分场景详解对比\"><a href=\"#🔍-分场景详解对比\" class=\"headerlink\" title=\"🔍 分场景详解对比\"></a>🔍 分场景详解对比</h2><hr>\n<h3 id=\"✅-场景-1：修改结构体字段\"><a href=\"#✅-场景-1：修改结构体字段\" class=\"headerlink\" title=\"✅ 场景 1：修改结构体字段\"></a>✅ 场景 1：修改结构体字段</h3><h4 id=\"Go：\"><a href=\"#Go：\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateName</span><span class=\"params\">(u *User)</span></span> &#123;</span><br><span class=\"line\">\tu.Name = <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：\"><a href=\"#Java：\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">updateName</span><span class=\"params\">(User u)</span> &#123;</span><br><span class=\"line\">\tu.name = <span class=\"string\">&quot;Alice&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 需要用 <code>*User</code> 明确是指针，否则值传递会拷贝。</li>\n<li>Java 所有对象传参天然是引用，直接修改。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-2：缓存中引用对象\"><a href=\"#✅-场景-2：缓存中引用对象\" class=\"headerlink\" title=\"✅ 场景 2：缓存中引用对象\"></a>✅ 场景 2：缓存中引用对象</h3><h4 id=\"Go：-1\"><a href=\"#Go：-1\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cache := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*Product&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-1\"><a href=\"#Java：-1\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Product&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 明确用 <code>*Product</code>，节省内存。</li>\n<li>Java 中 <code>Product</code> 是引用，不需要额外操作。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-3：可选字段（如-API-请求中可能未传）\"><a href=\"#✅-场景-3：可选字段（如-API-请求中可能未传）\" class=\"headerlink\" title=\"✅ 场景 3：可选字段（如 API 请求中可能未传）\"></a>✅ 场景 3：可选字段（如 API 请求中可能未传）</h3><h4 id=\"Go：-2\"><a href=\"#Go：-2\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UpdateUserRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tName *<span class=\"type\">string</span> <span class=\"comment\">// 可判断是否传</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-2\"><a href=\"#Java：-2\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpdateUserRequest</span> &#123;</span><br><span class=\"line\">\tString name; <span class=\"comment\">// 默认 null 就是“没传”</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 需要用指针来区分“没传” vs “传了默认值”。</li>\n<li>Java 所有对象默认可能是 <code>null</code>，可以直接用 <code>if (req.name != null)</code> 判断。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-4：返回或传入大型配置对象\"><a href=\"#✅-场景-4：返回或传入大型配置对象\" class=\"headerlink\" title=\"✅ 场景 4：返回或传入大型配置对象\"></a>✅ 场景 4：返回或传入大型配置对象</h3><h4 id=\"Go：-3\"><a href=\"#Go：-3\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConfig</span><span class=\"params\">()</span></span> *Config &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Config&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-3\"><a href=\"#Java：-3\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Config <span class=\"title function_\">loadConfig</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go：返回指针防止复制整个结构体。</li>\n<li>Java：默认就是返回引用，天然高效。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-5：链表、树等结构体\"><a href=\"#✅-场景-5：链表、树等结构体\" class=\"headerlink\" title=\"✅ 场景 5：链表、树等结构体\"></a>✅ 场景 5：链表、树等结构体</h3><h4 id=\"Go：-4\"><a href=\"#Go：-4\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tVal  <span class=\"type\">int</span></span><br><span class=\"line\">\tNext *Node</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-4\"><a href=\"#Java：-4\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> val;</span><br><span class=\"line\">\tNode next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 要用 <code>*Node</code> 明确引用关系。</li>\n<li>Java 中 <code>Node</code> 字段天然就是引用类型。</li>\n</ul>\n<hr>\n<h3 id=\"✅-场景-6：组合结构体\"><a href=\"#✅-场景-6：组合结构体\" class=\"headerlink\" title=\"✅ 场景 6：组合结构体\"></a>✅ 场景 6：组合结构体</h3><h4 id=\"Go：-5\"><a href=\"#Go：-5\" class=\"headerlink\" title=\"Go：\"></a>Go：</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Order <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tUser *User</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java：-5\"><a href=\"#Java：-5\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">\tUser user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>📌 <strong>区别：</strong></p>\n<ul>\n<li>Go 中组合用指针字段可避免复制。</li>\n<li>Java 所有类字段本身就是引用，默认行为就是组合。</li>\n</ul>\n<hr>\n<h2 id=\"🧠-总结：Go-vs-Java-指针-引用哲学\"><a href=\"#🧠-总结：Go-vs-Java-指针-引用哲学\" class=\"headerlink\" title=\"🧠 总结：Go vs Java 指针&#x2F;引用哲学\"></a>🧠 总结：Go vs Java 指针&#x2F;引用哲学</h2><table>\n<thead>\n<tr>\n<th>方面</th>\n<th>Go</th>\n<th>Java</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>值 vs 引用</td>\n<td>区分明确（值类型 vs 指针）</td>\n<td>所有对象默认是引用</td>\n</tr>\n<tr>\n<td>是否需要手动加 <code>*</code></td>\n<td>✅ 是，需要指明引用</td>\n<td>❌ 不需要</td>\n</tr>\n<tr>\n<td>内存管理</td>\n<td>自动垃圾回收（有指针但无手动 free）</td>\n<td>自动垃圾回收</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>不支持指针运算，较安全</td>\n<td>更安全，无裸指针</td>\n</tr>\n<tr>\n<td>可选字段建模</td>\n<td>通过 <code>*T</code> 判断是否设置</td>\n<td>判断 <code>null</code></td>\n</tr>\n<tr>\n<td>性能优化（避免复制）</td>\n<td>手动使用指针传参</td>\n<td>默认就是引用传递</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📌-总结一句话：\"><a href=\"#📌-总结一句话：\" class=\"headerlink\" title=\"📌 总结一句话：\"></a>📌 总结一句话：</h2><blockquote>\n<p>Java 和 Go 在实际开发中都大量使用“引用”，区别在于：<strong>Go 需要你手动声明使用指针，而 Java 默认一切对象就是引用。</strong></p>\n</blockquote>\n<hr>\n"},{"title":"Solidity中的转账","description":"在 Solidity 中，`transfer`、`send` 和 `call` 是用于向外部地址发送 ETH 的三种方法，但它们的行为和安全性存在显著差异。","toc":false,"date":"2025-05-04T10:18:06.000Z","_content":"在 Solidity 中，`transfer`、`send` 和 `call` 是用于向外部地址发送 ETH 的三种方法，但它们的行为和安全性存在显著差异。以下是它们的用法、区别及最佳实践。\n\n---\n\n### 1. **`transfer` (不推荐使用)**\n\n**用法**：\n\n```Solidity\naddress payable recipient = payable(0x123...);\nrecipient.transfer(amount);\n```\n\n\n**特点**：\n• **Gas 限制**：固定 2300 gas，足够触发接收合约的 `receive()` 或 `fallback()` 函数，但不足以执行复杂逻辑。\n• **错误处理**：如果发送失败（如接收合约抛出异常或 gas 不足），`transfer` 会抛出异常并回滚整个交易。\n• **弃用警告**：自 Solidity 0.8.0 起，`transfer` 和 `send` 不再推荐使用，因为固定的 2300 gas 可能在未来网络中不足（如 EIP-1884 提高了部分操作码的 gas 消耗）。\n\n---\n\n### 2. **`send` (不推荐使用)**\n\n**用法**：\n\n```Solidity\naddress payable recipient = payable(0x123...);\nbool success = recipient.send(amount);\nif (!success) {\n    // 处理发送失败\n}\n```\n\n\n**特点**：\n• **Gas 限制**：与 `transfer` 相同（2300 gas）。\n• **错误处理**：失败时返回 `false` 而非抛出异常，需手动检查返回值。\n• **弃用原因**：与 `transfer` 相同，2300 gas 可能不足。\n\n---\n\n### 3. **`call` (推荐方式)**\n\n**用法**：\n\n```Solidity\naddress payable recipient = payable(0x123...);\n(bool success, bytes memory data) = recipient.call{value: amount}(\"\");\nrequire(success, \"ETH transfer failed\");\n```\n\n\n**特点**：\n• **Gas 限制**：无硬编码限制，默认传递所有剩余 gas（可通过 `gas` 参数自定义，如 `.call{value: amount, gas: 50000}(\"\")`）。\n• **错误处理**：返回 `(bool success, bytes data)`，需手动检查 `success`。\n• **灵活性**：支持调用任意函数（如 `.call{value: amount}(abi.encodeWithSignature(\"foo(uint256)\", 123))`），但需警惕重入攻击。\n• **最佳实践**：当前推荐用于 ETH 转账，因其兼容性更好（如支持智能合约的复杂逻辑）。\n\n---\n\n### **关键区别**\n\n|方法|Gas 限制|错误处理|推荐程度|适用场景|\n|-|-|-|-|-|\n|`transfer`|固定 2300 gas|抛出异常|❌ 弃用|简单转账（旧代码）|\n|`send`|固定 2300 gas|返回 `bool`|❌ 弃用|需手动处理失败的转账|\n|`call`|可自定义 gas|返回 `(bool, bytes)`|✅ 推荐|现代合约（需防重入）|\n\n---\n\n### **最佳实践**\n\n1. **使用 `call` 并检查返回值**\n\n  ```Solidity\n(bool success, ) = recipient.call{value: amount}(\"\");\nrequire(success, \"Transfer failed\");\n```\n\n\n2. **防范重入攻击**\n• 在调用外部合约前执行所有状态变更（遵循 [Checks-Effects-Interactions](https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) 模式）。\n• 使用重入锁（如 OpenZeppelin 的 `ReentrancyGuard`）：\n\n  ```Solidity\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\ncontract MyContract is ReentrancyGuard {\n    function safeTransfer(address payable recipient) external payable nonReentrant {\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        require(success);\n    }\n}\n```\n\n\n3. **明确 gas 限制**\n如果接收方是合约，且不确定其逻辑是否安全，可限制 gas：\n\n  ```Solidity\nrecipient.call{value: amount, gas: 50000}(\"\");\n```\n\n\n4. **避免使用 `transfer` 和 `send`**\n除非维护旧代码，否则优先使用 `call`。\n\n---\n\n### **总结**\n\n• **简单转账**：用 `call` + `require` 检查。\n• **合约交互**：用 `call` 自定义 gas 并防范重入。\n• **弃用方法**：避免 `transfer` 和 `send`，因其 gas 限制可能导致未来兼容性问题。\n\n\n\n","source":"_posts/Solidity中的转账.md","raw":"---\ntitle: Solidity中的转账\ndescription: '在 Solidity 中，`transfer`、`send` 和 `call` 是用于向外部地址发送 ETH 的三种方法，但它们的行为和安全性存在显著差异。'\ntags: ['Solidity','web3']\ntoc: false\ndate: 2025-05-04 18:18:06\ncategories: Solidity学习\n---\n在 Solidity 中，`transfer`、`send` 和 `call` 是用于向外部地址发送 ETH 的三种方法，但它们的行为和安全性存在显著差异。以下是它们的用法、区别及最佳实践。\n\n---\n\n### 1. **`transfer` (不推荐使用)**\n\n**用法**：\n\n```Solidity\naddress payable recipient = payable(0x123...);\nrecipient.transfer(amount);\n```\n\n\n**特点**：\n• **Gas 限制**：固定 2300 gas，足够触发接收合约的 `receive()` 或 `fallback()` 函数，但不足以执行复杂逻辑。\n• **错误处理**：如果发送失败（如接收合约抛出异常或 gas 不足），`transfer` 会抛出异常并回滚整个交易。\n• **弃用警告**：自 Solidity 0.8.0 起，`transfer` 和 `send` 不再推荐使用，因为固定的 2300 gas 可能在未来网络中不足（如 EIP-1884 提高了部分操作码的 gas 消耗）。\n\n---\n\n### 2. **`send` (不推荐使用)**\n\n**用法**：\n\n```Solidity\naddress payable recipient = payable(0x123...);\nbool success = recipient.send(amount);\nif (!success) {\n    // 处理发送失败\n}\n```\n\n\n**特点**：\n• **Gas 限制**：与 `transfer` 相同（2300 gas）。\n• **错误处理**：失败时返回 `false` 而非抛出异常，需手动检查返回值。\n• **弃用原因**：与 `transfer` 相同，2300 gas 可能不足。\n\n---\n\n### 3. **`call` (推荐方式)**\n\n**用法**：\n\n```Solidity\naddress payable recipient = payable(0x123...);\n(bool success, bytes memory data) = recipient.call{value: amount}(\"\");\nrequire(success, \"ETH transfer failed\");\n```\n\n\n**特点**：\n• **Gas 限制**：无硬编码限制，默认传递所有剩余 gas（可通过 `gas` 参数自定义，如 `.call{value: amount, gas: 50000}(\"\")`）。\n• **错误处理**：返回 `(bool success, bytes data)`，需手动检查 `success`。\n• **灵活性**：支持调用任意函数（如 `.call{value: amount}(abi.encodeWithSignature(\"foo(uint256)\", 123))`），但需警惕重入攻击。\n• **最佳实践**：当前推荐用于 ETH 转账，因其兼容性更好（如支持智能合约的复杂逻辑）。\n\n---\n\n### **关键区别**\n\n|方法|Gas 限制|错误处理|推荐程度|适用场景|\n|-|-|-|-|-|\n|`transfer`|固定 2300 gas|抛出异常|❌ 弃用|简单转账（旧代码）|\n|`send`|固定 2300 gas|返回 `bool`|❌ 弃用|需手动处理失败的转账|\n|`call`|可自定义 gas|返回 `(bool, bytes)`|✅ 推荐|现代合约（需防重入）|\n\n---\n\n### **最佳实践**\n\n1. **使用 `call` 并检查返回值**\n\n  ```Solidity\n(bool success, ) = recipient.call{value: amount}(\"\");\nrequire(success, \"Transfer failed\");\n```\n\n\n2. **防范重入攻击**\n• 在调用外部合约前执行所有状态变更（遵循 [Checks-Effects-Interactions](https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) 模式）。\n• 使用重入锁（如 OpenZeppelin 的 `ReentrancyGuard`）：\n\n  ```Solidity\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\ncontract MyContract is ReentrancyGuard {\n    function safeTransfer(address payable recipient) external payable nonReentrant {\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        require(success);\n    }\n}\n```\n\n\n3. **明确 gas 限制**\n如果接收方是合约，且不确定其逻辑是否安全，可限制 gas：\n\n  ```Solidity\nrecipient.call{value: amount, gas: 50000}(\"\");\n```\n\n\n4. **避免使用 `transfer` 和 `send`**\n除非维护旧代码，否则优先使用 `call`。\n\n---\n\n### **总结**\n\n• **简单转账**：用 `call` + `require` 检查。\n• **合约交互**：用 `call` 自定义 gas 并防范重入。\n• **弃用方法**：避免 `transfer` 和 `send`，因其 gas 限制可能导致未来兼容性问题。\n\n\n\n","slug":"Solidity中的转账","published":1,"updated":"2025-05-04T10:19:27.271Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8h000xp3j55plv2wyo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>在 Solidity 中，<code>transfer</code>、<code>send</code> 和 <code>call</code> 是用于向外部地址发送 ETH 的三种方法，但它们的行为和安全性存在显著差异。以下是它们的用法、区别及最佳实践。</p>\n<hr>\n<h3 id=\"1-transfer-不推荐使用\"><a href=\"#1-transfer-不推荐使用\" class=\"headerlink\" title=\"1. transfer (不推荐使用)\"></a>1. <strong><code>transfer</code> (不推荐使用)</strong></h3><p><strong>用法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable recipient = payable(0x123...);</span><br><span class=\"line\">recipient.transfer(amount);</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>特点</strong>：<br>• <strong>Gas 限制</strong>：固定 2300 gas，足够触发接收合约的 <code>receive()</code> 或 <code>fallback()</code> 函数，但不足以执行复杂逻辑。<br>• <strong>错误处理</strong>：如果发送失败（如接收合约抛出异常或 gas 不足），<code>transfer</code> 会抛出异常并回滚整个交易。<br>• <strong>弃用警告</strong>：自 Solidity 0.8.0 起，<code>transfer</code> 和 <code>send</code> 不再推荐使用，因为固定的 2300 gas 可能在未来网络中不足（如 EIP-1884 提高了部分操作码的 gas 消耗）。</p>\n<hr>\n<h3 id=\"2-send-不推荐使用\"><a href=\"#2-send-不推荐使用\" class=\"headerlink\" title=\"2. send (不推荐使用)\"></a>2. <strong><code>send</code> (不推荐使用)</strong></h3><p><strong>用法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable recipient = payable(0x123...);</span><br><span class=\"line\">bool success = recipient.send(amount);</span><br><span class=\"line\">if (!success) &#123;</span><br><span class=\"line\">    // 处理发送失败</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>特点</strong>：<br>• <strong>Gas 限制</strong>：与 <code>transfer</code> 相同（2300 gas）。<br>• <strong>错误处理</strong>：失败时返回 <code>false</code> 而非抛出异常，需手动检查返回值。<br>• <strong>弃用原因</strong>：与 <code>transfer</code> 相同，2300 gas 可能不足。</p>\n<hr>\n<h3 id=\"3-call-推荐方式\"><a href=\"#3-call-推荐方式\" class=\"headerlink\" title=\"3. call (推荐方式)\"></a>3. <strong><code>call</code> (推荐方式)</strong></h3><p><strong>用法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable recipient = payable(0x123...);</span><br><span class=\"line\">(bool success, bytes memory data) = recipient.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class=\"line\">require(success, &quot;ETH transfer failed&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>特点</strong>：<br>• <strong>Gas 限制</strong>：无硬编码限制，默认传递所有剩余 gas（可通过 <code>gas</code> 参数自定义，如 <code>.call&#123;value: amount, gas: 50000&#125;(&quot;&quot;)</code>）。<br>• <strong>错误处理</strong>：返回 <code>(bool success, bytes data)</code>，需手动检查 <code>success</code>。<br>• <strong>灵活性</strong>：支持调用任意函数（如 <code>.call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;foo(uint256)&quot;, 123))</code>），但需警惕重入攻击。<br>• <strong>最佳实践</strong>：当前推荐用于 ETH 转账，因其兼容性更好（如支持智能合约的复杂逻辑）。</p>\n<hr>\n<h3 id=\"关键区别\"><a href=\"#关键区别\" class=\"headerlink\" title=\"关键区别\"></a><strong>关键区别</strong></h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>Gas 限制</th>\n<th>错误处理</th>\n<th>推荐程度</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>transfer</code></td>\n<td>固定 2300 gas</td>\n<td>抛出异常</td>\n<td>❌ 弃用</td>\n<td>简单转账（旧代码）</td>\n</tr>\n<tr>\n<td><code>send</code></td>\n<td>固定 2300 gas</td>\n<td>返回 <code>bool</code></td>\n<td>❌ 弃用</td>\n<td>需手动处理失败的转账</td>\n</tr>\n<tr>\n<td><code>call</code></td>\n<td>可自定义 gas</td>\n<td>返回 <code>(bool, bytes)</code></td>\n<td>✅ 推荐</td>\n<td>现代合约（需防重入）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a><strong>最佳实践</strong></h3><ol>\n<li><strong>使用 <code>call</code> 并检查返回值</strong></li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(bool success, ) = recipient.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class=\"line\">require(success, &quot;Transfer failed&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li><strong>防范重入攻击</strong><br>• 在调用外部合约前执行所有状态变更（遵循 <a href=\"https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern\">Checks-Effects-Interactions</a> 模式）。<br>• 使用重入锁（如 OpenZeppelin 的 <code>ReentrancyGuard</code>）：</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class=\"line\">contract MyContract is ReentrancyGuard &#123;</span><br><span class=\"line\">    function safeTransfer(address payable recipient) external payable nonReentrant &#123;</span><br><span class=\"line\">        (bool success, ) = recipient.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li><strong>明确 gas 限制</strong><br>如果接收方是合约，且不确定其逻辑是否安全，可限制 gas：</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">recipient.call&#123;value: amount, gas: 50000&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"4\">\n<li><strong>避免使用 <code>transfer</code> 和 <code>send</code></strong><br>除非维护旧代码，否则优先使用 <code>call</code>。</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>• <strong>简单转账</strong>：用 <code>call</code> + <code>require</code> 检查。<br>• <strong>合约交互</strong>：用 <code>call</code> 自定义 gas 并防范重入。<br>• <strong>弃用方法</strong>：避免 <code>transfer</code> 和 <code>send</code>，因其 gas 限制可能导致未来兼容性问题。</p>\n","excerpt":"","more":"<p>在 Solidity 中，<code>transfer</code>、<code>send</code> 和 <code>call</code> 是用于向外部地址发送 ETH 的三种方法，但它们的行为和安全性存在显著差异。以下是它们的用法、区别及最佳实践。</p>\n<hr>\n<h3 id=\"1-transfer-不推荐使用\"><a href=\"#1-transfer-不推荐使用\" class=\"headerlink\" title=\"1. transfer (不推荐使用)\"></a>1. <strong><code>transfer</code> (不推荐使用)</strong></h3><p><strong>用法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable recipient = payable(0x123...);</span><br><span class=\"line\">recipient.transfer(amount);</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>特点</strong>：<br>• <strong>Gas 限制</strong>：固定 2300 gas，足够触发接收合约的 <code>receive()</code> 或 <code>fallback()</code> 函数，但不足以执行复杂逻辑。<br>• <strong>错误处理</strong>：如果发送失败（如接收合约抛出异常或 gas 不足），<code>transfer</code> 会抛出异常并回滚整个交易。<br>• <strong>弃用警告</strong>：自 Solidity 0.8.0 起，<code>transfer</code> 和 <code>send</code> 不再推荐使用，因为固定的 2300 gas 可能在未来网络中不足（如 EIP-1884 提高了部分操作码的 gas 消耗）。</p>\n<hr>\n<h3 id=\"2-send-不推荐使用\"><a href=\"#2-send-不推荐使用\" class=\"headerlink\" title=\"2. send (不推荐使用)\"></a>2. <strong><code>send</code> (不推荐使用)</strong></h3><p><strong>用法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable recipient = payable(0x123...);</span><br><span class=\"line\">bool success = recipient.send(amount);</span><br><span class=\"line\">if (!success) &#123;</span><br><span class=\"line\">    // 处理发送失败</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>特点</strong>：<br>• <strong>Gas 限制</strong>：与 <code>transfer</code> 相同（2300 gas）。<br>• <strong>错误处理</strong>：失败时返回 <code>false</code> 而非抛出异常，需手动检查返回值。<br>• <strong>弃用原因</strong>：与 <code>transfer</code> 相同，2300 gas 可能不足。</p>\n<hr>\n<h3 id=\"3-call-推荐方式\"><a href=\"#3-call-推荐方式\" class=\"headerlink\" title=\"3. call (推荐方式)\"></a>3. <strong><code>call</code> (推荐方式)</strong></h3><p><strong>用法</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address payable recipient = payable(0x123...);</span><br><span class=\"line\">(bool success, bytes memory data) = recipient.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class=\"line\">require(success, &quot;ETH transfer failed&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>特点</strong>：<br>• <strong>Gas 限制</strong>：无硬编码限制，默认传递所有剩余 gas（可通过 <code>gas</code> 参数自定义，如 <code>.call&#123;value: amount, gas: 50000&#125;(&quot;&quot;)</code>）。<br>• <strong>错误处理</strong>：返回 <code>(bool success, bytes data)</code>，需手动检查 <code>success</code>。<br>• <strong>灵活性</strong>：支持调用任意函数（如 <code>.call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;foo(uint256)&quot;, 123))</code>），但需警惕重入攻击。<br>• <strong>最佳实践</strong>：当前推荐用于 ETH 转账，因其兼容性更好（如支持智能合约的复杂逻辑）。</p>\n<hr>\n<h3 id=\"关键区别\"><a href=\"#关键区别\" class=\"headerlink\" title=\"关键区别\"></a><strong>关键区别</strong></h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>Gas 限制</th>\n<th>错误处理</th>\n<th>推荐程度</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>transfer</code></td>\n<td>固定 2300 gas</td>\n<td>抛出异常</td>\n<td>❌ 弃用</td>\n<td>简单转账（旧代码）</td>\n</tr>\n<tr>\n<td><code>send</code></td>\n<td>固定 2300 gas</td>\n<td>返回 <code>bool</code></td>\n<td>❌ 弃用</td>\n<td>需手动处理失败的转账</td>\n</tr>\n<tr>\n<td><code>call</code></td>\n<td>可自定义 gas</td>\n<td>返回 <code>(bool, bytes)</code></td>\n<td>✅ 推荐</td>\n<td>现代合约（需防重入）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a><strong>最佳实践</strong></h3><ol>\n<li><strong>使用 <code>call</code> 并检查返回值</strong></li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(bool success, ) = recipient.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class=\"line\">require(success, &quot;Transfer failed&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li><strong>防范重入攻击</strong><br>• 在调用外部合约前执行所有状态变更（遵循 <a href=\"https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern\">Checks-Effects-Interactions</a> 模式）。<br>• 使用重入锁（如 OpenZeppelin 的 <code>ReentrancyGuard</code>）：</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class=\"line\">contract MyContract is ReentrancyGuard &#123;</span><br><span class=\"line\">    function safeTransfer(address payable recipient) external payable nonReentrant &#123;</span><br><span class=\"line\">        (bool success, ) = recipient.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li><strong>明确 gas 限制</strong><br>如果接收方是合约，且不确定其逻辑是否安全，可限制 gas：</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">recipient.call&#123;value: amount, gas: 50000&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"4\">\n<li><strong>避免使用 <code>transfer</code> 和 <code>send</code></strong><br>除非维护旧代码，否则优先使用 <code>call</code>。</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>• <strong>简单转账</strong>：用 <code>call</code> + <code>require</code> 检查。<br>• <strong>合约交互</strong>：用 <code>call</code> 自定义 gas 并防范重入。<br>• <strong>弃用方法</strong>：避免 <code>transfer</code> 和 <code>send</code>，因其 gas 限制可能导致未来兼容性问题。</p>\n"},{"title":"考研经验分享","description":"突发奇想写一下考研的经验分享，希望帮到有需要的同学","date":"2076-12-31T16:00:00.000Z","toc":false,"_content":"\n> 突发奇想写一下考研的经验分享，希望帮到有需要的同学\n\n  鼠鼠一战985自命题遗憾败北，二战京区22408的211稳稳上岸，两年里摸索了很多\n\n  原本感觉能写很多，但是时间相距甚远，记忆模糊了，简单写一些重要的内容\n\n  以下观点，纯属主观，博君一笑，请自行斟酌，不要和鼠鼠扯皮\n\n### 1.前言\n\n在现在这个时代，作为在校大学生首先需要对“考研”这件事做一个权衡，思考一些问题，例如：\n\n  - 我是否适合读研？\n\n  - 我是否需要读研？\n\n  - 读研能否给我想要的“东西”？\n\n  - 我毕业能不能找到工作？\n\n等等等等...因为是否读研可以看做是人生小阶段的一个小小的分支，所以要想好自己路\n\n就我个人而言，我的想法是：1.当前就业环境不佳，直接工作不一定能给我想要的生活；2.个人性格和出身原因，非常希望去到一个更高层次的地方（认知、知识和社交等）探索这个世界；\n\n所以我决定考研，并且给自己两年的机会，好在最后达成了目标\n\n\n\n### 2.时间地点安排\n\n对于时间，首先得先大致了解一下**考试的时间**安排（什么时候考试，什么时候报名之类的），这些信息还是比较好搜集的，简单看一下，心里有个数。\n\n然后是**自己的时间**，二战的话时间自由，一战的话了解一下自己学校的课程安排，学校应该不会用课程和实训来耽误学生考研学习，如果真的遇到学校为难的，咨询上岸学长怎么处理的，这个应该不成问题。\n\n对于**学习地点**的话，以鼠鼠的本科学校为例，对于一战的同学，前期的话可以去图书馆听课学习，但是到了强化和冲刺阶段，最好是选择学校提供的考研自习室，尽量不要去图书馆，因为受到开馆闭馆时间的限制，而自习室24小时开着，没人管，条件也更好（#60顶楼那个就不错）。\n\n对于一战来说，有一个时间节点比较特殊，就是七八月的**暑假**。一般有三个选项：回家、留校、租房。暑假非常非常非常关键，一定选择自己适合的方式，这里仅避雷鼠鼠本科学校的留校，非常不好。另外两种的话，仁者见仁智者见智，鼠鼠是选择了攒钱租房闭关度过两个月，而鼠鼠的好朋友弓大大在家学习最终也取得了那一届最好的成绩（420+）。\n\n最后就是**学习时间**，前期的基础阶段的话，鼠鼠认为无所谓，目标就是系统性的学一遍（学的好不好没差别，反正后面也会忘）。至于最后的冲刺阶段也很简单：“你有多少能量，就有多大作为”，这句话就是说到了快考试的那段时间，大家的精神和身体应该来说都相当疲惫了，尤其是精神，都有可能倦怠迷茫，那就得看自己的精神状态了，能学进去多少全看自己造化了。\n\n所以鼠鼠主要分享一下**强化阶段**的时间安排，这个还是比较重要的：\n\n|时间|内容|备注|\n|-|-|-|\n|7：00-7：30|起床+背单词||\n|7：30-8：00|随机睡回笼觉|保证精神|\n|8：00-9：00|英语真题|基础不好的可以继续背单词|\n|9：30-11：00|408|也有人说跟真实考试一样，上午学数学，鼠鼠认为无所谓，后期模考的时候可以注意一下|\n|11：30-13：30|吃饭+午休||\n|13：30-16：00|高数||\n|16：00-18：30|线代|很多人会踩的坑，线代和高数一定要一起学，都很重要，尤其是线代比较简单，纯送分|\n|18：30-20：00|吃饭+骑车+洗澡|适量运动，不然身体会垮掉，鼠鼠整个半年都没感冒过|\n|20：00-22：00|408||\n|22：00-23：00|王者荣耀，启动！|蘸豆，爽！|\n|23：00-00：00|休息|鼠鼠定力差，经常玩手机玩过头，不过感觉也无所谓|\n\n> 1.在整个备考期间一定要保证睡眠，至少要睡满7.5h(8h则更好)。睡眠充足对学习大有益处，虽然鼠鼠在这一点上做得很差。\n\n  2.计划是上面的计划，其实执行过程难免磕磕绊绊，比如睡个大懒觉、玩个一整天游戏或者出去旅游两天，都是小事，不要有负罪感，玩就爽玩，学就狂学。战略上拿下就行了，强化阶段战略是“**闭关修炼**”。\n\n  3.另外说明的是，鼠鼠的英语有点小天赋，所以压根就没怎么学，单词都没背，所以同学们需要根据自身情况调整。\n\n\n\n### 3.考研择校\n\n最重要的一关，一点比较颠覆性的认知是“选择大于努力”，这不是假大空的道理，也不是事后大家的玩梗，这是考研这件事（甚至是往后的人生）的准则，所以一定要重视择校这件事。\n\n择校的几个关键点：\n\n  - 确定考试科目：自命题 or 统考\n\n  - 确定目标院校档次：双一流 or 92\n\n  - 确定自身实力：近年真题 and 模拟考试\n\n  - 调研目标院校考情：各种分数指标 and 录取原则\n\n鼠鼠的个人观点：\n\n  - 考虑地区时建议不要被家乡束缚，眼光要长远，虽然江苏确实是鼠鼠心目中全国最好的地区没有之一，但也不能总吃细糠\n\n  - 推荐报考统考408，因为有些自命题非常不稳定，小心被坑死，鼠鼠已经死过一次了，所以大家不要贪图一两门课简单而失去了更大的优势，408其实不难，只是多\n\n  - 有实力的可以考11408，调剂时优势非常非常巨大，身边有朋友甚至调剂到比一志愿好更多更多的院校\n\n  - 推荐双一流以上的院校，往下的不值得一上，除非没办法的时候（调剂）\n\n  - 学习的时候留一两年的真题不做，留着摸摸自己的底\n\n  - 院校调研要多方位，微信公众号+B站+知乎+小红书等等等等，还有研可岸这个网站，里面有很多院校的信息\n\n鼠鼠本人属于是一念神魔型选手，发挥好随便挑，发挥差简直一坨，所以二战综合选择了“一线城市+中上游211”这样的目标。\n\n最后也欢迎学弟学妹也考来北京抱团发展。\n\n\n\n### 4.学科建议\n\n下面聊点具体的，但是一定要根据自身调整\n\n总的来说：“是否能够上岸” = “你的数学和专业课炸没炸”\n\n所以，***整个备考的重心始终要放在数学和专业课上***\n\n举个例子，数学最低分值的选择填空为5分，英语完型填空为0.5分一个，而过去的完型均分大约也就5分（除了最近年份），所以孰轻孰重，鼠鼠相信大家自己能判断\n\n#### 政治\n\n这门学科就是简单考察学生个人素养，热爱国家，心中有理想，脚下有力量就行。\n\n至于学习，12月的时候**肖四肖八**会出版，这将是唯一且最重要的学习资料。肖八写选择，听讲解，记忆知识点；肖四写选择，听讲解，背诵分析题。对于分析题，背下来还是比较难且枯燥的，推荐博主：大牙考研，他总结的带背版逻辑清晰，行为精简，更适合工科宝宝体质。\n\n前期的话，可以吃饭的时候把徐涛强化课当故事听一听，图一乐。其他乱七八糟的什么1000题什么的不要写。\n\n> **总结**：前期按兵不动，最后做好冲刺，不要花太多心思（因为花了也没用，性价比极低）\n\n  （2025年肖4大翻车，或者说被反向押题了，但是不能否认这本资料在之后考试中的重要性）\n\n#### 英语\n\n复习关键：**单词+阅读**\n\n单词，推荐使用手机软件背诵，随时随地背（虽然鼠鼠做不到），背上一两遍基本无敌了，基础不好一定要一直背。大部分的单词都只需要留下印象，看到以后知道是什么意思，不用会写。\n\n阅读，通过真题学习，不要看任何其他资料，只会误导方向。鼠鼠在一战的时候是做了一遍所有的真题，包括英一和英二，个人感觉两者差不太多，一开始错的挺多，写着写着就入魔了，基本不会出错，所以要多写，找到感觉。不要听人家说的神乎其神，阅读就是力大砖飞，干就完了。暑假的时候集中强化训练。真是耐听王的话，推荐看看唐迟的阅读课，有微乎其微的作用吧，不如力大砖飞。\n\n作文，两年经验来看，推荐自己总结模板，分数更高，需要的可以直接找鼠鼠要，包牛逼的。时间大概是十月十一月开始学问题不大。底子差的可以听听石雷鹏的课，简单易上手，宝宝巴士型。\n\n其他题型，学一下做题方法就行，基本都是送分题，无需在意也不用专门复习，十一月看一下就行。*（语法，学个damn）*\n\nPS：如果你是像鼠鼠这种的偏科神人，直接不学也没事，可以省出很多时间给数学和408。\n\n> **总结**：单词一直背，阅读狠狠练，力大砖飞！\n\n#### 数学\n\n1. 时间段：\n\n  - 基础：4月-6月\n\n  - 强化：7月-10月\n\n  - 冲刺：11月-12月\n\n2. 各阶段课程建议\n\n|阶段|目标|课程|资料|备注|\n|-|-|-|-|-|\n|基础|系统地学习一遍|三大名师任选其一：汤家凤、武忠祥、张宇\n线代：李永乐老爷爷 or 没咋了救命课|对应的讲义资料即可|每个人习惯差异很大，每个老师的课听一两节，看看哪个舒服就选哪个。例如汤老师的南京口音鼠鼠感觉很亲切，有种回高中的感觉，有助睡眠（bushi，所以选择基础课听汤老师|\n|强化|巩固知识点，学会做题|推荐：武忠祥 or 张宇 \n线代：李永乐老爷爷 or 没咋了救命课\n习题讲解：B站一些优质博主，例如没咋了，已经记不清了，自行搜索鉴别|对应的强化讲义|强化重点在于做题而不是听课，当然了可也是必须要听的\n注重习题复盘|\n|冲刺|提升应试能力，狠狠地写试卷，针对性地复习|查漏补缺，B站上找需要的视频来看|各种真题模拟卷，建议：不要急着买，每年试卷质量不一样，等一手网上各个博主的测评，值得写再买|看视频缺哪补哪，不要看什么《17堂课》这种长长的课，你没有那个时间了\n做套卷一定一定要计时，不然等于没做|\n\n\n3. 学习指南（各种碎碎念）\n\n  - 数学一定要大段时间一起学，能进心流是最好\n\n  - 听课和练习要结合，学完就去写，不要猛猛听课\n\n  - 练习题选择要看网上的评测，是否适合自己\n\n  - 重视线代，这门学科有独特魔力，一个星期不碰＝从没学过，一定不能停，千万不要不信邪\n\n  - 学习过程：听课→例题→练习题→(全篇复习：错题二刷)\n\n  - 做题时间原则，5分的题，5分钟没写出来，直接跳过\n\n  - 做试卷的原则，速通然后检查，最后攻坚克难\n\n  - 冲刺阶段：2天一套模拟卷，一天做，一天复盘总结（必不可少）\n\n  - 做题本很有必要去做，用于回顾知识；笔记本，对于数学而言意义不大，不建议搞\n\n  - 不断思考学习方法有没有更好的改进\n\n  - 最后阶段集中攻克薄弱，例如反常积分不会，找到专题内容猛猛补就行\n\n  - 数学关键是做题能力，不要当耐听王，多动手\n\n  - 各个博主的优质内容一定要在有了基础前提下学习，不要上来就跟着某个up主学这学那\n\n  - 数学也是力大砖飞，计算能力要过关，尤其是近几年的题目，会写但是未必得分，所以要多练\n\n  - 注意一些犄角旮旯的知识点，有时候出卷老头真的很逆天，25年搞了个万有引力直接爆了\n\n  - 记住数学的基础分就有120，所以不失误就已经赢了，要打牢基础，注重计算（鼠鼠就经常死在计算上，一定要多练）\n\n  - 跳出自己的舒适区，越不会越要搞会。这里我指的是自己的薄弱知识，而不是硬钢那些难题\n\n4. 其他问题\n\n  - 例如各个资料和试卷质量问题，可以联系鼠鼠询问，就不一一列举\n\n  - 资料推荐买盗版或者电子版，省下来的钱上岸之后猛猛玩\n\n  - 上面都挺关键的，距离考试时间已经很久远了，想不到更多了，欢迎提问\n\n> **总结**：基础不牢，地动山摇。多写题多总结 ＞ 耐听王。力大砖飞！\n\n#### 408\n\n5. 认知：\n\n  - 408的难度在于知识点的量很大，而不是知识点深度\n\n  - 408学习的精髓在于多次反复，因为他有很多文科的特性\n\n  - 408需要的时间也没有那么吓人，鼠鼠二战从7月开始学，仍然完完整整过了两遍，后期甚至没事干\n\n6. 学习建议：\n\n  基础阶段就是听王道课，过一遍，很难的内容直接跳，例如计组中的一些东西非常难懂，没关系直接跳。与此同时做王道的课后题中的选择题，推荐使用电子的刷题本，然后打印下来。每题都要弄懂，相关知识点写旁边。习题讲解推荐：Boky、里昂学长或者王道官方。\n\n  另外我听过Boky的其他课程，也非常非常推荐，这个女生讲解的很有条理，比起王道的课程更精简高效，全程班不知道质量如何，钱包有实力可以考虑。另外就是她的出版资料非常的棒，比起厚厚的王道书，简直就是神器，推荐入手，鼠鼠后期一直看得她的资料，再也没翻过王道书。\n\n  强化的话，王道的强化课是比较推荐的，讲大题的解题方法与知识点的综合，尤其是存储相关的内容和PV相关的内容，跟着做题学习大题，会有茅塞顿开的感觉。\n\n  然后就是真题阶段，这个阶段也非常重要，408最好的复习资料就是历年真题，鼠鼠认为至少要刷三遍以上才算吃透，要有一个错题本记录题目和知识点，因为408重复考察的很多。\n\n  王道在12月中旬的时候会有一个冲刺课，可以去报个名听一下，咸鱼会把最后几天的重点都勾出来，然后剩下的几天如果没东西复习了，就可以跟着他的重点再复习一次。\n\n7. 其他：\n\n  - 不要钻牛角尖，例如红黑树之类的，差不多得了，408量比较大，完成度更重要\n\n  - 一步步进行，打牢基础，你会发现408并不难，尤其是写真题的时候\n\n  - 计网的话咸鱼版本应该已经重置完成了，不够湖科大老师的任然非常推荐\n\n> **总结**：注重完成度，知识点全覆盖。反复多次，实实在在吃透真题。力大砖飞！\n\n### 其他疑问\n\n> 欢迎邮箱留言，鼠鼠知无不言：alan_root@outlook.com\n\n","source":"_posts/考研经验分享.md","raw":"---\ntitle: 考研经验分享\ndescription: '突发奇想写一下考研的经验分享，希望帮到有需要的同学'\ndate: 2077-01-01 00:00:00\ntags: '考研'\ncategories: 经验分享\ntoc: false\n---\n\n> 突发奇想写一下考研的经验分享，希望帮到有需要的同学\n\n  鼠鼠一战985自命题遗憾败北，二战京区22408的211稳稳上岸，两年里摸索了很多\n\n  原本感觉能写很多，但是时间相距甚远，记忆模糊了，简单写一些重要的内容\n\n  以下观点，纯属主观，博君一笑，请自行斟酌，不要和鼠鼠扯皮\n\n### 1.前言\n\n在现在这个时代，作为在校大学生首先需要对“考研”这件事做一个权衡，思考一些问题，例如：\n\n  - 我是否适合读研？\n\n  - 我是否需要读研？\n\n  - 读研能否给我想要的“东西”？\n\n  - 我毕业能不能找到工作？\n\n等等等等...因为是否读研可以看做是人生小阶段的一个小小的分支，所以要想好自己路\n\n就我个人而言，我的想法是：1.当前就业环境不佳，直接工作不一定能给我想要的生活；2.个人性格和出身原因，非常希望去到一个更高层次的地方（认知、知识和社交等）探索这个世界；\n\n所以我决定考研，并且给自己两年的机会，好在最后达成了目标\n\n\n\n### 2.时间地点安排\n\n对于时间，首先得先大致了解一下**考试的时间**安排（什么时候考试，什么时候报名之类的），这些信息还是比较好搜集的，简单看一下，心里有个数。\n\n然后是**自己的时间**，二战的话时间自由，一战的话了解一下自己学校的课程安排，学校应该不会用课程和实训来耽误学生考研学习，如果真的遇到学校为难的，咨询上岸学长怎么处理的，这个应该不成问题。\n\n对于**学习地点**的话，以鼠鼠的本科学校为例，对于一战的同学，前期的话可以去图书馆听课学习，但是到了强化和冲刺阶段，最好是选择学校提供的考研自习室，尽量不要去图书馆，因为受到开馆闭馆时间的限制，而自习室24小时开着，没人管，条件也更好（#60顶楼那个就不错）。\n\n对于一战来说，有一个时间节点比较特殊，就是七八月的**暑假**。一般有三个选项：回家、留校、租房。暑假非常非常非常关键，一定选择自己适合的方式，这里仅避雷鼠鼠本科学校的留校，非常不好。另外两种的话，仁者见仁智者见智，鼠鼠是选择了攒钱租房闭关度过两个月，而鼠鼠的好朋友弓大大在家学习最终也取得了那一届最好的成绩（420+）。\n\n最后就是**学习时间**，前期的基础阶段的话，鼠鼠认为无所谓，目标就是系统性的学一遍（学的好不好没差别，反正后面也会忘）。至于最后的冲刺阶段也很简单：“你有多少能量，就有多大作为”，这句话就是说到了快考试的那段时间，大家的精神和身体应该来说都相当疲惫了，尤其是精神，都有可能倦怠迷茫，那就得看自己的精神状态了，能学进去多少全看自己造化了。\n\n所以鼠鼠主要分享一下**强化阶段**的时间安排，这个还是比较重要的：\n\n|时间|内容|备注|\n|-|-|-|\n|7：00-7：30|起床+背单词||\n|7：30-8：00|随机睡回笼觉|保证精神|\n|8：00-9：00|英语真题|基础不好的可以继续背单词|\n|9：30-11：00|408|也有人说跟真实考试一样，上午学数学，鼠鼠认为无所谓，后期模考的时候可以注意一下|\n|11：30-13：30|吃饭+午休||\n|13：30-16：00|高数||\n|16：00-18：30|线代|很多人会踩的坑，线代和高数一定要一起学，都很重要，尤其是线代比较简单，纯送分|\n|18：30-20：00|吃饭+骑车+洗澡|适量运动，不然身体会垮掉，鼠鼠整个半年都没感冒过|\n|20：00-22：00|408||\n|22：00-23：00|王者荣耀，启动！|蘸豆，爽！|\n|23：00-00：00|休息|鼠鼠定力差，经常玩手机玩过头，不过感觉也无所谓|\n\n> 1.在整个备考期间一定要保证睡眠，至少要睡满7.5h(8h则更好)。睡眠充足对学习大有益处，虽然鼠鼠在这一点上做得很差。\n\n  2.计划是上面的计划，其实执行过程难免磕磕绊绊，比如睡个大懒觉、玩个一整天游戏或者出去旅游两天，都是小事，不要有负罪感，玩就爽玩，学就狂学。战略上拿下就行了，强化阶段战略是“**闭关修炼**”。\n\n  3.另外说明的是，鼠鼠的英语有点小天赋，所以压根就没怎么学，单词都没背，所以同学们需要根据自身情况调整。\n\n\n\n### 3.考研择校\n\n最重要的一关，一点比较颠覆性的认知是“选择大于努力”，这不是假大空的道理，也不是事后大家的玩梗，这是考研这件事（甚至是往后的人生）的准则，所以一定要重视择校这件事。\n\n择校的几个关键点：\n\n  - 确定考试科目：自命题 or 统考\n\n  - 确定目标院校档次：双一流 or 92\n\n  - 确定自身实力：近年真题 and 模拟考试\n\n  - 调研目标院校考情：各种分数指标 and 录取原则\n\n鼠鼠的个人观点：\n\n  - 考虑地区时建议不要被家乡束缚，眼光要长远，虽然江苏确实是鼠鼠心目中全国最好的地区没有之一，但也不能总吃细糠\n\n  - 推荐报考统考408，因为有些自命题非常不稳定，小心被坑死，鼠鼠已经死过一次了，所以大家不要贪图一两门课简单而失去了更大的优势，408其实不难，只是多\n\n  - 有实力的可以考11408，调剂时优势非常非常巨大，身边有朋友甚至调剂到比一志愿好更多更多的院校\n\n  - 推荐双一流以上的院校，往下的不值得一上，除非没办法的时候（调剂）\n\n  - 学习的时候留一两年的真题不做，留着摸摸自己的底\n\n  - 院校调研要多方位，微信公众号+B站+知乎+小红书等等等等，还有研可岸这个网站，里面有很多院校的信息\n\n鼠鼠本人属于是一念神魔型选手，发挥好随便挑，发挥差简直一坨，所以二战综合选择了“一线城市+中上游211”这样的目标。\n\n最后也欢迎学弟学妹也考来北京抱团发展。\n\n\n\n### 4.学科建议\n\n下面聊点具体的，但是一定要根据自身调整\n\n总的来说：“是否能够上岸” = “你的数学和专业课炸没炸”\n\n所以，***整个备考的重心始终要放在数学和专业课上***\n\n举个例子，数学最低分值的选择填空为5分，英语完型填空为0.5分一个，而过去的完型均分大约也就5分（除了最近年份），所以孰轻孰重，鼠鼠相信大家自己能判断\n\n#### 政治\n\n这门学科就是简单考察学生个人素养，热爱国家，心中有理想，脚下有力量就行。\n\n至于学习，12月的时候**肖四肖八**会出版，这将是唯一且最重要的学习资料。肖八写选择，听讲解，记忆知识点；肖四写选择，听讲解，背诵分析题。对于分析题，背下来还是比较难且枯燥的，推荐博主：大牙考研，他总结的带背版逻辑清晰，行为精简，更适合工科宝宝体质。\n\n前期的话，可以吃饭的时候把徐涛强化课当故事听一听，图一乐。其他乱七八糟的什么1000题什么的不要写。\n\n> **总结**：前期按兵不动，最后做好冲刺，不要花太多心思（因为花了也没用，性价比极低）\n\n  （2025年肖4大翻车，或者说被反向押题了，但是不能否认这本资料在之后考试中的重要性）\n\n#### 英语\n\n复习关键：**单词+阅读**\n\n单词，推荐使用手机软件背诵，随时随地背（虽然鼠鼠做不到），背上一两遍基本无敌了，基础不好一定要一直背。大部分的单词都只需要留下印象，看到以后知道是什么意思，不用会写。\n\n阅读，通过真题学习，不要看任何其他资料，只会误导方向。鼠鼠在一战的时候是做了一遍所有的真题，包括英一和英二，个人感觉两者差不太多，一开始错的挺多，写着写着就入魔了，基本不会出错，所以要多写，找到感觉。不要听人家说的神乎其神，阅读就是力大砖飞，干就完了。暑假的时候集中强化训练。真是耐听王的话，推荐看看唐迟的阅读课，有微乎其微的作用吧，不如力大砖飞。\n\n作文，两年经验来看，推荐自己总结模板，分数更高，需要的可以直接找鼠鼠要，包牛逼的。时间大概是十月十一月开始学问题不大。底子差的可以听听石雷鹏的课，简单易上手，宝宝巴士型。\n\n其他题型，学一下做题方法就行，基本都是送分题，无需在意也不用专门复习，十一月看一下就行。*（语法，学个damn）*\n\nPS：如果你是像鼠鼠这种的偏科神人，直接不学也没事，可以省出很多时间给数学和408。\n\n> **总结**：单词一直背，阅读狠狠练，力大砖飞！\n\n#### 数学\n\n1. 时间段：\n\n  - 基础：4月-6月\n\n  - 强化：7月-10月\n\n  - 冲刺：11月-12月\n\n2. 各阶段课程建议\n\n|阶段|目标|课程|资料|备注|\n|-|-|-|-|-|\n|基础|系统地学习一遍|三大名师任选其一：汤家凤、武忠祥、张宇\n线代：李永乐老爷爷 or 没咋了救命课|对应的讲义资料即可|每个人习惯差异很大，每个老师的课听一两节，看看哪个舒服就选哪个。例如汤老师的南京口音鼠鼠感觉很亲切，有种回高中的感觉，有助睡眠（bushi，所以选择基础课听汤老师|\n|强化|巩固知识点，学会做题|推荐：武忠祥 or 张宇 \n线代：李永乐老爷爷 or 没咋了救命课\n习题讲解：B站一些优质博主，例如没咋了，已经记不清了，自行搜索鉴别|对应的强化讲义|强化重点在于做题而不是听课，当然了可也是必须要听的\n注重习题复盘|\n|冲刺|提升应试能力，狠狠地写试卷，针对性地复习|查漏补缺，B站上找需要的视频来看|各种真题模拟卷，建议：不要急着买，每年试卷质量不一样，等一手网上各个博主的测评，值得写再买|看视频缺哪补哪，不要看什么《17堂课》这种长长的课，你没有那个时间了\n做套卷一定一定要计时，不然等于没做|\n\n\n3. 学习指南（各种碎碎念）\n\n  - 数学一定要大段时间一起学，能进心流是最好\n\n  - 听课和练习要结合，学完就去写，不要猛猛听课\n\n  - 练习题选择要看网上的评测，是否适合自己\n\n  - 重视线代，这门学科有独特魔力，一个星期不碰＝从没学过，一定不能停，千万不要不信邪\n\n  - 学习过程：听课→例题→练习题→(全篇复习：错题二刷)\n\n  - 做题时间原则，5分的题，5分钟没写出来，直接跳过\n\n  - 做试卷的原则，速通然后检查，最后攻坚克难\n\n  - 冲刺阶段：2天一套模拟卷，一天做，一天复盘总结（必不可少）\n\n  - 做题本很有必要去做，用于回顾知识；笔记本，对于数学而言意义不大，不建议搞\n\n  - 不断思考学习方法有没有更好的改进\n\n  - 最后阶段集中攻克薄弱，例如反常积分不会，找到专题内容猛猛补就行\n\n  - 数学关键是做题能力，不要当耐听王，多动手\n\n  - 各个博主的优质内容一定要在有了基础前提下学习，不要上来就跟着某个up主学这学那\n\n  - 数学也是力大砖飞，计算能力要过关，尤其是近几年的题目，会写但是未必得分，所以要多练\n\n  - 注意一些犄角旮旯的知识点，有时候出卷老头真的很逆天，25年搞了个万有引力直接爆了\n\n  - 记住数学的基础分就有120，所以不失误就已经赢了，要打牢基础，注重计算（鼠鼠就经常死在计算上，一定要多练）\n\n  - 跳出自己的舒适区，越不会越要搞会。这里我指的是自己的薄弱知识，而不是硬钢那些难题\n\n4. 其他问题\n\n  - 例如各个资料和试卷质量问题，可以联系鼠鼠询问，就不一一列举\n\n  - 资料推荐买盗版或者电子版，省下来的钱上岸之后猛猛玩\n\n  - 上面都挺关键的，距离考试时间已经很久远了，想不到更多了，欢迎提问\n\n> **总结**：基础不牢，地动山摇。多写题多总结 ＞ 耐听王。力大砖飞！\n\n#### 408\n\n5. 认知：\n\n  - 408的难度在于知识点的量很大，而不是知识点深度\n\n  - 408学习的精髓在于多次反复，因为他有很多文科的特性\n\n  - 408需要的时间也没有那么吓人，鼠鼠二战从7月开始学，仍然完完整整过了两遍，后期甚至没事干\n\n6. 学习建议：\n\n  基础阶段就是听王道课，过一遍，很难的内容直接跳，例如计组中的一些东西非常难懂，没关系直接跳。与此同时做王道的课后题中的选择题，推荐使用电子的刷题本，然后打印下来。每题都要弄懂，相关知识点写旁边。习题讲解推荐：Boky、里昂学长或者王道官方。\n\n  另外我听过Boky的其他课程，也非常非常推荐，这个女生讲解的很有条理，比起王道的课程更精简高效，全程班不知道质量如何，钱包有实力可以考虑。另外就是她的出版资料非常的棒，比起厚厚的王道书，简直就是神器，推荐入手，鼠鼠后期一直看得她的资料，再也没翻过王道书。\n\n  强化的话，王道的强化课是比较推荐的，讲大题的解题方法与知识点的综合，尤其是存储相关的内容和PV相关的内容，跟着做题学习大题，会有茅塞顿开的感觉。\n\n  然后就是真题阶段，这个阶段也非常重要，408最好的复习资料就是历年真题，鼠鼠认为至少要刷三遍以上才算吃透，要有一个错题本记录题目和知识点，因为408重复考察的很多。\n\n  王道在12月中旬的时候会有一个冲刺课，可以去报个名听一下，咸鱼会把最后几天的重点都勾出来，然后剩下的几天如果没东西复习了，就可以跟着他的重点再复习一次。\n\n7. 其他：\n\n  - 不要钻牛角尖，例如红黑树之类的，差不多得了，408量比较大，完成度更重要\n\n  - 一步步进行，打牢基础，你会发现408并不难，尤其是写真题的时候\n\n  - 计网的话咸鱼版本应该已经重置完成了，不够湖科大老师的任然非常推荐\n\n> **总结**：注重完成度，知识点全覆盖。反复多次，实实在在吃透真题。力大砖飞！\n\n### 其他疑问\n\n> 欢迎邮箱留言，鼠鼠知无不言：alan_root@outlook.com\n\n","slug":"考研经验分享","published":1,"updated":"2025-05-12T12:56:25.032Z","_id":"cmal0vt8h0011p3j534z338u0","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><blockquote>\n<p>突发奇想写一下考研的经验分享，希望帮到有需要的同学</p>\n</blockquote>\n<p>  鼠鼠一战985自命题遗憾败北，二战京区22408的211稳稳上岸，两年里摸索了很多</p>\n<p>  原本感觉能写很多，但是时间相距甚远，记忆模糊了，简单写一些重要的内容</p>\n<p>  以下观点，纯属主观，博君一笑，请自行斟酌，不要和鼠鼠扯皮</p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在现在这个时代，作为在校大学生首先需要对“考研”这件事做一个权衡，思考一些问题，例如：</p>\n<ul>\n<li><p>我是否适合读研？</p>\n</li>\n<li><p>我是否需要读研？</p>\n</li>\n<li><p>读研能否给我想要的“东西”？</p>\n</li>\n<li><p>我毕业能不能找到工作？</p>\n</li>\n</ul>\n<p>等等等等…因为是否读研可以看做是人生小阶段的一个小小的分支，所以要想好自己路</p>\n<p>就我个人而言，我的想法是：1.当前就业环境不佳，直接工作不一定能给我想要的生活；2.个人性格和出身原因，非常希望去到一个更高层次的地方（认知、知识和社交等）探索这个世界；</p>\n<p>所以我决定考研，并且给自己两年的机会，好在最后达成了目标</p>\n<h3 id=\"2-时间地点安排\"><a href=\"#2-时间地点安排\" class=\"headerlink\" title=\"2.时间地点安排\"></a>2.时间地点安排</h3><p>对于时间，首先得先大致了解一下<strong>考试的时间</strong>安排（什么时候考试，什么时候报名之类的），这些信息还是比较好搜集的，简单看一下，心里有个数。</p>\n<p>然后是<strong>自己的时间</strong>，二战的话时间自由，一战的话了解一下自己学校的课程安排，学校应该不会用课程和实训来耽误学生考研学习，如果真的遇到学校为难的，咨询上岸学长怎么处理的，这个应该不成问题。</p>\n<p>对于<strong>学习地点</strong>的话，以鼠鼠的本科学校为例，对于一战的同学，前期的话可以去图书馆听课学习，但是到了强化和冲刺阶段，最好是选择学校提供的考研自习室，尽量不要去图书馆，因为受到开馆闭馆时间的限制，而自习室24小时开着，没人管，条件也更好（#60顶楼那个就不错）。</p>\n<p>对于一战来说，有一个时间节点比较特殊，就是七八月的<strong>暑假</strong>。一般有三个选项：回家、留校、租房。暑假非常非常非常关键，一定选择自己适合的方式，这里仅避雷鼠鼠本科学校的留校，非常不好。另外两种的话，仁者见仁智者见智，鼠鼠是选择了攒钱租房闭关度过两个月，而鼠鼠的好朋友弓大大在家学习最终也取得了那一届最好的成绩（420+）。</p>\n<p>最后就是<strong>学习时间</strong>，前期的基础阶段的话，鼠鼠认为无所谓，目标就是系统性的学一遍（学的好不好没差别，反正后面也会忘）。至于最后的冲刺阶段也很简单：“你有多少能量，就有多大作为”，这句话就是说到了快考试的那段时间，大家的精神和身体应该来说都相当疲惫了，尤其是精神，都有可能倦怠迷茫，那就得看自己的精神状态了，能学进去多少全看自己造化了。</p>\n<p>所以鼠鼠主要分享一下<strong>强化阶段</strong>的时间安排，这个还是比较重要的：</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>内容</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7：00-7：30</td>\n<td>起床+背单词</td>\n<td></td>\n</tr>\n<tr>\n<td>7：30-8：00</td>\n<td>随机睡回笼觉</td>\n<td>保证精神</td>\n</tr>\n<tr>\n<td>8：00-9：00</td>\n<td>英语真题</td>\n<td>基础不好的可以继续背单词</td>\n</tr>\n<tr>\n<td>9：30-11：00</td>\n<td>408</td>\n<td>也有人说跟真实考试一样，上午学数学，鼠鼠认为无所谓，后期模考的时候可以注意一下</td>\n</tr>\n<tr>\n<td>11：30-13：30</td>\n<td>吃饭+午休</td>\n<td></td>\n</tr>\n<tr>\n<td>13：30-16：00</td>\n<td>高数</td>\n<td></td>\n</tr>\n<tr>\n<td>16：00-18：30</td>\n<td>线代</td>\n<td>很多人会踩的坑，线代和高数一定要一起学，都很重要，尤其是线代比较简单，纯送分</td>\n</tr>\n<tr>\n<td>18：30-20：00</td>\n<td>吃饭+骑车+洗澡</td>\n<td>适量运动，不然身体会垮掉，鼠鼠整个半年都没感冒过</td>\n</tr>\n<tr>\n<td>20：00-22：00</td>\n<td>408</td>\n<td></td>\n</tr>\n<tr>\n<td>22：00-23：00</td>\n<td>王者荣耀，启动！</td>\n<td>蘸豆，爽！</td>\n</tr>\n<tr>\n<td>23：00-00：00</td>\n<td>休息</td>\n<td>鼠鼠定力差，经常玩手机玩过头，不过感觉也无所谓</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>1.在整个备考期间一定要保证睡眠，至少要睡满7.5h(8h则更好)。睡眠充足对学习大有益处，虽然鼠鼠在这一点上做得很差。</p>\n</blockquote>\n<p>  2.计划是上面的计划，其实执行过程难免磕磕绊绊，比如睡个大懒觉、玩个一整天游戏或者出去旅游两天，都是小事，不要有负罪感，玩就爽玩，学就狂学。战略上拿下就行了，强化阶段战略是“<strong>闭关修炼</strong>”。</p>\n<p>  3.另外说明的是，鼠鼠的英语有点小天赋，所以压根就没怎么学，单词都没背，所以同学们需要根据自身情况调整。</p>\n<h3 id=\"3-考研择校\"><a href=\"#3-考研择校\" class=\"headerlink\" title=\"3.考研择校\"></a>3.考研择校</h3><p>最重要的一关，一点比较颠覆性的认知是“选择大于努力”，这不是假大空的道理，也不是事后大家的玩梗，这是考研这件事（甚至是往后的人生）的准则，所以一定要重视择校这件事。</p>\n<p>择校的几个关键点：</p>\n<ul>\n<li><p>确定考试科目：自命题 or 统考</p>\n</li>\n<li><p>确定目标院校档次：双一流 or 92</p>\n</li>\n<li><p>确定自身实力：近年真题 and 模拟考试</p>\n</li>\n<li><p>调研目标院校考情：各种分数指标 and 录取原则</p>\n</li>\n</ul>\n<p>鼠鼠的个人观点：</p>\n<ul>\n<li><p>考虑地区时建议不要被家乡束缚，眼光要长远，虽然江苏确实是鼠鼠心目中全国最好的地区没有之一，但也不能总吃细糠</p>\n</li>\n<li><p>推荐报考统考408，因为有些自命题非常不稳定，小心被坑死，鼠鼠已经死过一次了，所以大家不要贪图一两门课简单而失去了更大的优势，408其实不难，只是多</p>\n</li>\n<li><p>有实力的可以考11408，调剂时优势非常非常巨大，身边有朋友甚至调剂到比一志愿好更多更多的院校</p>\n</li>\n<li><p>推荐双一流以上的院校，往下的不值得一上，除非没办法的时候（调剂）</p>\n</li>\n<li><p>学习的时候留一两年的真题不做，留着摸摸自己的底</p>\n</li>\n<li><p>院校调研要多方位，微信公众号+B站+知乎+小红书等等等等，还有研可岸这个网站，里面有很多院校的信息</p>\n</li>\n</ul>\n<p>鼠鼠本人属于是一念神魔型选手，发挥好随便挑，发挥差简直一坨，所以二战综合选择了“一线城市+中上游211”这样的目标。</p>\n<p>最后也欢迎学弟学妹也考来北京抱团发展。</p>\n<h3 id=\"4-学科建议\"><a href=\"#4-学科建议\" class=\"headerlink\" title=\"4.学科建议\"></a>4.学科建议</h3><p>下面聊点具体的，但是一定要根据自身调整</p>\n<p>总的来说：“是否能够上岸” &#x3D; “你的数学和专业课炸没炸”</p>\n<p>所以，<em><strong>整个备考的重心始终要放在数学和专业课上</strong></em></p>\n<p>举个例子，数学最低分值的选择填空为5分，英语完型填空为0.5分一个，而过去的完型均分大约也就5分（除了最近年份），所以孰轻孰重，鼠鼠相信大家自己能判断</p>\n<h4 id=\"政治\"><a href=\"#政治\" class=\"headerlink\" title=\"政治\"></a>政治</h4><p>这门学科就是简单考察学生个人素养，热爱国家，心中有理想，脚下有力量就行。</p>\n<p>至于学习，12月的时候<strong>肖四肖八</strong>会出版，这将是唯一且最重要的学习资料。肖八写选择，听讲解，记忆知识点；肖四写选择，听讲解，背诵分析题。对于分析题，背下来还是比较难且枯燥的，推荐博主：大牙考研，他总结的带背版逻辑清晰，行为精简，更适合工科宝宝体质。</p>\n<p>前期的话，可以吃饭的时候把徐涛强化课当故事听一听，图一乐。其他乱七八糟的什么1000题什么的不要写。</p>\n<blockquote>\n<p><strong>总结</strong>：前期按兵不动，最后做好冲刺，不要花太多心思（因为花了也没用，性价比极低）</p>\n</blockquote>\n<p>  （2025年肖4大翻车，或者说被反向押题了，但是不能否认这本资料在之后考试中的重要性）</p>\n<h4 id=\"英语\"><a href=\"#英语\" class=\"headerlink\" title=\"英语\"></a>英语</h4><p>复习关键：<strong>单词+阅读</strong></p>\n<p>单词，推荐使用手机软件背诵，随时随地背（虽然鼠鼠做不到），背上一两遍基本无敌了，基础不好一定要一直背。大部分的单词都只需要留下印象，看到以后知道是什么意思，不用会写。</p>\n<p>阅读，通过真题学习，不要看任何其他资料，只会误导方向。鼠鼠在一战的时候是做了一遍所有的真题，包括英一和英二，个人感觉两者差不太多，一开始错的挺多，写着写着就入魔了，基本不会出错，所以要多写，找到感觉。不要听人家说的神乎其神，阅读就是力大砖飞，干就完了。暑假的时候集中强化训练。真是耐听王的话，推荐看看唐迟的阅读课，有微乎其微的作用吧，不如力大砖飞。</p>\n<p>作文，两年经验来看，推荐自己总结模板，分数更高，需要的可以直接找鼠鼠要，包牛逼的。时间大概是十月十一月开始学问题不大。底子差的可以听听石雷鹏的课，简单易上手，宝宝巴士型。</p>\n<p>其他题型，学一下做题方法就行，基本都是送分题，无需在意也不用专门复习，十一月看一下就行。<em>（语法，学个damn）</em></p>\n<p>PS：如果你是像鼠鼠这种的偏科神人，直接不学也没事，可以省出很多时间给数学和408。</p>\n<blockquote>\n<p><strong>总结</strong>：单词一直背，阅读狠狠练，力大砖飞！</p>\n</blockquote>\n<h4 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h4><ol>\n<li>时间段：</li>\n</ol>\n<ul>\n<li><p>基础：4月-6月</p>\n</li>\n<li><p>强化：7月-10月</p>\n</li>\n<li><p>冲刺：11月-12月</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>各阶段课程建议</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>目标</th>\n<th>课程</th>\n<th>资料</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>基础</td>\n<td>系统地学习一遍</td>\n<td>三大名师任选其一：汤家凤、武忠祥、张宇</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>线代：李永乐老爷爷 or 没咋了救命课</td>\n<td>对应的讲义资料即可</td>\n<td>每个人习惯差异很大，每个老师的课听一两节，看看哪个舒服就选哪个。例如汤老师的南京口音鼠鼠感觉很亲切，有种回高中的感觉，有助睡眠（bushi，所以选择基础课听汤老师</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>强化</td>\n<td>巩固知识点，学会做题</td>\n<td>推荐：武忠祥 or 张宇</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>线代：李永乐老爷爷 or 没咋了救命课</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>习题讲解：B站一些优质博主，例如没咋了，已经记不清了，自行搜索鉴别</td>\n<td>对应的强化讲义</td>\n<td>强化重点在于做题而不是听课，当然了可也是必须要听的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>注重习题复盘</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>冲刺</td>\n<td>提升应试能力，狠狠地写试卷，针对性地复习</td>\n<td>查漏补缺，B站上找需要的视频来看</td>\n<td>各种真题模拟卷，建议：不要急着买，每年试卷质量不一样，等一手网上各个博主的测评，值得写再买</td>\n<td>看视频缺哪补哪，不要看什么《17堂课》这种长长的课，你没有那个时间了</td>\n</tr>\n<tr>\n<td>做套卷一定一定要计时，不然等于没做</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ol start=\"3\">\n<li>学习指南（各种碎碎念）</li>\n</ol>\n<ul>\n<li><p>数学一定要大段时间一起学，能进心流是最好</p>\n</li>\n<li><p>听课和练习要结合，学完就去写，不要猛猛听课</p>\n</li>\n<li><p>练习题选择要看网上的评测，是否适合自己</p>\n</li>\n<li><p>重视线代，这门学科有独特魔力，一个星期不碰＝从没学过，一定不能停，千万不要不信邪</p>\n</li>\n<li><p>学习过程：听课→例题→练习题→(全篇复习：错题二刷)</p>\n</li>\n<li><p>做题时间原则，5分的题，5分钟没写出来，直接跳过</p>\n</li>\n<li><p>做试卷的原则，速通然后检查，最后攻坚克难</p>\n</li>\n<li><p>冲刺阶段：2天一套模拟卷，一天做，一天复盘总结（必不可少）</p>\n</li>\n<li><p>做题本很有必要去做，用于回顾知识；笔记本，对于数学而言意义不大，不建议搞</p>\n</li>\n<li><p>不断思考学习方法有没有更好的改进</p>\n</li>\n<li><p>最后阶段集中攻克薄弱，例如反常积分不会，找到专题内容猛猛补就行</p>\n</li>\n<li><p>数学关键是做题能力，不要当耐听王，多动手</p>\n</li>\n<li><p>各个博主的优质内容一定要在有了基础前提下学习，不要上来就跟着某个up主学这学那</p>\n</li>\n<li><p>数学也是力大砖飞，计算能力要过关，尤其是近几年的题目，会写但是未必得分，所以要多练</p>\n</li>\n<li><p>注意一些犄角旮旯的知识点，有时候出卷老头真的很逆天，25年搞了个万有引力直接爆了</p>\n</li>\n<li><p>记住数学的基础分就有120，所以不失误就已经赢了，要打牢基础，注重计算（鼠鼠就经常死在计算上，一定要多练）</p>\n</li>\n<li><p>跳出自己的舒适区，越不会越要搞会。这里我指的是自己的薄弱知识，而不是硬钢那些难题</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>其他问题</li>\n</ol>\n<ul>\n<li><p>例如各个资料和试卷质量问题，可以联系鼠鼠询问，就不一一列举</p>\n</li>\n<li><p>资料推荐买盗版或者电子版，省下来的钱上岸之后猛猛玩</p>\n</li>\n<li><p>上面都挺关键的，距离考试时间已经很久远了，想不到更多了，欢迎提问</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>总结</strong>：基础不牢，地动山摇。多写题多总结 ＞ 耐听王。力大砖飞！</p>\n</blockquote>\n<h4 id=\"408\"><a href=\"#408\" class=\"headerlink\" title=\"408\"></a>408</h4><ol start=\"5\">\n<li>认知：</li>\n</ol>\n<ul>\n<li><p>408的难度在于知识点的量很大，而不是知识点深度</p>\n</li>\n<li><p>408学习的精髓在于多次反复，因为他有很多文科的特性</p>\n</li>\n<li><p>408需要的时间也没有那么吓人，鼠鼠二战从7月开始学，仍然完完整整过了两遍，后期甚至没事干</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li>学习建议：</li>\n</ol>\n<p>  基础阶段就是听王道课，过一遍，很难的内容直接跳，例如计组中的一些东西非常难懂，没关系直接跳。与此同时做王道的课后题中的选择题，推荐使用电子的刷题本，然后打印下来。每题都要弄懂，相关知识点写旁边。习题讲解推荐：Boky、里昂学长或者王道官方。</p>\n<p>  另外我听过Boky的其他课程，也非常非常推荐，这个女生讲解的很有条理，比起王道的课程更精简高效，全程班不知道质量如何，钱包有实力可以考虑。另外就是她的出版资料非常的棒，比起厚厚的王道书，简直就是神器，推荐入手，鼠鼠后期一直看得她的资料，再也没翻过王道书。</p>\n<p>  强化的话，王道的强化课是比较推荐的，讲大题的解题方法与知识点的综合，尤其是存储相关的内容和PV相关的内容，跟着做题学习大题，会有茅塞顿开的感觉。</p>\n<p>  然后就是真题阶段，这个阶段也非常重要，408最好的复习资料就是历年真题，鼠鼠认为至少要刷三遍以上才算吃透，要有一个错题本记录题目和知识点，因为408重复考察的很多。</p>\n<p>  王道在12月中旬的时候会有一个冲刺课，可以去报个名听一下，咸鱼会把最后几天的重点都勾出来，然后剩下的几天如果没东西复习了，就可以跟着他的重点再复习一次。</p>\n<ol start=\"7\">\n<li>其他：</li>\n</ol>\n<ul>\n<li><p>不要钻牛角尖，例如红黑树之类的，差不多得了，408量比较大，完成度更重要</p>\n</li>\n<li><p>一步步进行，打牢基础，你会发现408并不难，尤其是写真题的时候</p>\n</li>\n<li><p>计网的话咸鱼版本应该已经重置完成了，不够湖科大老师的任然非常推荐</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>总结</strong>：注重完成度，知识点全覆盖。反复多次，实实在在吃透真题。力大砖飞！</p>\n</blockquote>\n<h3 id=\"其他疑问\"><a href=\"#其他疑问\" class=\"headerlink\" title=\"其他疑问\"></a>其他疑问</h3><blockquote>\n<p>欢迎邮箱留言，鼠鼠知无不言：<a href=\"mailto:&#97;&#108;&#97;&#110;&#95;&#114;&#111;&#111;&#x74;&#x40;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#111;&#109;\">&#97;&#108;&#97;&#110;&#95;&#114;&#111;&#111;&#x74;&#x40;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#111;&#109;</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>突发奇想写一下考研的经验分享，希望帮到有需要的同学</p>\n</blockquote>\n<p>  鼠鼠一战985自命题遗憾败北，二战京区22408的211稳稳上岸，两年里摸索了很多</p>\n<p>  原本感觉能写很多，但是时间相距甚远，记忆模糊了，简单写一些重要的内容</p>\n<p>  以下观点，纯属主观，博君一笑，请自行斟酌，不要和鼠鼠扯皮</p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在现在这个时代，作为在校大学生首先需要对“考研”这件事做一个权衡，思考一些问题，例如：</p>\n<ul>\n<li><p>我是否适合读研？</p>\n</li>\n<li><p>我是否需要读研？</p>\n</li>\n<li><p>读研能否给我想要的“东西”？</p>\n</li>\n<li><p>我毕业能不能找到工作？</p>\n</li>\n</ul>\n<p>等等等等…因为是否读研可以看做是人生小阶段的一个小小的分支，所以要想好自己路</p>\n<p>就我个人而言，我的想法是：1.当前就业环境不佳，直接工作不一定能给我想要的生活；2.个人性格和出身原因，非常希望去到一个更高层次的地方（认知、知识和社交等）探索这个世界；</p>\n<p>所以我决定考研，并且给自己两年的机会，好在最后达成了目标</p>\n<h3 id=\"2-时间地点安排\"><a href=\"#2-时间地点安排\" class=\"headerlink\" title=\"2.时间地点安排\"></a>2.时间地点安排</h3><p>对于时间，首先得先大致了解一下<strong>考试的时间</strong>安排（什么时候考试，什么时候报名之类的），这些信息还是比较好搜集的，简单看一下，心里有个数。</p>\n<p>然后是<strong>自己的时间</strong>，二战的话时间自由，一战的话了解一下自己学校的课程安排，学校应该不会用课程和实训来耽误学生考研学习，如果真的遇到学校为难的，咨询上岸学长怎么处理的，这个应该不成问题。</p>\n<p>对于<strong>学习地点</strong>的话，以鼠鼠的本科学校为例，对于一战的同学，前期的话可以去图书馆听课学习，但是到了强化和冲刺阶段，最好是选择学校提供的考研自习室，尽量不要去图书馆，因为受到开馆闭馆时间的限制，而自习室24小时开着，没人管，条件也更好（#60顶楼那个就不错）。</p>\n<p>对于一战来说，有一个时间节点比较特殊，就是七八月的<strong>暑假</strong>。一般有三个选项：回家、留校、租房。暑假非常非常非常关键，一定选择自己适合的方式，这里仅避雷鼠鼠本科学校的留校，非常不好。另外两种的话，仁者见仁智者见智，鼠鼠是选择了攒钱租房闭关度过两个月，而鼠鼠的好朋友弓大大在家学习最终也取得了那一届最好的成绩（420+）。</p>\n<p>最后就是<strong>学习时间</strong>，前期的基础阶段的话，鼠鼠认为无所谓，目标就是系统性的学一遍（学的好不好没差别，反正后面也会忘）。至于最后的冲刺阶段也很简单：“你有多少能量，就有多大作为”，这句话就是说到了快考试的那段时间，大家的精神和身体应该来说都相当疲惫了，尤其是精神，都有可能倦怠迷茫，那就得看自己的精神状态了，能学进去多少全看自己造化了。</p>\n<p>所以鼠鼠主要分享一下<strong>强化阶段</strong>的时间安排，这个还是比较重要的：</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>内容</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7：00-7：30</td>\n<td>起床+背单词</td>\n<td></td>\n</tr>\n<tr>\n<td>7：30-8：00</td>\n<td>随机睡回笼觉</td>\n<td>保证精神</td>\n</tr>\n<tr>\n<td>8：00-9：00</td>\n<td>英语真题</td>\n<td>基础不好的可以继续背单词</td>\n</tr>\n<tr>\n<td>9：30-11：00</td>\n<td>408</td>\n<td>也有人说跟真实考试一样，上午学数学，鼠鼠认为无所谓，后期模考的时候可以注意一下</td>\n</tr>\n<tr>\n<td>11：30-13：30</td>\n<td>吃饭+午休</td>\n<td></td>\n</tr>\n<tr>\n<td>13：30-16：00</td>\n<td>高数</td>\n<td></td>\n</tr>\n<tr>\n<td>16：00-18：30</td>\n<td>线代</td>\n<td>很多人会踩的坑，线代和高数一定要一起学，都很重要，尤其是线代比较简单，纯送分</td>\n</tr>\n<tr>\n<td>18：30-20：00</td>\n<td>吃饭+骑车+洗澡</td>\n<td>适量运动，不然身体会垮掉，鼠鼠整个半年都没感冒过</td>\n</tr>\n<tr>\n<td>20：00-22：00</td>\n<td>408</td>\n<td></td>\n</tr>\n<tr>\n<td>22：00-23：00</td>\n<td>王者荣耀，启动！</td>\n<td>蘸豆，爽！</td>\n</tr>\n<tr>\n<td>23：00-00：00</td>\n<td>休息</td>\n<td>鼠鼠定力差，经常玩手机玩过头，不过感觉也无所谓</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>1.在整个备考期间一定要保证睡眠，至少要睡满7.5h(8h则更好)。睡眠充足对学习大有益处，虽然鼠鼠在这一点上做得很差。</p>\n</blockquote>\n<p>  2.计划是上面的计划，其实执行过程难免磕磕绊绊，比如睡个大懒觉、玩个一整天游戏或者出去旅游两天，都是小事，不要有负罪感，玩就爽玩，学就狂学。战略上拿下就行了，强化阶段战略是“<strong>闭关修炼</strong>”。</p>\n<p>  3.另外说明的是，鼠鼠的英语有点小天赋，所以压根就没怎么学，单词都没背，所以同学们需要根据自身情况调整。</p>\n<h3 id=\"3-考研择校\"><a href=\"#3-考研择校\" class=\"headerlink\" title=\"3.考研择校\"></a>3.考研择校</h3><p>最重要的一关，一点比较颠覆性的认知是“选择大于努力”，这不是假大空的道理，也不是事后大家的玩梗，这是考研这件事（甚至是往后的人生）的准则，所以一定要重视择校这件事。</p>\n<p>择校的几个关键点：</p>\n<ul>\n<li><p>确定考试科目：自命题 or 统考</p>\n</li>\n<li><p>确定目标院校档次：双一流 or 92</p>\n</li>\n<li><p>确定自身实力：近年真题 and 模拟考试</p>\n</li>\n<li><p>调研目标院校考情：各种分数指标 and 录取原则</p>\n</li>\n</ul>\n<p>鼠鼠的个人观点：</p>\n<ul>\n<li><p>考虑地区时建议不要被家乡束缚，眼光要长远，虽然江苏确实是鼠鼠心目中全国最好的地区没有之一，但也不能总吃细糠</p>\n</li>\n<li><p>推荐报考统考408，因为有些自命题非常不稳定，小心被坑死，鼠鼠已经死过一次了，所以大家不要贪图一两门课简单而失去了更大的优势，408其实不难，只是多</p>\n</li>\n<li><p>有实力的可以考11408，调剂时优势非常非常巨大，身边有朋友甚至调剂到比一志愿好更多更多的院校</p>\n</li>\n<li><p>推荐双一流以上的院校，往下的不值得一上，除非没办法的时候（调剂）</p>\n</li>\n<li><p>学习的时候留一两年的真题不做，留着摸摸自己的底</p>\n</li>\n<li><p>院校调研要多方位，微信公众号+B站+知乎+小红书等等等等，还有研可岸这个网站，里面有很多院校的信息</p>\n</li>\n</ul>\n<p>鼠鼠本人属于是一念神魔型选手，发挥好随便挑，发挥差简直一坨，所以二战综合选择了“一线城市+中上游211”这样的目标。</p>\n<p>最后也欢迎学弟学妹也考来北京抱团发展。</p>\n<h3 id=\"4-学科建议\"><a href=\"#4-学科建议\" class=\"headerlink\" title=\"4.学科建议\"></a>4.学科建议</h3><p>下面聊点具体的，但是一定要根据自身调整</p>\n<p>总的来说：“是否能够上岸” &#x3D; “你的数学和专业课炸没炸”</p>\n<p>所以，<em><strong>整个备考的重心始终要放在数学和专业课上</strong></em></p>\n<p>举个例子，数学最低分值的选择填空为5分，英语完型填空为0.5分一个，而过去的完型均分大约也就5分（除了最近年份），所以孰轻孰重，鼠鼠相信大家自己能判断</p>\n<h4 id=\"政治\"><a href=\"#政治\" class=\"headerlink\" title=\"政治\"></a>政治</h4><p>这门学科就是简单考察学生个人素养，热爱国家，心中有理想，脚下有力量就行。</p>\n<p>至于学习，12月的时候<strong>肖四肖八</strong>会出版，这将是唯一且最重要的学习资料。肖八写选择，听讲解，记忆知识点；肖四写选择，听讲解，背诵分析题。对于分析题，背下来还是比较难且枯燥的，推荐博主：大牙考研，他总结的带背版逻辑清晰，行为精简，更适合工科宝宝体质。</p>\n<p>前期的话，可以吃饭的时候把徐涛强化课当故事听一听，图一乐。其他乱七八糟的什么1000题什么的不要写。</p>\n<blockquote>\n<p><strong>总结</strong>：前期按兵不动，最后做好冲刺，不要花太多心思（因为花了也没用，性价比极低）</p>\n</blockquote>\n<p>  （2025年肖4大翻车，或者说被反向押题了，但是不能否认这本资料在之后考试中的重要性）</p>\n<h4 id=\"英语\"><a href=\"#英语\" class=\"headerlink\" title=\"英语\"></a>英语</h4><p>复习关键：<strong>单词+阅读</strong></p>\n<p>单词，推荐使用手机软件背诵，随时随地背（虽然鼠鼠做不到），背上一两遍基本无敌了，基础不好一定要一直背。大部分的单词都只需要留下印象，看到以后知道是什么意思，不用会写。</p>\n<p>阅读，通过真题学习，不要看任何其他资料，只会误导方向。鼠鼠在一战的时候是做了一遍所有的真题，包括英一和英二，个人感觉两者差不太多，一开始错的挺多，写着写着就入魔了，基本不会出错，所以要多写，找到感觉。不要听人家说的神乎其神，阅读就是力大砖飞，干就完了。暑假的时候集中强化训练。真是耐听王的话，推荐看看唐迟的阅读课，有微乎其微的作用吧，不如力大砖飞。</p>\n<p>作文，两年经验来看，推荐自己总结模板，分数更高，需要的可以直接找鼠鼠要，包牛逼的。时间大概是十月十一月开始学问题不大。底子差的可以听听石雷鹏的课，简单易上手，宝宝巴士型。</p>\n<p>其他题型，学一下做题方法就行，基本都是送分题，无需在意也不用专门复习，十一月看一下就行。<em>（语法，学个damn）</em></p>\n<p>PS：如果你是像鼠鼠这种的偏科神人，直接不学也没事，可以省出很多时间给数学和408。</p>\n<blockquote>\n<p><strong>总结</strong>：单词一直背，阅读狠狠练，力大砖飞！</p>\n</blockquote>\n<h4 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h4><ol>\n<li>时间段：</li>\n</ol>\n<ul>\n<li><p>基础：4月-6月</p>\n</li>\n<li><p>强化：7月-10月</p>\n</li>\n<li><p>冲刺：11月-12月</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>各阶段课程建议</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>目标</th>\n<th>课程</th>\n<th>资料</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>基础</td>\n<td>系统地学习一遍</td>\n<td>三大名师任选其一：汤家凤、武忠祥、张宇</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>线代：李永乐老爷爷 or 没咋了救命课</td>\n<td>对应的讲义资料即可</td>\n<td>每个人习惯差异很大，每个老师的课听一两节，看看哪个舒服就选哪个。例如汤老师的南京口音鼠鼠感觉很亲切，有种回高中的感觉，有助睡眠（bushi，所以选择基础课听汤老师</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>强化</td>\n<td>巩固知识点，学会做题</td>\n<td>推荐：武忠祥 or 张宇</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>线代：李永乐老爷爷 or 没咋了救命课</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>习题讲解：B站一些优质博主，例如没咋了，已经记不清了，自行搜索鉴别</td>\n<td>对应的强化讲义</td>\n<td>强化重点在于做题而不是听课，当然了可也是必须要听的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>注重习题复盘</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>冲刺</td>\n<td>提升应试能力，狠狠地写试卷，针对性地复习</td>\n<td>查漏补缺，B站上找需要的视频来看</td>\n<td>各种真题模拟卷，建议：不要急着买，每年试卷质量不一样，等一手网上各个博主的测评，值得写再买</td>\n<td>看视频缺哪补哪，不要看什么《17堂课》这种长长的课，你没有那个时间了</td>\n</tr>\n<tr>\n<td>做套卷一定一定要计时，不然等于没做</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ol start=\"3\">\n<li>学习指南（各种碎碎念）</li>\n</ol>\n<ul>\n<li><p>数学一定要大段时间一起学，能进心流是最好</p>\n</li>\n<li><p>听课和练习要结合，学完就去写，不要猛猛听课</p>\n</li>\n<li><p>练习题选择要看网上的评测，是否适合自己</p>\n</li>\n<li><p>重视线代，这门学科有独特魔力，一个星期不碰＝从没学过，一定不能停，千万不要不信邪</p>\n</li>\n<li><p>学习过程：听课→例题→练习题→(全篇复习：错题二刷)</p>\n</li>\n<li><p>做题时间原则，5分的题，5分钟没写出来，直接跳过</p>\n</li>\n<li><p>做试卷的原则，速通然后检查，最后攻坚克难</p>\n</li>\n<li><p>冲刺阶段：2天一套模拟卷，一天做，一天复盘总结（必不可少）</p>\n</li>\n<li><p>做题本很有必要去做，用于回顾知识；笔记本，对于数学而言意义不大，不建议搞</p>\n</li>\n<li><p>不断思考学习方法有没有更好的改进</p>\n</li>\n<li><p>最后阶段集中攻克薄弱，例如反常积分不会，找到专题内容猛猛补就行</p>\n</li>\n<li><p>数学关键是做题能力，不要当耐听王，多动手</p>\n</li>\n<li><p>各个博主的优质内容一定要在有了基础前提下学习，不要上来就跟着某个up主学这学那</p>\n</li>\n<li><p>数学也是力大砖飞，计算能力要过关，尤其是近几年的题目，会写但是未必得分，所以要多练</p>\n</li>\n<li><p>注意一些犄角旮旯的知识点，有时候出卷老头真的很逆天，25年搞了个万有引力直接爆了</p>\n</li>\n<li><p>记住数学的基础分就有120，所以不失误就已经赢了，要打牢基础，注重计算（鼠鼠就经常死在计算上，一定要多练）</p>\n</li>\n<li><p>跳出自己的舒适区，越不会越要搞会。这里我指的是自己的薄弱知识，而不是硬钢那些难题</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>其他问题</li>\n</ol>\n<ul>\n<li><p>例如各个资料和试卷质量问题，可以联系鼠鼠询问，就不一一列举</p>\n</li>\n<li><p>资料推荐买盗版或者电子版，省下来的钱上岸之后猛猛玩</p>\n</li>\n<li><p>上面都挺关键的，距离考试时间已经很久远了，想不到更多了，欢迎提问</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>总结</strong>：基础不牢，地动山摇。多写题多总结 ＞ 耐听王。力大砖飞！</p>\n</blockquote>\n<h4 id=\"408\"><a href=\"#408\" class=\"headerlink\" title=\"408\"></a>408</h4><ol start=\"5\">\n<li>认知：</li>\n</ol>\n<ul>\n<li><p>408的难度在于知识点的量很大，而不是知识点深度</p>\n</li>\n<li><p>408学习的精髓在于多次反复，因为他有很多文科的特性</p>\n</li>\n<li><p>408需要的时间也没有那么吓人，鼠鼠二战从7月开始学，仍然完完整整过了两遍，后期甚至没事干</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li>学习建议：</li>\n</ol>\n<p>  基础阶段就是听王道课，过一遍，很难的内容直接跳，例如计组中的一些东西非常难懂，没关系直接跳。与此同时做王道的课后题中的选择题，推荐使用电子的刷题本，然后打印下来。每题都要弄懂，相关知识点写旁边。习题讲解推荐：Boky、里昂学长或者王道官方。</p>\n<p>  另外我听过Boky的其他课程，也非常非常推荐，这个女生讲解的很有条理，比起王道的课程更精简高效，全程班不知道质量如何，钱包有实力可以考虑。另外就是她的出版资料非常的棒，比起厚厚的王道书，简直就是神器，推荐入手，鼠鼠后期一直看得她的资料，再也没翻过王道书。</p>\n<p>  强化的话，王道的强化课是比较推荐的，讲大题的解题方法与知识点的综合，尤其是存储相关的内容和PV相关的内容，跟着做题学习大题，会有茅塞顿开的感觉。</p>\n<p>  然后就是真题阶段，这个阶段也非常重要，408最好的复习资料就是历年真题，鼠鼠认为至少要刷三遍以上才算吃透，要有一个错题本记录题目和知识点，因为408重复考察的很多。</p>\n<p>  王道在12月中旬的时候会有一个冲刺课，可以去报个名听一下，咸鱼会把最后几天的重点都勾出来，然后剩下的几天如果没东西复习了，就可以跟着他的重点再复习一次。</p>\n<ol start=\"7\">\n<li>其他：</li>\n</ol>\n<ul>\n<li><p>不要钻牛角尖，例如红黑树之类的，差不多得了，408量比较大，完成度更重要</p>\n</li>\n<li><p>一步步进行，打牢基础，你会发现408并不难，尤其是写真题的时候</p>\n</li>\n<li><p>计网的话咸鱼版本应该已经重置完成了，不够湖科大老师的任然非常推荐</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>总结</strong>：注重完成度，知识点全覆盖。反复多次，实实在在吃透真题。力大砖飞！</p>\n</blockquote>\n<h3 id=\"其他疑问\"><a href=\"#其他疑问\" class=\"headerlink\" title=\"其他疑问\"></a>其他疑问</h3><blockquote>\n<p>欢迎邮箱留言，鼠鼠知无不言：<a href=\"mailto:&#97;&#108;&#97;&#110;&#95;&#114;&#111;&#111;&#x74;&#x40;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#111;&#109;\">&#97;&#108;&#97;&#110;&#95;&#114;&#111;&#111;&#x74;&#x40;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#111;&#109;</a></p>\n</blockquote>\n"},{"title":"编程中闭包的概念","description":"闭包是一个函数，它“记住”了它创建时的环境（变量）","toc":false,"date":"2025-05-10T08:01:04.000Z","_content":"\n---\n\n## 🧠 一句话定义（简化版）：\n\n> **闭包是一个函数，它“记住”了它创建时的环境（变量）。**\n\n---\n\n## 🍱 生活类比：饭盒里的便当（闭包）\n\n想象你去上班，带了个便当盒（函数）：\n\n* 饭盒里放了饭菜（外部变量）\n* 虽然你已经离开了厨房（函数定义的作用域），\n* 但你打开便当盒，**饭菜还在**！你可以继续吃！\n\n➡️ **闭包就是这样的便当盒：带着“当时的变量环境”走了。**\n\n---\n\n## 🧪 编程版：一个 Go 的闭包示例\n\n```go\nfunc counter() func() int {\n    x := 0\n    return func() int {\n        x++\n        return x\n    }\n}\n\nfunc main() {\n    c := counter()\n    fmt.Println(c()) // 输出 1\n    fmt.Println(c()) // 输出 2\n    fmt.Println(c()) // 输出 3\n}\n```\n\n### 💡 发生了什么？\n\n* `counter` 返回一个匿名函数，这个函数访问了变量 `x`\n* `x` 是 **在 `counter()` 里定义的局部变量**\n* **即使 `counter()` 执行完了，`x` 依然活着**！\n* 每次调用 `c()`，`x` 都会 +1，因为闭包记住了它的值\n\n---\n\n## ✅ 用图感受一下\n\n```text\ncounter()\n   └── 创建变量 x = 0\n   └── 返回 func() {\n          x++\n          return x\n       }\n\nc()     ← 调用这个闭包，每次都会用到“记住的 x”\n```\n\n---\n\n## 🧩 再举一个真实用途：生成器\n\n```go\nfunc makeAdder(n int) func(int) int {\n    return func(x int) int {\n        return x + n\n    }\n}\n\nfunc main() {\n    add5 := makeAdder(5)\n    fmt.Println(add5(10)) // 输出 15\n\n    add10 := makeAdder(10)\n    fmt.Println(add10(10)) // 输出 20\n}\n```\n\n### 🧠 解释：\n\n* `makeAdder(5)` 返回的函数里“记住了 n = 5”\n* 即使 `makeAdder` 函数早就结束了，这个返回的闭包**仍然能使用 `n` 的值**\n\n---\n\n## 🧾 和普通函数的区别\n\n| 特点       | 普通函数  | 闭包（closure）    |\n| -------- | ----- | -------------- |\n| 是否依赖外部变量 | ❌ 否   | ✅ 是，能“记住”上下文   |\n| 生命周期限制   | 当前调用内 | 可能延续外部函数作用域之后  |\n| 实际用途     | 逻辑分离  | 保持状态、记忆值、回调函数等 |\n\n---\n\n## 🏁 总结一波\n\n> **闭包 = 函数 + 它创建时的环境变量的“快照”**\n\n它在很多地方都特别有用，比如：\n\n* 生成器函数\n* 回调函数\n* 保存状态的函数工厂\n* 柯里化（函数定制）\n\n---\n\n","source":"_posts/编程中闭包的概念.md","raw":"---\ntitle: 编程中闭包的概念\ndescription: '闭包是一个函数，它“记住”了它创建时的环境（变量）'\ntags: []\ntoc: false\ndate: 2025-05-10 16:01:04\ncategories:\n---\n\n---\n\n## 🧠 一句话定义（简化版）：\n\n> **闭包是一个函数，它“记住”了它创建时的环境（变量）。**\n\n---\n\n## 🍱 生活类比：饭盒里的便当（闭包）\n\n想象你去上班，带了个便当盒（函数）：\n\n* 饭盒里放了饭菜（外部变量）\n* 虽然你已经离开了厨房（函数定义的作用域），\n* 但你打开便当盒，**饭菜还在**！你可以继续吃！\n\n➡️ **闭包就是这样的便当盒：带着“当时的变量环境”走了。**\n\n---\n\n## 🧪 编程版：一个 Go 的闭包示例\n\n```go\nfunc counter() func() int {\n    x := 0\n    return func() int {\n        x++\n        return x\n    }\n}\n\nfunc main() {\n    c := counter()\n    fmt.Println(c()) // 输出 1\n    fmt.Println(c()) // 输出 2\n    fmt.Println(c()) // 输出 3\n}\n```\n\n### 💡 发生了什么？\n\n* `counter` 返回一个匿名函数，这个函数访问了变量 `x`\n* `x` 是 **在 `counter()` 里定义的局部变量**\n* **即使 `counter()` 执行完了，`x` 依然活着**！\n* 每次调用 `c()`，`x` 都会 +1，因为闭包记住了它的值\n\n---\n\n## ✅ 用图感受一下\n\n```text\ncounter()\n   └── 创建变量 x = 0\n   └── 返回 func() {\n          x++\n          return x\n       }\n\nc()     ← 调用这个闭包，每次都会用到“记住的 x”\n```\n\n---\n\n## 🧩 再举一个真实用途：生成器\n\n```go\nfunc makeAdder(n int) func(int) int {\n    return func(x int) int {\n        return x + n\n    }\n}\n\nfunc main() {\n    add5 := makeAdder(5)\n    fmt.Println(add5(10)) // 输出 15\n\n    add10 := makeAdder(10)\n    fmt.Println(add10(10)) // 输出 20\n}\n```\n\n### 🧠 解释：\n\n* `makeAdder(5)` 返回的函数里“记住了 n = 5”\n* 即使 `makeAdder` 函数早就结束了，这个返回的闭包**仍然能使用 `n` 的值**\n\n---\n\n## 🧾 和普通函数的区别\n\n| 特点       | 普通函数  | 闭包（closure）    |\n| -------- | ----- | -------------- |\n| 是否依赖外部变量 | ❌ 否   | ✅ 是，能“记住”上下文   |\n| 生命周期限制   | 当前调用内 | 可能延续外部函数作用域之后  |\n| 实际用途     | 逻辑分离  | 保持状态、记忆值、回调函数等 |\n\n---\n\n## 🏁 总结一波\n\n> **闭包 = 函数 + 它创建时的环境变量的“快照”**\n\n它在很多地方都特别有用，比如：\n\n* 生成器函数\n* 回调函数\n* 保存状态的函数工厂\n* 柯里化（函数定制）\n\n---\n\n","slug":"编程中闭包的概念","published":1,"updated":"2025-05-12T11:51:14.525Z","comments":1,"layout":"post","photos":[],"_id":"cmal0vt8h0014p3j5hay68o6e","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><hr>\n<h2 id=\"🧠-一句话定义（简化版）：\"><a href=\"#🧠-一句话定义（简化版）：\" class=\"headerlink\" title=\"🧠 一句话定义（简化版）：\"></a>🧠 一句话定义（简化版）：</h2><blockquote>\n<p><strong>闭包是一个函数，它“记住”了它创建时的环境（变量）。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"🍱-生活类比：饭盒里的便当（闭包）\"><a href=\"#🍱-生活类比：饭盒里的便当（闭包）\" class=\"headerlink\" title=\"🍱 生活类比：饭盒里的便当（闭包）\"></a>🍱 生活类比：饭盒里的便当（闭包）</h2><p>想象你去上班，带了个便当盒（函数）：</p>\n<ul>\n<li>饭盒里放了饭菜（外部变量）</li>\n<li>虽然你已经离开了厨房（函数定义的作用域），</li>\n<li>但你打开便当盒，<strong>饭菜还在</strong>！你可以继续吃！</li>\n</ul>\n<p>➡️ <strong>闭包就是这样的便当盒：带着“当时的变量环境”走了。</strong></p>\n<hr>\n<h2 id=\"🧪-编程版：一个-Go-的闭包示例\"><a href=\"#🧪-编程版：一个-Go-的闭包示例\" class=\"headerlink\" title=\"🧪 编程版：一个 Go 的闭包示例\"></a>🧪 编程版：一个 Go 的闭包示例</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counter</span><span class=\"params\">()</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    x := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        x++</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    c := counter()</span><br><span class=\"line\">    fmt.Println(c()) <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">    fmt.Println(c()) <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">    fmt.Println(c()) <span class=\"comment\">// 输出 3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"💡-发生了什么？\"><a href=\"#💡-发生了什么？\" class=\"headerlink\" title=\"💡 发生了什么？\"></a>💡 发生了什么？</h3><ul>\n<li><code>counter</code> 返回一个匿名函数，这个函数访问了变量 <code>x</code></li>\n<li><code>x</code> 是 <strong>在 <code>counter()</code> 里定义的局部变量</strong></li>\n<li><strong>即使 <code>counter()</code> 执行完了，<code>x</code> 依然活着</strong>！</li>\n<li>每次调用 <code>c()</code>，<code>x</code> 都会 +1，因为闭包记住了它的值</li>\n</ul>\n<hr>\n<h2 id=\"✅-用图感受一下\"><a href=\"#✅-用图感受一下\" class=\"headerlink\" title=\"✅ 用图感受一下\"></a>✅ 用图感受一下</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">counter()</span><br><span class=\"line\">   └── 创建变量 x = 0</span><br><span class=\"line\">   └── 返回 func() &#123;</span><br><span class=\"line\">          x++</span><br><span class=\"line\">          return x</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">c()     ← 调用这个闭包，每次都会用到“记住的 x”</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧩-再举一个真实用途：生成器\"><a href=\"#🧩-再举一个真实用途：生成器\" class=\"headerlink\" title=\"🧩 再举一个真实用途：生成器\"></a>🧩 再举一个真实用途：生成器</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeAdder</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    add5 := makeAdder(<span class=\"number\">5</span>)</span><br><span class=\"line\">    fmt.Println(add5(<span class=\"number\">10</span>)) <span class=\"comment\">// 输出 15</span></span><br><span class=\"line\"></span><br><span class=\"line\">    add10 := makeAdder(<span class=\"number\">10</span>)</span><br><span class=\"line\">    fmt.Println(add10(<span class=\"number\">10</span>)) <span class=\"comment\">// 输出 20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🧠-解释：\"><a href=\"#🧠-解释：\" class=\"headerlink\" title=\"🧠 解释：\"></a>🧠 解释：</h3><ul>\n<li><code>makeAdder(5)</code> 返回的函数里“记住了 n &#x3D; 5”</li>\n<li>即使 <code>makeAdder</code> 函数早就结束了，这个返回的闭包<strong>仍然能使用 <code>n</code> 的值</strong></li>\n</ul>\n<hr>\n<h2 id=\"🧾-和普通函数的区别\"><a href=\"#🧾-和普通函数的区别\" class=\"headerlink\" title=\"🧾 和普通函数的区别\"></a>🧾 和普通函数的区别</h2><table>\n<thead>\n<tr>\n<th>特点</th>\n<th>普通函数</th>\n<th>闭包（closure）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否依赖外部变量</td>\n<td>❌ 否</td>\n<td>✅ 是，能“记住”上下文</td>\n</tr>\n<tr>\n<td>生命周期限制</td>\n<td>当前调用内</td>\n<td>可能延续外部函数作用域之后</td>\n</tr>\n<tr>\n<td>实际用途</td>\n<td>逻辑分离</td>\n<td>保持状态、记忆值、回调函数等</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🏁-总结一波\"><a href=\"#🏁-总结一波\" class=\"headerlink\" title=\"🏁 总结一波\"></a>🏁 总结一波</h2><blockquote>\n<p><strong>闭包 &#x3D; 函数 + 它创建时的环境变量的“快照”</strong></p>\n</blockquote>\n<p>它在很多地方都特别有用，比如：</p>\n<ul>\n<li>生成器函数</li>\n<li>回调函数</li>\n<li>保存状态的函数工厂</li>\n<li>柯里化（函数定制）</li>\n</ul>\n<hr>\n","excerpt":"","more":"<hr>\n<h2 id=\"🧠-一句话定义（简化版）：\"><a href=\"#🧠-一句话定义（简化版）：\" class=\"headerlink\" title=\"🧠 一句话定义（简化版）：\"></a>🧠 一句话定义（简化版）：</h2><blockquote>\n<p><strong>闭包是一个函数，它“记住”了它创建时的环境（变量）。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"🍱-生活类比：饭盒里的便当（闭包）\"><a href=\"#🍱-生活类比：饭盒里的便当（闭包）\" class=\"headerlink\" title=\"🍱 生活类比：饭盒里的便当（闭包）\"></a>🍱 生活类比：饭盒里的便当（闭包）</h2><p>想象你去上班，带了个便当盒（函数）：</p>\n<ul>\n<li>饭盒里放了饭菜（外部变量）</li>\n<li>虽然你已经离开了厨房（函数定义的作用域），</li>\n<li>但你打开便当盒，<strong>饭菜还在</strong>！你可以继续吃！</li>\n</ul>\n<p>➡️ <strong>闭包就是这样的便当盒：带着“当时的变量环境”走了。</strong></p>\n<hr>\n<h2 id=\"🧪-编程版：一个-Go-的闭包示例\"><a href=\"#🧪-编程版：一个-Go-的闭包示例\" class=\"headerlink\" title=\"🧪 编程版：一个 Go 的闭包示例\"></a>🧪 编程版：一个 Go 的闭包示例</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counter</span><span class=\"params\">()</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    x := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        x++</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    c := counter()</span><br><span class=\"line\">    fmt.Println(c()) <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">    fmt.Println(c()) <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">    fmt.Println(c()) <span class=\"comment\">// 输出 3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"💡-发生了什么？\"><a href=\"#💡-发生了什么？\" class=\"headerlink\" title=\"💡 发生了什么？\"></a>💡 发生了什么？</h3><ul>\n<li><code>counter</code> 返回一个匿名函数，这个函数访问了变量 <code>x</code></li>\n<li><code>x</code> 是 <strong>在 <code>counter()</code> 里定义的局部变量</strong></li>\n<li><strong>即使 <code>counter()</code> 执行完了，<code>x</code> 依然活着</strong>！</li>\n<li>每次调用 <code>c()</code>，<code>x</code> 都会 +1，因为闭包记住了它的值</li>\n</ul>\n<hr>\n<h2 id=\"✅-用图感受一下\"><a href=\"#✅-用图感受一下\" class=\"headerlink\" title=\"✅ 用图感受一下\"></a>✅ 用图感受一下</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">counter()</span><br><span class=\"line\">   └── 创建变量 x = 0</span><br><span class=\"line\">   └── 返回 func() &#123;</span><br><span class=\"line\">          x++</span><br><span class=\"line\">          return x</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">c()     ← 调用这个闭包，每次都会用到“记住的 x”</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧩-再举一个真实用途：生成器\"><a href=\"#🧩-再举一个真实用途：生成器\" class=\"headerlink\" title=\"🧩 再举一个真实用途：生成器\"></a>🧩 再举一个真实用途：生成器</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeAdder</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    add5 := makeAdder(<span class=\"number\">5</span>)</span><br><span class=\"line\">    fmt.Println(add5(<span class=\"number\">10</span>)) <span class=\"comment\">// 输出 15</span></span><br><span class=\"line\"></span><br><span class=\"line\">    add10 := makeAdder(<span class=\"number\">10</span>)</span><br><span class=\"line\">    fmt.Println(add10(<span class=\"number\">10</span>)) <span class=\"comment\">// 输出 20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🧠-解释：\"><a href=\"#🧠-解释：\" class=\"headerlink\" title=\"🧠 解释：\"></a>🧠 解释：</h3><ul>\n<li><code>makeAdder(5)</code> 返回的函数里“记住了 n &#x3D; 5”</li>\n<li>即使 <code>makeAdder</code> 函数早就结束了，这个返回的闭包<strong>仍然能使用 <code>n</code> 的值</strong></li>\n</ul>\n<hr>\n<h2 id=\"🧾-和普通函数的区别\"><a href=\"#🧾-和普通函数的区别\" class=\"headerlink\" title=\"🧾 和普通函数的区别\"></a>🧾 和普通函数的区别</h2><table>\n<thead>\n<tr>\n<th>特点</th>\n<th>普通函数</th>\n<th>闭包（closure）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否依赖外部变量</td>\n<td>❌ 否</td>\n<td>✅ 是，能“记住”上下文</td>\n</tr>\n<tr>\n<td>生命周期限制</td>\n<td>当前调用内</td>\n<td>可能延续外部函数作用域之后</td>\n</tr>\n<tr>\n<td>实际用途</td>\n<td>逻辑分离</td>\n<td>保持状态、记忆值、回调函数等</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🏁-总结一波\"><a href=\"#🏁-总结一波\" class=\"headerlink\" title=\"🏁 总结一波\"></a>🏁 总结一波</h2><blockquote>\n<p><strong>闭包 &#x3D; 函数 + 它创建时的环境变量的“快照”</strong></p>\n</blockquote>\n<p>它在很多地方都特别有用，比如：</p>\n<ul>\n<li>生成器函数</li>\n<li>回调函数</li>\n<li>保存状态的函数工厂</li>\n<li>柯里化（函数定制）</li>\n</ul>\n<hr>\n"},{"title":"conda常用命令","description":"Anaconda 是一个流行的 Python 数据科学平台，主要用于管理虚拟环境和包。","toc":false,"date":"2025-05-20T10:51:23.000Z","_content":"\nAnaconda 是一个流行的 Python 数据科学平台，主要用于管理虚拟环境和包。以下是常用的 Anaconda 命令分类整理：\n\n---\n\n**1. 环境管理**\n• 查看所有环境  \n\n  ```bash\n  conda env list\n  ```\n• 创建新环境  \n\n  ```bash\n  conda create --name myenv python=3.9  # 指定 Python 版本\n  ```\n• 激活/退出环境  \n\n  ```bash\n  conda activate myenv    # 激活环境\n  conda deactivate        # 退出当前环境\n  ```\n• 删除环境  \n\n  ```bash\n  conda env remove --name myenv\n  ```\n• 导出/导入环境配置  \n\n  ```bash\n  conda env export > environment.yml    # 导出\n  conda env create -f environment.yml   # 导入\n  ```\n\n---\n\n**2. 包管理**\n• 安装包  \n\n  ```bash\n  conda install numpy        # 安装指定包\n  conda install numpy=1.21    # 指定版本\n  pip install package_name    # 使用 pip 安装（conda 不支持的包）\n  ```\n• 卸载包  \n\n  ```bash\n  conda uninstall numpy\n  ```\n• 更新包  \n\n  ```bash\n  conda update numpy         # 更新单个包\n  conda update --all         # 更新所有包\n  ```\n• 搜索包  \n\n  ```bash\n  conda search numpy\n  ```\n• 列出已安装包  \n\n  ```bash\n  conda list\n  ```\n\n---\n\n**3. Anaconda 自身管理**\n• 更新 Conda  \n\n  ```bash\n  conda update conda\n  ```\n• 更新 Anaconda  \n\n  ```bash\n  conda update anaconda\n  ```\n• 清理缓存/无用包  \n\n  ```bash\n  conda clean --all\n  ```\n\n---\n\n**4. Jupyter Notebook 相关**\n• 在特定环境中安装 Jupyter  \n\n  ```bash\n  conda install nb_conda       # 支持环境切换\n  ```\n• 启动 Jupyter Notebook  \n\n  ```bash\n  jupyter notebook\n  ```\n• 生成 Jupyter 内核（针对虚拟环境）  \n\n  ```bash\n  python -m ipykernel install --user --name myenv --display-name \"Python (myenv)\"\n  ```\n\n---\n\n**5. 其他实用命令**\n• 查看 Conda 信息  \n\n  ```bash\n  conda info\n  ```\n• 检查 Conda 版本  \n\n  ```bash\n  conda --version\n  ```\n• 从 requirements.txt 安装包（pip 格式）  \n\n  ```bash\n  pip install -r requirements.txt\n  ```\n\n---\n\n**常见问题解决**\n1. Conda 命令慢/卡顿  \n   • 更换国内镜像源（如清华源）：  \n\n     ```bash\n     conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n     conda config --set show_channel_urls yes\n     ```\n   • 恢复默认源：  \n\n     ```bash\n     conda config --remove-key channels\n     ```\n---","source":"_posts/conda常用命令.md","raw":"---\ntitle: conda常用命令\ndescription: 'Anaconda 是一个流行的 Python 数据科学平台，主要用于管理虚拟环境和包。'\ntags: ['科研', 'conda', 'python']\ntoc: false\ndate: 2025-05-20 18:51:23\ncategories:\n---\n\nAnaconda 是一个流行的 Python 数据科学平台，主要用于管理虚拟环境和包。以下是常用的 Anaconda 命令分类整理：\n\n---\n\n**1. 环境管理**\n• 查看所有环境  \n\n  ```bash\n  conda env list\n  ```\n• 创建新环境  \n\n  ```bash\n  conda create --name myenv python=3.9  # 指定 Python 版本\n  ```\n• 激活/退出环境  \n\n  ```bash\n  conda activate myenv    # 激活环境\n  conda deactivate        # 退出当前环境\n  ```\n• 删除环境  \n\n  ```bash\n  conda env remove --name myenv\n  ```\n• 导出/导入环境配置  \n\n  ```bash\n  conda env export > environment.yml    # 导出\n  conda env create -f environment.yml   # 导入\n  ```\n\n---\n\n**2. 包管理**\n• 安装包  \n\n  ```bash\n  conda install numpy        # 安装指定包\n  conda install numpy=1.21    # 指定版本\n  pip install package_name    # 使用 pip 安装（conda 不支持的包）\n  ```\n• 卸载包  \n\n  ```bash\n  conda uninstall numpy\n  ```\n• 更新包  \n\n  ```bash\n  conda update numpy         # 更新单个包\n  conda update --all         # 更新所有包\n  ```\n• 搜索包  \n\n  ```bash\n  conda search numpy\n  ```\n• 列出已安装包  \n\n  ```bash\n  conda list\n  ```\n\n---\n\n**3. Anaconda 自身管理**\n• 更新 Conda  \n\n  ```bash\n  conda update conda\n  ```\n• 更新 Anaconda  \n\n  ```bash\n  conda update anaconda\n  ```\n• 清理缓存/无用包  \n\n  ```bash\n  conda clean --all\n  ```\n\n---\n\n**4. Jupyter Notebook 相关**\n• 在特定环境中安装 Jupyter  \n\n  ```bash\n  conda install nb_conda       # 支持环境切换\n  ```\n• 启动 Jupyter Notebook  \n\n  ```bash\n  jupyter notebook\n  ```\n• 生成 Jupyter 内核（针对虚拟环境）  \n\n  ```bash\n  python -m ipykernel install --user --name myenv --display-name \"Python (myenv)\"\n  ```\n\n---\n\n**5. 其他实用命令**\n• 查看 Conda 信息  \n\n  ```bash\n  conda info\n  ```\n• 检查 Conda 版本  \n\n  ```bash\n  conda --version\n  ```\n• 从 requirements.txt 安装包（pip 格式）  \n\n  ```bash\n  pip install -r requirements.txt\n  ```\n\n---\n\n**常见问题解决**\n1. Conda 命令慢/卡顿  \n   • 更换国内镜像源（如清华源）：  \n\n     ```bash\n     conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n     conda config --set show_channel_urls yes\n     ```\n   • 恢复默认源：  \n\n     ```bash\n     conda config --remove-key channels\n     ```\n---","slug":"conda常用命令","published":1,"updated":"2025-05-20T10:52:35.358Z","comments":1,"layout":"post","photos":[],"_id":"cmawebaqp00003oj59kmk2629","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Anaconda 是一个流行的 Python 数据科学平台，主要用于管理虚拟环境和包。以下是常用的 Anaconda 命令分类整理：</p>\n<hr>\n<p><strong>1. 环境管理</strong><br>• 查看所有环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda <span class=\"built_in\">env</span> list</span><br></pre></td></tr></table></figure>\n<p>• 创建新环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create --name myenv python=3.9  <span class=\"comment\"># 指定 Python 版本</span></span><br></pre></td></tr></table></figure>\n<p>• 激活&#x2F;退出环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate myenv    <span class=\"comment\"># 激活环境</span></span><br><span class=\"line\">conda deactivate        <span class=\"comment\"># 退出当前环境</span></span><br></pre></td></tr></table></figure>\n<p>• 删除环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda <span class=\"built_in\">env</span> remove --name myenv</span><br></pre></td></tr></table></figure>\n<p>• 导出&#x2F;导入环境配置  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda <span class=\"built_in\">env</span> <span class=\"built_in\">export</span> &gt; environment.yml    <span class=\"comment\"># 导出</span></span><br><span class=\"line\">conda <span class=\"built_in\">env</span> create -f environment.yml   <span class=\"comment\"># 导入</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>2. 包管理</strong><br>• 安装包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install numpy        <span class=\"comment\"># 安装指定包</span></span><br><span class=\"line\">conda install numpy=1.21    <span class=\"comment\"># 指定版本</span></span><br><span class=\"line\">pip install package_name    <span class=\"comment\"># 使用 pip 安装（conda 不支持的包）</span></span><br></pre></td></tr></table></figure>\n<p>• 卸载包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda uninstall numpy</span><br></pre></td></tr></table></figure>\n<p>• 更新包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update numpy         <span class=\"comment\"># 更新单个包</span></span><br><span class=\"line\">conda update --all         <span class=\"comment\"># 更新所有包</span></span><br></pre></td></tr></table></figure>\n<p>• 搜索包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda search numpy</span><br></pre></td></tr></table></figure>\n<p>• 列出已安装包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda list</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>3. Anaconda 自身管理</strong><br>• 更新 Conda  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update conda</span><br></pre></td></tr></table></figure>\n<p>• 更新 Anaconda  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update anaconda</span><br></pre></td></tr></table></figure>\n<p>• 清理缓存&#x2F;无用包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda clean --all</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>4. Jupyter Notebook 相关</strong><br>• 在特定环境中安装 Jupyter  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install nb_conda       <span class=\"comment\"># 支持环境切换</span></span><br></pre></td></tr></table></figure>\n<p>• 启动 Jupyter Notebook  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jupyter notebook</span><br></pre></td></tr></table></figure>\n<p>• 生成 Jupyter 内核（针对虚拟环境）  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m ipykernel install --user --name myenv --display-name <span class=\"string\">&quot;Python (myenv)&quot;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>5. 其他实用命令</strong><br>• 查看 Conda 信息  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info</span><br></pre></td></tr></table></figure>\n<p>• 检查 Conda 版本  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda --version</span><br></pre></td></tr></table></figure>\n<p>• 从 requirements.txt 安装包（pip 格式）  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>常见问题解决</strong></p>\n<ol>\n<li><p>Conda 命令慢&#x2F;卡顿<br>• 更换国内镜像源（如清华源）：  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --<span class=\"built_in\">set</span> show_channel_urls <span class=\"built_in\">yes</span></span><br></pre></td></tr></table></figure>\n<p>• 恢复默认源：  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --remove-key channels</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n","excerpt":"","more":"<p>Anaconda 是一个流行的 Python 数据科学平台，主要用于管理虚拟环境和包。以下是常用的 Anaconda 命令分类整理：</p>\n<hr>\n<p><strong>1. 环境管理</strong><br>• 查看所有环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda <span class=\"built_in\">env</span> list</span><br></pre></td></tr></table></figure>\n<p>• 创建新环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create --name myenv python=3.9  <span class=\"comment\"># 指定 Python 版本</span></span><br></pre></td></tr></table></figure>\n<p>• 激活&#x2F;退出环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate myenv    <span class=\"comment\"># 激活环境</span></span><br><span class=\"line\">conda deactivate        <span class=\"comment\"># 退出当前环境</span></span><br></pre></td></tr></table></figure>\n<p>• 删除环境  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda <span class=\"built_in\">env</span> remove --name myenv</span><br></pre></td></tr></table></figure>\n<p>• 导出&#x2F;导入环境配置  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda <span class=\"built_in\">env</span> <span class=\"built_in\">export</span> &gt; environment.yml    <span class=\"comment\"># 导出</span></span><br><span class=\"line\">conda <span class=\"built_in\">env</span> create -f environment.yml   <span class=\"comment\"># 导入</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>2. 包管理</strong><br>• 安装包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install numpy        <span class=\"comment\"># 安装指定包</span></span><br><span class=\"line\">conda install numpy=1.21    <span class=\"comment\"># 指定版本</span></span><br><span class=\"line\">pip install package_name    <span class=\"comment\"># 使用 pip 安装（conda 不支持的包）</span></span><br></pre></td></tr></table></figure>\n<p>• 卸载包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda uninstall numpy</span><br></pre></td></tr></table></figure>\n<p>• 更新包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update numpy         <span class=\"comment\"># 更新单个包</span></span><br><span class=\"line\">conda update --all         <span class=\"comment\"># 更新所有包</span></span><br></pre></td></tr></table></figure>\n<p>• 搜索包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda search numpy</span><br></pre></td></tr></table></figure>\n<p>• 列出已安装包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda list</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>3. Anaconda 自身管理</strong><br>• 更新 Conda  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update conda</span><br></pre></td></tr></table></figure>\n<p>• 更新 Anaconda  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update anaconda</span><br></pre></td></tr></table></figure>\n<p>• 清理缓存&#x2F;无用包  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda clean --all</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>4. Jupyter Notebook 相关</strong><br>• 在特定环境中安装 Jupyter  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install nb_conda       <span class=\"comment\"># 支持环境切换</span></span><br></pre></td></tr></table></figure>\n<p>• 启动 Jupyter Notebook  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jupyter notebook</span><br></pre></td></tr></table></figure>\n<p>• 生成 Jupyter 内核（针对虚拟环境）  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m ipykernel install --user --name myenv --display-name <span class=\"string\">&quot;Python (myenv)&quot;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>5. 其他实用命令</strong><br>• 查看 Conda 信息  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info</span><br></pre></td></tr></table></figure>\n<p>• 检查 Conda 版本  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda --version</span><br></pre></td></tr></table></figure>\n<p>• 从 requirements.txt 安装包（pip 格式）  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>常见问题解决</strong></p>\n<ol>\n<li><p>Conda 命令慢&#x2F;卡顿<br>• 更换国内镜像源（如清华源）：  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --<span class=\"built_in\">set</span> show_channel_urls <span class=\"built_in\">yes</span></span><br></pre></td></tr></table></figure>\n<p>• 恢复默认源：  </p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --remove-key channels</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n"},{"title":"go语言之CLI框架：cobra","description":"Cobra 是一个用于创建强大现代 CLI 应用程序的 Go 库，许多知名项目如 Kubernetes、Docker 和 Hugo 都使用它。","toc":false,"date":"2025-05-25T00:36:31.000Z","_content":"\n\n## 📦 第一步：安装 Cobra CLI 工具\n\n```bash\ngo install github.com/spf13/cobra-cli@latest\n```\n\n确保 `$GOPATH/bin` 在你的 `PATH` 中，然后你可以运行：\n\n```bash\ncobra-cli --help\n```\n\n---\n\n## 🧱 第二步：初始化项目\n\n创建你的 Go 项目目录：\n\n```bash\nmkdir tasker && cd tasker\ngo mod init github.com/yourname/tasker\n```\n\n使用 `cobra-cli` 初始化：\n\n```bash\ncobra-cli init --pkg-name github.com/yourname/tasker\n```\n\n这会生成如下结构：\n\n```\ntasker/\n├── cmd/\n│   └── root.go\n├── main.go\n```\n\n---\n\n## 🚀 第三步：运行项目\n\n在当前目录运行：\n\n```bash\ngo run main.go\n```\n\n输出将会是：\n\n```\ntasker is a CLI application\n```\n\n你可以查看帮助：\n\n```bash\ngo run main.go --help\n```\n\n---\n\n## ➕ 第四步：添加子命令\n\n### 示例：添加 `add` 命令\n\n```bash\ncobra-cli add add\n```\n\n编辑 `cmd/add.go`：\n\n```go\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar addCmd = &cobra.Command{\n\tUse:   \"add [task]\",\n\tShort: \"添加一个新任务\",\n\tArgs:  cobra.ExactArgs(1),\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\ttask := args[0]\n\t\tfmt.Printf(\"添加任务: %s\\n\", task)\n\t},\n}\n\nfunc init() {\n\trootCmd.AddCommand(addCmd)\n}\n```\n\n现在你可以运行：\n\n```bash\ngo run main.go add \"写 Cobra 教程\"\n```\n\n---\n\n## 📋 第五步：添加 `list` 命令\n\n```bash\ncobra-cli add list\n```\n\n编辑 `cmd/list.go`：\n\n```go\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar tasks = []string{}\n\nvar listCmd = &cobra.Command{\n\tUse:   \"list\",\n\tShort: \"列出所有任务\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tif len(tasks) == 0 {\n\t\t\tfmt.Println(\"没有任务\")\n\t\t\treturn\n\t\t}\n\t\tfor i, task := range tasks {\n\t\t\tfmt.Printf(\"%d. %s\\n\", i+1, task)\n\t\t}\n\t},\n}\n\nfunc init() {\n\trootCmd.AddCommand(listCmd)\n}\n```\n\n### 📝 注意：数据结构在内存中，不持久化。可用 `map[string]string` 或写入文件模拟更复杂逻辑。\n\n---\n\n## 🎛 第六步：添加标志（flags）\n\n比如我们想让 `add` 命令带一个 `--priority` 选项：\n\n在 `add.go` 的 `init()` 函数中添加：\n\n```go\naddCmd.Flags().StringP(\"priority\", \"p\", \"normal\", \"任务优先级\")\n```\n\n并在 `Run` 中读取：\n\n```go\npriority, _ := cmd.Flags().GetString(\"priority\")\nfmt.Printf(\"添加任务: %s（优先级: %s）\\n\", task, priority)\n```\n\n示例运行：\n\n```bash\ngo run main.go add \"学习 Go\" --priority high\n```\n\n---\n\n## 🧼 第七步：美化和构建项目\n\n构建可执行文件：\n\n```bash\ngo build -o tasker\n./tasker --help\n```\n\n可以将 `tasker` 添加到系统 PATH 中，变成全局命令行工具。\n\n---\n\n## 📦 最终项目结构\n\n```\ntasker/\n├── cmd/\n│   ├── add.go\n│   ├── list.go\n│   └── root.go\n├── go.mod\n└── main.go\n```\n\n---\n","source":"_posts/go语言之CLI框架cobra.md","raw":"---\ntitle: go语言之CLI框架：cobra\ndescription: 'Cobra 是一个用于创建强大现代 CLI 应用程序的 Go 库，许多知名项目如 Kubernetes、Docker 和 Hugo 都使用它。'\ntags: ['go']\ntoc: false\ndate: 2025-05-25 08:36:31\ncategories:\n    - go\n    - basic\n---\n\n\n## 📦 第一步：安装 Cobra CLI 工具\n\n```bash\ngo install github.com/spf13/cobra-cli@latest\n```\n\n确保 `$GOPATH/bin` 在你的 `PATH` 中，然后你可以运行：\n\n```bash\ncobra-cli --help\n```\n\n---\n\n## 🧱 第二步：初始化项目\n\n创建你的 Go 项目目录：\n\n```bash\nmkdir tasker && cd tasker\ngo mod init github.com/yourname/tasker\n```\n\n使用 `cobra-cli` 初始化：\n\n```bash\ncobra-cli init --pkg-name github.com/yourname/tasker\n```\n\n这会生成如下结构：\n\n```\ntasker/\n├── cmd/\n│   └── root.go\n├── main.go\n```\n\n---\n\n## 🚀 第三步：运行项目\n\n在当前目录运行：\n\n```bash\ngo run main.go\n```\n\n输出将会是：\n\n```\ntasker is a CLI application\n```\n\n你可以查看帮助：\n\n```bash\ngo run main.go --help\n```\n\n---\n\n## ➕ 第四步：添加子命令\n\n### 示例：添加 `add` 命令\n\n```bash\ncobra-cli add add\n```\n\n编辑 `cmd/add.go`：\n\n```go\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar addCmd = &cobra.Command{\n\tUse:   \"add [task]\",\n\tShort: \"添加一个新任务\",\n\tArgs:  cobra.ExactArgs(1),\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\ttask := args[0]\n\t\tfmt.Printf(\"添加任务: %s\\n\", task)\n\t},\n}\n\nfunc init() {\n\trootCmd.AddCommand(addCmd)\n}\n```\n\n现在你可以运行：\n\n```bash\ngo run main.go add \"写 Cobra 教程\"\n```\n\n---\n\n## 📋 第五步：添加 `list` 命令\n\n```bash\ncobra-cli add list\n```\n\n编辑 `cmd/list.go`：\n\n```go\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar tasks = []string{}\n\nvar listCmd = &cobra.Command{\n\tUse:   \"list\",\n\tShort: \"列出所有任务\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tif len(tasks) == 0 {\n\t\t\tfmt.Println(\"没有任务\")\n\t\t\treturn\n\t\t}\n\t\tfor i, task := range tasks {\n\t\t\tfmt.Printf(\"%d. %s\\n\", i+1, task)\n\t\t}\n\t},\n}\n\nfunc init() {\n\trootCmd.AddCommand(listCmd)\n}\n```\n\n### 📝 注意：数据结构在内存中，不持久化。可用 `map[string]string` 或写入文件模拟更复杂逻辑。\n\n---\n\n## 🎛 第六步：添加标志（flags）\n\n比如我们想让 `add` 命令带一个 `--priority` 选项：\n\n在 `add.go` 的 `init()` 函数中添加：\n\n```go\naddCmd.Flags().StringP(\"priority\", \"p\", \"normal\", \"任务优先级\")\n```\n\n并在 `Run` 中读取：\n\n```go\npriority, _ := cmd.Flags().GetString(\"priority\")\nfmt.Printf(\"添加任务: %s（优先级: %s）\\n\", task, priority)\n```\n\n示例运行：\n\n```bash\ngo run main.go add \"学习 Go\" --priority high\n```\n\n---\n\n## 🧼 第七步：美化和构建项目\n\n构建可执行文件：\n\n```bash\ngo build -o tasker\n./tasker --help\n```\n\n可以将 `tasker` 添加到系统 PATH 中，变成全局命令行工具。\n\n---\n\n## 📦 最终项目结构\n\n```\ntasker/\n├── cmd/\n│   ├── add.go\n│   ├── list.go\n│   └── root.go\n├── go.mod\n└── main.go\n```\n\n---\n","slug":"go语言之CLI框架cobra","published":1,"updated":"2025-05-26T00:56:02.166Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxa0000hkvodhh12cvg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"📦-第一步：安装-Cobra-CLI-工具\"><a href=\"#📦-第一步：安装-Cobra-CLI-工具\" class=\"headerlink\" title=\"📦 第一步：安装 Cobra CLI 工具\"></a>📦 第一步：安装 Cobra CLI 工具</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install github.com/spf13/cobra-cli@latest</span><br></pre></td></tr></table></figure>\n\n<p>确保 <code>$GOPATH/bin</code> 在你的 <code>PATH</code> 中，然后你可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧱-第二步：初始化项目\"><a href=\"#🧱-第二步：初始化项目\" class=\"headerlink\" title=\"🧱 第二步：初始化项目\"></a>🧱 第二步：初始化项目</h2><p>创建你的 Go 项目目录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> tasker &amp;&amp; <span class=\"built_in\">cd</span> tasker</span><br><span class=\"line\">go mod init github.com/yourname/tasker</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>cobra-cli</code> 初始化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli init --pkg-name github.com/yourname/tasker</span><br></pre></td></tr></table></figure>\n\n<p>这会生成如下结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasker/</span><br><span class=\"line\">├── cmd/</span><br><span class=\"line\">│   └── root.go</span><br><span class=\"line\">├── main.go</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🚀-第三步：运行项目\"><a href=\"#🚀-第三步：运行项目\" class=\"headerlink\" title=\"🚀 第三步：运行项目\"></a>🚀 第三步：运行项目</h2><p>在当前目录运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go</span><br></pre></td></tr></table></figure>\n\n<p>输出将会是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasker is a CLI application</span><br></pre></td></tr></table></figure>\n\n<p>你可以查看帮助：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"➕-第四步：添加子命令\"><a href=\"#➕-第四步：添加子命令\" class=\"headerlink\" title=\"➕ 第四步：添加子命令\"></a>➕ 第四步：添加子命令</h2><h3 id=\"示例：添加-add-命令\"><a href=\"#示例：添加-add-命令\" class=\"headerlink\" title=\"示例：添加 add 命令\"></a>示例：添加 <code>add</code> 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli add add</span><br></pre></td></tr></table></figure>\n\n<p>编辑 <code>cmd/add.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cmd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">\tUse:   <span class=\"string\">&quot;add [task]&quot;</span>,</span><br><span class=\"line\">\tShort: <span class=\"string\">&quot;添加一个新任务&quot;</span>,</span><br><span class=\"line\">\tArgs:  cobra.ExactArgs(<span class=\"number\">1</span>),</span><br><span class=\"line\">\tRun: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\ttask := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;添加任务: %s\\n&quot;</span>, task)</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\trootCmd.AddCommand(addCmd)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go add <span class=\"string\">&quot;写 Cobra 教程&quot;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"📋-第五步：添加-list-命令\"><a href=\"#📋-第五步：添加-list-命令\" class=\"headerlink\" title=\"📋 第五步：添加 list 命令\"></a>📋 第五步：添加 <code>list</code> 命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli add list</span><br></pre></td></tr></table></figure>\n\n<p>编辑 <code>cmd/list.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cmd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tasks = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> listCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">\tUse:   <span class=\"string\">&quot;list&quot;</span>,</span><br><span class=\"line\">\tShort: <span class=\"string\">&quot;列出所有任务&quot;</span>,</span><br><span class=\"line\">\tRun: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(tasks) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;没有任务&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i, task := <span class=\"keyword\">range</span> tasks &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;%d. %s\\n&quot;</span>, i+<span class=\"number\">1</span>, task)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\trootCmd.AddCommand(listCmd)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📝-注意：数据结构在内存中，不持久化。可用-map-string-string-或写入文件模拟更复杂逻辑。\"><a href=\"#📝-注意：数据结构在内存中，不持久化。可用-map-string-string-或写入文件模拟更复杂逻辑。\" class=\"headerlink\" title=\"📝 注意：数据结构在内存中，不持久化。可用 map[string]string 或写入文件模拟更复杂逻辑。\"></a>📝 注意：数据结构在内存中，不持久化。可用 <code>map[string]string</code> 或写入文件模拟更复杂逻辑。</h3><hr>\n<h2 id=\"🎛-第六步：添加标志（flags）\"><a href=\"#🎛-第六步：添加标志（flags）\" class=\"headerlink\" title=\"🎛 第六步：添加标志（flags）\"></a>🎛 第六步：添加标志（flags）</h2><p>比如我们想让 <code>add</code> 命令带一个 <code>--priority</code> 选项：</p>\n<p>在 <code>add.go</code> 的 <code>init()</code> 函数中添加：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addCmd.Flags().StringP(<span class=\"string\">&quot;priority&quot;</span>, <span class=\"string\">&quot;p&quot;</span>, <span class=\"string\">&quot;normal&quot;</span>, <span class=\"string\">&quot;任务优先级&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>并在 <code>Run</code> 中读取：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">priority, _ := cmd.Flags().GetString(<span class=\"string\">&quot;priority&quot;</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;添加任务: %s（优先级: %s）\\n&quot;</span>, task, priority)</span><br></pre></td></tr></table></figure>\n\n<p>示例运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go add <span class=\"string\">&quot;学习 Go&quot;</span> --priority high</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧼-第七步：美化和构建项目\"><a href=\"#🧼-第七步：美化和构建项目\" class=\"headerlink\" title=\"🧼 第七步：美化和构建项目\"></a>🧼 第七步：美化和构建项目</h2><p>构建可执行文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build -o tasker</span><br><span class=\"line\">./tasker --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p>可以将 <code>tasker</code> 添加到系统 PATH 中，变成全局命令行工具。</p>\n<hr>\n<h2 id=\"📦-最终项目结构\"><a href=\"#📦-最终项目结构\" class=\"headerlink\" title=\"📦 最终项目结构\"></a>📦 最终项目结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasker/</span><br><span class=\"line\">├── cmd/</span><br><span class=\"line\">│   ├── add.go</span><br><span class=\"line\">│   ├── list.go</span><br><span class=\"line\">│   └── root.go</span><br><span class=\"line\">├── go.mod</span><br><span class=\"line\">└── main.go</span><br></pre></td></tr></table></figure>\n\n<hr>\n","excerpt":"","more":"<h2 id=\"📦-第一步：安装-Cobra-CLI-工具\"><a href=\"#📦-第一步：安装-Cobra-CLI-工具\" class=\"headerlink\" title=\"📦 第一步：安装 Cobra CLI 工具\"></a>📦 第一步：安装 Cobra CLI 工具</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install github.com/spf13/cobra-cli@latest</span><br></pre></td></tr></table></figure>\n\n<p>确保 <code>$GOPATH/bin</code> 在你的 <code>PATH</code> 中，然后你可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧱-第二步：初始化项目\"><a href=\"#🧱-第二步：初始化项目\" class=\"headerlink\" title=\"🧱 第二步：初始化项目\"></a>🧱 第二步：初始化项目</h2><p>创建你的 Go 项目目录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> tasker &amp;&amp; <span class=\"built_in\">cd</span> tasker</span><br><span class=\"line\">go mod init github.com/yourname/tasker</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>cobra-cli</code> 初始化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli init --pkg-name github.com/yourname/tasker</span><br></pre></td></tr></table></figure>\n\n<p>这会生成如下结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasker/</span><br><span class=\"line\">├── cmd/</span><br><span class=\"line\">│   └── root.go</span><br><span class=\"line\">├── main.go</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🚀-第三步：运行项目\"><a href=\"#🚀-第三步：运行项目\" class=\"headerlink\" title=\"🚀 第三步：运行项目\"></a>🚀 第三步：运行项目</h2><p>在当前目录运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go</span><br></pre></td></tr></table></figure>\n\n<p>输出将会是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasker is a CLI application</span><br></pre></td></tr></table></figure>\n\n<p>你可以查看帮助：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"➕-第四步：添加子命令\"><a href=\"#➕-第四步：添加子命令\" class=\"headerlink\" title=\"➕ 第四步：添加子命令\"></a>➕ 第四步：添加子命令</h2><h3 id=\"示例：添加-add-命令\"><a href=\"#示例：添加-add-命令\" class=\"headerlink\" title=\"示例：添加 add 命令\"></a>示例：添加 <code>add</code> 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli add add</span><br></pre></td></tr></table></figure>\n\n<p>编辑 <code>cmd/add.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cmd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">\tUse:   <span class=\"string\">&quot;add [task]&quot;</span>,</span><br><span class=\"line\">\tShort: <span class=\"string\">&quot;添加一个新任务&quot;</span>,</span><br><span class=\"line\">\tArgs:  cobra.ExactArgs(<span class=\"number\">1</span>),</span><br><span class=\"line\">\tRun: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\ttask := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;添加任务: %s\\n&quot;</span>, task)</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\trootCmd.AddCommand(addCmd)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go add <span class=\"string\">&quot;写 Cobra 教程&quot;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"📋-第五步：添加-list-命令\"><a href=\"#📋-第五步：添加-list-命令\" class=\"headerlink\" title=\"📋 第五步：添加 list 命令\"></a>📋 第五步：添加 <code>list</code> 命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cobra-cli add list</span><br></pre></td></tr></table></figure>\n\n<p>编辑 <code>cmd/list.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cmd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tasks = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> listCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">\tUse:   <span class=\"string\">&quot;list&quot;</span>,</span><br><span class=\"line\">\tShort: <span class=\"string\">&quot;列出所有任务&quot;</span>,</span><br><span class=\"line\">\tRun: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(tasks) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;没有任务&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i, task := <span class=\"keyword\">range</span> tasks &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;%d. %s\\n&quot;</span>, i+<span class=\"number\">1</span>, task)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\trootCmd.AddCommand(listCmd)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📝-注意：数据结构在内存中，不持久化。可用-map-string-string-或写入文件模拟更复杂逻辑。\"><a href=\"#📝-注意：数据结构在内存中，不持久化。可用-map-string-string-或写入文件模拟更复杂逻辑。\" class=\"headerlink\" title=\"📝 注意：数据结构在内存中，不持久化。可用 map[string]string 或写入文件模拟更复杂逻辑。\"></a>📝 注意：数据结构在内存中，不持久化。可用 <code>map[string]string</code> 或写入文件模拟更复杂逻辑。</h3><hr>\n<h2 id=\"🎛-第六步：添加标志（flags）\"><a href=\"#🎛-第六步：添加标志（flags）\" class=\"headerlink\" title=\"🎛 第六步：添加标志（flags）\"></a>🎛 第六步：添加标志（flags）</h2><p>比如我们想让 <code>add</code> 命令带一个 <code>--priority</code> 选项：</p>\n<p>在 <code>add.go</code> 的 <code>init()</code> 函数中添加：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addCmd.Flags().StringP(<span class=\"string\">&quot;priority&quot;</span>, <span class=\"string\">&quot;p&quot;</span>, <span class=\"string\">&quot;normal&quot;</span>, <span class=\"string\">&quot;任务优先级&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>并在 <code>Run</code> 中读取：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">priority, _ := cmd.Flags().GetString(<span class=\"string\">&quot;priority&quot;</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;添加任务: %s（优先级: %s）\\n&quot;</span>, task, priority)</span><br></pre></td></tr></table></figure>\n\n<p>示例运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run main.go add <span class=\"string\">&quot;学习 Go&quot;</span> --priority high</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧼-第七步：美化和构建项目\"><a href=\"#🧼-第七步：美化和构建项目\" class=\"headerlink\" title=\"🧼 第七步：美化和构建项目\"></a>🧼 第七步：美化和构建项目</h2><p>构建可执行文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build -o tasker</span><br><span class=\"line\">./tasker --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p>可以将 <code>tasker</code> 添加到系统 PATH 中，变成全局命令行工具。</p>\n<hr>\n<h2 id=\"📦-最终项目结构\"><a href=\"#📦-最终项目结构\" class=\"headerlink\" title=\"📦 最终项目结构\"></a>📦 最终项目结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasker/</span><br><span class=\"line\">├── cmd/</span><br><span class=\"line\">│   ├── add.go</span><br><span class=\"line\">│   ├── list.go</span><br><span class=\"line\">│   └── root.go</span><br><span class=\"line\">├── go.mod</span><br><span class=\"line\">└── main.go</span><br></pre></td></tr></table></figure>\n\n<hr>\n"},{"title":"go语言之嵌入","description":"Go 语言中嵌入（embedding）摒弃了传统面向对象语言中“类继承”的复杂性，取而代之的是一种显式组合","toc":false,"date":"2025-05-14T05:22:09.000Z","_content":"\nGo 语言中嵌入（embedding）**是一种设计哲学和工程思维的体现，它摒弃了传统面向对象语言（如 Java/C++）中“类继承”的复杂性，取而代之的是一种**显式组合（composition over inheritance）的设计风格。\n\n---\n\n## 🧠 一、Go 的设计哲学：组合优于继承\n\n传统 OOP 语言采用类的继承来复用行为，但容易带来以下问题：\n\n* **继承层级过深**：容易造成维护困难；\n* **强耦合**：子类与父类紧密绑定；\n* **隐藏依赖**：不利于解耦和测试；\n* **继承冲突**：多重继承带来的歧义。\n\n> Go 的核心哲学是：**清晰的组合 + 显式的接口 + 零隐藏魔法**。\n\n---\n\n## 🧩 二、嵌入的本质：字段和方法的提升\n\n嵌入只是将一个类型的字段或方法**提升到另一个结构体中**，不做任何隐式继承。\n\n```go\ntype Logger struct {}\n\nfunc (l Logger) Log(msg string) {\n\tfmt.Println(\"Log:\", msg)\n}\n\ntype Service struct {\n\tLogger  // 嵌入\n\tName string\n}\n```\n\n这里，`Service` 就拥有了 `Log()` 方法，但你一眼能看出它来自 `Logger` ——这就是 Go 所强调的**显式组合但隐式使用**。\n\n---\n\n## 🔍 三、底层原理：语法糖 + 方法查找\n\nGo 的嵌入实际上是**语法糖**：\n\n```go\ns := Service{}\ns.Log(\"test\")\n```\n\n编译器会自动解释为：\n\n```go\ns.Logger.Log(\"test\")\n```\n\n方法和字段都遵循**字段查找机制**，嵌套结构最多支持一层字段提升。\n\n---\n\n## 🔧 四、实际应用场景\n\n### 1. **复用通用字段结构**\n\n```go\ntype BaseModel struct {\n\tID        int\n\tCreatedAt time.Time\n}\n\ntype Product struct {\n\tBaseModel\n\tName string\n}\n```\n\n> 所有实体都可以通过嵌入 BaseModel 拥有通用字段，无需重复定义。\n\n---\n\n### 2. **共享行为（方法）**\n\n```go\ntype Logger struct {}\n\nfunc (l Logger) Log(msg string) {\n\tfmt.Println(\"[LOG]:\", msg)\n}\n\ntype Server struct {\n\tLogger\n\tAddr string\n}\n```\n\n> 嵌入一个 Logger，可以让多个结构体共享日志功能。\n\n---\n\n### 3. **模拟继承 + 方法重写**\n\n```go\ntype Animal struct {}\n\nfunc (a Animal) Speak() string {\n\treturn \"...\"\n}\n\ntype Dog struct {\n\tAnimal\n}\n\nfunc (d Dog) Speak() string {\n\treturn \"Woof\"\n}\n```\n\n> 如果 `Dog` 定义了自己的 `Speak()` 方法，就会覆盖 `Animal` 的方法。\n\n---\n\n### 4. **接口嵌入：组合接口**\n\n```go\ntype Reader interface {\n\tRead(p []byte) (int, error)\n}\n\ntype Writer interface {\n\tWrite(p []byte) (int, error)\n}\n\ntype ReadWriter interface {\n\tReader\n\tWriter\n}\n```\n\n> 多个小接口嵌入成大接口，符合 Go 的接口拆分哲学：**\"尽量小的接口\"**。\n\n---\n\n## 💡 五、设计优势总结\n\n| 优点     | 说明                 |\n| ------ | ------------------ |\n| 简洁     | 无需冗长的继承结构          |\n| 解耦     | 结构体之间组合而非依赖        |\n| 清晰     | 嵌入行为是显式可见的         |\n| 灵活     | 可以随意组合不同的功能块       |\n| 类型安全   | 编译器检查嵌入字段和方法       |\n| 避免菱形继承 | 多重嵌入不会有 C++ 那种冲突问题 |\n\n---\n\n## 🤔 常见的工程实践场景\n\n| 场景        | 示例                       |\n| --------- | ------------------------ |\n| 数据库模型基类   | `BaseModel` 提供 ID、时间戳等字段 |\n| 服务组件封装    | 嵌入日志、配置、HTTP 客户端等模块      |\n| 中间件链封装    | 使用嵌入构造链式 handler         |\n| 接口适配器     | 通过接口嵌入组合多个职责             |\n| 控制反转（IoC） | 提供默认行为，再由上层结构体重写方法       |\n\n---\n\n## 🥵 组合（嵌入）结和接口代替继承的最佳实践\n\n案例：打印机\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// ---------------- Shared Component ----------------\ntype Logger struct{}\n\nfunc (l Logger) Log(msg string) {\n\tfmt.Println(\"[LOG]:\", msg)\n}\n\n// ---------------- Interface ----------------\ntype Printer interface {\n\tPrint()\n}\n\n// ---------------- PDF Printer ----------------\ntype PDFPrinter struct {\n\tLogger\n\tFile string\n}\n\nfunc (p PDFPrinter) Print() {\n\tp.Log(\"Printing PDF: \" + p.File)\n\tfmt.Println(\"PDF content: <pdf data>\")\n}\n\n// ---------------- HTML Printer ----------------\ntype HTMLPrinter struct {\n\tLogger\n\tHTML string\n}\n\nfunc (h HTMLPrinter) Print() {\n\th.Log(\"Printing HTML: \" + h.HTML)\n\tfmt.Println(\"HTML content: <html data>\")\n}\n\n// ---------------- Polymorphic Function ----------------\nfunc Process(p Printer) {\n\tp.Print()\n}\n\n// ---------------- Main ----------------\nfunc main() {\n\tpdf := PDFPrinter{File: \"invoice.pdf\"}\n\thtml := HTMLPrinter{HTML: \"<h1>Hello</h1>\"}\n\n\tProcess(pdf)\n\tProcess(html)\n} \n\n```","source":"_posts/go语言之嵌入.md","raw":"---\ntitle: go语言之嵌入\ndescription: 'Go 语言中嵌入（embedding）摒弃了传统面向对象语言中“类继承”的复杂性，取而代之的是一种显式组合'\ntags: ['go']\ntoc: false\ndate: 2025-05-14 13:22:09\ncategories:\n    - go\n    - basic\n---\n\nGo 语言中嵌入（embedding）**是一种设计哲学和工程思维的体现，它摒弃了传统面向对象语言（如 Java/C++）中“类继承”的复杂性，取而代之的是一种**显式组合（composition over inheritance）的设计风格。\n\n---\n\n## 🧠 一、Go 的设计哲学：组合优于继承\n\n传统 OOP 语言采用类的继承来复用行为，但容易带来以下问题：\n\n* **继承层级过深**：容易造成维护困难；\n* **强耦合**：子类与父类紧密绑定；\n* **隐藏依赖**：不利于解耦和测试；\n* **继承冲突**：多重继承带来的歧义。\n\n> Go 的核心哲学是：**清晰的组合 + 显式的接口 + 零隐藏魔法**。\n\n---\n\n## 🧩 二、嵌入的本质：字段和方法的提升\n\n嵌入只是将一个类型的字段或方法**提升到另一个结构体中**，不做任何隐式继承。\n\n```go\ntype Logger struct {}\n\nfunc (l Logger) Log(msg string) {\n\tfmt.Println(\"Log:\", msg)\n}\n\ntype Service struct {\n\tLogger  // 嵌入\n\tName string\n}\n```\n\n这里，`Service` 就拥有了 `Log()` 方法，但你一眼能看出它来自 `Logger` ——这就是 Go 所强调的**显式组合但隐式使用**。\n\n---\n\n## 🔍 三、底层原理：语法糖 + 方法查找\n\nGo 的嵌入实际上是**语法糖**：\n\n```go\ns := Service{}\ns.Log(\"test\")\n```\n\n编译器会自动解释为：\n\n```go\ns.Logger.Log(\"test\")\n```\n\n方法和字段都遵循**字段查找机制**，嵌套结构最多支持一层字段提升。\n\n---\n\n## 🔧 四、实际应用场景\n\n### 1. **复用通用字段结构**\n\n```go\ntype BaseModel struct {\n\tID        int\n\tCreatedAt time.Time\n}\n\ntype Product struct {\n\tBaseModel\n\tName string\n}\n```\n\n> 所有实体都可以通过嵌入 BaseModel 拥有通用字段，无需重复定义。\n\n---\n\n### 2. **共享行为（方法）**\n\n```go\ntype Logger struct {}\n\nfunc (l Logger) Log(msg string) {\n\tfmt.Println(\"[LOG]:\", msg)\n}\n\ntype Server struct {\n\tLogger\n\tAddr string\n}\n```\n\n> 嵌入一个 Logger，可以让多个结构体共享日志功能。\n\n---\n\n### 3. **模拟继承 + 方法重写**\n\n```go\ntype Animal struct {}\n\nfunc (a Animal) Speak() string {\n\treturn \"...\"\n}\n\ntype Dog struct {\n\tAnimal\n}\n\nfunc (d Dog) Speak() string {\n\treturn \"Woof\"\n}\n```\n\n> 如果 `Dog` 定义了自己的 `Speak()` 方法，就会覆盖 `Animal` 的方法。\n\n---\n\n### 4. **接口嵌入：组合接口**\n\n```go\ntype Reader interface {\n\tRead(p []byte) (int, error)\n}\n\ntype Writer interface {\n\tWrite(p []byte) (int, error)\n}\n\ntype ReadWriter interface {\n\tReader\n\tWriter\n}\n```\n\n> 多个小接口嵌入成大接口，符合 Go 的接口拆分哲学：**\"尽量小的接口\"**。\n\n---\n\n## 💡 五、设计优势总结\n\n| 优点     | 说明                 |\n| ------ | ------------------ |\n| 简洁     | 无需冗长的继承结构          |\n| 解耦     | 结构体之间组合而非依赖        |\n| 清晰     | 嵌入行为是显式可见的         |\n| 灵活     | 可以随意组合不同的功能块       |\n| 类型安全   | 编译器检查嵌入字段和方法       |\n| 避免菱形继承 | 多重嵌入不会有 C++ 那种冲突问题 |\n\n---\n\n## 🤔 常见的工程实践场景\n\n| 场景        | 示例                       |\n| --------- | ------------------------ |\n| 数据库模型基类   | `BaseModel` 提供 ID、时间戳等字段 |\n| 服务组件封装    | 嵌入日志、配置、HTTP 客户端等模块      |\n| 中间件链封装    | 使用嵌入构造链式 handler         |\n| 接口适配器     | 通过接口嵌入组合多个职责             |\n| 控制反转（IoC） | 提供默认行为，再由上层结构体重写方法       |\n\n---\n\n## 🥵 组合（嵌入）结和接口代替继承的最佳实践\n\n案例：打印机\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// ---------------- Shared Component ----------------\ntype Logger struct{}\n\nfunc (l Logger) Log(msg string) {\n\tfmt.Println(\"[LOG]:\", msg)\n}\n\n// ---------------- Interface ----------------\ntype Printer interface {\n\tPrint()\n}\n\n// ---------------- PDF Printer ----------------\ntype PDFPrinter struct {\n\tLogger\n\tFile string\n}\n\nfunc (p PDFPrinter) Print() {\n\tp.Log(\"Printing PDF: \" + p.File)\n\tfmt.Println(\"PDF content: <pdf data>\")\n}\n\n// ---------------- HTML Printer ----------------\ntype HTMLPrinter struct {\n\tLogger\n\tHTML string\n}\n\nfunc (h HTMLPrinter) Print() {\n\th.Log(\"Printing HTML: \" + h.HTML)\n\tfmt.Println(\"HTML content: <html data>\")\n}\n\n// ---------------- Polymorphic Function ----------------\nfunc Process(p Printer) {\n\tp.Print()\n}\n\n// ---------------- Main ----------------\nfunc main() {\n\tpdf := PDFPrinter{File: \"invoice.pdf\"}\n\thtml := HTMLPrinter{HTML: \"<h1>Hello</h1>\"}\n\n\tProcess(pdf)\n\tProcess(html)\n} \n\n```","slug":"go语言之嵌入","published":1,"updated":"2025-05-23T06:25:48.018Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxc0001hkvo09gzd2y7","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Go 语言中嵌入（embedding）<strong>是一种设计哲学和工程思维的体现，它摒弃了传统面向对象语言（如 Java&#x2F;C++）中“类继承”的复杂性，取而代之的是一种</strong>显式组合（composition over inheritance）的设计风格。</p>\n<hr>\n<h2 id=\"🧠-一、Go-的设计哲学：组合优于继承\"><a href=\"#🧠-一、Go-的设计哲学：组合优于继承\" class=\"headerlink\" title=\"🧠 一、Go 的设计哲学：组合优于继承\"></a>🧠 一、Go 的设计哲学：组合优于继承</h2><p>传统 OOP 语言采用类的继承来复用行为，但容易带来以下问题：</p>\n<ul>\n<li><strong>继承层级过深</strong>：容易造成维护困难；</li>\n<li><strong>强耦合</strong>：子类与父类紧密绑定；</li>\n<li><strong>隐藏依赖</strong>：不利于解耦和测试；</li>\n<li><strong>继承冲突</strong>：多重继承带来的歧义。</li>\n</ul>\n<blockquote>\n<p>Go 的核心哲学是：<strong>清晰的组合 + 显式的接口 + 零隐藏魔法</strong>。</p>\n</blockquote>\n<hr>\n<h2 id=\"🧩-二、嵌入的本质：字段和方法的提升\"><a href=\"#🧩-二、嵌入的本质：字段和方法的提升\" class=\"headerlink\" title=\"🧩 二、嵌入的本质：字段和方法的提升\"></a>🧩 二、嵌入的本质：字段和方法的提升</h2><p>嵌入只是将一个类型的字段或方法<strong>提升到另一个结构体中</strong>，不做任何隐式继承。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Logger)</span></span> Log(msg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Log:&quot;</span>, msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Service <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger  <span class=\"comment\">// 嵌入</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，<code>Service</code> 就拥有了 <code>Log()</code> 方法，但你一眼能看出它来自 <code>Logger</code> ——这就是 Go 所强调的<strong>显式组合但隐式使用</strong>。</p>\n<hr>\n<h2 id=\"🔍-三、底层原理：语法糖-方法查找\"><a href=\"#🔍-三、底层原理：语法糖-方法查找\" class=\"headerlink\" title=\"🔍 三、底层原理：语法糖 + 方法查找\"></a>🔍 三、底层原理：语法糖 + 方法查找</h2><p>Go 的嵌入实际上是<strong>语法糖</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := Service&#123;&#125;</span><br><span class=\"line\">s.Log(<span class=\"string\">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>编译器会自动解释为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.Logger.Log(<span class=\"string\">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>方法和字段都遵循<strong>字段查找机制</strong>，嵌套结构最多支持一层字段提升。</p>\n<hr>\n<h2 id=\"🔧-四、实际应用场景\"><a href=\"#🔧-四、实际应用场景\" class=\"headerlink\" title=\"🔧 四、实际应用场景\"></a>🔧 四、实际应用场景</h2><h3 id=\"1-复用通用字段结构\"><a href=\"#1-复用通用字段结构\" class=\"headerlink\" title=\"1. 复用通用字段结构\"></a>1. <strong>复用通用字段结构</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BaseModel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tID        <span class=\"type\">int</span></span><br><span class=\"line\">\tCreatedAt time.Time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Product <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tBaseModel</span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>所有实体都可以通过嵌入 BaseModel 拥有通用字段，无需重复定义。</p>\n</blockquote>\n<hr>\n<h3 id=\"2-共享行为（方法）\"><a href=\"#2-共享行为（方法）\" class=\"headerlink\" title=\"2. 共享行为（方法）\"></a>2. <strong>共享行为（方法）</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Logger)</span></span> Log(msg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;[LOG]:&quot;</span>, msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger</span><br><span class=\"line\">\tAddr <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>嵌入一个 Logger，可以让多个结构体共享日志功能。</p>\n</blockquote>\n<hr>\n<h3 id=\"3-模拟继承-方法重写\"><a href=\"#3-模拟继承-方法重写\" class=\"headerlink\" title=\"3. 模拟继承 + 方法重写\"></a>3. <strong>模拟继承 + 方法重写</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a Animal)</span></span> Speak() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;...&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Dog <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tAnimal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d Dog)</span></span> Speak() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Woof&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果 <code>Dog</code> 定义了自己的 <code>Speak()</code> 方法，就会覆盖 <code>Animal</code> 的方法。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-接口嵌入：组合接口\"><a href=\"#4-接口嵌入：组合接口\" class=\"headerlink\" title=\"4. 接口嵌入：组合接口\"></a>4. <strong>接口嵌入：组合接口</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tRead(p []<span class=\"type\">byte</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tWrite(p []<span class=\"type\">byte</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tReader</span><br><span class=\"line\">\tWriter</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>多个小接口嵌入成大接口，符合 Go 的接口拆分哲学：**”尽量小的接口”**。</p>\n</blockquote>\n<hr>\n<h2 id=\"💡-五、设计优势总结\"><a href=\"#💡-五、设计优势总结\" class=\"headerlink\" title=\"💡 五、设计优势总结\"></a>💡 五、设计优势总结</h2><table>\n<thead>\n<tr>\n<th>优点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简洁</td>\n<td>无需冗长的继承结构</td>\n</tr>\n<tr>\n<td>解耦</td>\n<td>结构体之间组合而非依赖</td>\n</tr>\n<tr>\n<td>清晰</td>\n<td>嵌入行为是显式可见的</td>\n</tr>\n<tr>\n<td>灵活</td>\n<td>可以随意组合不同的功能块</td>\n</tr>\n<tr>\n<td>类型安全</td>\n<td>编译器检查嵌入字段和方法</td>\n</tr>\n<tr>\n<td>避免菱形继承</td>\n<td>多重嵌入不会有 C++ 那种冲突问题</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🤔-常见的工程实践场景\"><a href=\"#🤔-常见的工程实践场景\" class=\"headerlink\" title=\"🤔 常见的工程实践场景\"></a>🤔 常见的工程实践场景</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库模型基类</td>\n<td><code>BaseModel</code> 提供 ID、时间戳等字段</td>\n</tr>\n<tr>\n<td>服务组件封装</td>\n<td>嵌入日志、配置、HTTP 客户端等模块</td>\n</tr>\n<tr>\n<td>中间件链封装</td>\n<td>使用嵌入构造链式 handler</td>\n</tr>\n<tr>\n<td>接口适配器</td>\n<td>通过接口嵌入组合多个职责</td>\n</tr>\n<tr>\n<td>控制反转（IoC）</td>\n<td>提供默认行为，再由上层结构体重写方法</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🥵-组合（嵌入）结和接口代替继承的最佳实践\"><a href=\"#🥵-组合（嵌入）结和接口代替继承的最佳实践\" class=\"headerlink\" title=\"🥵 组合（嵌入）结和接口代替继承的最佳实践\"></a>🥵 组合（嵌入）结和接口代替继承的最佳实践</h2><p>案例：打印机</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Shared Component ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Logger)</span></span> Log(msg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;[LOG]:&quot;</span>, msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Interface ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Printer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tPrint()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- PDF Printer ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PDFPrinter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger</span><br><span class=\"line\">\tFile <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p PDFPrinter)</span></span> Print() &#123;</span><br><span class=\"line\">\tp.Log(<span class=\"string\">&quot;Printing PDF: &quot;</span> + p.File)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;PDF content: &lt;pdf data&gt;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- HTML Printer ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> HTMLPrinter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger</span><br><span class=\"line\">\tHTML <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h HTMLPrinter)</span></span> Print() &#123;</span><br><span class=\"line\">\th.Log(<span class=\"string\">&quot;Printing HTML: &quot;</span> + h.HTML)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;HTML content: &lt;html data&gt;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Polymorphic Function ----------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Process</span><span class=\"params\">(p Printer)</span></span> &#123;</span><br><span class=\"line\">\tp.Print()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Main ----------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpdf := PDFPrinter&#123;File: <span class=\"string\">&quot;invoice.pdf&quot;</span>&#125;</span><br><span class=\"line\">\thtml := HTMLPrinter&#123;HTML: <span class=\"string\">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tProcess(pdf)</span><br><span class=\"line\">\tProcess(html)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>Go 语言中嵌入（embedding）<strong>是一种设计哲学和工程思维的体现，它摒弃了传统面向对象语言（如 Java&#x2F;C++）中“类继承”的复杂性，取而代之的是一种</strong>显式组合（composition over inheritance）的设计风格。</p>\n<hr>\n<h2 id=\"🧠-一、Go-的设计哲学：组合优于继承\"><a href=\"#🧠-一、Go-的设计哲学：组合优于继承\" class=\"headerlink\" title=\"🧠 一、Go 的设计哲学：组合优于继承\"></a>🧠 一、Go 的设计哲学：组合优于继承</h2><p>传统 OOP 语言采用类的继承来复用行为，但容易带来以下问题：</p>\n<ul>\n<li><strong>继承层级过深</strong>：容易造成维护困难；</li>\n<li><strong>强耦合</strong>：子类与父类紧密绑定；</li>\n<li><strong>隐藏依赖</strong>：不利于解耦和测试；</li>\n<li><strong>继承冲突</strong>：多重继承带来的歧义。</li>\n</ul>\n<blockquote>\n<p>Go 的核心哲学是：<strong>清晰的组合 + 显式的接口 + 零隐藏魔法</strong>。</p>\n</blockquote>\n<hr>\n<h2 id=\"🧩-二、嵌入的本质：字段和方法的提升\"><a href=\"#🧩-二、嵌入的本质：字段和方法的提升\" class=\"headerlink\" title=\"🧩 二、嵌入的本质：字段和方法的提升\"></a>🧩 二、嵌入的本质：字段和方法的提升</h2><p>嵌入只是将一个类型的字段或方法<strong>提升到另一个结构体中</strong>，不做任何隐式继承。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Logger)</span></span> Log(msg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Log:&quot;</span>, msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Service <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger  <span class=\"comment\">// 嵌入</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，<code>Service</code> 就拥有了 <code>Log()</code> 方法，但你一眼能看出它来自 <code>Logger</code> ——这就是 Go 所强调的<strong>显式组合但隐式使用</strong>。</p>\n<hr>\n<h2 id=\"🔍-三、底层原理：语法糖-方法查找\"><a href=\"#🔍-三、底层原理：语法糖-方法查找\" class=\"headerlink\" title=\"🔍 三、底层原理：语法糖 + 方法查找\"></a>🔍 三、底层原理：语法糖 + 方法查找</h2><p>Go 的嵌入实际上是<strong>语法糖</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := Service&#123;&#125;</span><br><span class=\"line\">s.Log(<span class=\"string\">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>编译器会自动解释为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.Logger.Log(<span class=\"string\">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>方法和字段都遵循<strong>字段查找机制</strong>，嵌套结构最多支持一层字段提升。</p>\n<hr>\n<h2 id=\"🔧-四、实际应用场景\"><a href=\"#🔧-四、实际应用场景\" class=\"headerlink\" title=\"🔧 四、实际应用场景\"></a>🔧 四、实际应用场景</h2><h3 id=\"1-复用通用字段结构\"><a href=\"#1-复用通用字段结构\" class=\"headerlink\" title=\"1. 复用通用字段结构\"></a>1. <strong>复用通用字段结构</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BaseModel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tID        <span class=\"type\">int</span></span><br><span class=\"line\">\tCreatedAt time.Time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Product <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tBaseModel</span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>所有实体都可以通过嵌入 BaseModel 拥有通用字段，无需重复定义。</p>\n</blockquote>\n<hr>\n<h3 id=\"2-共享行为（方法）\"><a href=\"#2-共享行为（方法）\" class=\"headerlink\" title=\"2. 共享行为（方法）\"></a>2. <strong>共享行为（方法）</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Logger)</span></span> Log(msg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;[LOG]:&quot;</span>, msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger</span><br><span class=\"line\">\tAddr <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>嵌入一个 Logger，可以让多个结构体共享日志功能。</p>\n</blockquote>\n<hr>\n<h3 id=\"3-模拟继承-方法重写\"><a href=\"#3-模拟继承-方法重写\" class=\"headerlink\" title=\"3. 模拟继承 + 方法重写\"></a>3. <strong>模拟继承 + 方法重写</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a Animal)</span></span> Speak() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;...&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Dog <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tAnimal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d Dog)</span></span> Speak() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Woof&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果 <code>Dog</code> 定义了自己的 <code>Speak()</code> 方法，就会覆盖 <code>Animal</code> 的方法。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-接口嵌入：组合接口\"><a href=\"#4-接口嵌入：组合接口\" class=\"headerlink\" title=\"4. 接口嵌入：组合接口\"></a>4. <strong>接口嵌入：组合接口</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tRead(p []<span class=\"type\">byte</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tWrite(p []<span class=\"type\">byte</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tReader</span><br><span class=\"line\">\tWriter</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>多个小接口嵌入成大接口，符合 Go 的接口拆分哲学：**”尽量小的接口”**。</p>\n</blockquote>\n<hr>\n<h2 id=\"💡-五、设计优势总结\"><a href=\"#💡-五、设计优势总结\" class=\"headerlink\" title=\"💡 五、设计优势总结\"></a>💡 五、设计优势总结</h2><table>\n<thead>\n<tr>\n<th>优点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简洁</td>\n<td>无需冗长的继承结构</td>\n</tr>\n<tr>\n<td>解耦</td>\n<td>结构体之间组合而非依赖</td>\n</tr>\n<tr>\n<td>清晰</td>\n<td>嵌入行为是显式可见的</td>\n</tr>\n<tr>\n<td>灵活</td>\n<td>可以随意组合不同的功能块</td>\n</tr>\n<tr>\n<td>类型安全</td>\n<td>编译器检查嵌入字段和方法</td>\n</tr>\n<tr>\n<td>避免菱形继承</td>\n<td>多重嵌入不会有 C++ 那种冲突问题</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🤔-常见的工程实践场景\"><a href=\"#🤔-常见的工程实践场景\" class=\"headerlink\" title=\"🤔 常见的工程实践场景\"></a>🤔 常见的工程实践场景</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库模型基类</td>\n<td><code>BaseModel</code> 提供 ID、时间戳等字段</td>\n</tr>\n<tr>\n<td>服务组件封装</td>\n<td>嵌入日志、配置、HTTP 客户端等模块</td>\n</tr>\n<tr>\n<td>中间件链封装</td>\n<td>使用嵌入构造链式 handler</td>\n</tr>\n<tr>\n<td>接口适配器</td>\n<td>通过接口嵌入组合多个职责</td>\n</tr>\n<tr>\n<td>控制反转（IoC）</td>\n<td>提供默认行为，再由上层结构体重写方法</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🥵-组合（嵌入）结和接口代替继承的最佳实践\"><a href=\"#🥵-组合（嵌入）结和接口代替继承的最佳实践\" class=\"headerlink\" title=\"🥵 组合（嵌入）结和接口代替继承的最佳实践\"></a>🥵 组合（嵌入）结和接口代替继承的最佳实践</h2><p>案例：打印机</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Shared Component ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Logger <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Logger)</span></span> Log(msg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;[LOG]:&quot;</span>, msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Interface ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Printer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tPrint()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- PDF Printer ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PDFPrinter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger</span><br><span class=\"line\">\tFile <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p PDFPrinter)</span></span> Print() &#123;</span><br><span class=\"line\">\tp.Log(<span class=\"string\">&quot;Printing PDF: &quot;</span> + p.File)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;PDF content: &lt;pdf data&gt;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- HTML Printer ----------------</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> HTMLPrinter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLogger</span><br><span class=\"line\">\tHTML <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h HTMLPrinter)</span></span> Print() &#123;</span><br><span class=\"line\">\th.Log(<span class=\"string\">&quot;Printing HTML: &quot;</span> + h.HTML)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;HTML content: &lt;html data&gt;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Polymorphic Function ----------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Process</span><span class=\"params\">(p Printer)</span></span> &#123;</span><br><span class=\"line\">\tp.Print()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---------------- Main ----------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpdf := PDFPrinter&#123;File: <span class=\"string\">&quot;invoice.pdf&quot;</span>&#125;</span><br><span class=\"line\">\thtml := HTMLPrinter&#123;HTML: <span class=\"string\">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tProcess(pdf)</span><br><span class=\"line\">\tProcess(html)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"go语言之最常用标准库","description":"Go 的标准库提供了一系列强大且实用的内置包，涵盖了从基本 I/O 到网络编程等各种常见任务，无需外部依赖即可构建可靠的应用程序。","toc":false,"date":"2025-05-23T06:23:12.000Z","_content":"\n**1. `fmt` 包:**\n\n* **功能:** 提供格式化输入输出的功能，类似于 C 语言的 `printf` 和 `scanf`。\n* **为什么必备:** 几乎所有的程序都需要进行输入输出，无论是打印日志、用户交互还是格式化数据。\n* **学习建议:** 重点学习 `Printf`、`Sprintf`、`Fprintf` 等格式化输出函数，以及 `Scanf`、`Sscanf`、`Fscanf` 等格式化输入函数。了解各种格式化动词（如 `%d`, `%s`, `%v` 等）的用法。\n\n**2. `os` 包:**\n\n* **功能:** 提供与操作系统交互的功能，如文件操作、进程管理、环境变量等。\n* **为什么必备:** 任何需要与底层操作系统交互的程序都会用到这个包。\n* **学习建议:** 学习文件和目录的操作（`os.Create`, `os.Open`, `os.Mkdir`, `os.Remove` 等），环境变量的获取和设置（`os.Getenv`, `os.Setenv` 等），以及进程相关的操作（`os.Exit` 等）。\n\n**3. `net/http` 包:**\n\n* **功能:** 提供 HTTP 客户端和服务器的实现。\n* **为什么必备:** 在当今互联网时代，Web 开发非常普遍，无论是构建 API 还是简单的 HTTP 客户端，这个包都是必不可少的。\n* **学习建议:** 学习如何创建一个简单的 HTTP 服务器（`http.HandleFunc`, `http.ListenAndServe`），以及如何发起 HTTP 请求（`http.Get`, `http.Post` 等）。了解 `http.Request` 和 `http.ResponseWriter` 的结构和用法。\n\n**4. `io` 包:**\n\n* **功能:** 提供基本的 I/O 接口。很多其他的 I/O 相关的包都基于 `io` 包的接口。\n* **为什么必备:** 处理输入和输出流是编程中常见的任务。\n* **学习建议:** 理解 `io.Reader` 和 `io.Writer` 接口，以及一些常用的实现，如 `bytes.Buffer` 和 `os.File`。\n\n**5. `bufio` 包:**\n\n* **功能:** 提供带缓冲的 I/O 操作，可以提高 I/O 的效率。\n* **为什么必备:** 在处理大量数据或需要更精细控制 I/O 的场景下很有用。\n* **学习建议:** 学习 `bufio.Reader` 和 `bufio.Writer` 的用法，以及它们提供的缓冲读取和写入方法。\n\n**6. `strings` 包:**\n\n* **功能:** 提供字符串操作的常用函数，如查找、替换、分割等。\n* **为什么必备:** 字符串处理在各种应用中都很常见。\n* **学习建议:** 学习 `strings.Contains`, `strings.Index`, `strings.ReplaceAll`, `strings.Split`, `strings.Join` 等常用函数。\n\n**7. `strconv` 包:**\n\n* **功能:** 提供字符串和基本数据类型之间的转换功能。\n* **为什么必备:** 在处理用户输入、配置文件等场景下，经常需要在字符串和数值之间进行转换。\n* **学习建议:** 学习 `strconv.Atoi` (字符串转整数), `strconv.Itoa` (整数转字符串), 以及其他类型转换函数，如 `ParseBool`, `ParseFloat` 等。\n","source":"_posts/go语言之常用标准库.md","raw":"---\ntitle: go语言之最常用标准库\ndescription: 'Go 的标准库提供了一系列强大且实用的内置包，涵盖了从基本 I/O 到网络编程等各种常见任务，无需外部依赖即可构建可靠的应用程序。'\ntags: ['go']\ntoc: false\ndate: 2025-05-23 14:23:12\ncategories:\n    - go\n    - basic\n---\n\n**1. `fmt` 包:**\n\n* **功能:** 提供格式化输入输出的功能，类似于 C 语言的 `printf` 和 `scanf`。\n* **为什么必备:** 几乎所有的程序都需要进行输入输出，无论是打印日志、用户交互还是格式化数据。\n* **学习建议:** 重点学习 `Printf`、`Sprintf`、`Fprintf` 等格式化输出函数，以及 `Scanf`、`Sscanf`、`Fscanf` 等格式化输入函数。了解各种格式化动词（如 `%d`, `%s`, `%v` 等）的用法。\n\n**2. `os` 包:**\n\n* **功能:** 提供与操作系统交互的功能，如文件操作、进程管理、环境变量等。\n* **为什么必备:** 任何需要与底层操作系统交互的程序都会用到这个包。\n* **学习建议:** 学习文件和目录的操作（`os.Create`, `os.Open`, `os.Mkdir`, `os.Remove` 等），环境变量的获取和设置（`os.Getenv`, `os.Setenv` 等），以及进程相关的操作（`os.Exit` 等）。\n\n**3. `net/http` 包:**\n\n* **功能:** 提供 HTTP 客户端和服务器的实现。\n* **为什么必备:** 在当今互联网时代，Web 开发非常普遍，无论是构建 API 还是简单的 HTTP 客户端，这个包都是必不可少的。\n* **学习建议:** 学习如何创建一个简单的 HTTP 服务器（`http.HandleFunc`, `http.ListenAndServe`），以及如何发起 HTTP 请求（`http.Get`, `http.Post` 等）。了解 `http.Request` 和 `http.ResponseWriter` 的结构和用法。\n\n**4. `io` 包:**\n\n* **功能:** 提供基本的 I/O 接口。很多其他的 I/O 相关的包都基于 `io` 包的接口。\n* **为什么必备:** 处理输入和输出流是编程中常见的任务。\n* **学习建议:** 理解 `io.Reader` 和 `io.Writer` 接口，以及一些常用的实现，如 `bytes.Buffer` 和 `os.File`。\n\n**5. `bufio` 包:**\n\n* **功能:** 提供带缓冲的 I/O 操作，可以提高 I/O 的效率。\n* **为什么必备:** 在处理大量数据或需要更精细控制 I/O 的场景下很有用。\n* **学习建议:** 学习 `bufio.Reader` 和 `bufio.Writer` 的用法，以及它们提供的缓冲读取和写入方法。\n\n**6. `strings` 包:**\n\n* **功能:** 提供字符串操作的常用函数，如查找、替换、分割等。\n* **为什么必备:** 字符串处理在各种应用中都很常见。\n* **学习建议:** 学习 `strings.Contains`, `strings.Index`, `strings.ReplaceAll`, `strings.Split`, `strings.Join` 等常用函数。\n\n**7. `strconv` 包:**\n\n* **功能:** 提供字符串和基本数据类型之间的转换功能。\n* **为什么必备:** 在处理用户输入、配置文件等场景下，经常需要在字符串和数值之间进行转换。\n* **学习建议:** 学习 `strconv.Atoi` (字符串转整数), `strconv.Itoa` (整数转字符串), 以及其他类型转换函数，如 `ParseBool`, `ParseFloat` 等。\n","slug":"go语言之常用标准库","published":1,"updated":"2025-05-23T06:26:13.771Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxd0003hkvo3gtc5svn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>1. <code>fmt</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供格式化输入输出的功能，类似于 C 语言的 <code>printf</code> 和 <code>scanf</code>。</li>\n<li><strong>为什么必备:</strong> 几乎所有的程序都需要进行输入输出，无论是打印日志、用户交互还是格式化数据。</li>\n<li><strong>学习建议:</strong> 重点学习 <code>Printf</code>、<code>Sprintf</code>、<code>Fprintf</code> 等格式化输出函数，以及 <code>Scanf</code>、<code>Sscanf</code>、<code>Fscanf</code> 等格式化输入函数。了解各种格式化动词（如 <code>%d</code>, <code>%s</code>, <code>%v</code> 等）的用法。</li>\n</ul>\n<p><strong>2. <code>os</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供与操作系统交互的功能，如文件操作、进程管理、环境变量等。</li>\n<li><strong>为什么必备:</strong> 任何需要与底层操作系统交互的程序都会用到这个包。</li>\n<li><strong>学习建议:</strong> 学习文件和目录的操作（<code>os.Create</code>, <code>os.Open</code>, <code>os.Mkdir</code>, <code>os.Remove</code> 等），环境变量的获取和设置（<code>os.Getenv</code>, <code>os.Setenv</code> 等），以及进程相关的操作（<code>os.Exit</code> 等）。</li>\n</ul>\n<p><strong>3. <code>net/http</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供 HTTP 客户端和服务器的实现。</li>\n<li><strong>为什么必备:</strong> 在当今互联网时代，Web 开发非常普遍，无论是构建 API 还是简单的 HTTP 客户端，这个包都是必不可少的。</li>\n<li><strong>学习建议:</strong> 学习如何创建一个简单的 HTTP 服务器（<code>http.HandleFunc</code>, <code>http.ListenAndServe</code>），以及如何发起 HTTP 请求（<code>http.Get</code>, <code>http.Post</code> 等）。了解 <code>http.Request</code> 和 <code>http.ResponseWriter</code> 的结构和用法。</li>\n</ul>\n<p><strong>4. <code>io</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供基本的 I&#x2F;O 接口。很多其他的 I&#x2F;O 相关的包都基于 <code>io</code> 包的接口。</li>\n<li><strong>为什么必备:</strong> 处理输入和输出流是编程中常见的任务。</li>\n<li><strong>学习建议:</strong> 理解 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，以及一些常用的实现，如 <code>bytes.Buffer</code> 和 <code>os.File</code>。</li>\n</ul>\n<p><strong>5. <code>bufio</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供带缓冲的 I&#x2F;O 操作，可以提高 I&#x2F;O 的效率。</li>\n<li><strong>为什么必备:</strong> 在处理大量数据或需要更精细控制 I&#x2F;O 的场景下很有用。</li>\n<li><strong>学习建议:</strong> 学习 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 的用法，以及它们提供的缓冲读取和写入方法。</li>\n</ul>\n<p><strong>6. <code>strings</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供字符串操作的常用函数，如查找、替换、分割等。</li>\n<li><strong>为什么必备:</strong> 字符串处理在各种应用中都很常见。</li>\n<li><strong>学习建议:</strong> 学习 <code>strings.Contains</code>, <code>strings.Index</code>, <code>strings.ReplaceAll</code>, <code>strings.Split</code>, <code>strings.Join</code> 等常用函数。</li>\n</ul>\n<p><strong>7. <code>strconv</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供字符串和基本数据类型之间的转换功能。</li>\n<li><strong>为什么必备:</strong> 在处理用户输入、配置文件等场景下，经常需要在字符串和数值之间进行转换。</li>\n<li><strong>学习建议:</strong> 学习 <code>strconv.Atoi</code> (字符串转整数), <code>strconv.Itoa</code> (整数转字符串), 以及其他类型转换函数，如 <code>ParseBool</code>, <code>ParseFloat</code> 等。</li>\n</ul>\n","excerpt":"","more":"<p><strong>1. <code>fmt</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供格式化输入输出的功能，类似于 C 语言的 <code>printf</code> 和 <code>scanf</code>。</li>\n<li><strong>为什么必备:</strong> 几乎所有的程序都需要进行输入输出，无论是打印日志、用户交互还是格式化数据。</li>\n<li><strong>学习建议:</strong> 重点学习 <code>Printf</code>、<code>Sprintf</code>、<code>Fprintf</code> 等格式化输出函数，以及 <code>Scanf</code>、<code>Sscanf</code>、<code>Fscanf</code> 等格式化输入函数。了解各种格式化动词（如 <code>%d</code>, <code>%s</code>, <code>%v</code> 等）的用法。</li>\n</ul>\n<p><strong>2. <code>os</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供与操作系统交互的功能，如文件操作、进程管理、环境变量等。</li>\n<li><strong>为什么必备:</strong> 任何需要与底层操作系统交互的程序都会用到这个包。</li>\n<li><strong>学习建议:</strong> 学习文件和目录的操作（<code>os.Create</code>, <code>os.Open</code>, <code>os.Mkdir</code>, <code>os.Remove</code> 等），环境变量的获取和设置（<code>os.Getenv</code>, <code>os.Setenv</code> 等），以及进程相关的操作（<code>os.Exit</code> 等）。</li>\n</ul>\n<p><strong>3. <code>net/http</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供 HTTP 客户端和服务器的实现。</li>\n<li><strong>为什么必备:</strong> 在当今互联网时代，Web 开发非常普遍，无论是构建 API 还是简单的 HTTP 客户端，这个包都是必不可少的。</li>\n<li><strong>学习建议:</strong> 学习如何创建一个简单的 HTTP 服务器（<code>http.HandleFunc</code>, <code>http.ListenAndServe</code>），以及如何发起 HTTP 请求（<code>http.Get</code>, <code>http.Post</code> 等）。了解 <code>http.Request</code> 和 <code>http.ResponseWriter</code> 的结构和用法。</li>\n</ul>\n<p><strong>4. <code>io</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供基本的 I&#x2F;O 接口。很多其他的 I&#x2F;O 相关的包都基于 <code>io</code> 包的接口。</li>\n<li><strong>为什么必备:</strong> 处理输入和输出流是编程中常见的任务。</li>\n<li><strong>学习建议:</strong> 理解 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，以及一些常用的实现，如 <code>bytes.Buffer</code> 和 <code>os.File</code>。</li>\n</ul>\n<p><strong>5. <code>bufio</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供带缓冲的 I&#x2F;O 操作，可以提高 I&#x2F;O 的效率。</li>\n<li><strong>为什么必备:</strong> 在处理大量数据或需要更精细控制 I&#x2F;O 的场景下很有用。</li>\n<li><strong>学习建议:</strong> 学习 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 的用法，以及它们提供的缓冲读取和写入方法。</li>\n</ul>\n<p><strong>6. <code>strings</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供字符串操作的常用函数，如查找、替换、分割等。</li>\n<li><strong>为什么必备:</strong> 字符串处理在各种应用中都很常见。</li>\n<li><strong>学习建议:</strong> 学习 <code>strings.Contains</code>, <code>strings.Index</code>, <code>strings.ReplaceAll</code>, <code>strings.Split</code>, <code>strings.Join</code> 等常用函数。</li>\n</ul>\n<p><strong>7. <code>strconv</code> 包:</strong></p>\n<ul>\n<li><strong>功能:</strong> 提供字符串和基本数据类型之间的转换功能。</li>\n<li><strong>为什么必备:</strong> 在处理用户输入、配置文件等场景下，经常需要在字符串和数值之间进行转换。</li>\n<li><strong>学习建议:</strong> 学习 <code>strconv.Atoi</code> (字符串转整数), <code>strconv.Itoa</code> (整数转字符串), 以及其他类型转换函数，如 <code>ParseBool</code>, <code>ParseFloat</code> 等。</li>\n</ul>\n"},{"title":"go语言之并发编程入门指南","description":"快速熟悉go语言并发编程的基础知识，本文相当于一个目录性质的文章，想要学会go的并发编程还得下功夫","toc":false,"date":"2025-05-18T10:41:45.000Z","_content":"\n\n# Go 并发编程指南\n\n## 一、并发与并行的基本概念\n\n* **并发（Concurrency）**：多个任务在同一时间段内交替执行（单核或多核皆可）。\n* **并行（Parallelism）**：多个任务在同一时刻同时执行（仅在多核 CPU 中实现）。\n\n## 二、Goroutine：轻量级线程\n\n### 1. 基本使用\n\n```go\ngo func() {\n    fmt.Println(\"Hello from goroutine\")\n}()\n```\n\n* 每个 `goroutine` 约 2KB 栈空间，由 Go 调度器调度（非操作系统线程）。\n* 创建开销小，可大规模使用（成千上万）。\n\n### 2. 注意事项\n\n* goroutine 是异步执行的，主协程退出会导致所有子 goroutine 被杀死。\n* 需使用 `sync.WaitGroup` 或其他手段控制生命周期。\n\n## 三、通道 Channel：Goroutine 间通信\n\n### 1. 基本语法\n\n```go\nch := make(chan int)     // 创建无缓冲通道\nch := make(chan int, 10) // 创建带缓冲通道\n\nch <- 1      // 发送数据\nx := <-ch    // 接收数据\n```\n\n### 2. 特点\n\n* 通道通信是**阻塞的**（无缓冲时发送/接收都阻塞）。\n* 可用于 goroutine 之间安全地共享数据。\n\n### 3. 关闭通道\n\n```go\nclose(ch) // 通知接收方不再发送\n```\n\n### 4. 使用 `range` 读取所有数据\n\n```go\nfor v := range ch {\n    fmt.Println(v)\n}\n```\n\n## 四、select：监听多个通道\n\n```go\nselect {\ncase v := <-ch1:\n    fmt.Println(\"From ch1:\", v)\ncase ch2 <- 42:\n    fmt.Println(\"Send to ch2\")\ndefault:\n    fmt.Println(\"No channel ready\")\n}\n```\n\n* `select` 会阻塞直到某个分支可执行。\n* 可用于实现超时、广播、负载均衡等逻辑。\n\n## 五、WaitGroup：等待一组 goroutine 完成\n\n```go\nvar wg sync.WaitGroup\nwg.Add(2)\n\ngo func() {\n    defer wg.Done()\n    // 执行任务\n}()\n\ngo func() {\n    defer wg.Done()\n    // 执行任务\n}()\n\nwg.Wait() // 阻塞直到计数器归零\n```\n\n## 六、Mutex：互斥锁\n\n用于保护共享资源，避免数据竞争。\n\n```go\nvar mu sync.Mutex\n\nmu.Lock()\n// 临界区\nmu.Unlock()\n```\n\n## 七、Once：只执行一次（如单例）\n\n```go\nvar once sync.Once\n\nonce.Do(func() {\n    fmt.Println(\"Only once\")\n})\n```\n\n## 八、Cond：条件变量\n\n适用于需要等待某条件成立再继续执行的情况。\n\n```go\nvar mu sync.Mutex\ncond := sync.NewCond(&mu)\n\ngo func() {\n    cond.L.Lock()\n    cond.Wait() // 等待条件\n    // 条件满足后执行\n    cond.L.Unlock()\n}()\n\ncond.L.Lock()\ncond.Signal() // 或 cond.Broadcast()\ncond.L.Unlock()\n```\n\n## 九、Context：控制 goroutine 的生命周期\n\n### 1. 取消 goroutine\n\n```go\nctx, cancel := context.WithCancel(context.Background())\ngo func(ctx context.Context) {\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            // 正常执行\n        }\n    }\n}(ctx)\n\ncancel() // 通知 goroutine 退出\n```\n\n### 2. 超时 / 截止时间\n\n```go\nctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n```\n\n## 十、定时器和 Ticker\n\n```go\ntime.After(1 * time.Second)     // 一次性定时器\ntime.NewTicker(1 * time.Second) // 周期性定时器\n```\n\n## 十一、数据竞争与工具\n\n* 使用 `go run -race` 启用数据竞争检测。\n* Go 的 `race detector` 是诊断并发程序的强大工具。\n\n## 十二、高级模式和最佳实践\n\n* 使用工作池（Worker Pool）限制 goroutine 并发数。\n* 避免共享内存，推荐通过 Channel 传递数据。\n* 对共享状态使用原子操作或互斥锁。\n* 理解 CSP 模型：“不要通过共享内存来通信，而应该通过通信来共享内存”。\n\n---\n\n","source":"_posts/go语言之并发编程入门指南.md","raw":"---\ntitle: go语言之并发编程入门指南\ndescription: '快速熟悉go语言并发编程的基础知识，本文相当于一个目录性质的文章，想要学会go的并发编程还得下功夫'\ntags: ['go']\ntoc: false\ndate: 2025-05-18 18:41:45\ncategories:\n    - go\n    - basic\n---\n\n\n# Go 并发编程指南\n\n## 一、并发与并行的基本概念\n\n* **并发（Concurrency）**：多个任务在同一时间段内交替执行（单核或多核皆可）。\n* **并行（Parallelism）**：多个任务在同一时刻同时执行（仅在多核 CPU 中实现）。\n\n## 二、Goroutine：轻量级线程\n\n### 1. 基本使用\n\n```go\ngo func() {\n    fmt.Println(\"Hello from goroutine\")\n}()\n```\n\n* 每个 `goroutine` 约 2KB 栈空间，由 Go 调度器调度（非操作系统线程）。\n* 创建开销小，可大规模使用（成千上万）。\n\n### 2. 注意事项\n\n* goroutine 是异步执行的，主协程退出会导致所有子 goroutine 被杀死。\n* 需使用 `sync.WaitGroup` 或其他手段控制生命周期。\n\n## 三、通道 Channel：Goroutine 间通信\n\n### 1. 基本语法\n\n```go\nch := make(chan int)     // 创建无缓冲通道\nch := make(chan int, 10) // 创建带缓冲通道\n\nch <- 1      // 发送数据\nx := <-ch    // 接收数据\n```\n\n### 2. 特点\n\n* 通道通信是**阻塞的**（无缓冲时发送/接收都阻塞）。\n* 可用于 goroutine 之间安全地共享数据。\n\n### 3. 关闭通道\n\n```go\nclose(ch) // 通知接收方不再发送\n```\n\n### 4. 使用 `range` 读取所有数据\n\n```go\nfor v := range ch {\n    fmt.Println(v)\n}\n```\n\n## 四、select：监听多个通道\n\n```go\nselect {\ncase v := <-ch1:\n    fmt.Println(\"From ch1:\", v)\ncase ch2 <- 42:\n    fmt.Println(\"Send to ch2\")\ndefault:\n    fmt.Println(\"No channel ready\")\n}\n```\n\n* `select` 会阻塞直到某个分支可执行。\n* 可用于实现超时、广播、负载均衡等逻辑。\n\n## 五、WaitGroup：等待一组 goroutine 完成\n\n```go\nvar wg sync.WaitGroup\nwg.Add(2)\n\ngo func() {\n    defer wg.Done()\n    // 执行任务\n}()\n\ngo func() {\n    defer wg.Done()\n    // 执行任务\n}()\n\nwg.Wait() // 阻塞直到计数器归零\n```\n\n## 六、Mutex：互斥锁\n\n用于保护共享资源，避免数据竞争。\n\n```go\nvar mu sync.Mutex\n\nmu.Lock()\n// 临界区\nmu.Unlock()\n```\n\n## 七、Once：只执行一次（如单例）\n\n```go\nvar once sync.Once\n\nonce.Do(func() {\n    fmt.Println(\"Only once\")\n})\n```\n\n## 八、Cond：条件变量\n\n适用于需要等待某条件成立再继续执行的情况。\n\n```go\nvar mu sync.Mutex\ncond := sync.NewCond(&mu)\n\ngo func() {\n    cond.L.Lock()\n    cond.Wait() // 等待条件\n    // 条件满足后执行\n    cond.L.Unlock()\n}()\n\ncond.L.Lock()\ncond.Signal() // 或 cond.Broadcast()\ncond.L.Unlock()\n```\n\n## 九、Context：控制 goroutine 的生命周期\n\n### 1. 取消 goroutine\n\n```go\nctx, cancel := context.WithCancel(context.Background())\ngo func(ctx context.Context) {\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            // 正常执行\n        }\n    }\n}(ctx)\n\ncancel() // 通知 goroutine 退出\n```\n\n### 2. 超时 / 截止时间\n\n```go\nctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n```\n\n## 十、定时器和 Ticker\n\n```go\ntime.After(1 * time.Second)     // 一次性定时器\ntime.NewTicker(1 * time.Second) // 周期性定时器\n```\n\n## 十一、数据竞争与工具\n\n* 使用 `go run -race` 启用数据竞争检测。\n* Go 的 `race detector` 是诊断并发程序的强大工具。\n\n## 十二、高级模式和最佳实践\n\n* 使用工作池（Worker Pool）限制 goroutine 并发数。\n* 避免共享内存，推荐通过 Channel 传递数据。\n* 对共享状态使用原子操作或互斥锁。\n* 理解 CSP 模型：“不要通过共享内存来通信，而应该通过通信来共享内存”。\n\n---\n\n","slug":"go语言之并发编程入门指南","published":1,"updated":"2025-05-23T06:27:10.599Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxd0005hkvobwut1eqr","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"Go-并发编程指南\"><a href=\"#Go-并发编程指南\" class=\"headerlink\" title=\"Go 并发编程指南\"></a>Go 并发编程指南</h1><h2 id=\"一、并发与并行的基本概念\"><a href=\"#一、并发与并行的基本概念\" class=\"headerlink\" title=\"一、并发与并行的基本概念\"></a>一、并发与并行的基本概念</h2><ul>\n<li><strong>并发（Concurrency）</strong>：多个任务在同一时间段内交替执行（单核或多核皆可）。</li>\n<li><strong>并行（Parallelism）</strong>：多个任务在同一时刻同时执行（仅在多核 CPU 中实现）。</li>\n</ul>\n<h2 id=\"二、Goroutine：轻量级线程\"><a href=\"#二、Goroutine：轻量级线程\" class=\"headerlink\" title=\"二、Goroutine：轻量级线程\"></a>二、Goroutine：轻量级线程</h2><h3 id=\"1-基本使用\"><a href=\"#1-基本使用\" class=\"headerlink\" title=\"1. 基本使用\"></a>1. 基本使用</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello from goroutine&quot;</span>)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每个 <code>goroutine</code> 约 2KB 栈空间，由 Go 调度器调度（非操作系统线程）。</li>\n<li>创建开销小，可大规模使用（成千上万）。</li>\n</ul>\n<h3 id=\"2-注意事项\"><a href=\"#2-注意事项\" class=\"headerlink\" title=\"2. 注意事项\"></a>2. 注意事项</h3><ul>\n<li>goroutine 是异步执行的，主协程退出会导致所有子 goroutine 被杀死。</li>\n<li>需使用 <code>sync.WaitGroup</code> 或其他手段控制生命周期。</li>\n</ul>\n<h2 id=\"三、通道-Channel：Goroutine-间通信\"><a href=\"#三、通道-Channel：Goroutine-间通信\" class=\"headerlink\" title=\"三、通道 Channel：Goroutine 间通信\"></a>三、通道 Channel：Goroutine 间通信</h2><h3 id=\"1-基本语法\"><a href=\"#1-基本语法\" class=\"headerlink\" title=\"1. 基本语法\"></a>1. 基本语法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)     <span class=\"comment\">// 创建无缓冲通道</span></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 创建带缓冲通道</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch &lt;- <span class=\"number\">1</span>      <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">x := &lt;-ch    <span class=\"comment\">// 接收数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-特点\"><a href=\"#2-特点\" class=\"headerlink\" title=\"2. 特点\"></a>2. 特点</h3><ul>\n<li>通道通信是<strong>阻塞的</strong>（无缓冲时发送&#x2F;接收都阻塞）。</li>\n<li>可用于 goroutine 之间安全地共享数据。</li>\n</ul>\n<h3 id=\"3-关闭通道\"><a href=\"#3-关闭通道\" class=\"headerlink\" title=\"3. 关闭通道\"></a>3. 关闭通道</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">close</span>(ch) <span class=\"comment\">// 通知接收方不再发送</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-使用-range-读取所有数据\"><a href=\"#4-使用-range-读取所有数据\" class=\"headerlink\" title=\"4. 使用 range 读取所有数据\"></a>4. 使用 <code>range</code> 读取所有数据</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">    fmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、select：监听多个通道\"><a href=\"#四、select：监听多个通道\" class=\"headerlink\" title=\"四、select：监听多个通道\"></a>四、select：监听多个通道</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> v := &lt;-ch1:</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;From ch1:&quot;</span>, v)</span><br><span class=\"line\"><span class=\"keyword\">case</span> ch2 &lt;- <span class=\"number\">42</span>:</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Send to ch2&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;No channel ready&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>select</code> 会阻塞直到某个分支可执行。</li>\n<li>可用于实现超时、广播、负载均衡等逻辑。</li>\n</ul>\n<h2 id=\"五、WaitGroup：等待一组-goroutine-完成\"><a href=\"#五、WaitGroup：等待一组-goroutine-完成\" class=\"headerlink\" title=\"五、WaitGroup：等待一组 goroutine 完成\"></a>五、WaitGroup：等待一组 goroutine 完成</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">wg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">    <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">    <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">wg.Wait() <span class=\"comment\">// 阻塞直到计数器归零</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、Mutex：互斥锁\"><a href=\"#六、Mutex：互斥锁\" class=\"headerlink\" title=\"六、Mutex：互斥锁\"></a>六、Mutex：互斥锁</h2><p>用于保护共享资源，避免数据竞争。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"></span><br><span class=\"line\">mu.Lock()</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">mu.Unlock()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、Once：只执行一次（如单例）\"><a href=\"#七、Once：只执行一次（如单例）\" class=\"headerlink\" title=\"七、Once：只执行一次（如单例）\"></a>七、Once：只执行一次（如单例）</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\">once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Only once&quot;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八、Cond：条件变量\"><a href=\"#八、Cond：条件变量\" class=\"headerlink\" title=\"八、Cond：条件变量\"></a>八、Cond：条件变量</h2><p>适用于需要等待某条件成立再继续执行的情况。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\">cond := sync.NewCond(&amp;mu)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    cond.L.Lock()</span><br><span class=\"line\">    cond.Wait() <span class=\"comment\">// 等待条件</span></span><br><span class=\"line\">    <span class=\"comment\">// 条件满足后执行</span></span><br><span class=\"line\">    cond.L.Unlock()</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">cond.L.Lock()</span><br><span class=\"line\">cond.Signal() <span class=\"comment\">// 或 cond.Broadcast()</span></span><br><span class=\"line\">cond.L.Unlock()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九、Context：控制-goroutine-的生命周期\"><a href=\"#九、Context：控制-goroutine-的生命周期\" class=\"headerlink\" title=\"九、Context：控制 goroutine 的生命周期\"></a>九、Context：控制 goroutine 的生命周期</h2><h3 id=\"1-取消-goroutine\"><a href=\"#1-取消-goroutine\" class=\"headerlink\" title=\"1. 取消 goroutine\"></a>1. 取消 goroutine</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx, cancel := context.WithCancel(context.Background())</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 正常执行</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(ctx)</span><br><span class=\"line\"></span><br><span class=\"line\">cancel() <span class=\"comment\">// 通知 goroutine 退出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-超时-截止时间\"><a href=\"#2-超时-截止时间\" class=\"headerlink\" title=\"2. 超时 &#x2F; 截止时间\"></a>2. 超时 &#x2F; 截止时间</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx, cancel := context.WithTimeout(context.Background(), <span class=\"number\">2</span>*time.Second)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> cancel()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十、定时器和-Ticker\"><a href=\"#十、定时器和-Ticker\" class=\"headerlink\" title=\"十、定时器和 Ticker\"></a>十、定时器和 Ticker</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time.After(<span class=\"number\">1</span> * time.Second)     <span class=\"comment\">// 一次性定时器</span></span><br><span class=\"line\">time.NewTicker(<span class=\"number\">1</span> * time.Second) <span class=\"comment\">// 周期性定时器</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十一、数据竞争与工具\"><a href=\"#十一、数据竞争与工具\" class=\"headerlink\" title=\"十一、数据竞争与工具\"></a>十一、数据竞争与工具</h2><ul>\n<li>使用 <code>go run -race</code> 启用数据竞争检测。</li>\n<li>Go 的 <code>race detector</code> 是诊断并发程序的强大工具。</li>\n</ul>\n<h2 id=\"十二、高级模式和最佳实践\"><a href=\"#十二、高级模式和最佳实践\" class=\"headerlink\" title=\"十二、高级模式和最佳实践\"></a>十二、高级模式和最佳实践</h2><ul>\n<li>使用工作池（Worker Pool）限制 goroutine 并发数。</li>\n<li>避免共享内存，推荐通过 Channel 传递数据。</li>\n<li>对共享状态使用原子操作或互斥锁。</li>\n<li>理解 CSP 模型：“不要通过共享内存来通信，而应该通过通信来共享内存”。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h1 id=\"Go-并发编程指南\"><a href=\"#Go-并发编程指南\" class=\"headerlink\" title=\"Go 并发编程指南\"></a>Go 并发编程指南</h1><h2 id=\"一、并发与并行的基本概念\"><a href=\"#一、并发与并行的基本概念\" class=\"headerlink\" title=\"一、并发与并行的基本概念\"></a>一、并发与并行的基本概念</h2><ul>\n<li><strong>并发（Concurrency）</strong>：多个任务在同一时间段内交替执行（单核或多核皆可）。</li>\n<li><strong>并行（Parallelism）</strong>：多个任务在同一时刻同时执行（仅在多核 CPU 中实现）。</li>\n</ul>\n<h2 id=\"二、Goroutine：轻量级线程\"><a href=\"#二、Goroutine：轻量级线程\" class=\"headerlink\" title=\"二、Goroutine：轻量级线程\"></a>二、Goroutine：轻量级线程</h2><h3 id=\"1-基本使用\"><a href=\"#1-基本使用\" class=\"headerlink\" title=\"1. 基本使用\"></a>1. 基本使用</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello from goroutine&quot;</span>)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每个 <code>goroutine</code> 约 2KB 栈空间，由 Go 调度器调度（非操作系统线程）。</li>\n<li>创建开销小，可大规模使用（成千上万）。</li>\n</ul>\n<h3 id=\"2-注意事项\"><a href=\"#2-注意事项\" class=\"headerlink\" title=\"2. 注意事项\"></a>2. 注意事项</h3><ul>\n<li>goroutine 是异步执行的，主协程退出会导致所有子 goroutine 被杀死。</li>\n<li>需使用 <code>sync.WaitGroup</code> 或其他手段控制生命周期。</li>\n</ul>\n<h2 id=\"三、通道-Channel：Goroutine-间通信\"><a href=\"#三、通道-Channel：Goroutine-间通信\" class=\"headerlink\" title=\"三、通道 Channel：Goroutine 间通信\"></a>三、通道 Channel：Goroutine 间通信</h2><h3 id=\"1-基本语法\"><a href=\"#1-基本语法\" class=\"headerlink\" title=\"1. 基本语法\"></a>1. 基本语法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)     <span class=\"comment\">// 创建无缓冲通道</span></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 创建带缓冲通道</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch &lt;- <span class=\"number\">1</span>      <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">x := &lt;-ch    <span class=\"comment\">// 接收数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-特点\"><a href=\"#2-特点\" class=\"headerlink\" title=\"2. 特点\"></a>2. 特点</h3><ul>\n<li>通道通信是<strong>阻塞的</strong>（无缓冲时发送&#x2F;接收都阻塞）。</li>\n<li>可用于 goroutine 之间安全地共享数据。</li>\n</ul>\n<h3 id=\"3-关闭通道\"><a href=\"#3-关闭通道\" class=\"headerlink\" title=\"3. 关闭通道\"></a>3. 关闭通道</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">close</span>(ch) <span class=\"comment\">// 通知接收方不再发送</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-使用-range-读取所有数据\"><a href=\"#4-使用-range-读取所有数据\" class=\"headerlink\" title=\"4. 使用 range 读取所有数据\"></a>4. 使用 <code>range</code> 读取所有数据</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">    fmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、select：监听多个通道\"><a href=\"#四、select：监听多个通道\" class=\"headerlink\" title=\"四、select：监听多个通道\"></a>四、select：监听多个通道</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> v := &lt;-ch1:</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;From ch1:&quot;</span>, v)</span><br><span class=\"line\"><span class=\"keyword\">case</span> ch2 &lt;- <span class=\"number\">42</span>:</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Send to ch2&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;No channel ready&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>select</code> 会阻塞直到某个分支可执行。</li>\n<li>可用于实现超时、广播、负载均衡等逻辑。</li>\n</ul>\n<h2 id=\"五、WaitGroup：等待一组-goroutine-完成\"><a href=\"#五、WaitGroup：等待一组-goroutine-完成\" class=\"headerlink\" title=\"五、WaitGroup：等待一组 goroutine 完成\"></a>五、WaitGroup：等待一组 goroutine 完成</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">wg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">    <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">    <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">wg.Wait() <span class=\"comment\">// 阻塞直到计数器归零</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、Mutex：互斥锁\"><a href=\"#六、Mutex：互斥锁\" class=\"headerlink\" title=\"六、Mutex：互斥锁\"></a>六、Mutex：互斥锁</h2><p>用于保护共享资源，避免数据竞争。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"></span><br><span class=\"line\">mu.Lock()</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">mu.Unlock()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、Once：只执行一次（如单例）\"><a href=\"#七、Once：只执行一次（如单例）\" class=\"headerlink\" title=\"七、Once：只执行一次（如单例）\"></a>七、Once：只执行一次（如单例）</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\">once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Only once&quot;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八、Cond：条件变量\"><a href=\"#八、Cond：条件变量\" class=\"headerlink\" title=\"八、Cond：条件变量\"></a>八、Cond：条件变量</h2><p>适用于需要等待某条件成立再继续执行的情况。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\">cond := sync.NewCond(&amp;mu)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    cond.L.Lock()</span><br><span class=\"line\">    cond.Wait() <span class=\"comment\">// 等待条件</span></span><br><span class=\"line\">    <span class=\"comment\">// 条件满足后执行</span></span><br><span class=\"line\">    cond.L.Unlock()</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">cond.L.Lock()</span><br><span class=\"line\">cond.Signal() <span class=\"comment\">// 或 cond.Broadcast()</span></span><br><span class=\"line\">cond.L.Unlock()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九、Context：控制-goroutine-的生命周期\"><a href=\"#九、Context：控制-goroutine-的生命周期\" class=\"headerlink\" title=\"九、Context：控制 goroutine 的生命周期\"></a>九、Context：控制 goroutine 的生命周期</h2><h3 id=\"1-取消-goroutine\"><a href=\"#1-取消-goroutine\" class=\"headerlink\" title=\"1. 取消 goroutine\"></a>1. 取消 goroutine</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx, cancel := context.WithCancel(context.Background())</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 正常执行</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(ctx)</span><br><span class=\"line\"></span><br><span class=\"line\">cancel() <span class=\"comment\">// 通知 goroutine 退出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-超时-截止时间\"><a href=\"#2-超时-截止时间\" class=\"headerlink\" title=\"2. 超时 &#x2F; 截止时间\"></a>2. 超时 &#x2F; 截止时间</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx, cancel := context.WithTimeout(context.Background(), <span class=\"number\">2</span>*time.Second)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> cancel()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十、定时器和-Ticker\"><a href=\"#十、定时器和-Ticker\" class=\"headerlink\" title=\"十、定时器和 Ticker\"></a>十、定时器和 Ticker</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time.After(<span class=\"number\">1</span> * time.Second)     <span class=\"comment\">// 一次性定时器</span></span><br><span class=\"line\">time.NewTicker(<span class=\"number\">1</span> * time.Second) <span class=\"comment\">// 周期性定时器</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十一、数据竞争与工具\"><a href=\"#十一、数据竞争与工具\" class=\"headerlink\" title=\"十一、数据竞争与工具\"></a>十一、数据竞争与工具</h2><ul>\n<li>使用 <code>go run -race</code> 启用数据竞争检测。</li>\n<li>Go 的 <code>race detector</code> 是诊断并发程序的强大工具。</li>\n</ul>\n<h2 id=\"十二、高级模式和最佳实践\"><a href=\"#十二、高级模式和最佳实践\" class=\"headerlink\" title=\"十二、高级模式和最佳实践\"></a>十二、高级模式和最佳实践</h2><ul>\n<li>使用工作池（Worker Pool）限制 goroutine 并发数。</li>\n<li>避免共享内存，推荐通过 Channel 传递数据。</li>\n<li>对共享状态使用原子操作或互斥锁。</li>\n<li>理解 CSP 模型：“不要通过共享内存来通信，而应该通过通信来共享内存”。</li>\n</ul>\n<hr>\n"},{"title":"go语言之接口设计原则","description":"接口设计要聚焦最小功能集（遵循接口隔离原则）,并使用组合接口，将多个小接口组合成更大接口","toc":false,"date":"2025-05-15T02:05:08.000Z","_content":"\n假设接口定义如下：\n\n```go\ntype MyInterface interface {\n    Foo()\n    Bar()\n}\n```\n\n然后你有一个结构体只实现了 `Foo()`，没有实现 `Bar()`：\n\n```go\ntype MyStruct struct{}\n\nfunc (m MyStruct) Foo() {\n    fmt.Println(\"Foo called\")\n}\n```\n\n### ❌ 此时的行为\n\n如果你尝试这样赋值：\n\n```go\nvar x MyInterface = MyStruct{}  // ❌ 编译错误\n```\n\n**会报编译错误：**\n\n> `MyStruct` does not implement `MyInterface` (missing method `Bar`)\n\n---\n\n### ✅ Go 的接口是结构性的\n\nGo 使用结构性类型系统，**只要类型实现了接口所需的所有方法，就隐式满足该接口。**\n所以如果缺失任意一个方法，即便名字完全匹配，**也不能赋值给该接口变量。**\n\n---\n\n### ✅ 正确实现方式\n\n```go\ntype MyStruct struct{}\n\nfunc (m MyStruct) Foo() {\n    fmt.Println(\"Foo called\")\n}\n\nfunc (m MyStruct) Bar() {\n    fmt.Println(\"Bar called\")\n}\n\nvar x MyInterface = MyStruct{}  // ✅ OK\n```\n\n---\n\n### 实际开发建议\n\n* **接口设计要聚焦最小功能集**（遵循接口隔离原则），以便结构体可以按需实现。\n* **使用组合接口**：将多个小接口组合成更大接口，例如：\n\n```go\ntype Fooer interface {\n    Foo()\n}\n\ntype Barer interface {\n    Bar()\n}\n\ntype FooBar interface {\n    Fooer\n    Barer\n}\n```\n\n---\n\n","source":"_posts/go语言之接口设计原则.md","raw":"---\ntitle: go语言之接口设计原则\ndescription: '接口设计要聚焦最小功能集（遵循接口隔离原则）,并使用组合接口，将多个小接口组合成更大接口'\ntags: ['go']\ntoc: false\ndate: 2025-05-15 10:05:08\ncategories:\n    - go\n    - basic\n---\n\n假设接口定义如下：\n\n```go\ntype MyInterface interface {\n    Foo()\n    Bar()\n}\n```\n\n然后你有一个结构体只实现了 `Foo()`，没有实现 `Bar()`：\n\n```go\ntype MyStruct struct{}\n\nfunc (m MyStruct) Foo() {\n    fmt.Println(\"Foo called\")\n}\n```\n\n### ❌ 此时的行为\n\n如果你尝试这样赋值：\n\n```go\nvar x MyInterface = MyStruct{}  // ❌ 编译错误\n```\n\n**会报编译错误：**\n\n> `MyStruct` does not implement `MyInterface` (missing method `Bar`)\n\n---\n\n### ✅ Go 的接口是结构性的\n\nGo 使用结构性类型系统，**只要类型实现了接口所需的所有方法，就隐式满足该接口。**\n所以如果缺失任意一个方法，即便名字完全匹配，**也不能赋值给该接口变量。**\n\n---\n\n### ✅ 正确实现方式\n\n```go\ntype MyStruct struct{}\n\nfunc (m MyStruct) Foo() {\n    fmt.Println(\"Foo called\")\n}\n\nfunc (m MyStruct) Bar() {\n    fmt.Println(\"Bar called\")\n}\n\nvar x MyInterface = MyStruct{}  // ✅ OK\n```\n\n---\n\n### 实际开发建议\n\n* **接口设计要聚焦最小功能集**（遵循接口隔离原则），以便结构体可以按需实现。\n* **使用组合接口**：将多个小接口组合成更大接口，例如：\n\n```go\ntype Fooer interface {\n    Foo()\n}\n\ntype Barer interface {\n    Bar()\n}\n\ntype FooBar interface {\n    Fooer\n    Barer\n}\n```\n\n---\n\n","slug":"go语言之接口设计原则","published":1,"updated":"2025-05-23T06:25:40.845Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxd0008hkvodv9w0ecx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>假设接口定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Foo()</span><br><span class=\"line\">    Bar()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你有一个结构体只实现了 <code>Foo()</code>，没有实现 <code>Bar()</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m MyStruct)</span></span> Foo() &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Foo called&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"❌-此时的行为\"><a href=\"#❌-此时的行为\" class=\"headerlink\" title=\"❌ 此时的行为\"></a>❌ 此时的行为</h3><p>如果你尝试这样赋值：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x MyInterface = MyStruct&#123;&#125;  <span class=\"comment\">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>会报编译错误：</strong></p>\n<blockquote>\n<p><code>MyStruct</code> does not implement <code>MyInterface</code> (missing method <code>Bar</code>)</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-Go-的接口是结构性的\"><a href=\"#✅-Go-的接口是结构性的\" class=\"headerlink\" title=\"✅ Go 的接口是结构性的\"></a>✅ Go 的接口是结构性的</h3><p>Go 使用结构性类型系统，<strong>只要类型实现了接口所需的所有方法，就隐式满足该接口。</strong><br>所以如果缺失任意一个方法，即便名字完全匹配，<strong>也不能赋值给该接口变量。</strong></p>\n<hr>\n<h3 id=\"✅-正确实现方式\"><a href=\"#✅-正确实现方式\" class=\"headerlink\" title=\"✅ 正确实现方式\"></a>✅ 正确实现方式</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m MyStruct)</span></span> Foo() &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Foo called&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m MyStruct)</span></span> Bar() &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Bar called&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x MyInterface = MyStruct&#123;&#125;  <span class=\"comment\">// ✅ OK</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"实际开发建议\"><a href=\"#实际开发建议\" class=\"headerlink\" title=\"实际开发建议\"></a>实际开发建议</h3><ul>\n<li><strong>接口设计要聚焦最小功能集</strong>（遵循接口隔离原则），以便结构体可以按需实现。</li>\n<li><strong>使用组合接口</strong>：将多个小接口组合成更大接口，例如：</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Fooer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Foo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Barer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> FooBar <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Fooer</span><br><span class=\"line\">    Barer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n","excerpt":"","more":"<p>假设接口定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Foo()</span><br><span class=\"line\">    Bar()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你有一个结构体只实现了 <code>Foo()</code>，没有实现 <code>Bar()</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m MyStruct)</span></span> Foo() &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Foo called&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"❌-此时的行为\"><a href=\"#❌-此时的行为\" class=\"headerlink\" title=\"❌ 此时的行为\"></a>❌ 此时的行为</h3><p>如果你尝试这样赋值：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x MyInterface = MyStruct&#123;&#125;  <span class=\"comment\">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>会报编译错误：</strong></p>\n<blockquote>\n<p><code>MyStruct</code> does not implement <code>MyInterface</code> (missing method <code>Bar</code>)</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-Go-的接口是结构性的\"><a href=\"#✅-Go-的接口是结构性的\" class=\"headerlink\" title=\"✅ Go 的接口是结构性的\"></a>✅ Go 的接口是结构性的</h3><p>Go 使用结构性类型系统，<strong>只要类型实现了接口所需的所有方法，就隐式满足该接口。</strong><br>所以如果缺失任意一个方法，即便名字完全匹配，<strong>也不能赋值给该接口变量。</strong></p>\n<hr>\n<h3 id=\"✅-正确实现方式\"><a href=\"#✅-正确实现方式\" class=\"headerlink\" title=\"✅ 正确实现方式\"></a>✅ 正确实现方式</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m MyStruct)</span></span> Foo() &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Foo called&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m MyStruct)</span></span> Bar() &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Bar called&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x MyInterface = MyStruct&#123;&#125;  <span class=\"comment\">// ✅ OK</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"实际开发建议\"><a href=\"#实际开发建议\" class=\"headerlink\" title=\"实际开发建议\"></a>实际开发建议</h3><ul>\n<li><strong>接口设计要聚焦最小功能集</strong>（遵循接口隔离原则），以便结构体可以按需实现。</li>\n<li><strong>使用组合接口</strong>：将多个小接口组合成更大接口，例如：</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Fooer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Foo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Barer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> FooBar <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Fooer</span><br><span class=\"line\">    Barer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n"},{"title":"go语言之无缓冲通道","description":"go语言中的无缓冲通道为何会造成阻塞，何种情况下适合使用？","toc":false,"date":"2025-05-18T10:07:44.000Z","_content":"Go 语言中的通道（`channel`）是用于**协程间通信**的核心工具。它有两种形式：**无缓冲通道** 和 **有缓冲通道**。\n\n---\n\n## 🌱 什么是通道（channel）？\n\n在 Go 中，通道用于在 goroutine 之间传递数据。它就像一个**传送带**，一个 goroutine 把数据“放上去”，另一个 goroutine 把它“取下来”。\n\n---\n\n## ⚙️ 无缓冲通道（unbuffered channel）\n\n### ✅ 特点：\n\n* **发送和接收必须同步进行。**\n* 如果发送时没有接收方在等着，发送就会**阻塞（卡住）**，直到接收方出现。\n* 更适合用于**协程同步**。\n\n### 🎯 比喻：\n\n像两个人面对面递纸条，递的人不能走，直到接的人把纸条接过去。\n\n### 🔧 示例代码：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tch := make(chan string) // 无缓冲通道\n\n\tgo func() {\n\t\tch <- \"hello from goroutine\" // 会阻塞直到 main() 接收\n\t}()\n\n\tmsg := <-ch // 接收到消息后，上面的发送才完成\n\tfmt.Println(msg)\n}\n```\n\n---\n\n## ⚙️ 有缓冲通道（buffered channel）\n\n### ✅ 特点：\n\n* 允许**指定缓冲大小**。\n* 发送操作在缓冲未满时不会阻塞。\n* 接收操作在缓冲非空时不会阻塞。\n* 适用于**解耦发送者和接收者速度**不同的场景。\n\n### 🎯 比喻：\n\n像一个邮箱，有多个格子可以放纸条。你可以先投进去，只要格子没满。\n\n### 🔧 示例代码：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tch := make(chan string, 2) // 有缓冲通道，容量为2\n\n\tch <- \"message 1\" // ✅ 不阻塞\n\tch <- \"message 2\" // ✅ 不阻塞\n\t// ch <- \"message 3\" // ❌ 超出缓冲，会阻塞，除非有接收\n\n\tfmt.Println(<-ch) // 输出 message 1\n\tfmt.Println(<-ch) // 输出 message 2\n}\n```\n\n---\n\n## 🧠 总结对比\n\n| 特性       | 无缓冲通道     | 有缓冲通道           |\n| -------- | --------- | --------------- |\n| 阻塞行为     | 发送和接收必须同步 | 缓冲满才阻塞发送，空才阻塞接收 |\n| 是否适合同步   | ✅ 是       | ❌ 不直接适合         |\n| 是否适合解耦速度 | ❌ 否       | ✅ 是             |\n| 使用难度     | 稍高，容易死锁   | 相对灵活，但容易忘记接收    |\n\n---\n\n\n","source":"_posts/go语言之无缓冲通道.md","raw":"---\ntitle: go语言之无缓冲通道\ndescription: 'go语言中的无缓冲通道为何会造成阻塞，何种情况下适合使用？'\ntags: ['go']\ntoc: false\ndate: 2025-05-18 18:07:44\ncategories:\n    - go\n    - basic\n---\nGo 语言中的通道（`channel`）是用于**协程间通信**的核心工具。它有两种形式：**无缓冲通道** 和 **有缓冲通道**。\n\n---\n\n## 🌱 什么是通道（channel）？\n\n在 Go 中，通道用于在 goroutine 之间传递数据。它就像一个**传送带**，一个 goroutine 把数据“放上去”，另一个 goroutine 把它“取下来”。\n\n---\n\n## ⚙️ 无缓冲通道（unbuffered channel）\n\n### ✅ 特点：\n\n* **发送和接收必须同步进行。**\n* 如果发送时没有接收方在等着，发送就会**阻塞（卡住）**，直到接收方出现。\n* 更适合用于**协程同步**。\n\n### 🎯 比喻：\n\n像两个人面对面递纸条，递的人不能走，直到接的人把纸条接过去。\n\n### 🔧 示例代码：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tch := make(chan string) // 无缓冲通道\n\n\tgo func() {\n\t\tch <- \"hello from goroutine\" // 会阻塞直到 main() 接收\n\t}()\n\n\tmsg := <-ch // 接收到消息后，上面的发送才完成\n\tfmt.Println(msg)\n}\n```\n\n---\n\n## ⚙️ 有缓冲通道（buffered channel）\n\n### ✅ 特点：\n\n* 允许**指定缓冲大小**。\n* 发送操作在缓冲未满时不会阻塞。\n* 接收操作在缓冲非空时不会阻塞。\n* 适用于**解耦发送者和接收者速度**不同的场景。\n\n### 🎯 比喻：\n\n像一个邮箱，有多个格子可以放纸条。你可以先投进去，只要格子没满。\n\n### 🔧 示例代码：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tch := make(chan string, 2) // 有缓冲通道，容量为2\n\n\tch <- \"message 1\" // ✅ 不阻塞\n\tch <- \"message 2\" // ✅ 不阻塞\n\t// ch <- \"message 3\" // ❌ 超出缓冲，会阻塞，除非有接收\n\n\tfmt.Println(<-ch) // 输出 message 1\n\tfmt.Println(<-ch) // 输出 message 2\n}\n```\n\n---\n\n## 🧠 总结对比\n\n| 特性       | 无缓冲通道     | 有缓冲通道           |\n| -------- | --------- | --------------- |\n| 阻塞行为     | 发送和接收必须同步 | 缓冲满才阻塞发送，空才阻塞接收 |\n| 是否适合同步   | ✅ 是       | ❌ 不直接适合         |\n| 是否适合解耦速度 | ❌ 否       | ✅ 是             |\n| 使用难度     | 稍高，容易死锁   | 相对灵活，但容易忘记接收    |\n\n---\n\n\n","slug":"go语言之无缓冲通道","published":1,"updated":"2025-05-23T06:25:29.715Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxd000bhkvoebjs6qmd","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Go 语言中的通道（<code>channel</code>）是用于<strong>协程间通信</strong>的核心工具。它有两种形式：<strong>无缓冲通道</strong> 和 <strong>有缓冲通道</strong>。</p>\n<hr>\n<h2 id=\"🌱-什么是通道（channel）？\"><a href=\"#🌱-什么是通道（channel）？\" class=\"headerlink\" title=\"🌱 什么是通道（channel）？\"></a>🌱 什么是通道（channel）？</h2><p>在 Go 中，通道用于在 goroutine 之间传递数据。它就像一个<strong>传送带</strong>，一个 goroutine 把数据“放上去”，另一个 goroutine 把它“取下来”。</p>\n<hr>\n<h2 id=\"⚙️-无缓冲通道（unbuffered-channel）\"><a href=\"#⚙️-无缓冲通道（unbuffered-channel）\" class=\"headerlink\" title=\"⚙️ 无缓冲通道（unbuffered channel）\"></a>⚙️ 无缓冲通道（unbuffered channel）</h2><h3 id=\"✅-特点：\"><a href=\"#✅-特点：\" class=\"headerlink\" title=\"✅ 特点：\"></a>✅ 特点：</h3><ul>\n<li><strong>发送和接收必须同步进行。</strong></li>\n<li>如果发送时没有接收方在等着，发送就会<strong>阻塞（卡住）</strong>，直到接收方出现。</li>\n<li>更适合用于<strong>协程同步</strong>。</li>\n</ul>\n<h3 id=\"🎯-比喻：\"><a href=\"#🎯-比喻：\" class=\"headerlink\" title=\"🎯 比喻：\"></a>🎯 比喻：</h3><p>像两个人面对面递纸条，递的人不能走，直到接的人把纸条接过去。</p>\n<h3 id=\"🔧-示例代码：\"><a href=\"#🔧-示例代码：\" class=\"headerlink\" title=\"🔧 示例代码：\"></a>🔧 示例代码：</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>) <span class=\"comment\">// 无缓冲通道</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tch &lt;- <span class=\"string\">&quot;hello from goroutine&quot;</span> <span class=\"comment\">// 会阻塞直到 main() 接收</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tmsg := &lt;-ch <span class=\"comment\">// 接收到消息后，上面的发送才完成</span></span><br><span class=\"line\">\tfmt.Println(msg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"⚙️-有缓冲通道（buffered-channel）\"><a href=\"#⚙️-有缓冲通道（buffered-channel）\" class=\"headerlink\" title=\"⚙️ 有缓冲通道（buffered channel）\"></a>⚙️ 有缓冲通道（buffered channel）</h2><h3 id=\"✅-特点：-1\"><a href=\"#✅-特点：-1\" class=\"headerlink\" title=\"✅ 特点：\"></a>✅ 特点：</h3><ul>\n<li>允许<strong>指定缓冲大小</strong>。</li>\n<li>发送操作在缓冲未满时不会阻塞。</li>\n<li>接收操作在缓冲非空时不会阻塞。</li>\n<li>适用于<strong>解耦发送者和接收者速度</strong>不同的场景。</li>\n</ul>\n<h3 id=\"🎯-比喻：-1\"><a href=\"#🎯-比喻：-1\" class=\"headerlink\" title=\"🎯 比喻：\"></a>🎯 比喻：</h3><p>像一个邮箱，有多个格子可以放纸条。你可以先投进去，只要格子没满。</p>\n<h3 id=\"🔧-示例代码：-1\"><a href=\"#🔧-示例代码：-1\" class=\"headerlink\" title=\"🔧 示例代码：\"></a>🔧 示例代码：</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 有缓冲通道，容量为2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tch &lt;- <span class=\"string\">&quot;message 1&quot;</span> <span class=\"comment\">// ✅ 不阻塞</span></span><br><span class=\"line\">\tch &lt;- <span class=\"string\">&quot;message 2&quot;</span> <span class=\"comment\">// ✅ 不阻塞</span></span><br><span class=\"line\">\t<span class=\"comment\">// ch &lt;- &quot;message 3&quot; // ❌ 超出缓冲，会阻塞，除非有接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(&lt;-ch) <span class=\"comment\">// 输出 message 1</span></span><br><span class=\"line\">\tfmt.Println(&lt;-ch) <span class=\"comment\">// 输出 message 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧠-总结对比\"><a href=\"#🧠-总结对比\" class=\"headerlink\" title=\"🧠 总结对比\"></a>🧠 总结对比</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>无缓冲通道</th>\n<th>有缓冲通道</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>阻塞行为</td>\n<td>发送和接收必须同步</td>\n<td>缓冲满才阻塞发送，空才阻塞接收</td>\n</tr>\n<tr>\n<td>是否适合同步</td>\n<td>✅ 是</td>\n<td>❌ 不直接适合</td>\n</tr>\n<tr>\n<td>是否适合解耦速度</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>使用难度</td>\n<td>稍高，容易死锁</td>\n<td>相对灵活，但容易忘记接收</td>\n</tr>\n</tbody></table>\n<hr>\n","excerpt":"","more":"<p>Go 语言中的通道（<code>channel</code>）是用于<strong>协程间通信</strong>的核心工具。它有两种形式：<strong>无缓冲通道</strong> 和 <strong>有缓冲通道</strong>。</p>\n<hr>\n<h2 id=\"🌱-什么是通道（channel）？\"><a href=\"#🌱-什么是通道（channel）？\" class=\"headerlink\" title=\"🌱 什么是通道（channel）？\"></a>🌱 什么是通道（channel）？</h2><p>在 Go 中，通道用于在 goroutine 之间传递数据。它就像一个<strong>传送带</strong>，一个 goroutine 把数据“放上去”，另一个 goroutine 把它“取下来”。</p>\n<hr>\n<h2 id=\"⚙️-无缓冲通道（unbuffered-channel）\"><a href=\"#⚙️-无缓冲通道（unbuffered-channel）\" class=\"headerlink\" title=\"⚙️ 无缓冲通道（unbuffered channel）\"></a>⚙️ 无缓冲通道（unbuffered channel）</h2><h3 id=\"✅-特点：\"><a href=\"#✅-特点：\" class=\"headerlink\" title=\"✅ 特点：\"></a>✅ 特点：</h3><ul>\n<li><strong>发送和接收必须同步进行。</strong></li>\n<li>如果发送时没有接收方在等着，发送就会<strong>阻塞（卡住）</strong>，直到接收方出现。</li>\n<li>更适合用于<strong>协程同步</strong>。</li>\n</ul>\n<h3 id=\"🎯-比喻：\"><a href=\"#🎯-比喻：\" class=\"headerlink\" title=\"🎯 比喻：\"></a>🎯 比喻：</h3><p>像两个人面对面递纸条，递的人不能走，直到接的人把纸条接过去。</p>\n<h3 id=\"🔧-示例代码：\"><a href=\"#🔧-示例代码：\" class=\"headerlink\" title=\"🔧 示例代码：\"></a>🔧 示例代码：</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>) <span class=\"comment\">// 无缓冲通道</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tch &lt;- <span class=\"string\">&quot;hello from goroutine&quot;</span> <span class=\"comment\">// 会阻塞直到 main() 接收</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tmsg := &lt;-ch <span class=\"comment\">// 接收到消息后，上面的发送才完成</span></span><br><span class=\"line\">\tfmt.Println(msg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"⚙️-有缓冲通道（buffered-channel）\"><a href=\"#⚙️-有缓冲通道（buffered-channel）\" class=\"headerlink\" title=\"⚙️ 有缓冲通道（buffered channel）\"></a>⚙️ 有缓冲通道（buffered channel）</h2><h3 id=\"✅-特点：-1\"><a href=\"#✅-特点：-1\" class=\"headerlink\" title=\"✅ 特点：\"></a>✅ 特点：</h3><ul>\n<li>允许<strong>指定缓冲大小</strong>。</li>\n<li>发送操作在缓冲未满时不会阻塞。</li>\n<li>接收操作在缓冲非空时不会阻塞。</li>\n<li>适用于<strong>解耦发送者和接收者速度</strong>不同的场景。</li>\n</ul>\n<h3 id=\"🎯-比喻：-1\"><a href=\"#🎯-比喻：-1\" class=\"headerlink\" title=\"🎯 比喻：\"></a>🎯 比喻：</h3><p>像一个邮箱，有多个格子可以放纸条。你可以先投进去，只要格子没满。</p>\n<h3 id=\"🔧-示例代码：-1\"><a href=\"#🔧-示例代码：-1\" class=\"headerlink\" title=\"🔧 示例代码：\"></a>🔧 示例代码：</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 有缓冲通道，容量为2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tch &lt;- <span class=\"string\">&quot;message 1&quot;</span> <span class=\"comment\">// ✅ 不阻塞</span></span><br><span class=\"line\">\tch &lt;- <span class=\"string\">&quot;message 2&quot;</span> <span class=\"comment\">// ✅ 不阻塞</span></span><br><span class=\"line\">\t<span class=\"comment\">// ch &lt;- &quot;message 3&quot; // ❌ 超出缓冲，会阻塞，除非有接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(&lt;-ch) <span class=\"comment\">// 输出 message 1</span></span><br><span class=\"line\">\tfmt.Println(&lt;-ch) <span class=\"comment\">// 输出 message 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧠-总结对比\"><a href=\"#🧠-总结对比\" class=\"headerlink\" title=\"🧠 总结对比\"></a>🧠 总结对比</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>无缓冲通道</th>\n<th>有缓冲通道</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>阻塞行为</td>\n<td>发送和接收必须同步</td>\n<td>缓冲满才阻塞发送，空才阻塞接收</td>\n</tr>\n<tr>\n<td>是否适合同步</td>\n<td>✅ 是</td>\n<td>❌ 不直接适合</td>\n</tr>\n<tr>\n<td>是否适合解耦速度</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>使用难度</td>\n<td>稍高，容易死锁</td>\n<td>相对灵活，但容易忘记接收</td>\n</tr>\n</tbody></table>\n<hr>\n"},{"title":"go语言之未知结构体反序列化","description":"JSON 解码到map[string]interface{} 来处理动态或未知结构数据的技巧","toc":false,"date":"2025-05-24T02:07:14.000Z","_content":"\n### 📝 技巧：解码 JSON 到 `map[string]interface{}`\n\n**讲解：**\n\n当处理来自外部 API 或其他来源的 JSON 数据时，你可能并不总是事先知道其确切的结构。或者，你可能只对 JSON 数据中的一部分字段感兴趣，而不想为了完整地映射整个 JSON 结构而定义复杂的 Go 结构体。\n\n在这种情况下，你可以将 JSON 数据解码到一个通用的 Go 类型：`map[string]interface{}`。\n\n-   `map[string]interface{}` 是一个键值对的集合，其中键是字符串（对应 JSON 对象的键），值可以是任何类型 (`interface{}`)。这使得你可以灵活地访问 JSON 数据中的各种类型的值（字符串、数字、布尔值、嵌套的对象或数组）。\n\n**使用场景：**\n\n-   处理结构不固定的 JSON 响应。\n-   只需要访问 JSON 数据中的特定字段。\n-   在完全了解 JSON 结构之前探索数据。\n\n**代码示例：**\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// 假设我们收到了以下 JSON 数据，但我们不确定其完整结构\n\tjsonData := []byte(`{\n\t\t\"name\": \"Dynamic Object\",\n\t\t\"version\": 1.0,\n\t\t\"details\": {\n\t\t\t\"author\": \"AI Assistant\",\n\t\t\t\"created_at\": \"2025-05-24T10:00:00Z\"\n\t\t},\n\t\t\"tags\": [\"dynamic\", \"json\", \"go\"]\n\t}`)\n\n\t// 将 JSON 解码到 map[string]interface{}\n\tvar genericData map[string]interface{}\n\terr := json.Unmarshal(jsonData, &genericData)\n\tif err != nil {\n\t\tfmt.Println(\"JSON decoding error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Decoded generic data:\", genericData)\n\n\t// 现在我们可以通过键来访问数据，并进行类型断言\n\tif name, ok := genericData[\"name\"].(string); ok {\n\t\tfmt.Println(\"Name:\", name)\n\t}\n\n\tif version, ok := genericData[\"version\"].(float64); ok {\n\t\tfmt.Println(\"Version:\", version)\n\t}\n\n\tif details, ok := genericData[\"details\"].(map[string]interface{}); ok {\n\t\tif author, ok := details[\"author\"].(string); ok {\n\t\t\tfmt.Println(\"Author:\", author)\n\t\t}\n\t\tif createdAt, ok := details[\"created_at\"].(string); ok {\n\t\t\tfmt.Println(\"Created At:\", createdAt)\n\t\t}\n\t}\n\n\tif tags, ok := genericData[\"tags\"].([]interface{}); ok {\n\t\tfmt.Println(\"Tags:\")\n\t\tfor _, tag := range tags {\n\t\t\tif t, ok := tag.(string); ok {\n\t\t\t\tfmt.Printf(\"- %s\\n\", t)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n**输出：**\n\n```\nDecoded generic data: map[details:map[author:AI Assistant created_at:2025-05-24T10:00:00Z] name:Dynamic Object tags:[dynamic json go] version:1]\nName: Dynamic Object\nVersion: 1\nAuthor: AI Assistant\nCreated At: 2025-05-24T10:00:00Z\nTags:\n- dynamic\n- json\n- go\n```\n\n**总结：**\n\n使用 `json.Unmarshal` 将 JSON 数据解码到 `map[string]interface{}` 提供了一种灵活的方式来处理结构未知的 JSON 数据。你需要通过类型断言来使用 map 中的值。\n\n","source":"_posts/go语言之未知结构体反序列化.md","raw":"---\ntitle: go语言之未知结构体反序列化\ndescription: 'JSON 解码到map[string]interface{} 来处理动态或未知结构数据的技巧'\ntags: []\ntoc: false\ndate: 2025-05-24 10:07:14\ncategories:\n---\n\n### 📝 技巧：解码 JSON 到 `map[string]interface{}`\n\n**讲解：**\n\n当处理来自外部 API 或其他来源的 JSON 数据时，你可能并不总是事先知道其确切的结构。或者，你可能只对 JSON 数据中的一部分字段感兴趣，而不想为了完整地映射整个 JSON 结构而定义复杂的 Go 结构体。\n\n在这种情况下，你可以将 JSON 数据解码到一个通用的 Go 类型：`map[string]interface{}`。\n\n-   `map[string]interface{}` 是一个键值对的集合，其中键是字符串（对应 JSON 对象的键），值可以是任何类型 (`interface{}`)。这使得你可以灵活地访问 JSON 数据中的各种类型的值（字符串、数字、布尔值、嵌套的对象或数组）。\n\n**使用场景：**\n\n-   处理结构不固定的 JSON 响应。\n-   只需要访问 JSON 数据中的特定字段。\n-   在完全了解 JSON 结构之前探索数据。\n\n**代码示例：**\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// 假设我们收到了以下 JSON 数据，但我们不确定其完整结构\n\tjsonData := []byte(`{\n\t\t\"name\": \"Dynamic Object\",\n\t\t\"version\": 1.0,\n\t\t\"details\": {\n\t\t\t\"author\": \"AI Assistant\",\n\t\t\t\"created_at\": \"2025-05-24T10:00:00Z\"\n\t\t},\n\t\t\"tags\": [\"dynamic\", \"json\", \"go\"]\n\t}`)\n\n\t// 将 JSON 解码到 map[string]interface{}\n\tvar genericData map[string]interface{}\n\terr := json.Unmarshal(jsonData, &genericData)\n\tif err != nil {\n\t\tfmt.Println(\"JSON decoding error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Decoded generic data:\", genericData)\n\n\t// 现在我们可以通过键来访问数据，并进行类型断言\n\tif name, ok := genericData[\"name\"].(string); ok {\n\t\tfmt.Println(\"Name:\", name)\n\t}\n\n\tif version, ok := genericData[\"version\"].(float64); ok {\n\t\tfmt.Println(\"Version:\", version)\n\t}\n\n\tif details, ok := genericData[\"details\"].(map[string]interface{}); ok {\n\t\tif author, ok := details[\"author\"].(string); ok {\n\t\t\tfmt.Println(\"Author:\", author)\n\t\t}\n\t\tif createdAt, ok := details[\"created_at\"].(string); ok {\n\t\t\tfmt.Println(\"Created At:\", createdAt)\n\t\t}\n\t}\n\n\tif tags, ok := genericData[\"tags\"].([]interface{}); ok {\n\t\tfmt.Println(\"Tags:\")\n\t\tfor _, tag := range tags {\n\t\t\tif t, ok := tag.(string); ok {\n\t\t\t\tfmt.Printf(\"- %s\\n\", t)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n**输出：**\n\n```\nDecoded generic data: map[details:map[author:AI Assistant created_at:2025-05-24T10:00:00Z] name:Dynamic Object tags:[dynamic json go] version:1]\nName: Dynamic Object\nVersion: 1\nAuthor: AI Assistant\nCreated At: 2025-05-24T10:00:00Z\nTags:\n- dynamic\n- json\n- go\n```\n\n**总结：**\n\n使用 `json.Unmarshal` 将 JSON 数据解码到 `map[string]interface{}` 提供了一种灵活的方式来处理结构未知的 JSON 数据。你需要通过类型断言来使用 map 中的值。\n\n","slug":"go语言之未知结构体反序列化","published":1,"updated":"2025-05-24T02:08:17.205Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxe000ehkvoc8f2ch2z","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"📝-技巧：解码-JSON-到-map-string-interface\"><a href=\"#📝-技巧：解码-JSON-到-map-string-interface\" class=\"headerlink\" title=\"📝 技巧：解码 JSON 到 map[string]interface{}\"></a>📝 技巧：解码 JSON 到 <code>map[string]interface&#123;&#125;</code></h3><p><strong>讲解：</strong></p>\n<p>当处理来自外部 API 或其他来源的 JSON 数据时，你可能并不总是事先知道其确切的结构。或者，你可能只对 JSON 数据中的一部分字段感兴趣，而不想为了完整地映射整个 JSON 结构而定义复杂的 Go 结构体。</p>\n<p>在这种情况下，你可以将 JSON 数据解码到一个通用的 Go 类型：<code>map[string]interface&#123;&#125;</code>。</p>\n<ul>\n<li><code>map[string]interface&#123;&#125;</code> 是一个键值对的集合，其中键是字符串（对应 JSON 对象的键），值可以是任何类型 (<code>interface&#123;&#125;</code>)。这使得你可以灵活地访问 JSON 数据中的各种类型的值（字符串、数字、布尔值、嵌套的对象或数组）。</li>\n</ul>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>处理结构不固定的 JSON 响应。</li>\n<li>只需要访问 JSON 数据中的特定字段。</li>\n<li>在完全了解 JSON 结构之前探索数据。</li>\n</ul>\n<p><strong>代码示例：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 假设我们收到了以下 JSON 数据，但我们不确定其完整结构</span></span><br><span class=\"line\">\tjsonData := []<span class=\"type\">byte</span>(<span class=\"string\">`&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;name&quot;: &quot;Dynamic Object&quot;,</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;version&quot;: 1.0,</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;details&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&quot;author&quot;: &quot;AI Assistant&quot;,</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&quot;created_at&quot;: &quot;2025-05-24T10:00:00Z&quot;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;,</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;tags&quot;: [&quot;dynamic&quot;, &quot;json&quot;, &quot;go&quot;]</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将 JSON 解码到 map[string]interface&#123;&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> genericData <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\terr := json.Unmarshal(jsonData, &amp;genericData)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;JSON decoding error:&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Decoded generic data:&quot;</span>, genericData)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 现在我们可以通过键来访问数据，并进行类型断言</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> name, ok := genericData[<span class=\"string\">&quot;name&quot;</span>].(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Name:&quot;</span>, name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> version, ok := genericData[<span class=\"string\">&quot;version&quot;</span>].(<span class=\"type\">float64</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Version:&quot;</span>, version)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> details, ok := genericData[<span class=\"string\">&quot;details&quot;</span>].(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;); ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> author, ok := details[<span class=\"string\">&quot;author&quot;</span>].(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;Author:&quot;</span>, author)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> createdAt, ok := details[<span class=\"string\">&quot;created_at&quot;</span>].(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;Created At:&quot;</span>, createdAt)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> tags, ok := genericData[<span class=\"string\">&quot;tags&quot;</span>].([]<span class=\"keyword\">interface</span>&#123;&#125;); ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Tags:&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, tag := <span class=\"keyword\">range</span> tags &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> t, ok := tag.(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">&quot;- %s\\n&quot;</span>, t)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Decoded generic data: map[details:map[author:AI Assistant created_at:2025-05-24T10:00:00Z] name:Dynamic Object tags:[dynamic json go] version:1]</span><br><span class=\"line\">Name: Dynamic Object</span><br><span class=\"line\">Version: 1</span><br><span class=\"line\">Author: AI Assistant</span><br><span class=\"line\">Created At: 2025-05-24T10:00:00Z</span><br><span class=\"line\">Tags:</span><br><span class=\"line\">- dynamic</span><br><span class=\"line\">- json</span><br><span class=\"line\">- go</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>使用 <code>json.Unmarshal</code> 将 JSON 数据解码到 <code>map[string]interface&#123;&#125;</code> 提供了一种灵活的方式来处理结构未知的 JSON 数据。你需要通过类型断言来使用 map 中的值。</p>\n","excerpt":"","more":"<h3 id=\"📝-技巧：解码-JSON-到-map-string-interface\"><a href=\"#📝-技巧：解码-JSON-到-map-string-interface\" class=\"headerlink\" title=\"📝 技巧：解码 JSON 到 map[string]interface{}\"></a>📝 技巧：解码 JSON 到 <code>map[string]interface&#123;&#125;</code></h3><p><strong>讲解：</strong></p>\n<p>当处理来自外部 API 或其他来源的 JSON 数据时，你可能并不总是事先知道其确切的结构。或者，你可能只对 JSON 数据中的一部分字段感兴趣，而不想为了完整地映射整个 JSON 结构而定义复杂的 Go 结构体。</p>\n<p>在这种情况下，你可以将 JSON 数据解码到一个通用的 Go 类型：<code>map[string]interface&#123;&#125;</code>。</p>\n<ul>\n<li><code>map[string]interface&#123;&#125;</code> 是一个键值对的集合，其中键是字符串（对应 JSON 对象的键），值可以是任何类型 (<code>interface&#123;&#125;</code>)。这使得你可以灵活地访问 JSON 数据中的各种类型的值（字符串、数字、布尔值、嵌套的对象或数组）。</li>\n</ul>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>处理结构不固定的 JSON 响应。</li>\n<li>只需要访问 JSON 数据中的特定字段。</li>\n<li>在完全了解 JSON 结构之前探索数据。</li>\n</ul>\n<p><strong>代码示例：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 假设我们收到了以下 JSON 数据，但我们不确定其完整结构</span></span><br><span class=\"line\">\tjsonData := []<span class=\"type\">byte</span>(<span class=\"string\">`&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;name&quot;: &quot;Dynamic Object&quot;,</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;version&quot;: 1.0,</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;details&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&quot;author&quot;: &quot;AI Assistant&quot;,</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&quot;created_at&quot;: &quot;2025-05-24T10:00:00Z&quot;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;,</span></span><br><span class=\"line\"><span class=\"string\">\t\t&quot;tags&quot;: [&quot;dynamic&quot;, &quot;json&quot;, &quot;go&quot;]</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将 JSON 解码到 map[string]interface&#123;&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> genericData <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\terr := json.Unmarshal(jsonData, &amp;genericData)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;JSON decoding error:&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Decoded generic data:&quot;</span>, genericData)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 现在我们可以通过键来访问数据，并进行类型断言</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> name, ok := genericData[<span class=\"string\">&quot;name&quot;</span>].(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Name:&quot;</span>, name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> version, ok := genericData[<span class=\"string\">&quot;version&quot;</span>].(<span class=\"type\">float64</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Version:&quot;</span>, version)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> details, ok := genericData[<span class=\"string\">&quot;details&quot;</span>].(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;); ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> author, ok := details[<span class=\"string\">&quot;author&quot;</span>].(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;Author:&quot;</span>, author)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> createdAt, ok := details[<span class=\"string\">&quot;created_at&quot;</span>].(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;Created At:&quot;</span>, createdAt)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> tags, ok := genericData[<span class=\"string\">&quot;tags&quot;</span>].([]<span class=\"keyword\">interface</span>&#123;&#125;); ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Tags:&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, tag := <span class=\"keyword\">range</span> tags &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> t, ok := tag.(<span class=\"type\">string</span>); ok &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">&quot;- %s\\n&quot;</span>, t)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Decoded generic data: map[details:map[author:AI Assistant created_at:2025-05-24T10:00:00Z] name:Dynamic Object tags:[dynamic json go] version:1]</span><br><span class=\"line\">Name: Dynamic Object</span><br><span class=\"line\">Version: 1</span><br><span class=\"line\">Author: AI Assistant</span><br><span class=\"line\">Created At: 2025-05-24T10:00:00Z</span><br><span class=\"line\">Tags:</span><br><span class=\"line\">- dynamic</span><br><span class=\"line\">- json</span><br><span class=\"line\">- go</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>使用 <code>json.Unmarshal</code> 将 JSON 数据解码到 <code>map[string]interface&#123;&#125;</code> 提供了一种灵活的方式来处理结构未知的 JSON 数据。你需要通过类型断言来使用 map 中的值。</p>\n"},{"title":"go语言之枚举","description":"为什么 Go 没有 enum？","toc":false,"date":"2025-05-13T08:25:43.000Z","_content":"\n---\n\n# 📘 Go 语言中的枚举\n\n---\n\n## 🔸 1. 为什么 Go 没有 enum？\n\nGo 的设计哲学之一是 **“少即是多（Less is more）”**。它刻意避免加入 C/C++ 或 Java 风格的 `enum` 语法，而鼓励开发者通过现有机制构建自己的“枚举”，使语言更简洁。\n\n---\n\n## 🔸 2. 使用 `const + iota` 自定义类型模拟枚举\n\n### ✅ 示例：订单状态（OrderStatus）\n\n```go\n// 自定义一个新类型\ntype OrderStatus int\n\n// 声明常量并用 iota 自动编号\nconst (\n\tPending OrderStatus = iota\n\tProcessing\n\tShipped\n\tDelivered\n\tCancelled\n)\n```\n\n此时你定义了一个类型 `OrderStatus`，并赋值了几个状态枚举。使用时：\n\n```go\nvar s OrderStatus = Shipped\nfmt.Println(\"Order status:\", s) // 输出：Order status: 2（不直观）\n```\n\n---\n\n## 🔸 3. 让枚举可读：添加 `String()` 方法\n\n要让输出更清晰（而不是数字），实现 `fmt.Stringer` 接口：\n\n```go\nfunc (s OrderStatus) String() string {\n\tswitch s {\n\tcase Pending:\n\t\treturn \"Pending\"\n\tcase Processing:\n\t\treturn \"Processing\"\n\tcase Shipped:\n\t\treturn \"Shipped\"\n\tcase Delivered:\n\t\treturn \"Delivered\"\n\tcase Cancelled:\n\t\treturn \"Cancelled\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n```\n\n现在输出变成：\n\n```go\nfmt.Println(\"Order status:\", s) // 输出：Order status: Shipped\n```\n\n---\n\n## 🔸 4. 提高开发效率：使用 `stringer` 工具自动生成\n\nGo 提供了官方工具 [`stringer`](https://pkg.go.dev/golang.org/x/tools/cmd/stringer) 来自动生成 `String()` 方法。\n\n### ✅ 步骤：\n\n1. 安装：\n\n   ```sh\n   go install golang.org/x/tools/cmd/stringer@latest\n   ```\n\n2. 在代码顶部加注释：\n\n   ```go\n   //go:generate stringer -type=OrderStatus\n   ```\n\n3. 执行：\n\n   ```sh\n   go generate\n   ```\n\n4. 它会生成一个 `orderstatus_string.go` 文件，自动添加 `String()` 方法！\n\n---\n\n## 🔸 5. 在实际开发中的典型应用场景\n\n| 枚举类型   | 场景举例                               |\n| ------ | ---------------------------------- |\n| 用户角色   | Admin, Moderator, User             |\n| 支付方式   | WeChat, Alipay, CreditCard         |\n| 网络协议类型 | HTTP, HTTPS, FTP                   |\n| 日志级别   | Debug, Info, Warn, Error           |\n| 服务状态   | Starting, Running, Stopped, Failed |\n\n示例代码（支付方式）：\n\n```go\ntype PaymentMethod int\n\nconst (\n\tAlipay PaymentMethod = iota\n\tWeChat\n\tCreditCard\n)\n\nfunc (p PaymentMethod) String() string {\n\tswitch p {\n\tcase Alipay:\n\t\treturn \"Alipay\"\n\tcase WeChat:\n\t\treturn \"WeChat\"\n\tcase CreditCard:\n\t\treturn \"CreditCard\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n```\n\n用法：\n\n```go\npay := WeChat\nfmt.Println(\"Chosen method:\", pay) // 输出：Chosen method: WeChat\n```\n\n---\n\n## 🔸 6. 枚举类型优势总结\n\n| 特性          | 使用枚举自定义类型的好处               |\n| ----------- | -------------------------- |\n| 类型安全        | 不会误传其他类型，编译时检查             |\n| 可读性高        | 使用名称而非数字，便于维护和调试           |\n| 易于扩展        | 可以集中管理、统一处理                |\n| 支持 `switch` | 可用于 `switch case` 表达逻辑分支处理 |\n| 与接口搭配灵活使用   | 可以与接口模式组合形成更复杂的业务逻辑        |\n\n---\n\n## 🔸 7. 一个完整小案例：订单状态切换器\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype OrderStatus int\n\nconst (\n\tPending OrderStatus = iota\n\tConfirmed\n\tShipped\n\tDelivered\n)\n\nfunc (s OrderStatus) String() string {\n\tswitch s {\n\tcase Pending:\n\t\treturn \"Pending\"\n\tcase Confirmed:\n\t\treturn \"Confirmed\"\n\tcase Shipped:\n\t\treturn \"Shipped\"\n\tcase Delivered:\n\t\treturn \"Delivered\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n\nfunc nextStatus(s OrderStatus) OrderStatus {\n\tswitch s {\n\tcase Pending:\n\t\treturn Confirmed\n\tcase Confirmed:\n\t\treturn Shipped\n\tcase Shipped:\n\t\treturn Delivered\n\tdefault:\n\t\treturn s\n\t}\n}\n\nfunc main() {\n\tstatus := Pending\n\tfor i := 0; i < 4; i++ {\n\t\tfmt.Println(\"Current status:\", status)\n\t\tstatus = nextStatus(status)\n\t}\n}\n```\n\n**输出：**\n\n```\nCurrent status: Pending\nCurrent status: Confirmed\nCurrent status: Shipped\nCurrent status: Delivered\n```\n\n---\n\n## ✅ 总结\n\n* Go 没有内置枚举语法，但我们可以用 `const + type + iota` 灵活模拟。\n* 枚举用得非常广泛，尤其是在：\n\n  * 状态管理\n  * 类型控制\n  * 协议识别\n  * 日志处理 等场景\n* 可以手写 `String()` 方法提高可读性，或用 `stringer` 工具自动生成。\n\n---\n\n","source":"_posts/go语言之枚举.md","raw":"---\ntitle: go语言之枚举\ndescription: '为什么 Go 没有 enum？'\ntags: ['go']\ntoc: false\ndate: 2025-05-13 16:25:43\ncategories:\n    - go\n    - basic\n---\n\n---\n\n# 📘 Go 语言中的枚举\n\n---\n\n## 🔸 1. 为什么 Go 没有 enum？\n\nGo 的设计哲学之一是 **“少即是多（Less is more）”**。它刻意避免加入 C/C++ 或 Java 风格的 `enum` 语法，而鼓励开发者通过现有机制构建自己的“枚举”，使语言更简洁。\n\n---\n\n## 🔸 2. 使用 `const + iota` 自定义类型模拟枚举\n\n### ✅ 示例：订单状态（OrderStatus）\n\n```go\n// 自定义一个新类型\ntype OrderStatus int\n\n// 声明常量并用 iota 自动编号\nconst (\n\tPending OrderStatus = iota\n\tProcessing\n\tShipped\n\tDelivered\n\tCancelled\n)\n```\n\n此时你定义了一个类型 `OrderStatus`，并赋值了几个状态枚举。使用时：\n\n```go\nvar s OrderStatus = Shipped\nfmt.Println(\"Order status:\", s) // 输出：Order status: 2（不直观）\n```\n\n---\n\n## 🔸 3. 让枚举可读：添加 `String()` 方法\n\n要让输出更清晰（而不是数字），实现 `fmt.Stringer` 接口：\n\n```go\nfunc (s OrderStatus) String() string {\n\tswitch s {\n\tcase Pending:\n\t\treturn \"Pending\"\n\tcase Processing:\n\t\treturn \"Processing\"\n\tcase Shipped:\n\t\treturn \"Shipped\"\n\tcase Delivered:\n\t\treturn \"Delivered\"\n\tcase Cancelled:\n\t\treturn \"Cancelled\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n```\n\n现在输出变成：\n\n```go\nfmt.Println(\"Order status:\", s) // 输出：Order status: Shipped\n```\n\n---\n\n## 🔸 4. 提高开发效率：使用 `stringer` 工具自动生成\n\nGo 提供了官方工具 [`stringer`](https://pkg.go.dev/golang.org/x/tools/cmd/stringer) 来自动生成 `String()` 方法。\n\n### ✅ 步骤：\n\n1. 安装：\n\n   ```sh\n   go install golang.org/x/tools/cmd/stringer@latest\n   ```\n\n2. 在代码顶部加注释：\n\n   ```go\n   //go:generate stringer -type=OrderStatus\n   ```\n\n3. 执行：\n\n   ```sh\n   go generate\n   ```\n\n4. 它会生成一个 `orderstatus_string.go` 文件，自动添加 `String()` 方法！\n\n---\n\n## 🔸 5. 在实际开发中的典型应用场景\n\n| 枚举类型   | 场景举例                               |\n| ------ | ---------------------------------- |\n| 用户角色   | Admin, Moderator, User             |\n| 支付方式   | WeChat, Alipay, CreditCard         |\n| 网络协议类型 | HTTP, HTTPS, FTP                   |\n| 日志级别   | Debug, Info, Warn, Error           |\n| 服务状态   | Starting, Running, Stopped, Failed |\n\n示例代码（支付方式）：\n\n```go\ntype PaymentMethod int\n\nconst (\n\tAlipay PaymentMethod = iota\n\tWeChat\n\tCreditCard\n)\n\nfunc (p PaymentMethod) String() string {\n\tswitch p {\n\tcase Alipay:\n\t\treturn \"Alipay\"\n\tcase WeChat:\n\t\treturn \"WeChat\"\n\tcase CreditCard:\n\t\treturn \"CreditCard\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n```\n\n用法：\n\n```go\npay := WeChat\nfmt.Println(\"Chosen method:\", pay) // 输出：Chosen method: WeChat\n```\n\n---\n\n## 🔸 6. 枚举类型优势总结\n\n| 特性          | 使用枚举自定义类型的好处               |\n| ----------- | -------------------------- |\n| 类型安全        | 不会误传其他类型，编译时检查             |\n| 可读性高        | 使用名称而非数字，便于维护和调试           |\n| 易于扩展        | 可以集中管理、统一处理                |\n| 支持 `switch` | 可用于 `switch case` 表达逻辑分支处理 |\n| 与接口搭配灵活使用   | 可以与接口模式组合形成更复杂的业务逻辑        |\n\n---\n\n## 🔸 7. 一个完整小案例：订单状态切换器\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype OrderStatus int\n\nconst (\n\tPending OrderStatus = iota\n\tConfirmed\n\tShipped\n\tDelivered\n)\n\nfunc (s OrderStatus) String() string {\n\tswitch s {\n\tcase Pending:\n\t\treturn \"Pending\"\n\tcase Confirmed:\n\t\treturn \"Confirmed\"\n\tcase Shipped:\n\t\treturn \"Shipped\"\n\tcase Delivered:\n\t\treturn \"Delivered\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n\nfunc nextStatus(s OrderStatus) OrderStatus {\n\tswitch s {\n\tcase Pending:\n\t\treturn Confirmed\n\tcase Confirmed:\n\t\treturn Shipped\n\tcase Shipped:\n\t\treturn Delivered\n\tdefault:\n\t\treturn s\n\t}\n}\n\nfunc main() {\n\tstatus := Pending\n\tfor i := 0; i < 4; i++ {\n\t\tfmt.Println(\"Current status:\", status)\n\t\tstatus = nextStatus(status)\n\t}\n}\n```\n\n**输出：**\n\n```\nCurrent status: Pending\nCurrent status: Confirmed\nCurrent status: Shipped\nCurrent status: Delivered\n```\n\n---\n\n## ✅ 总结\n\n* Go 没有内置枚举语法，但我们可以用 `const + type + iota` 灵活模拟。\n* 枚举用得非常广泛，尤其是在：\n\n  * 状态管理\n  * 类型控制\n  * 协议识别\n  * 日志处理 等场景\n* 可以手写 `String()` 方法提高可读性，或用 `stringer` 工具自动生成。\n\n---\n\n","slug":"go语言之枚举","published":1,"updated":"2025-05-23T06:25:44.894Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxe000hhkvoh4aybwc0","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><hr>\n<h1 id=\"📘-Go-语言中的枚举\"><a href=\"#📘-Go-语言中的枚举\" class=\"headerlink\" title=\"📘 Go 语言中的枚举\"></a>📘 Go 语言中的枚举</h1><hr>\n<h2 id=\"🔸-1-为什么-Go-没有-enum？\"><a href=\"#🔸-1-为什么-Go-没有-enum？\" class=\"headerlink\" title=\"🔸 1. 为什么 Go 没有 enum？\"></a>🔸 1. 为什么 Go 没有 enum？</h2><p>Go 的设计哲学之一是 <strong>“少即是多（Less is more）”</strong>。它刻意避免加入 C&#x2F;C++ 或 Java 风格的 <code>enum</code> 语法，而鼓励开发者通过现有机制构建自己的“枚举”，使语言更简洁。</p>\n<hr>\n<h2 id=\"🔸-2-使用-const-iota-自定义类型模拟枚举\"><a href=\"#🔸-2-使用-const-iota-自定义类型模拟枚举\" class=\"headerlink\" title=\"🔸 2. 使用 const + iota 自定义类型模拟枚举\"></a>🔸 2. 使用 <code>const + iota</code> 自定义类型模拟枚举</h2><h3 id=\"✅-示例：订单状态（OrderStatus）\"><a href=\"#✅-示例：订单状态（OrderStatus）\" class=\"headerlink\" title=\"✅ 示例：订单状态（OrderStatus）\"></a>✅ 示例：订单状态（OrderStatus）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义一个新类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> OrderStatus <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明常量并用 iota 自动编号</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tPending OrderStatus = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tProcessing</span><br><span class=\"line\">\tShipped</span><br><span class=\"line\">\tDelivered</span><br><span class=\"line\">\tCancelled</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>此时你定义了一个类型 <code>OrderStatus</code>，并赋值了几个状态枚举。使用时：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s OrderStatus = Shipped</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Order status:&quot;</span>, s) <span class=\"comment\">// 输出：Order status: 2（不直观）</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔸-3-让枚举可读：添加-String-方法\"><a href=\"#🔸-3-让枚举可读：添加-String-方法\" class=\"headerlink\" title=\"🔸 3. 让枚举可读：添加 String() 方法\"></a>🔸 3. 让枚举可读：添加 <code>String()</code> 方法</h2><p>要让输出更清晰（而不是数字），实现 <code>fmt.Stringer</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s OrderStatus)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> s &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Pending:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Pending&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Processing:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Processing&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Shipped:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Shipped&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Delivered:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Delivered&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Cancelled:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Cancelled&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在输出变成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Order status:&quot;</span>, s) <span class=\"comment\">// 输出：Order status: Shipped</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔸-4-提高开发效率：使用-stringer-工具自动生成\"><a href=\"#🔸-4-提高开发效率：使用-stringer-工具自动生成\" class=\"headerlink\" title=\"🔸 4. 提高开发效率：使用 stringer 工具自动生成\"></a>🔸 4. 提高开发效率：使用 <code>stringer</code> 工具自动生成</h2><p>Go 提供了官方工具 <a href=\"https://pkg.go.dev/golang.org/x/tools/cmd/stringer\"><code>stringer</code></a> 来自动生成 <code>String()</code> 方法。</p>\n<h3 id=\"✅-步骤：\"><a href=\"#✅-步骤：\" class=\"headerlink\" title=\"✅ 步骤：\"></a>✅ 步骤：</h3><ol>\n<li><p>安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install golang.org/x/tools/cmd/stringer@latest</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在代码顶部加注释：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:generate stringer -type=OrderStatus</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go generate</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>它会生成一个 <code>orderstatus_string.go</code> 文件，自动添加 <code>String()</code> 方法！</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"🔸-5-在实际开发中的典型应用场景\"><a href=\"#🔸-5-在实际开发中的典型应用场景\" class=\"headerlink\" title=\"🔸 5. 在实际开发中的典型应用场景\"></a>🔸 5. 在实际开发中的典型应用场景</h2><table>\n<thead>\n<tr>\n<th>枚举类型</th>\n<th>场景举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>用户角色</td>\n<td>Admin, Moderator, User</td>\n</tr>\n<tr>\n<td>支付方式</td>\n<td>WeChat, Alipay, CreditCard</td>\n</tr>\n<tr>\n<td>网络协议类型</td>\n<td>HTTP, HTTPS, FTP</td>\n</tr>\n<tr>\n<td>日志级别</td>\n<td>Debug, Info, Warn, Error</td>\n</tr>\n<tr>\n<td>服务状态</td>\n<td>Starting, Running, Stopped, Failed</td>\n</tr>\n</tbody></table>\n<p>示例代码（支付方式）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PaymentMethod <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tAlipay PaymentMethod = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tWeChat</span><br><span class=\"line\">\tCreditCard</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p PaymentMethod)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> p &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Alipay:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Alipay&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> WeChat:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;WeChat&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> CreditCard:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;CreditCard&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pay := WeChat</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Chosen method:&quot;</span>, pay) <span class=\"comment\">// 输出：Chosen method: WeChat</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔸-6-枚举类型优势总结\"><a href=\"#🔸-6-枚举类型优势总结\" class=\"headerlink\" title=\"🔸 6. 枚举类型优势总结\"></a>🔸 6. 枚举类型优势总结</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>使用枚举自定义类型的好处</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类型安全</td>\n<td>不会误传其他类型，编译时检查</td>\n</tr>\n<tr>\n<td>可读性高</td>\n<td>使用名称而非数字，便于维护和调试</td>\n</tr>\n<tr>\n<td>易于扩展</td>\n<td>可以集中管理、统一处理</td>\n</tr>\n<tr>\n<td>支持 <code>switch</code></td>\n<td>可用于 <code>switch case</code> 表达逻辑分支处理</td>\n</tr>\n<tr>\n<td>与接口搭配灵活使用</td>\n<td>可以与接口模式组合形成更复杂的业务逻辑</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔸-7-一个完整小案例：订单状态切换器\"><a href=\"#🔸-7-一个完整小案例：订单状态切换器\" class=\"headerlink\" title=\"🔸 7. 一个完整小案例：订单状态切换器\"></a>🔸 7. 一个完整小案例：订单状态切换器</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> OrderStatus <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tPending OrderStatus = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tConfirmed</span><br><span class=\"line\">\tShipped</span><br><span class=\"line\">\tDelivered</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s OrderStatus)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> s &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Pending:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Pending&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Confirmed:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Confirmed&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Shipped:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Shipped&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Delivered:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Delivered&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nextStatus</span><span class=\"params\">(s OrderStatus)</span></span> OrderStatus &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> s &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Pending:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Confirmed</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Confirmed:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Shipped</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Shipped:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Delivered</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tstatus := Pending</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++ &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Current status:&quot;</span>, status)</span><br><span class=\"line\">\t\tstatus = nextStatus(status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Current status: Pending</span><br><span class=\"line\">Current status: Confirmed</span><br><span class=\"line\">Current status: Shipped</span><br><span class=\"line\">Current status: Delivered</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><ul>\n<li><p>Go 没有内置枚举语法，但我们可以用 <code>const + type + iota</code> 灵活模拟。</p>\n</li>\n<li><p>枚举用得非常广泛，尤其是在：</p>\n<ul>\n<li>状态管理</li>\n<li>类型控制</li>\n<li>协议识别</li>\n<li>日志处理 等场景</li>\n</ul>\n</li>\n<li><p>可以手写 <code>String()</code> 方法提高可读性，或用 <code>stringer</code> 工具自动生成。</p>\n</li>\n</ul>\n<hr>\n","excerpt":"","more":"<hr>\n<h1 id=\"📘-Go-语言中的枚举\"><a href=\"#📘-Go-语言中的枚举\" class=\"headerlink\" title=\"📘 Go 语言中的枚举\"></a>📘 Go 语言中的枚举</h1><hr>\n<h2 id=\"🔸-1-为什么-Go-没有-enum？\"><a href=\"#🔸-1-为什么-Go-没有-enum？\" class=\"headerlink\" title=\"🔸 1. 为什么 Go 没有 enum？\"></a>🔸 1. 为什么 Go 没有 enum？</h2><p>Go 的设计哲学之一是 <strong>“少即是多（Less is more）”</strong>。它刻意避免加入 C&#x2F;C++ 或 Java 风格的 <code>enum</code> 语法，而鼓励开发者通过现有机制构建自己的“枚举”，使语言更简洁。</p>\n<hr>\n<h2 id=\"🔸-2-使用-const-iota-自定义类型模拟枚举\"><a href=\"#🔸-2-使用-const-iota-自定义类型模拟枚举\" class=\"headerlink\" title=\"🔸 2. 使用 const + iota 自定义类型模拟枚举\"></a>🔸 2. 使用 <code>const + iota</code> 自定义类型模拟枚举</h2><h3 id=\"✅-示例：订单状态（OrderStatus）\"><a href=\"#✅-示例：订单状态（OrderStatus）\" class=\"headerlink\" title=\"✅ 示例：订单状态（OrderStatus）\"></a>✅ 示例：订单状态（OrderStatus）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义一个新类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> OrderStatus <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明常量并用 iota 自动编号</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tPending OrderStatus = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tProcessing</span><br><span class=\"line\">\tShipped</span><br><span class=\"line\">\tDelivered</span><br><span class=\"line\">\tCancelled</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>此时你定义了一个类型 <code>OrderStatus</code>，并赋值了几个状态枚举。使用时：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s OrderStatus = Shipped</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Order status:&quot;</span>, s) <span class=\"comment\">// 输出：Order status: 2（不直观）</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔸-3-让枚举可读：添加-String-方法\"><a href=\"#🔸-3-让枚举可读：添加-String-方法\" class=\"headerlink\" title=\"🔸 3. 让枚举可读：添加 String() 方法\"></a>🔸 3. 让枚举可读：添加 <code>String()</code> 方法</h2><p>要让输出更清晰（而不是数字），实现 <code>fmt.Stringer</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s OrderStatus)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> s &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Pending:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Pending&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Processing:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Processing&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Shipped:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Shipped&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Delivered:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Delivered&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Cancelled:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Cancelled&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在输出变成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Order status:&quot;</span>, s) <span class=\"comment\">// 输出：Order status: Shipped</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔸-4-提高开发效率：使用-stringer-工具自动生成\"><a href=\"#🔸-4-提高开发效率：使用-stringer-工具自动生成\" class=\"headerlink\" title=\"🔸 4. 提高开发效率：使用 stringer 工具自动生成\"></a>🔸 4. 提高开发效率：使用 <code>stringer</code> 工具自动生成</h2><p>Go 提供了官方工具 <a href=\"https://pkg.go.dev/golang.org/x/tools/cmd/stringer\"><code>stringer</code></a> 来自动生成 <code>String()</code> 方法。</p>\n<h3 id=\"✅-步骤：\"><a href=\"#✅-步骤：\" class=\"headerlink\" title=\"✅ 步骤：\"></a>✅ 步骤：</h3><ol>\n<li><p>安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install golang.org/x/tools/cmd/stringer@latest</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在代码顶部加注释：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:generate stringer -type=OrderStatus</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go generate</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>它会生成一个 <code>orderstatus_string.go</code> 文件，自动添加 <code>String()</code> 方法！</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"🔸-5-在实际开发中的典型应用场景\"><a href=\"#🔸-5-在实际开发中的典型应用场景\" class=\"headerlink\" title=\"🔸 5. 在实际开发中的典型应用场景\"></a>🔸 5. 在实际开发中的典型应用场景</h2><table>\n<thead>\n<tr>\n<th>枚举类型</th>\n<th>场景举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>用户角色</td>\n<td>Admin, Moderator, User</td>\n</tr>\n<tr>\n<td>支付方式</td>\n<td>WeChat, Alipay, CreditCard</td>\n</tr>\n<tr>\n<td>网络协议类型</td>\n<td>HTTP, HTTPS, FTP</td>\n</tr>\n<tr>\n<td>日志级别</td>\n<td>Debug, Info, Warn, Error</td>\n</tr>\n<tr>\n<td>服务状态</td>\n<td>Starting, Running, Stopped, Failed</td>\n</tr>\n</tbody></table>\n<p>示例代码（支付方式）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PaymentMethod <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tAlipay PaymentMethod = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tWeChat</span><br><span class=\"line\">\tCreditCard</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p PaymentMethod)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> p &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Alipay:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Alipay&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> WeChat:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;WeChat&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> CreditCard:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;CreditCard&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pay := WeChat</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Chosen method:&quot;</span>, pay) <span class=\"comment\">// 输出：Chosen method: WeChat</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔸-6-枚举类型优势总结\"><a href=\"#🔸-6-枚举类型优势总结\" class=\"headerlink\" title=\"🔸 6. 枚举类型优势总结\"></a>🔸 6. 枚举类型优势总结</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>使用枚举自定义类型的好处</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类型安全</td>\n<td>不会误传其他类型，编译时检查</td>\n</tr>\n<tr>\n<td>可读性高</td>\n<td>使用名称而非数字，便于维护和调试</td>\n</tr>\n<tr>\n<td>易于扩展</td>\n<td>可以集中管理、统一处理</td>\n</tr>\n<tr>\n<td>支持 <code>switch</code></td>\n<td>可用于 <code>switch case</code> 表达逻辑分支处理</td>\n</tr>\n<tr>\n<td>与接口搭配灵活使用</td>\n<td>可以与接口模式组合形成更复杂的业务逻辑</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔸-7-一个完整小案例：订单状态切换器\"><a href=\"#🔸-7-一个完整小案例：订单状态切换器\" class=\"headerlink\" title=\"🔸 7. 一个完整小案例：订单状态切换器\"></a>🔸 7. 一个完整小案例：订单状态切换器</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> OrderStatus <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tPending OrderStatus = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tConfirmed</span><br><span class=\"line\">\tShipped</span><br><span class=\"line\">\tDelivered</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s OrderStatus)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> s &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Pending:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Pending&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Confirmed:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Confirmed&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Shipped:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Shipped&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Delivered:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Delivered&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nextStatus</span><span class=\"params\">(s OrderStatus)</span></span> OrderStatus &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> s &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Pending:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Confirmed</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Confirmed:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Shipped</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Shipped:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Delivered</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tstatus := Pending</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++ &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Current status:&quot;</span>, status)</span><br><span class=\"line\">\t\tstatus = nextStatus(status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Current status: Pending</span><br><span class=\"line\">Current status: Confirmed</span><br><span class=\"line\">Current status: Shipped</span><br><span class=\"line\">Current status: Delivered</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><ul>\n<li><p>Go 没有内置枚举语法，但我们可以用 <code>const + type + iota</code> 灵活模拟。</p>\n</li>\n<li><p>枚举用得非常广泛，尤其是在：</p>\n<ul>\n<li>状态管理</li>\n<li>类型控制</li>\n<li>协议识别</li>\n<li>日志处理 等场景</li>\n</ul>\n</li>\n<li><p>可以手写 <code>String()</code> 方法提高可读性，或用 <code>stringer</code> 工具自动生成。</p>\n</li>\n</ul>\n<hr>\n"},{"title":"go语言之错误处理","description":"Go 不使用异常机制（try-catch），而是通过返回错误值来显式地处理错误","toc":false,"date":"2025-05-15T01:47:12.000Z","_content":"\n# Go语言中的错误处理详解\n\nGo 语言的错误处理机制与许多其他语言有所不同。Go 不使用异常机制（`try-catch`），而是通过返回错误值来显式地处理错误。虽然这种方式比异常机制更加简洁和明确，但它也带来了更多的冗长和细节。\n\n## 📌 一、Go 错误处理的基本方式\n\nGo 语言的错误通常是通过 `error` 接口来表示的。`error` 接口本身非常简单：\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n任何实现了 `Error()` 方法的类型，都可以作为 `error` 类型使用。\n\n### 返回错误\n\nGo 中大多数函数会返回一个 `error` 类型的值来表示执行过程中可能出现的错误。典型的错误处理模式如下：\n\n```go\nfunc someFunction() (string, error) {\n    // 返回数据和错误\n    return \"\", fmt.Errorf(\"something went wrong\")\n}\n```\n\n调用时，可以通过检查返回的 `error` 值来判断是否发生错误：\n\n```go\nresult, err := someFunction()\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Println(\"Success:\", result)\n```\n\n## 📌 二、创建和包装错误\n\nGo 提供了标准库中的 `errors` 包来创建简单的错误，也提供了 `fmt.Errorf` 来包装错误并增加上下文信息。\n\n### 1. 使用 `errors.New` 创建简单错误\n\n```go\nimport \"errors\"\n\nvar ErrNotFound = errors.New(\"resource not found\")\n```\n\n### 2. 使用 `fmt.Errorf` 包装错误\n\n```go\nreturn fmt.Errorf(\"failed to load config file: %w\", err)\n```\n\n### 3. 错误包装与错误链\n\n```go\nif errors.Is(err, ErrNotFound) {\n    fmt.Println(\"Resource not found\")\n}\n```\n\n## 📌 三、自定义错误类型\n\n### 定义自定义错误类型\n\n```go\ntype AppError struct {\n    Code    int\n    Message string\n    Err     error\n}\n\nfunc (e *AppError) Error() string {\n    return fmt.Sprintf(\"[code %d] %s: %v\", e.Code, e.Message, e.Err)\n}\n\nfunc (e *AppError) Unwrap() error {\n    return e.Err\n}\n\nfunc NewAppError(code int, msg string, err error) *AppError {\n    return &AppError{\n        Code:    code,\n        Message: msg,\n        Err:     err,\n    }\n}\n```\n\n### 使用自定义错误类型\n\n```go\nfunc loadConfig(file string) error {\n    data, err := os.ReadFile(file)\n    if err != nil {\n        return NewAppError(1001, \"failed to load config\", err)\n    }\n    fmt.Println(\"Config data:\", string(data))\n    return nil\n}\n\nfunc main() {\n    err := loadConfig(\"config.json\")\n    if err != nil {\n        var appErr *AppError\n        if errors.As(err, &appErr) {\n            fmt.Printf(\"Custom error caught: %s\\n\", appErr.Error())\n        } else {\n            fmt.Println(\"Unknown error:\", err)\n        }\n    }\n}\n```\n\n## 📌 四、错误判断与处理\n\n```go\nif errors.Is(err, ErrNotFound) {\n    fmt.Println(\"Resource not found\")\n}\n\nvar appErr *AppError\nif errors.As(err, &appErr) {\n    fmt.Printf(\"AppError with code: %d\\n\", appErr.Code)\n}\n```\n\n## 📌 五、最佳实践\n\n1. 错误返回而非 panic。\n2. 错误信息应简洁并富有上下文。\n3. 使用自定义错误类型增强错误可处理性。\n4. 使用统一的错误处理策略与工具函数。\n\n## 📌 六、使用 panic 和 recover（仅限不可恢复场景）\n\n```go\nfunc SafeRun(fn func()) (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    fn()\n    return nil\n}\n```\n\n## 📌 七、Starter 封装实战：构建统一错误处理框架\n\n在项目中，可以封装一个 starter 模板，集中管理错误定义与处理。以下是一个 starter 错误模块的例子：\n\n### 定义错误类型\n\n```go\npackage errs\n\nimport (\n    \"fmt\"\n)\n\ntype ErrorCode int\n\nconst (\n    ErrInternal ErrorCode = 1000\n    ErrDatabase ErrorCode = 1001\n    ErrValidation ErrorCode = 1002\n)\n\ntype AppError struct {\n    Code ErrorCode\n    Msg  string\n    Err  error\n}\n\nfunc (e *AppError) Error() string {\n    return fmt.Sprintf(\"[%d] %s: %v\", e.Code, e.Msg, e.Err)\n}\n\nfunc (e *AppError) Unwrap() error {\n    return e.Err\n}\n\nfunc New(code ErrorCode, msg string, err error) *AppError {\n    return &AppError{Code: code, Msg: msg, Err: err}\n}\n```\n\n### 使用封装的错误模块\n\n```go\npackage service\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"project/errs\"\n)\n\nfunc LoadUser(id int) (string, error) {\n    if id == 0 {\n        return \"\", errs.New(errs.ErrValidation, \"user id is invalid\", nil)\n    }\n    // 模拟数据库错误\n    dbErr := errors.New(\"db connection failed\")\n    return \"\", errs.New(errs.ErrDatabase, \"failed to load user\", dbErr)\n}\n\nfunc main() {\n    name, err := LoadUser(0)\n    if err != nil {\n        var appErr *errs.AppError\n        if errors.As(err, &appErr) {\n            fmt.Println(\"Handled error:\", appErr)\n        }\n    } else {\n        fmt.Println(\"Loaded user:\", name)\n    }\n}\n```\n\n通过构建统一错误处理模块，我们可以提升项目结构清晰度，使错误处理更加系统化和可维护。\n\n---\n\n## 📌 八、总结\n\nGo 的错误处理机制强调**显式、清晰和简单**。通过定义错误类型、错误链和自定义错误，我们能够创建更加清晰和易于管理的错误处理流程。\n\n✅ 错误应返回而不是 panic。\n\n✅ 通过 `fmt.Errorf` 增加上下文信息。\n\n✅ 自定义错误类型 + 错误链判断提升可读性与可维护性。\n\n✅ 封装 starter 错误模块，提高开发效率。\n","source":"_posts/go语言之错误处理.md","raw":"---\ntitle: go语言之错误处理\ndescription: 'Go 不使用异常机制（try-catch），而是通过返回错误值来显式地处理错误'\ntags: ['go']\ntoc: false\ndate: 2025-05-15 09:47:12\ncategories:\n    - go\n    - basic\n---\n\n# Go语言中的错误处理详解\n\nGo 语言的错误处理机制与许多其他语言有所不同。Go 不使用异常机制（`try-catch`），而是通过返回错误值来显式地处理错误。虽然这种方式比异常机制更加简洁和明确，但它也带来了更多的冗长和细节。\n\n## 📌 一、Go 错误处理的基本方式\n\nGo 语言的错误通常是通过 `error` 接口来表示的。`error` 接口本身非常简单：\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n任何实现了 `Error()` 方法的类型，都可以作为 `error` 类型使用。\n\n### 返回错误\n\nGo 中大多数函数会返回一个 `error` 类型的值来表示执行过程中可能出现的错误。典型的错误处理模式如下：\n\n```go\nfunc someFunction() (string, error) {\n    // 返回数据和错误\n    return \"\", fmt.Errorf(\"something went wrong\")\n}\n```\n\n调用时，可以通过检查返回的 `error` 值来判断是否发生错误：\n\n```go\nresult, err := someFunction()\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Println(\"Success:\", result)\n```\n\n## 📌 二、创建和包装错误\n\nGo 提供了标准库中的 `errors` 包来创建简单的错误，也提供了 `fmt.Errorf` 来包装错误并增加上下文信息。\n\n### 1. 使用 `errors.New` 创建简单错误\n\n```go\nimport \"errors\"\n\nvar ErrNotFound = errors.New(\"resource not found\")\n```\n\n### 2. 使用 `fmt.Errorf` 包装错误\n\n```go\nreturn fmt.Errorf(\"failed to load config file: %w\", err)\n```\n\n### 3. 错误包装与错误链\n\n```go\nif errors.Is(err, ErrNotFound) {\n    fmt.Println(\"Resource not found\")\n}\n```\n\n## 📌 三、自定义错误类型\n\n### 定义自定义错误类型\n\n```go\ntype AppError struct {\n    Code    int\n    Message string\n    Err     error\n}\n\nfunc (e *AppError) Error() string {\n    return fmt.Sprintf(\"[code %d] %s: %v\", e.Code, e.Message, e.Err)\n}\n\nfunc (e *AppError) Unwrap() error {\n    return e.Err\n}\n\nfunc NewAppError(code int, msg string, err error) *AppError {\n    return &AppError{\n        Code:    code,\n        Message: msg,\n        Err:     err,\n    }\n}\n```\n\n### 使用自定义错误类型\n\n```go\nfunc loadConfig(file string) error {\n    data, err := os.ReadFile(file)\n    if err != nil {\n        return NewAppError(1001, \"failed to load config\", err)\n    }\n    fmt.Println(\"Config data:\", string(data))\n    return nil\n}\n\nfunc main() {\n    err := loadConfig(\"config.json\")\n    if err != nil {\n        var appErr *AppError\n        if errors.As(err, &appErr) {\n            fmt.Printf(\"Custom error caught: %s\\n\", appErr.Error())\n        } else {\n            fmt.Println(\"Unknown error:\", err)\n        }\n    }\n}\n```\n\n## 📌 四、错误判断与处理\n\n```go\nif errors.Is(err, ErrNotFound) {\n    fmt.Println(\"Resource not found\")\n}\n\nvar appErr *AppError\nif errors.As(err, &appErr) {\n    fmt.Printf(\"AppError with code: %d\\n\", appErr.Code)\n}\n```\n\n## 📌 五、最佳实践\n\n1. 错误返回而非 panic。\n2. 错误信息应简洁并富有上下文。\n3. 使用自定义错误类型增强错误可处理性。\n4. 使用统一的错误处理策略与工具函数。\n\n## 📌 六、使用 panic 和 recover（仅限不可恢复场景）\n\n```go\nfunc SafeRun(fn func()) (err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recovered: %v\", r)\n        }\n    }()\n    fn()\n    return nil\n}\n```\n\n## 📌 七、Starter 封装实战：构建统一错误处理框架\n\n在项目中，可以封装一个 starter 模板，集中管理错误定义与处理。以下是一个 starter 错误模块的例子：\n\n### 定义错误类型\n\n```go\npackage errs\n\nimport (\n    \"fmt\"\n)\n\ntype ErrorCode int\n\nconst (\n    ErrInternal ErrorCode = 1000\n    ErrDatabase ErrorCode = 1001\n    ErrValidation ErrorCode = 1002\n)\n\ntype AppError struct {\n    Code ErrorCode\n    Msg  string\n    Err  error\n}\n\nfunc (e *AppError) Error() string {\n    return fmt.Sprintf(\"[%d] %s: %v\", e.Code, e.Msg, e.Err)\n}\n\nfunc (e *AppError) Unwrap() error {\n    return e.Err\n}\n\nfunc New(code ErrorCode, msg string, err error) *AppError {\n    return &AppError{Code: code, Msg: msg, Err: err}\n}\n```\n\n### 使用封装的错误模块\n\n```go\npackage service\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"project/errs\"\n)\n\nfunc LoadUser(id int) (string, error) {\n    if id == 0 {\n        return \"\", errs.New(errs.ErrValidation, \"user id is invalid\", nil)\n    }\n    // 模拟数据库错误\n    dbErr := errors.New(\"db connection failed\")\n    return \"\", errs.New(errs.ErrDatabase, \"failed to load user\", dbErr)\n}\n\nfunc main() {\n    name, err := LoadUser(0)\n    if err != nil {\n        var appErr *errs.AppError\n        if errors.As(err, &appErr) {\n            fmt.Println(\"Handled error:\", appErr)\n        }\n    } else {\n        fmt.Println(\"Loaded user:\", name)\n    }\n}\n```\n\n通过构建统一错误处理模块，我们可以提升项目结构清晰度，使错误处理更加系统化和可维护。\n\n---\n\n## 📌 八、总结\n\nGo 的错误处理机制强调**显式、清晰和简单**。通过定义错误类型、错误链和自定义错误，我们能够创建更加清晰和易于管理的错误处理流程。\n\n✅ 错误应返回而不是 panic。\n\n✅ 通过 `fmt.Errorf` 增加上下文信息。\n\n✅ 自定义错误类型 + 错误链判断提升可读性与可维护性。\n\n✅ 封装 starter 错误模块，提高开发效率。\n","slug":"go语言之错误处理","published":1,"updated":"2025-05-23T06:25:35.689Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxe000jhkvo9xeydyrt","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"Go语言中的错误处理详解\"><a href=\"#Go语言中的错误处理详解\" class=\"headerlink\" title=\"Go语言中的错误处理详解\"></a>Go语言中的错误处理详解</h1><p>Go 语言的错误处理机制与许多其他语言有所不同。Go 不使用异常机制（<code>try-catch</code>），而是通过返回错误值来显式地处理错误。虽然这种方式比异常机制更加简洁和明确，但它也带来了更多的冗长和细节。</p>\n<h2 id=\"📌-一、Go-错误处理的基本方式\"><a href=\"#📌-一、Go-错误处理的基本方式\" class=\"headerlink\" title=\"📌 一、Go 错误处理的基本方式\"></a>📌 一、Go 错误处理的基本方式</h2><p>Go 语言的错误通常是通过 <code>error</code> 接口来表示的。<code>error</code> 接口本身非常简单：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">error</span> <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>任何实现了 <code>Error()</code> 方法的类型，都可以作为 <code>error</code> 类型使用。</p>\n<h3 id=\"返回错误\"><a href=\"#返回错误\" class=\"headerlink\" title=\"返回错误\"></a>返回错误</h3><p>Go 中大多数函数会返回一个 <code>error</code> 类型的值来表示执行过程中可能出现的错误。典型的错误处理模式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回数据和错误</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"string\">&quot;something went wrong&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时，可以通过检查返回的 <code>error</code> 值来判断是否发生错误：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result, err := someFunction()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Error:&quot;</span>, err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Success:&quot;</span>, result)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-二、创建和包装错误\"><a href=\"#📌-二、创建和包装错误\" class=\"headerlink\" title=\"📌 二、创建和包装错误\"></a>📌 二、创建和包装错误</h2><p>Go 提供了标准库中的 <code>errors</code> 包来创建简单的错误，也提供了 <code>fmt.Errorf</code> 来包装错误并增加上下文信息。</p>\n<h3 id=\"1-使用-errors-New-创建简单错误\"><a href=\"#1-使用-errors-New-创建简单错误\" class=\"headerlink\" title=\"1. 使用 errors.New 创建简单错误\"></a>1. 使用 <code>errors.New</code> 创建简单错误</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrNotFound = errors.New(<span class=\"string\">&quot;resource not found&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-fmt-Errorf-包装错误\"><a href=\"#2-使用-fmt-Errorf-包装错误\" class=\"headerlink\" title=\"2. 使用 fmt.Errorf 包装错误\"></a>2. 使用 <code>fmt.Errorf</code> 包装错误</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;failed to load config file: %w&quot;</span>, err)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-错误包装与错误链\"><a href=\"#3-错误包装与错误链\" class=\"headerlink\" title=\"3. 错误包装与错误链\"></a>3. 错误包装与错误链</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Resource not found&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-三、自定义错误类型\"><a href=\"#📌-三、自定义错误类型\" class=\"headerlink\" title=\"📌 三、自定义错误类型\"></a>📌 三、自定义错误类型</h2><h3 id=\"定义自定义错误类型\"><a href=\"#定义自定义错误类型\" class=\"headerlink\" title=\"定义自定义错误类型\"></a>定义自定义错误类型</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> AppError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Code    <span class=\"type\">int</span></span><br><span class=\"line\">    Message <span class=\"type\">string</span></span><br><span class=\"line\">    Err     <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;[code %d] %s: %v&quot;</span>, e.Code, e.Message, e.Err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Unwrap() <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.Err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAppError</span><span class=\"params\">(code <span class=\"type\">int</span>, msg <span class=\"type\">string</span>, err <span class=\"type\">error</span>)</span></span> *AppError &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;AppError&#123;</span><br><span class=\"line\">        Code:    code,</span><br><span class=\"line\">        Message: msg,</span><br><span class=\"line\">        Err:     err,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用自定义错误类型\"><a href=\"#使用自定义错误类型\" class=\"headerlink\" title=\"使用自定义错误类型\"></a>使用自定义错误类型</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadConfig</span><span class=\"params\">(file <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    data, err := os.ReadFile(file)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> NewAppError(<span class=\"number\">1001</span>, <span class=\"string\">&quot;failed to load config&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Config data:&quot;</span>, <span class=\"type\">string</span>(data))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    err := loadConfig(<span class=\"string\">&quot;config.json&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> appErr *AppError</span><br><span class=\"line\">        <span class=\"keyword\">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;Custom error caught: %s\\n&quot;</span>, appErr.Error())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;Unknown error:&quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-四、错误判断与处理\"><a href=\"#📌-四、错误判断与处理\" class=\"headerlink\" title=\"📌 四、错误判断与处理\"></a>📌 四、错误判断与处理</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Resource not found&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> appErr *AppError</span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;AppError with code: %d\\n&quot;</span>, appErr.Code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-五、最佳实践\"><a href=\"#📌-五、最佳实践\" class=\"headerlink\" title=\"📌 五、最佳实践\"></a>📌 五、最佳实践</h2><ol>\n<li>错误返回而非 panic。</li>\n<li>错误信息应简洁并富有上下文。</li>\n<li>使用自定义错误类型增强错误可处理性。</li>\n<li>使用统一的错误处理策略与工具函数。</li>\n</ol>\n<h2 id=\"📌-六、使用-panic-和-recover（仅限不可恢复场景）\"><a href=\"#📌-六、使用-panic-和-recover（仅限不可恢复场景）\" class=\"headerlink\" title=\"📌 六、使用 panic 和 recover（仅限不可恢复场景）\"></a>📌 六、使用 panic 和 recover（仅限不可恢复场景）</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SafeRun</span><span class=\"params\">(fn <span class=\"keyword\">func</span>()</span></span>) (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            err = fmt.Errorf(<span class=\"string\">&quot;panic recovered: %v&quot;</span>, r)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    fn()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-七、Starter-封装实战：构建统一错误处理框架\"><a href=\"#📌-七、Starter-封装实战：构建统一错误处理框架\" class=\"headerlink\" title=\"📌 七、Starter 封装实战：构建统一错误处理框架\"></a>📌 七、Starter 封装实战：构建统一错误处理框架</h2><p>在项目中，可以封装一个 starter 模板，集中管理错误定义与处理。以下是一个 starter 错误模块的例子：</p>\n<h3 id=\"定义错误类型\"><a href=\"#定义错误类型\" class=\"headerlink\" title=\"定义错误类型\"></a>定义错误类型</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> errs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ErrorCode <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    ErrInternal ErrorCode = <span class=\"number\">1000</span></span><br><span class=\"line\">    ErrDatabase ErrorCode = <span class=\"number\">1001</span></span><br><span class=\"line\">    ErrValidation ErrorCode = <span class=\"number\">1002</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> AppError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Code ErrorCode</span><br><span class=\"line\">    Msg  <span class=\"type\">string</span></span><br><span class=\"line\">    Err  <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;[%d] %s: %v&quot;</span>, e.Code, e.Msg, e.Err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Unwrap() <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.Err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(code ErrorCode, msg <span class=\"type\">string</span>, err <span class=\"type\">error</span>)</span></span> *AppError &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;AppError&#123;Code: code, Msg: msg, Err: err&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用封装的错误模块\"><a href=\"#使用封装的错误模块\" class=\"headerlink\" title=\"使用封装的错误模块\"></a>使用封装的错误模块</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;project/errs&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadUser</span><span class=\"params\">(id <span class=\"type\">int</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> id == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, errs.New(errs.ErrValidation, <span class=\"string\">&quot;user id is invalid&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟数据库错误</span></span><br><span class=\"line\">    dbErr := errors.New(<span class=\"string\">&quot;db connection failed&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, errs.New(errs.ErrDatabase, <span class=\"string\">&quot;failed to load user&quot;</span>, dbErr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    name, err := LoadUser(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> appErr *errs.AppError</span><br><span class=\"line\">        <span class=\"keyword\">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;Handled error:&quot;</span>, appErr)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;Loaded user:&quot;</span>, name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过构建统一错误处理模块，我们可以提升项目结构清晰度，使错误处理更加系统化和可维护。</p>\n<hr>\n<h2 id=\"📌-八、总结\"><a href=\"#📌-八、总结\" class=\"headerlink\" title=\"📌 八、总结\"></a>📌 八、总结</h2><p>Go 的错误处理机制强调<strong>显式、清晰和简单</strong>。通过定义错误类型、错误链和自定义错误，我们能够创建更加清晰和易于管理的错误处理流程。</p>\n<p>✅ 错误应返回而不是 panic。</p>\n<p>✅ 通过 <code>fmt.Errorf</code> 增加上下文信息。</p>\n<p>✅ 自定义错误类型 + 错误链判断提升可读性与可维护性。</p>\n<p>✅ 封装 starter 错误模块，提高开发效率。</p>\n","excerpt":"","more":"<h1 id=\"Go语言中的错误处理详解\"><a href=\"#Go语言中的错误处理详解\" class=\"headerlink\" title=\"Go语言中的错误处理详解\"></a>Go语言中的错误处理详解</h1><p>Go 语言的错误处理机制与许多其他语言有所不同。Go 不使用异常机制（<code>try-catch</code>），而是通过返回错误值来显式地处理错误。虽然这种方式比异常机制更加简洁和明确，但它也带来了更多的冗长和细节。</p>\n<h2 id=\"📌-一、Go-错误处理的基本方式\"><a href=\"#📌-一、Go-错误处理的基本方式\" class=\"headerlink\" title=\"📌 一、Go 错误处理的基本方式\"></a>📌 一、Go 错误处理的基本方式</h2><p>Go 语言的错误通常是通过 <code>error</code> 接口来表示的。<code>error</code> 接口本身非常简单：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"type\">error</span> <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>任何实现了 <code>Error()</code> 方法的类型，都可以作为 <code>error</code> 类型使用。</p>\n<h3 id=\"返回错误\"><a href=\"#返回错误\" class=\"headerlink\" title=\"返回错误\"></a>返回错误</h3><p>Go 中大多数函数会返回一个 <code>error</code> 类型的值来表示执行过程中可能出现的错误。典型的错误处理模式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回数据和错误</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"string\">&quot;something went wrong&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时，可以通过检查返回的 <code>error</code> 值来判断是否发生错误：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result, err := someFunction()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Error:&quot;</span>, err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;Success:&quot;</span>, result)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-二、创建和包装错误\"><a href=\"#📌-二、创建和包装错误\" class=\"headerlink\" title=\"📌 二、创建和包装错误\"></a>📌 二、创建和包装错误</h2><p>Go 提供了标准库中的 <code>errors</code> 包来创建简单的错误，也提供了 <code>fmt.Errorf</code> 来包装错误并增加上下文信息。</p>\n<h3 id=\"1-使用-errors-New-创建简单错误\"><a href=\"#1-使用-errors-New-创建简单错误\" class=\"headerlink\" title=\"1. 使用 errors.New 创建简单错误\"></a>1. 使用 <code>errors.New</code> 创建简单错误</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrNotFound = errors.New(<span class=\"string\">&quot;resource not found&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-fmt-Errorf-包装错误\"><a href=\"#2-使用-fmt-Errorf-包装错误\" class=\"headerlink\" title=\"2. 使用 fmt.Errorf 包装错误\"></a>2. 使用 <code>fmt.Errorf</code> 包装错误</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;failed to load config file: %w&quot;</span>, err)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-错误包装与错误链\"><a href=\"#3-错误包装与错误链\" class=\"headerlink\" title=\"3. 错误包装与错误链\"></a>3. 错误包装与错误链</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Resource not found&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-三、自定义错误类型\"><a href=\"#📌-三、自定义错误类型\" class=\"headerlink\" title=\"📌 三、自定义错误类型\"></a>📌 三、自定义错误类型</h2><h3 id=\"定义自定义错误类型\"><a href=\"#定义自定义错误类型\" class=\"headerlink\" title=\"定义自定义错误类型\"></a>定义自定义错误类型</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> AppError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Code    <span class=\"type\">int</span></span><br><span class=\"line\">    Message <span class=\"type\">string</span></span><br><span class=\"line\">    Err     <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;[code %d] %s: %v&quot;</span>, e.Code, e.Message, e.Err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Unwrap() <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.Err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAppError</span><span class=\"params\">(code <span class=\"type\">int</span>, msg <span class=\"type\">string</span>, err <span class=\"type\">error</span>)</span></span> *AppError &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;AppError&#123;</span><br><span class=\"line\">        Code:    code,</span><br><span class=\"line\">        Message: msg,</span><br><span class=\"line\">        Err:     err,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用自定义错误类型\"><a href=\"#使用自定义错误类型\" class=\"headerlink\" title=\"使用自定义错误类型\"></a>使用自定义错误类型</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadConfig</span><span class=\"params\">(file <span class=\"type\">string</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    data, err := os.ReadFile(file)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> NewAppError(<span class=\"number\">1001</span>, <span class=\"string\">&quot;failed to load config&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Config data:&quot;</span>, <span class=\"type\">string</span>(data))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    err := loadConfig(<span class=\"string\">&quot;config.json&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> appErr *AppError</span><br><span class=\"line\">        <span class=\"keyword\">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;Custom error caught: %s\\n&quot;</span>, appErr.Error())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;Unknown error:&quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-四、错误判断与处理\"><a href=\"#📌-四、错误判断与处理\" class=\"headerlink\" title=\"📌 四、错误判断与处理\"></a>📌 四、错误判断与处理</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Resource not found&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> appErr *AppError</span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;AppError with code: %d\\n&quot;</span>, appErr.Code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-五、最佳实践\"><a href=\"#📌-五、最佳实践\" class=\"headerlink\" title=\"📌 五、最佳实践\"></a>📌 五、最佳实践</h2><ol>\n<li>错误返回而非 panic。</li>\n<li>错误信息应简洁并富有上下文。</li>\n<li>使用自定义错误类型增强错误可处理性。</li>\n<li>使用统一的错误处理策略与工具函数。</li>\n</ol>\n<h2 id=\"📌-六、使用-panic-和-recover（仅限不可恢复场景）\"><a href=\"#📌-六、使用-panic-和-recover（仅限不可恢复场景）\" class=\"headerlink\" title=\"📌 六、使用 panic 和 recover（仅限不可恢复场景）\"></a>📌 六、使用 panic 和 recover（仅限不可恢复场景）</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SafeRun</span><span class=\"params\">(fn <span class=\"keyword\">func</span>()</span></span>) (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            err = fmt.Errorf(<span class=\"string\">&quot;panic recovered: %v&quot;</span>, r)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    fn()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📌-七、Starter-封装实战：构建统一错误处理框架\"><a href=\"#📌-七、Starter-封装实战：构建统一错误处理框架\" class=\"headerlink\" title=\"📌 七、Starter 封装实战：构建统一错误处理框架\"></a>📌 七、Starter 封装实战：构建统一错误处理框架</h2><p>在项目中，可以封装一个 starter 模板，集中管理错误定义与处理。以下是一个 starter 错误模块的例子：</p>\n<h3 id=\"定义错误类型\"><a href=\"#定义错误类型\" class=\"headerlink\" title=\"定义错误类型\"></a>定义错误类型</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> errs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ErrorCode <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    ErrInternal ErrorCode = <span class=\"number\">1000</span></span><br><span class=\"line\">    ErrDatabase ErrorCode = <span class=\"number\">1001</span></span><br><span class=\"line\">    ErrValidation ErrorCode = <span class=\"number\">1002</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> AppError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Code ErrorCode</span><br><span class=\"line\">    Msg  <span class=\"type\">string</span></span><br><span class=\"line\">    Err  <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;[%d] %s: %v&quot;</span>, e.Code, e.Msg, e.Err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *AppError)</span></span> Unwrap() <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.Err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(code ErrorCode, msg <span class=\"type\">string</span>, err <span class=\"type\">error</span>)</span></span> *AppError &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;AppError&#123;Code: code, Msg: msg, Err: err&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用封装的错误模块\"><a href=\"#使用封装的错误模块\" class=\"headerlink\" title=\"使用封装的错误模块\"></a>使用封装的错误模块</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;project/errs&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadUser</span><span class=\"params\">(id <span class=\"type\">int</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> id == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, errs.New(errs.ErrValidation, <span class=\"string\">&quot;user id is invalid&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟数据库错误</span></span><br><span class=\"line\">    dbErr := errors.New(<span class=\"string\">&quot;db connection failed&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, errs.New(errs.ErrDatabase, <span class=\"string\">&quot;failed to load user&quot;</span>, dbErr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    name, err := LoadUser(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> appErr *errs.AppError</span><br><span class=\"line\">        <span class=\"keyword\">if</span> errors.As(err, &amp;appErr) &#123;</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;Handled error:&quot;</span>, appErr)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;Loaded user:&quot;</span>, name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过构建统一错误处理模块，我们可以提升项目结构清晰度，使错误处理更加系统化和可维护。</p>\n<hr>\n<h2 id=\"📌-八、总结\"><a href=\"#📌-八、总结\" class=\"headerlink\" title=\"📌 八、总结\"></a>📌 八、总结</h2><p>Go 的错误处理机制强调<strong>显式、清晰和简单</strong>。通过定义错误类型、错误链和自定义错误，我们能够创建更加清晰和易于管理的错误处理流程。</p>\n<p>✅ 错误应返回而不是 panic。</p>\n<p>✅ 通过 <code>fmt.Errorf</code> 增加上下文信息。</p>\n<p>✅ 自定义错误类型 + 错误链判断提升可读性与可维护性。</p>\n<p>✅ 封装 starter 错误模块，提高开发效率。</p>\n"},{"title":"远程通信协议：RPCvsHTTP","description":"RPC是什么？HTTP是什么？RPC和HTTP有什么区别？","toc":false,"date":"2025-05-24T03:44:48.000Z","_content":"\n# RPC与HTTP：理解远程通信的核心概念\n\n## 什么是RPC？\n\nRPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许一个程序（客户端）像调用本地方法一样调用另一个地址空间（通常是远程服务器）上的程序或服务，而不需要显式处理网络通信的细节。\n\nRPC的核心思想是**透明性**——开发者可以像调用本地函数一样调用远程函数，底层通信细节被隐藏起来。RPC框架通常包括：\n• 客户端存根（stub）：负责将调用信息序列化并发送到网络\n• 服务器端骨架（skeleton）：负责接收请求并调用实际的方法\n• 通信协议：定义数据传输格式和规则\n• 序列化机制：将数据结构或对象转换为可传输的格式\n\n常见的RPC框架包括gRPC、Thrift、Dubbo等。\n\n## 什么是HTTP？\n\nHTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，用于分布式、协作式的超媒体信息系统。它是万维网（WWW）数据通信的基础。\n\nHTTP基于**请求-响应模型**工作：\n1. 客户端（通常是浏览器）向服务器发送HTTP请求\n2. 服务器处理请求并返回HTTP响应\n3. 连接通常会在响应后关闭（除非使用持久连接）\n\nHTTP是无状态协议，每个请求都是独立的，服务器不会保留之前请求的信息。现代HTTP/1.1和HTTP/2支持持久连接、管道化和头部压缩等特性。\n\n## RPC与HTTP的区别\n\n| 特性 | RPC | HTTP |\n|------|-----|------|\n| **设计目的** | 远程方法调用，强调透明性 | 超文本传输，强调资源交换 |\n| **通信模型** | 通常面向过程/方法调用 | 面向资源（RESTful）或动作（SOAP） |\n| **协议层** | 可以在传输层之上直接构建 | 应用层协议，通常基于TCP |\n| **性能** | 通常更高（二进制协议，更少的开销） | 相对较低（文本协议，更多元数据） |\n| **序列化** | 使用高效的二进制格式（如Protocol Buffers） | 通常使用文本格式（JSON/XML） |\n| **服务发现** | 内置服务发现机制 | 需要额外组件（如API网关） |\n| **适用场景** | 内部服务间通信，高性能需求 | 公开API，浏览器-服务器交互 |\n| **跨语言支持** | 需要特定客户端实现 | 通用性强，几乎所有语言都支持 |\n\n## 如何选择？\n\n选择RPC还是HTTP取决于具体场景：\n\n**使用RPC当：**\n• 需要高性能的内部服务通信\n• 服务间调用频繁且延迟敏感\n• 需要强类型接口和编译时检查\n• 系统由同一团队维护，可以统一技术栈\n\n**使用HTTP当：**\n• 需要公开API供第三方使用\n• 需要与浏览器直接交互\n• 系统组件由不同团队维护，需要松耦合\n• 需要利用现有的HTTP基础设施（缓存、负载均衡等）\n\n## 现代趋势：融合与演进\n\n值得注意的是，现代技术趋势正在模糊RPC和HTTP的界限：\n• gRPC基于HTTP/2，结合了RPC的高效和HTTP的通用性\n• RESTful API设计借鉴了RPC的一些思想\n• GraphQL提供了类似RPC的精确查询能力，同时运行在HTTP上\n\n## 结论\n\nRPC和HTTP都是实现远程通信的重要技术，各有优势和适用场景。理解它们的核心差异有助于我们在系统设计中做出合理的选择。随着技术的发展，两者也在相互借鉴和融合，开发者可以根据具体需求选择最适合的方案，甚至组合使用它们。","source":"_posts/远程通信协议：RPCvsHTTP.md","raw":"---\ntitle: 远程通信协议：RPCvsHTTP\ndescription: 'RPC是什么？HTTP是什么？RPC和HTTP有什么区别？'\ntags: []\ntoc: false\ndate: 2025-05-24 11:44:48\ncategories:\n---\n\n# RPC与HTTP：理解远程通信的核心概念\n\n## 什么是RPC？\n\nRPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许一个程序（客户端）像调用本地方法一样调用另一个地址空间（通常是远程服务器）上的程序或服务，而不需要显式处理网络通信的细节。\n\nRPC的核心思想是**透明性**——开发者可以像调用本地函数一样调用远程函数，底层通信细节被隐藏起来。RPC框架通常包括：\n• 客户端存根（stub）：负责将调用信息序列化并发送到网络\n• 服务器端骨架（skeleton）：负责接收请求并调用实际的方法\n• 通信协议：定义数据传输格式和规则\n• 序列化机制：将数据结构或对象转换为可传输的格式\n\n常见的RPC框架包括gRPC、Thrift、Dubbo等。\n\n## 什么是HTTP？\n\nHTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，用于分布式、协作式的超媒体信息系统。它是万维网（WWW）数据通信的基础。\n\nHTTP基于**请求-响应模型**工作：\n1. 客户端（通常是浏览器）向服务器发送HTTP请求\n2. 服务器处理请求并返回HTTP响应\n3. 连接通常会在响应后关闭（除非使用持久连接）\n\nHTTP是无状态协议，每个请求都是独立的，服务器不会保留之前请求的信息。现代HTTP/1.1和HTTP/2支持持久连接、管道化和头部压缩等特性。\n\n## RPC与HTTP的区别\n\n| 特性 | RPC | HTTP |\n|------|-----|------|\n| **设计目的** | 远程方法调用，强调透明性 | 超文本传输，强调资源交换 |\n| **通信模型** | 通常面向过程/方法调用 | 面向资源（RESTful）或动作（SOAP） |\n| **协议层** | 可以在传输层之上直接构建 | 应用层协议，通常基于TCP |\n| **性能** | 通常更高（二进制协议，更少的开销） | 相对较低（文本协议，更多元数据） |\n| **序列化** | 使用高效的二进制格式（如Protocol Buffers） | 通常使用文本格式（JSON/XML） |\n| **服务发现** | 内置服务发现机制 | 需要额外组件（如API网关） |\n| **适用场景** | 内部服务间通信，高性能需求 | 公开API，浏览器-服务器交互 |\n| **跨语言支持** | 需要特定客户端实现 | 通用性强，几乎所有语言都支持 |\n\n## 如何选择？\n\n选择RPC还是HTTP取决于具体场景：\n\n**使用RPC当：**\n• 需要高性能的内部服务通信\n• 服务间调用频繁且延迟敏感\n• 需要强类型接口和编译时检查\n• 系统由同一团队维护，可以统一技术栈\n\n**使用HTTP当：**\n• 需要公开API供第三方使用\n• 需要与浏览器直接交互\n• 系统组件由不同团队维护，需要松耦合\n• 需要利用现有的HTTP基础设施（缓存、负载均衡等）\n\n## 现代趋势：融合与演进\n\n值得注意的是，现代技术趋势正在模糊RPC和HTTP的界限：\n• gRPC基于HTTP/2，结合了RPC的高效和HTTP的通用性\n• RESTful API设计借鉴了RPC的一些思想\n• GraphQL提供了类似RPC的精确查询能力，同时运行在HTTP上\n\n## 结论\n\nRPC和HTTP都是实现远程通信的重要技术，各有优势和适用场景。理解它们的核心差异有助于我们在系统设计中做出合理的选择。随着技术的发展，两者也在相互借鉴和融合，开发者可以根据具体需求选择最适合的方案，甚至组合使用它们。","slug":"远程通信协议：RPCvsHTTP","published":1,"updated":"2025-05-24T03:45:24.272Z","comments":1,"layout":"post","photos":[],"_id":"cmb4dndxf000mhkvo0yoq67vz","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"RPC与HTTP：理解远程通信的核心概念\"><a href=\"#RPC与HTTP：理解远程通信的核心概念\" class=\"headerlink\" title=\"RPC与HTTP：理解远程通信的核心概念\"></a>RPC与HTTP：理解远程通信的核心概念</h1><h2 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h2><p>RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许一个程序（客户端）像调用本地方法一样调用另一个地址空间（通常是远程服务器）上的程序或服务，而不需要显式处理网络通信的细节。</p>\n<p>RPC的核心思想是<strong>透明性</strong>——开发者可以像调用本地函数一样调用远程函数，底层通信细节被隐藏起来。RPC框架通常包括：<br>• 客户端存根（stub）：负责将调用信息序列化并发送到网络<br>• 服务器端骨架（skeleton）：负责接收请求并调用实际的方法<br>• 通信协议：定义数据传输格式和规则<br>• 序列化机制：将数据结构或对象转换为可传输的格式</p>\n<p>常见的RPC框架包括gRPC、Thrift、Dubbo等。</p>\n<h2 id=\"什么是HTTP？\"><a href=\"#什么是HTTP？\" class=\"headerlink\" title=\"什么是HTTP？\"></a>什么是HTTP？</h2><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，用于分布式、协作式的超媒体信息系统。它是万维网（WWW）数据通信的基础。</p>\n<p>HTTP基于<strong>请求-响应模型</strong>工作：</p>\n<ol>\n<li>客户端（通常是浏览器）向服务器发送HTTP请求</li>\n<li>服务器处理请求并返回HTTP响应</li>\n<li>连接通常会在响应后关闭（除非使用持久连接）</li>\n</ol>\n<p>HTTP是无状态协议，每个请求都是独立的，服务器不会保留之前请求的信息。现代HTTP&#x2F;1.1和HTTP&#x2F;2支持持久连接、管道化和头部压缩等特性。</p>\n<h2 id=\"RPC与HTTP的区别\"><a href=\"#RPC与HTTP的区别\" class=\"headerlink\" title=\"RPC与HTTP的区别\"></a>RPC与HTTP的区别</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>RPC</th>\n<th>HTTP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>设计目的</strong></td>\n<td>远程方法调用，强调透明性</td>\n<td>超文本传输，强调资源交换</td>\n</tr>\n<tr>\n<td><strong>通信模型</strong></td>\n<td>通常面向过程&#x2F;方法调用</td>\n<td>面向资源（RESTful）或动作（SOAP）</td>\n</tr>\n<tr>\n<td><strong>协议层</strong></td>\n<td>可以在传输层之上直接构建</td>\n<td>应用层协议，通常基于TCP</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>通常更高（二进制协议，更少的开销）</td>\n<td>相对较低（文本协议，更多元数据）</td>\n</tr>\n<tr>\n<td><strong>序列化</strong></td>\n<td>使用高效的二进制格式（如Protocol Buffers）</td>\n<td>通常使用文本格式（JSON&#x2F;XML）</td>\n</tr>\n<tr>\n<td><strong>服务发现</strong></td>\n<td>内置服务发现机制</td>\n<td>需要额外组件（如API网关）</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>内部服务间通信，高性能需求</td>\n<td>公开API，浏览器-服务器交互</td>\n</tr>\n<tr>\n<td><strong>跨语言支持</strong></td>\n<td>需要特定客户端实现</td>\n<td>通用性强，几乎所有语言都支持</td>\n</tr>\n</tbody></table>\n<h2 id=\"如何选择？\"><a href=\"#如何选择？\" class=\"headerlink\" title=\"如何选择？\"></a>如何选择？</h2><p>选择RPC还是HTTP取决于具体场景：</p>\n<p><strong>使用RPC当：</strong><br>• 需要高性能的内部服务通信<br>• 服务间调用频繁且延迟敏感<br>• 需要强类型接口和编译时检查<br>• 系统由同一团队维护，可以统一技术栈</p>\n<p><strong>使用HTTP当：</strong><br>• 需要公开API供第三方使用<br>• 需要与浏览器直接交互<br>• 系统组件由不同团队维护，需要松耦合<br>• 需要利用现有的HTTP基础设施（缓存、负载均衡等）</p>\n<h2 id=\"现代趋势：融合与演进\"><a href=\"#现代趋势：融合与演进\" class=\"headerlink\" title=\"现代趋势：融合与演进\"></a>现代趋势：融合与演进</h2><p>值得注意的是，现代技术趋势正在模糊RPC和HTTP的界限：<br>• gRPC基于HTTP&#x2F;2，结合了RPC的高效和HTTP的通用性<br>• RESTful API设计借鉴了RPC的一些思想<br>• GraphQL提供了类似RPC的精确查询能力，同时运行在HTTP上</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>RPC和HTTP都是实现远程通信的重要技术，各有优势和适用场景。理解它们的核心差异有助于我们在系统设计中做出合理的选择。随着技术的发展，两者也在相互借鉴和融合，开发者可以根据具体需求选择最适合的方案，甚至组合使用它们。</p>\n","excerpt":"","more":"<h1 id=\"RPC与HTTP：理解远程通信的核心概念\"><a href=\"#RPC与HTTP：理解远程通信的核心概念\" class=\"headerlink\" title=\"RPC与HTTP：理解远程通信的核心概念\"></a>RPC与HTTP：理解远程通信的核心概念</h1><h2 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h2><p>RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许一个程序（客户端）像调用本地方法一样调用另一个地址空间（通常是远程服务器）上的程序或服务，而不需要显式处理网络通信的细节。</p>\n<p>RPC的核心思想是<strong>透明性</strong>——开发者可以像调用本地函数一样调用远程函数，底层通信细节被隐藏起来。RPC框架通常包括：<br>• 客户端存根（stub）：负责将调用信息序列化并发送到网络<br>• 服务器端骨架（skeleton）：负责接收请求并调用实际的方法<br>• 通信协议：定义数据传输格式和规则<br>• 序列化机制：将数据结构或对象转换为可传输的格式</p>\n<p>常见的RPC框架包括gRPC、Thrift、Dubbo等。</p>\n<h2 id=\"什么是HTTP？\"><a href=\"#什么是HTTP？\" class=\"headerlink\" title=\"什么是HTTP？\"></a>什么是HTTP？</h2><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，用于分布式、协作式的超媒体信息系统。它是万维网（WWW）数据通信的基础。</p>\n<p>HTTP基于<strong>请求-响应模型</strong>工作：</p>\n<ol>\n<li>客户端（通常是浏览器）向服务器发送HTTP请求</li>\n<li>服务器处理请求并返回HTTP响应</li>\n<li>连接通常会在响应后关闭（除非使用持久连接）</li>\n</ol>\n<p>HTTP是无状态协议，每个请求都是独立的，服务器不会保留之前请求的信息。现代HTTP&#x2F;1.1和HTTP&#x2F;2支持持久连接、管道化和头部压缩等特性。</p>\n<h2 id=\"RPC与HTTP的区别\"><a href=\"#RPC与HTTP的区别\" class=\"headerlink\" title=\"RPC与HTTP的区别\"></a>RPC与HTTP的区别</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>RPC</th>\n<th>HTTP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>设计目的</strong></td>\n<td>远程方法调用，强调透明性</td>\n<td>超文本传输，强调资源交换</td>\n</tr>\n<tr>\n<td><strong>通信模型</strong></td>\n<td>通常面向过程&#x2F;方法调用</td>\n<td>面向资源（RESTful）或动作（SOAP）</td>\n</tr>\n<tr>\n<td><strong>协议层</strong></td>\n<td>可以在传输层之上直接构建</td>\n<td>应用层协议，通常基于TCP</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>通常更高（二进制协议，更少的开销）</td>\n<td>相对较低（文本协议，更多元数据）</td>\n</tr>\n<tr>\n<td><strong>序列化</strong></td>\n<td>使用高效的二进制格式（如Protocol Buffers）</td>\n<td>通常使用文本格式（JSON&#x2F;XML）</td>\n</tr>\n<tr>\n<td><strong>服务发现</strong></td>\n<td>内置服务发现机制</td>\n<td>需要额外组件（如API网关）</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>内部服务间通信，高性能需求</td>\n<td>公开API，浏览器-服务器交互</td>\n</tr>\n<tr>\n<td><strong>跨语言支持</strong></td>\n<td>需要特定客户端实现</td>\n<td>通用性强，几乎所有语言都支持</td>\n</tr>\n</tbody></table>\n<h2 id=\"如何选择？\"><a href=\"#如何选择？\" class=\"headerlink\" title=\"如何选择？\"></a>如何选择？</h2><p>选择RPC还是HTTP取决于具体场景：</p>\n<p><strong>使用RPC当：</strong><br>• 需要高性能的内部服务通信<br>• 服务间调用频繁且延迟敏感<br>• 需要强类型接口和编译时检查<br>• 系统由同一团队维护，可以统一技术栈</p>\n<p><strong>使用HTTP当：</strong><br>• 需要公开API供第三方使用<br>• 需要与浏览器直接交互<br>• 系统组件由不同团队维护，需要松耦合<br>• 需要利用现有的HTTP基础设施（缓存、负载均衡等）</p>\n<h2 id=\"现代趋势：融合与演进\"><a href=\"#现代趋势：融合与演进\" class=\"headerlink\" title=\"现代趋势：融合与演进\"></a>现代趋势：融合与演进</h2><p>值得注意的是，现代技术趋势正在模糊RPC和HTTP的界限：<br>• gRPC基于HTTP&#x2F;2，结合了RPC的高效和HTTP的通用性<br>• RESTful API设计借鉴了RPC的一些思想<br>• GraphQL提供了类似RPC的精确查询能力，同时运行在HTTP上</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>RPC和HTTP都是实现远程通信的重要技术，各有优势和适用场景。理解它们的核心差异有助于我们在系统设计中做出合理的选择。随着技术的发展，两者也在相互借鉴和融合，开发者可以根据具体需求选择最适合的方案，甚至组合使用它们。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmal0vt8a0003p3j51249coph","category_id":"cmal0vt8c0007p3j53b7o2q3c","_id":"cmal0vt8f000hp3j5966t3unn"},{"post_id":"cmal0vt8f000ip3j5b9w7agoj","category_id":"cmal0vt8g000mp3j5g8kq6liq","_id":"cmal0vt8h000zp3j54rhk5ccu"},{"post_id":"cmal0vt8g000sp3j55kgxhhva","category_id":"cmal0vt8g000mp3j5g8kq6liq","_id":"cmal0vt8h0012p3j58lvx5vy0"},{"post_id":"cmal0vt8f000kp3j59pl7c209","category_id":"cmal0vt8g000mp3j5g8kq6liq","_id":"cmal0vt8i0015p3j5bp5wfgin"},{"post_id":"cmal0vt8h000xp3j55plv2wyo","category_id":"cmal0vt8g000mp3j5g8kq6liq","_id":"cmal0vt8i0019p3j5dp33dld4"},{"post_id":"cmal0vt8h0011p3j534z338u0","category_id":"cmal0vt8i0017p3j50u7vargg","_id":"cmal0vt8i001fp3j5c0076zeb"},{"post_id":"cmal0vt8g000qp3j52e4754q5","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmal0vt8i001jp3j55ut1cz08"},{"post_id":"cmal0vt8g000qp3j52e4754q5","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmal0vt8i001mp3j59b4l7mfi"},{"post_id":"cmb4dndxa0000hkvodhh12cvg","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxd0006hkvob3vaelia"},{"post_id":"cmb4dndxa0000hkvodhh12cvg","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxd0009hkvoct0xcmnr"},{"post_id":"cmb4dndxc0001hkvo09gzd2y7","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxe000chkvofdh493rf"},{"post_id":"cmb4dndxc0001hkvo09gzd2y7","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxe000fhkvo9rho7mpe"},{"post_id":"cmb4dndxd0003hkvo3gtc5svn","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxe000ihkvohksdbsyj"},{"post_id":"cmb4dndxd0003hkvo3gtc5svn","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxe000khkvod4xu43ac"},{"post_id":"cmb4dndxd0005hkvobwut1eqr","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxf000nhkvogui83idl"},{"post_id":"cmb4dndxd0005hkvobwut1eqr","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxf000phkvobwf5fzup"},{"post_id":"cmb4dndxd0008hkvodv9w0ecx","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxf000qhkvo0cf1ca30"},{"post_id":"cmb4dndxd0008hkvodv9w0ecx","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxf000rhkvo0kide6wh"},{"post_id":"cmb4dndxd000bhkvoebjs6qmd","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxf000shkvobfvv0hx5"},{"post_id":"cmb4dndxd000bhkvoebjs6qmd","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxf000thkvo47xm0cdr"},{"post_id":"cmb4dndxe000hhkvoh4aybwc0","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxf000uhkvof7gxao2y"},{"post_id":"cmb4dndxe000hhkvoh4aybwc0","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxf000vhkvogg9abepw"},{"post_id":"cmb4dndxe000jhkvo9xeydyrt","category_id":"cmal0vt8h000yp3j5f810gwyw","_id":"cmb4dndxf000whkvo5xbvfuyj"},{"post_id":"cmb4dndxe000jhkvo9xeydyrt","category_id":"cmal0vt8i001cp3j58b3sd1di","_id":"cmb4dndxf000xhkvocpo66cl5"}],"PostTag":[{"post_id":"cmal0vt880001p3j5e0fm5d2t","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8d000cp3j5hwddhvuv"},{"post_id":"cmal0vt8a0003p3j51249coph","tag_id":"cmal0vt8d000bp3j58p43hq2i","_id":"cmal0vt8g000lp3j54ay63d20"},{"post_id":"cmal0vt8a0003p3j51249coph","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8g000op3j5gkdgf9ph"},{"post_id":"cmal0vt8c0006p3j5e6bz9sb2","tag_id":"cmal0vt8f000jp3j5djae6k03","_id":"cmal0vt8g000rp3j58sj15m1q"},{"post_id":"cmal0vt8c0009p3j5brsi3n0j","tag_id":"cmal0vt8f000jp3j5djae6k03","_id":"cmal0vt8h000wp3j50dlx8wxh"},{"post_id":"cmal0vt8d000ap3j59wmwbzm7","tag_id":"cmal0vt8g000up3j55qzy879b","_id":"cmal0vt8h0013p3j5euexfa12"},{"post_id":"cmal0vt8d000ap3j59wmwbzm7","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8i0016p3j59x15b564"},{"post_id":"cmal0vt8d000dp3j56mvg7iu6","tag_id":"cmal0vt8g000up3j55qzy879b","_id":"cmal0vt8i001ap3j5hcyhgr7k"},{"post_id":"cmal0vt8d000dp3j56mvg7iu6","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8i001bp3j59zhie6mm"},{"post_id":"cmal0vt8d000ep3j5hd4uc4l1","tag_id":"cmal0vt8i0018p3j5a5d21z1y","_id":"cmal0vt8i001ep3j5b16x5bdi"},{"post_id":"cmal0vt8f000ip3j5b9w7agoj","tag_id":"cmal0vt8i001dp3j57smi4kk6","_id":"cmal0vt8i001hp3j5babt0lyv"},{"post_id":"cmal0vt8f000ip3j5b9w7agoj","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8i001ip3j52ok18g83"},{"post_id":"cmal0vt8f000kp3j59pl7c209","tag_id":"cmal0vt8i001dp3j57smi4kk6","_id":"cmal0vt8i001lp3j5hut65cmw"},{"post_id":"cmal0vt8g000np3j5hdudbx2w","tag_id":"cmal0vt8i001kp3j523ciallk","_id":"cmal0vt8j001pp3j55cbg7elc"},{"post_id":"cmal0vt8g000np3j5hdudbx2w","tag_id":"cmal0vt8i001np3j59xwe175z","_id":"cmal0vt8j001qp3j5ef5065su"},{"post_id":"cmal0vt8g000np3j5hdudbx2w","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8j001sp3j59m2p8s2o"},{"post_id":"cmal0vt8g000qp3j52e4754q5","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmal0vt8j001tp3j5enkpck0y"},{"post_id":"cmal0vt8g000sp3j55kgxhhva","tag_id":"cmal0vt8i001dp3j57smi4kk6","_id":"cmal0vt8j001vp3j59xlbfe0x"},{"post_id":"cmal0vt8g000sp3j55kgxhhva","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8j001wp3j58f5p54gh"},{"post_id":"cmal0vt8h000xp3j55plv2wyo","tag_id":"cmal0vt8i001dp3j57smi4kk6","_id":"cmal0vt8j001yp3j59ibuf5qe"},{"post_id":"cmal0vt8h000xp3j55plv2wyo","tag_id":"cmal0vt8b0004p3j576mwarbk","_id":"cmal0vt8j001zp3j53qy6fp6r"},{"post_id":"cmal0vt8h0011p3j534z338u0","tag_id":"cmal0vt8j001xp3j57c6tb7nc","_id":"cmal0vt8j0020p3j5hmi4hvzz"},{"post_id":"cmawebaqp00003oj59kmk2629","tag_id":"cmawebaqt00023oj5gxwxe4o4","_id":"cmawebar0000m3oj5844w2pfu"},{"post_id":"cmawebaqp00003oj59kmk2629","tag_id":"cmawebaqy00083oj59qtwcz2l","_id":"cmawebar0000o3oj51zyfc7px"},{"post_id":"cmawebaqp00003oj59kmk2629","tag_id":"cmawebaqz000g3oj5btw8c5e9","_id":"cmawebar0000q3oj53wz00tp2"},{"post_id":"cmb4dndxa0000hkvodhh12cvg","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxc0002hkvo1xyi7sbl"},{"post_id":"cmb4dndxc0001hkvo09gzd2y7","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxd0004hkvohdhs7qwd"},{"post_id":"cmb4dndxd0003hkvo3gtc5svn","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxd0007hkvodwbs5q8t"},{"post_id":"cmb4dndxd0005hkvobwut1eqr","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxd000ahkvo04hdd5cu"},{"post_id":"cmb4dndxd0008hkvodv9w0ecx","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxe000dhkvoflb976g5"},{"post_id":"cmb4dndxd000bhkvoebjs6qmd","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxe000ghkvoamrz6x05"},{"post_id":"cmb4dndxe000hhkvoh4aybwc0","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxf000lhkvoej0d4o0a"},{"post_id":"cmb4dndxe000jhkvo9xeydyrt","tag_id":"cmal0vt8i001op3j56owt6fq0","_id":"cmb4dndxf000ohkvo619ren54"}],"Tag":[{"name":"web3","_id":"cmal0vt8b0004p3j576mwarbk"},{"name":"Foundry","_id":"cmal0vt8d000bp3j58p43hq2i"},{"name":"git","_id":"cmal0vt8f000jp3j5djae6k03"},{"name":"hardhat","_id":"cmal0vt8g000up3j55qzy879b"},{"name":"js","_id":"cmal0vt8i0018p3j5a5d21z1y"},{"name":"Solidity","_id":"cmal0vt8i001dp3j57smi4kk6"},{"name":"ethers","_id":"cmal0vt8i001kp3j523ciallk"},{"name":"viem","_id":"cmal0vt8i001np3j59xwe175z"},{"name":"go","_id":"cmal0vt8i001op3j56owt6fq0"},{"name":"考研","_id":"cmal0vt8j001xp3j57c6tb7nc"},{"name":"科研","_id":"cmawebaqt00023oj5gxwxe4o4"},{"name":"conda","_id":"cmawebaqy00083oj59qtwcz2l"},{"name":"python","_id":"cmawebaqz000g3oj5btw8c5e9"}]}}